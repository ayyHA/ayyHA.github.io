<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>convolution-winograd</title>
    <link href="/2024/10/02/convolution-winograd/"/>
    <url>/2024/10/02/convolution-winograd/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flashAttention-with-cuda</title>
    <link href="/2024/09/26/flashAttention-with-cuda/"/>
    <url>/2024/09/26/flashAttention-with-cuda/</url>
    
    <content type="html"><![CDATA[<h2 id="从softmax变形说起"><a class="markdownIt-Anchor" href="#从softmax变形说起"></a> 从softmax变形说起</h2><h3 id="safe-softmax3-pass"><a class="markdownIt-Anchor" href="#safe-softmax3-pass"></a> safe softmax(3-pass)</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi>R</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">x \in R^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>是一个长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>的向量,对它进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">softmax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>即有如下公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mfrac><msup><mi>e</mi><msub><mi>x</mi><mi>i</mi></msub></msup><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msup><mi>e</mi><msub><mi>x</mi><mi>j</mi></msub></msup></mrow></mfrac><msubsup><mo stretchy="false">}</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup></mrow><annotation encoding="application/x-tex">softmax(\{x_1,...,x_N\}) = \{\frac{e^{x_i}}{\sum_{j=1}^{N}{e^{x_j}}}\}^{N}_{i=1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.648441em;vertical-align:-1.3070490000000001em;"></span><span class="mopen">{</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.341392em;"><span style="top:-2.128769em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6064620000000001em;"><span style="top:-3.0050700000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3070490000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>我们知道指数函数它的值随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的增长是爆炸性增长的,当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大于某个值就会爆float,那么为了将它约束在fp32,即得到的值是安全的,没有上溢,可以减去一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(x) = max(\{x_1,...,x_N\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span></span></span></span>,那么显然我们的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_i-m(x)\le0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,则取到的值都是安全的.</p><p>那么整个softmax过程,可以由三个循环来表示:</p><ul><li>遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>,求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">{</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">m(x) = \max{\{x_i\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></span>;</li><li>遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>,求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">l(x) = \sum_{i=1}^N{e^{x_i-m(x)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></li><li>遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>,求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">softmax(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mfrac><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mfrac><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>N</mi></msub><mo>−</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">softmax(x) = [\frac{e^{x_i-m(x)}}{l(x)},...,\frac{e^{x_N-m(x)}}{l(x)}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.5907em;vertical-align:-0.52em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667142857142856em;"><span style="top:-2.9667142857142856em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.65952em;"></span><span class="mord mathnormal mtight">i</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31472em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0707em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667142857142857em;"><span style="top:-2.966714285714285em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3447999999999998em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6833299999999998em;"></span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.33853em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">m</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li></ul><h3 id="online-softmax2-pass"><a class="markdownIt-Anchor" href="#online-softmax2-pass"></a> online softmax(2-pass)</h3><p>上面的safe softmax使用了3次循环,即需要访问gmem3次,如果可以融合中间的计算,就可以减少对gmem的访问次数,可以采用以下思路融合前两个计算:</p><ul><li>遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>m</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m_{j}(x) = \max(m_{j-1}(x),x_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">j\le N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>;</li><li>遍历<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>l</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><msup><mi>e</mi><mrow><msub><mi>m</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>m</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><msub><mi>m</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">l_j(x) = l_{j-1}(x)*e^{m_{j-1}(x) - m_j(x)} + e^{x_j - m_j(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9713299999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p>上述式子可以进行融合,因此可以在1个循环内完成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的计算</p><div class="note note-info">            <p>注: 上述式子中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l_j(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的计算其实把它展开来看就很好理解,因为加上一个上一轮的最大值(就是把它消掉),减去这一轮更新的最大值</p><p>上述的式子实际上就实现了分段的softmax,即softmax所要处理的一整个向量,不需要计算完全,可以逐段计算,然后利用上述思想进行合并</p>          </div><h2 id="flashattentionv1"><a class="markdownIt-Anchor" href="#flashattentionv1"></a> FlashAttentionV1</h2><h3 id="1-pass-attention"><a class="markdownIt-Anchor" href="#1-pass-attention"></a> 1-pass Attention</h3><p>Attention计算的公式忽略对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>做scaled,以及忽略mask,可以得出简化后的Attention公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention = softmax(QK^{T})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>而MHA(Multi Head Attention)只是在这个基础上将输入的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>i</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">hidden\_dimension</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>切成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">num\_head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span></span></span></span>份的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">head\_dimension</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>,即内部的注意力机制的计算都是一样的,只是切成了多份进行并行计算,这里我们只考虑一个头的Attention的优化,因为别的操作一样~</p><p>其中Attention中式子产生的中间阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">S = QK^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P = softmax(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>这俩阵分别代表的是pre-softmax logits和注意力得分阵,最终期望得到的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>=</mo><mi>P</mi><mi>V</mi></mrow><annotation encoding="application/x-tex">O = PV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>.其中这里给定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo separator="true">,</mo><mi>O</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">Q,K,V,O \in R^{N \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>表示的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">sequence\_length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>表示的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">head\_dimension</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></p><p>根据online softmax的思路,可以描述出一个下图的2-pass的公式来计算Attention:</p><p><img src="https://s2.loli.net/2024/10/04/aT6mxXI1JkYHtLA.png" alt="attention-2pass" /></p><p>其中上图中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d_i&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>其实就是上述的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l_i(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,其中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span></span></span></span>阵的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>行与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>K</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">K^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行计算得到的元素,这个元素进行softmax后,作为标量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>阵第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>行进行相乘,累加到一个向量元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">o</span></span></span></span>上,最终这个值累加完后存放到结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>阵的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>行,这里需要解释的点其实就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a_iV[i,:]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span></span></span></span>表示的含义(其实就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub><mo>∈</mo><msup><mi>R</mi><mrow><mn>1</mn><mo>×</mo><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">P_k \in R^{1\times N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></span>,与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V \in R^{N \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>进行相乘得到的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>k</mi></msub><mo>=</mo><msub><mi>P</mi><mi>k</mi></msub><mi>V</mi></mrow><annotation encoding="application/x-tex">O_k = P_kV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>拆分后得到的结果),如下图所示,当i这个变量遍历完整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">sequence\_length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span>则底下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>O</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">O^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>中的浅蓝块会变成深蓝块,即计算完毕,体现在公式则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">o_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的更新到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">o_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p><img src="https://s2.loli.net/2024/10/04/BCLQE1AuegRoGaq.png" alt="attention-2pass-oi" style="zoom:80%;" /><p>这个2pass的Attention其实第二个循环中的值依赖于第一重循环中得到的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>,由此得出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,即对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做softmax后,与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V[i,:]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span></span></span></span>中对应的第i行相乘,从而更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">o_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>如果是以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>作为最后所求的值,则无法将2pass融合至1pass,但是我们所求的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">[</mo><mi>k</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo><mo>=</mo><msub><mi>o</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">O[k,:] = o_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,因此可以试着把中间不断迭代的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">o_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>展开来看,有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><mrow><mo stretchy="false">(</mo><mfrac><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><msub><mi>m</mi><mi>N</mi></msub></mrow></msup><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mfrac><mi>V</mi><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">o_i = \sum_{j=1}^{i}{(\frac{e^{x_j-m_N}}{d&#x27;_N}V[j,:])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2254460000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.733692em;"><span style="top:-2.4064690000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29353099999999993em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9795309999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></span></p><p>将它分段来看,从而舍去整一行向量得到的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>,我们取到第i个元素的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,累和为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>,则原式子改写成:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>o</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><mrow><mo stretchy="false">(</mo><mfrac><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><msub><mi>m</mi><mi>i</mi></msub></mrow></msup><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mfrac><mi>V</mi><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">o&#x27;_i = \sum_{j=1}^{i}{(\frac{e^{x_j-m_i}}{d&#x27;_i}V[j,:])}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2254460000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.733692em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></span></p><p>经过裂项(裂出第i项,以寻找递推式)并整理可得:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>o</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><msubsup><mi>o</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mfrac><mrow><msubsup><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><msup><mi>e</mi><mrow><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>m</mi><mi>i</mi></msub></mrow></msup></mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mfrac><mo>+</mo><mfrac><msup><mi>e</mi><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>m</mi><mi>i</mi></msub></mrow></msup><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mfrac><mi>V</mi><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">o&#x27;_i = o&#x27;_{i-1}\frac{d&#x27;_{i-1}e^{m_{i-1}-m_i}}{d&#x27;_i} + \frac{e^{x_i-m_i}}{d&#x27;_i}V[i,:]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4411899999999997em;vertical-align:-0.9628639999999999em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.478326em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.733692em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.706995em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.316995em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32808571428571426em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.411195em;vertical-align:-0.9628639999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.733692em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span></span></span></span></span></p><p>上面的递推式可以这么理解:将第i-1项得到的结果,将其softmax的原分母<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0688870000000001em;vertical-align:-0.316995em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.316995em;"><span></span></span></span></span></span></span></span></span></span>约去,更新内部每个元素减去的最大值,然后除于最新的累和值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>,完成前[1,i-1]的更新;并且加上此次计算得到的第i项的结果,得出[1,i]项的结果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>o</mi><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">o&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span></p><p>根据上述递推式,可以使得Attention只需要1pass.过程如下:</p><p><img src="https://s2.loli.net/2024/10/06/r5DM9w3AUz4LijT.png" alt="attention-1pass" /></p><h3 id="tiled-attention"><a class="markdownIt-Anchor" href="#tiled-attention"></a> Tiled Attention</h3><img src="https://s2.loli.net/2024/10/04/9mqkS5IwCl34OjV.png" alt="flashattnv1-algo" style="zoom:67%;" />  <p>这里的分块,是将QKVO进行分块,它们的shape都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mrow><mi>N</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R^{N \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>,想要在1个block内的smem放下</p><h2 id="flashattentionv2"><a class="markdownIt-Anchor" href="#flashattentionv2"></a> FlashAttentionV2</h2><p>相较于V1的更新:</p><ul><li>公式修改,以利用Tensor Core;</li><li>循环顺序调转,变成先切Q后切K,V</li><li></li></ul><h2 id="flashattentionv3"><a class="markdownIt-Anchor" href="#flashattentionv3"></a> FlashAttentionV3</h2><p><mark>只有阅读,没有hopper</mark></p><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件:</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/668888063">[Attention优化][2w字]🔥原理&amp;图解: 从Online-Softmax到FlashAttention V1/V2/V3</a></li><li><a href="https://courses.cs.washington.edu/courses/cse599m/23sp/notes/flashattn.pdf">From Online Softmax to FlashAttention</a></li><li><a href="https://arxiv.org/pdf/2205.14135">FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness</a></li><li><a href="https://arxiv.org/pdf/2307.08691">FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>flashAttention</tag>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tensor-core学习</title>
    <link href="/2024/08/08/tensor-core%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/08/08/tensor-core%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="tensor-core是啥"><a class="markdownIt-Anchor" href="#tensor-core是啥"></a> tensor core是啥</h2><p><strong>tensor core是一种专门处理矩阵乘运算的<u>运算单元</u></strong>,可以加速矩阵乘运算,实现混合精度计算;</p><p>Volta架构的tensor core支持fp16和fp32下的混合精度矩阵乘法</p><ul><li><p>可以通过c++的<strong>wmma(warp-level matrix multiply accumulate) api</strong>调用tensor core,支持如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><mi>A</mi><mi>B</mi><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">D = AB+C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mi>B</mi><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">C=AB+C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>的混合精度矩阵乘法</p></li><li><p><s>也可以通过<strong>wmma ptx</strong>调用tensor core,相关指令如下:</s> (<mark>此项废弃,因为wmma的ptx更像是Volta架构初次上新tensor core的尝试,不成熟,后面出的架构都用mma ptx</mark>)</p><ul><li><code>wmma.load</code>  tensor core数据加载指令,将矩阵数据从gmem/smem 加载到tensor core的寄存器</li><li><code>wmma.store</code></li><li><code>wmma.mma</code></li></ul></li><li><p>还可以用<strong>mma ptx</strong>指令调用tensor core:</p><ul><li><code>ldmatrix</code> tensor core数据加载指令,支持<strong>将矩阵数据从smem加载到tensor core的寄存器</strong></li><li><code>mma</code></li></ul></li></ul><div class="note note-info">            <p>注: 根据别人的逆向工程来看tensor core并没有独立的registerfile,也就是说用的还都是SM上的那个registerfile,跟cuda  core用的是同样的寄存器</p>          </div><p>调用cuda core和tensor core的区别如下:</p><ul><li>计算层级: cuda core是thread level; tensor core是warp level;</li><li>计算维度: cuda core是一维逐点计算, tensor core是二维逐tile计算(这个可以用C阵的一个元素和一个tile理解)</li><li>计算依赖: wmma调tensor core要用fragment这个数据存储类,cuda core不用借助别的啥</li></ul><p>实际上,在进行反汇编查看SASS码的时候可以发现,采用的是<code>LDSM</code>(LoaD Matrix fromt Shared memory)和<code>HMMA</code></p><h2 id="wmma-api"><a class="markdownIt-Anchor" href="#wmma-api"></a> WMMA API</h2><h3 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mma.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_fp16.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> nvcuda;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WMMA_M 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WMMA_N 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WMMA_K 16</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WARPSIZE 32</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checkCudaError(func) &#123;              \</span><br><span class="hljs-meta">    cudaError_t e = (func);                 \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span>(e != cudaSuccess)&#123;         \</span><br><span class="hljs-meta">        printf(<span class="hljs-meta-string">&quot;CUDA ERROR %s %d : %s\n&quot;</span>,__FILE__,__LINE__,cudaGetErrorString(e));  \</span><br><span class="hljs-meta">        exit(-1);                           \</span><br><span class="hljs-meta">    &#125;                                       \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ceilOperation(a,b) ((a+b-1) / b)</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. 采用wmma实现朴素的sgemm，跟朴素的sgemm实现思路差不多</span><br><span class="hljs-comment">    不过先前的方法是一个thread处理C中的一个元素，现在是一个warp处理C中的一个tile(16x16的tile,其中A,B的tile的k也是16)</span><br><span class="hljs-comment">    因为wmma是warp level的mma</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">sgemm_wmma_naive</span><span class="hljs-params">(<span class="hljs-keyword">const</span> half* __restrict__ A, <span class="hljs-keyword">const</span> half* __restrict__ B,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 half* __restrict__ C,<span class="hljs-keyword">int</span> M,<span class="hljs-keyword">int</span> N,<span class="hljs-keyword">int</span> K)</span></span>&#123;<br>    <span class="hljs-comment">// 沿着K方向上的A,B的tile需要遍历的次数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> kCnt = <span class="hljs-built_in">ceilOperation</span>(K,WMMA_K);<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bx = blockIdx.x;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> by = blockIdx.y;<br>    <span class="hljs-comment">// 这里是1个block只有1个warp</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> warpRow = by * WMMA_M;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> warpCol = bx * WMMA_N;<br>    <span class="hljs-keyword">if</span>(warpRow &gt; M || warpCol &gt; N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 用fragment模板类给数据做包装,C,D阵用accumulator,A,B阵有对应的matrix_a和matrix_b</span><br>    wmma::fragment&lt;wmma::accumulator,WMMA_M,WMMA_N,WMMA_K,half&gt; cFrag;<br><br>    wmma::<span class="hljs-built_in">fill_fragment</span>(cFrag,<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;kCnt;k++)&#123;<br>        wmma::fragment&lt;wmma::matrix_a,WMMA_M,WMMA_N,WMMA_K,half,wmma::row_major&gt; aFrag;<br>        wmma::fragment&lt;wmma::matrix_b,WMMA_M,WMMA_N,WMMA_K,half,wmma::col_major&gt; bFrag;<br><br>        wmma::<span class="hljs-built_in">load_matrix_sync</span>(aFrag,A+warpRow*K+k*WMMA_K,K);<br>        wmma::<span class="hljs-built_in">load_matrix_sync</span>(bFrag,B+warpCol*K+k*WMMA_K,K);<br>    <br>        wmma::<span class="hljs-built_in">mma_sync</span>(cFrag,aFrag,bFrag,cFrag);<br>    &#125;<br>    wmma::<span class="hljs-built_in">store_matrix_sync</span>(C+warpRow*N+warpCol,cFrag,N,wmma::mem_row_major);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span>** argv)</span></span>&#123; <br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;Please input 4 elements,like: ./xx M N K\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> gpu_id = <span class="hljs-number">2</span>;<br>    cudaDeviceProp prop;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cudaGetDeviceProperties</span>(&amp;prop,gpu_id) == cudaSuccess)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Using GPU:%d : %s\n&quot;</span>,gpu_id,prop.name);<br>    &#125;<br><br>    <span class="hljs-built_in">cudaSetDevice</span>(gpu_id);<br><br>    <span class="hljs-keyword">int</span> M = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">int</span> N = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">int</span> K = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">3</span>]);<br><br>    <span class="hljs-keyword">size_t</span> sizeA = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(half)*M*K;<br>    <span class="hljs-keyword">size_t</span> sizeB = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(half)*K*N;<br>    <span class="hljs-keyword">size_t</span> sizeC = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(half)*M*N;<br><br>    half* hA = (half*)<span class="hljs-built_in">malloc</span>(sizeA);<br>    half* hB = (half*)<span class="hljs-built_in">malloc</span>(sizeB);    <br>    half* hC = (half*)<span class="hljs-built_in">malloc</span>(sizeC);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M*K;i++)&#123;<br>        hA[i] = i/<span class="hljs-number">256.0f</span>;  <span class="hljs-comment">//i/6;</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;K*N;i++)&#123;<br>        hB[i] = (i+<span class="hljs-number">1.25f</span>)/<span class="hljs-number">128.0f</span>;  <span class="hljs-comment">//(i+1.25f)/2;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hA[%d]: %f; hB[%d]: %f\n&quot;</span>,i,__half2float(hA[i]),i,__half2float(hB[i]));<br><br>    half* dA,*dB,*dC;<br>    <span class="hljs-comment">// float* dC;</span><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMalloc</span>(&amp;dA,sizeA));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMalloc</span>(&amp;dB,sizeB));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMalloc</span>(&amp;dC,sizeC));<br><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMemcpy</span>(dA,hA,sizeA,cudaMemcpyHostToDevice));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMemcpy</span>(dB,hB,sizeB,cudaMemcpyHostToDevice));<br><br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(WARPSIZE)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(ceilOperation(N,WMMA_N),ceilOperation(M,WMMA_M))</span></span>;<br><br>    sgemm_wmma_naive&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA,dB,dC,M,N,K);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMemcpy</span>(hC,dC,sizeC,cudaMemcpyDeviceToHost));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hC[%d]:[%.6f]\n&quot;</span>,i,__half2float(hC[i]));<br><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaFree</span>(dA));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaFree</span>(dB));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaFree</span>(dC));<br>    <span class="hljs-built_in">free</span>(hA);<br>    <span class="hljs-built_in">free</span>(hB);<br>    <span class="hljs-built_in">free</span>(hC);<br>    <span class="hljs-built_in">cudaDeviceReset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意：由于fp16是E5M10，即它的最大值和最小值是±65504，所以处理的时候需要注意一下控制范围，不然很容易INF</p>          </div><h2 id="mma-ptx"><a class="markdownIt-Anchor" href="#mma-ptx"></a> MMA PTX</h2><h3 id="ldmatrix指令"><a class="markdownIt-Anchor" href="#ldmatrix指令"></a> ldmatrix指令</h3><h3 id="实验-2"><a class="markdownIt-Anchor" href="#实验-2"></a> 实验</h3><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_fp16.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHAPE 8*8*4</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> checkCudaError(func) &#123;                                                      \</span><br><span class="hljs-meta">    cudaError_t e = (func);                                                         \</span><br><span class="hljs-meta">    <span class="hljs-meta-keyword">if</span>(e!=cudaSuccess)&#123;                                                             \</span><br><span class="hljs-meta">        printf(<span class="hljs-meta-string">&quot;CUDA ERROR %s %d : %s\n&quot;</span>,__FILE__,__LINE__,cudaGetErrorString(e));  \</span><br><span class="hljs-meta">    &#125;                                                                               \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FLOAT4(pointer) (reinterpret_cast<span class="hljs-meta-string">&lt;float4*&gt;</span>(&amp;(pointer))[0])</span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">test_ldmatrix</span><span class="hljs-params">(half* dIn,half* dOut)</span></span>&#123;<br>    __shared__ half smemTmp[SHAPE];<br>    <span class="hljs-keyword">int</span> idx = threadIdx.x * <span class="hljs-number">8</span>;    <br>    <span class="hljs-comment">// 把数据从gmem -&gt; smem,一个线程取一行数据，即128bit共8个fp16,也即是4个fp32,可以用float4一次取完</span><br>    <span class="hljs-built_in">FLOAT4</span>(smemTmp[idx]) = <span class="hljs-built_in">FLOAT4</span>(dIn[idx]);<br>    <span class="hljs-comment">// printf(&quot;[%d]:[%f]\n&quot;,threadIdx.x,__half2float(smemTmp[idx]));    // smem数据是按要求摆放的 </span><br>    <br>    <span class="hljs-keyword">uint32_t</span> reg[<span class="hljs-number">4</span>];<br>    <span class="hljs-comment">// 使用ldmatrix, smem -&gt; reg</span><br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;ldmatrix.sync.aligned.m8n8.x4.b16 &#123;%0,%1,%2,%3&#125;,[%4];    \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;=r&quot;</span>(reg[<span class="hljs-number">0</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;=r&quot;</span>(reg[<span class="hljs-number">1</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;=r&quot;</span>(reg[<span class="hljs-number">2</span>]),</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-string">&quot;=r&quot;</span>(reg[<span class="hljs-number">3</span>])</span></span><br><span class="hljs-params"><span class="hljs-function">        : <span class="hljs-string">&quot;l&quot;</span>(&amp;smemTmp[idx])</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br>    <span class="hljs-comment">// 把每个线程寄存器得到的东西给它移动到我们的dOut中 reg -&gt; gmem</span><br>    *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;dOut[idx]))    = *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;reg[<span class="hljs-number">0</span>]));<br>    *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;dOut[idx+<span class="hljs-number">2</span>]))  = *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;reg[<span class="hljs-number">1</span>]));<br>    *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;dOut[idx+<span class="hljs-number">4</span>]))  = *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;reg[<span class="hljs-number">2</span>]));<br>    *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;dOut[idx+<span class="hljs-number">6</span>]))  = *(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">float</span>*&gt;(&amp;reg[<span class="hljs-number">3</span>]));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 数组是 fp16,4个8*8的阵,用以查看ldmatrix中.num为.x4的数据排布</span><br>    half hLoad[SHAPE];<br>    half hStore[SHAPE];<br>    <span class="hljs-comment">// 初始化data,为[0,255]的整型</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;SHAPE;i++)&#123;<br>        hLoad[i]=i;<br>    &#125;<br><br>    <span class="hljs-keyword">size_t</span> sizeData = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(half) * (SHAPE);<br>    half* dLoad,*dStore;<br><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMalloc</span>(&amp;dLoad,sizeData));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMalloc</span>(&amp;dStore,sizeData));<br><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMemcpy</span>(dLoad,hLoad,sizeData,cudaMemcpyHostToDevice));<br>    test_ldmatrix&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">32</span>&gt;&gt;&gt;(dLoad,dStore);<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaMemcpy</span>(hStore,dStore,sizeData,cudaMemcpyDeviceToHost));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;T%02d &quot;</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j+=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r%d %12f %12f &quot;</span>,j/<span class="hljs-number">2</span>,__half2float(hStore[i*<span class="hljs-number">8</span>+j]),__half2float(hStore[i*<span class="hljs-number">8</span>+j+<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;    <br><br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaFree</span>(dLoad));<br>    <span class="hljs-built_in">checkCudaError</span>(<span class="hljs-built_in">cudaFree</span>(dStore));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/08/10/BsMyUx9jIu3RLbA.png" alt="ldmatrix_no_trans" style="zoom:80%;" /><img src="https://s2.loli.net/2024/08/10/qZrAJ8dP3x15XTM.png" alt="ldmatrix_with_trans" style="zoom:80%;" /><h3 id="mma指令"><a class="markdownIt-Anchor" href="#mma指令"></a> mma指令</h3><p>看完上面的ldmatrix指令，你会好奇，为啥要搞得这么复杂啊，1个warp的线程这样读，转置也是另一种读法</p><p>实际上ldmatrix是为了和mma指令搭配使用的，看下mma指令在M16N8K16情况下的1个warp涉及到的C tile和A tile以及B tile的线程分布情况，你就知道为啥这么复杂了：</p><p>很明显，它跟上面那个ldmatrix指令读取时的数据分布到线程的情况是一样的，因此可以很好的搭配起来使用<mark>具体为什么要这么复杂的数据分布，我觉得是设计的时候考虑到了如shared mem bank conflict一类的问题而致的？</mark></p><p><strong>参考文件：</strong></p><ul><li><a href="https://docs.nvidia.com/cuda/parallel-thread-execution">Nvidia-PTX</a></li><li><a href="https://docs.nvidia.com/cuda/inline-ptx-assembly">Nvidia-InlinePTXAssembly</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GPU</tag>
      
      <tag>CUDA C/C++</tag>
      
      <tag>tensor core</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pnnx基础学习</title>
    <link href="/2024/07/13/pnnx%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/13/pnnx%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是模型部署"><a class="markdownIt-Anchor" href="#什么是模型部署"></a> 什么是模型部署</h2><blockquote><p><strong>本部分参考OpenMMLab在知乎的博文进行编写</strong></p></blockquote><p>模型部署需要明确<strong>部署场景</strong>,<strong>部署方式</strong>(中心服务化还是本地终端部署),模型优化指标,如何提高吞吐和减少延迟</p><h3 id="部署场景"><a class="markdownIt-Anchor" href="#部署场景"></a> 部署场景</h3><ul><li><strong>中心服务器云端部署</strong><ul><li>用户通过API调用接口或网页访问</li></ul></li><li><strong>边缘部署</strong><ul><li>用于<strong>嵌入式设备</strong>,要将模型打包封装到SDK,集成到嵌入式设备,<strong>数据处理和模型推理要在终端设备上执行</strong>(功耗,别耗电;要小,不占地儿)</li></ul></li></ul><h3 id="部署方式"><a class="markdownIt-Anchor" href="#部署方式"></a> 部署方式</h3><table><thead><tr><th></th><th style="text-align:center">SDK部署</th><th style="text-align:center">Service部署</th></tr></thead><tbody><tr><td>部署环境</td><td style="text-align:center">SDK引擎</td><td style="text-align:center">训练框架</td></tr><tr><td>模型语义转换</td><td style="text-align:center">需要进行前后处理和模型算子重实现</td><td style="text-align:center">一般框架内部负责语义转换</td></tr><tr><td>前后处理对齐算子</td><td style="text-align:center">训练和部署对应两套实现,需要进行算子数值对齐</td><td style="text-align:center">共用算子</td></tr><tr><td>计算优化</td><td style="text-align:center">挖掘芯片编译器的深度优化能力</td><td style="text-align:center">利用引擎已有的训练优化能力</td></tr></tbody></table><h3 id="部署核心优化指标"><a class="markdownIt-Anchor" href="#部署核心优化指标"></a> 部署核心优化指标</h3><p>合理把控：成本、功耗、性价比</p><ul><li>成本<ul><li>芯片选型</li><li>算力需求挑芯片（如加个DSP增加定点算力）</li></ul></li><li>功耗<ul><li>电池电池电池！！要用专用的优化的加速器单元如NPU以节省功耗</li></ul></li><li>性价比<ul><li>云端追求多路的吞吐量优化需求</li><li>终端追求单路延迟需要；针对CV和NLP问题对精度的要求不一样，因此有芯片选型的问题：CV INT4/INT8；NLP FP16</li></ul></li></ul><h3 id="部署流程"><a class="markdownIt-Anchor" href="#部署流程"></a> 部署流程</h3><p>这里用的是商汤的SenseParrots来讲解部署流程，且以SDK部署为例</p><h4 id="模型转换"><a class="markdownIt-Anchor" href="#模型转换"></a> 模型转换</h4><p>转换模型以适配不同框架。主流以ONNX或Caffe为模型交换格式。</p><p>主要分为：</p><ul><li><strong>计算图生成</strong></li><li><strong>计算图优化（optional，如算子融合）</strong></li><li><strong>计算图转换</strong></li></ul><h5 id="计算图生成"><a class="markdownIt-Anchor" href="#计算图生成"></a> 计算图生成</h5><p>通过一次推理来记录，将模型翻译成静态的表达（转成静态图）。在模型推理时，框架会记录算子的详细信息，也包括入参出参，以及所属层次</p><h5 id="计算图优化"><a class="markdownIt-Anchor" href="#计算图优化"></a> 计算图优化</h5><p>去除冗余op，算子融合</p><h5 id="计算图转换"><a class="markdownIt-Anchor" href="#计算图转换"></a> 计算图转换</h5><p>分析静态计算图算子，转换到目标格式。支持多后端（啥意思？）</p><h4 id="模型量化压缩"><a class="markdownIt-Anchor" href="#模型量化压缩"></a> 模型量化压缩</h4><p>边缘部署要求<strong>模型小</strong>，<strong>吞吐率高</strong> -&gt; 蒸馏/剪枝/量化</p><p>量化：FP32压缩到INT8/INT4乃至INT1（？），比如压到INT8-&gt;上面说了终端设备芯片选型会弄个定点计算单元，可以低比特指令实现低精度算子</p><p>量化技术栈：</p><ul><li><strong>量化训练（Quantization Aware Training）</strong>:插入伪量化算子（模拟低精度运算），通过梯度下降来做微调，以使得得到精度符合预期的模型</li><li><strong>离线量化（Post Training Quantization）</strong>： 少量校准数据集（原始数据集中挑），获得网络的激活分布，用统计手段或优化浮点定点输出分布来获得量化参数</li></ul><p>平衡吞吐和精度是一个问题；结合推理引擎挖掘芯片的能力；</p><h4 id="模型打包封装sdk"><a class="markdownIt-Anchor" href="#模型打包封装sdk"></a> 模型打包封装SDK</h4><p>要做前后处理，相当于是流水线中的一个流水段，可能是许多模型的一部分</p><p>保护模型还要加密（没想过还有这个，不过也合理）</p><h2 id="pnnx"><a class="markdownIt-Anchor" href="#pnnx"></a> PNNX</h2><p><strong>PNNX: <u>P</u>yTorch <u>N</u>eural <u>N</u>etwork e<u>X</u>change</strong></p><p>模型部署新方式</p><p><mark>介绍补充</mark></p><h2 id="pnnx2ncnn运行resnet-50快速上手vulkan"><a class="markdownIt-Anchor" href="#pnnx2ncnn运行resnet-50快速上手vulkan"></a> pnnx2ncnn运行ResNet-50快速上手(vulkan)</h2><p>开始前请先确定自己的ncnn已编译安装完成</p><h3 id="搭建项目结构"><a class="markdownIt-Anchor" href="#搭建项目结构"></a> 搭建项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>|-- CMakeLists.txt<br>|-- bin<br>|-- build<br>|-- images<br>|   `-- cat.jpg<br>|-- src<br>|   `-- infer.cpp<br>|-- utils<br>|   `-- resnet50.py<br>`-- weight_param<br></code></pre></td></tr></table></figure><p>项目结构如上所示,其中:</p><ul><li><strong>CMakeLists.txt</strong>: 用于构建项目</li><li><strong>bin</strong>: 用于存储最终编译得到的可执行文件</li><li><strong>build</strong>: 用于项目构建,以便清理</li><li><strong>images</strong>: 存放用于进行推理效果检测的图片,图片大小需要为224x224,这里准备了一张小猫的图片</li><li><strong>src</strong>: 用于存放源文件</li><li><strong>utils</strong>: 用于存放python文件</li><li><strong>weight_param</strong>: 用于存放python文件导出的TorchScript文件和pnnx进行转换后的权重和计算图参数文件</li></ul><h3 id="获取pnnx"><a class="markdownIt-Anchor" href="#获取pnnx"></a> 获取pnnx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pnnx<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 此方法方便快捷,当然也可以<code>wget</code>对应的源文件进行编译</p>          </div><h3 id="pytorch-resnet50转换为torchscipt"><a class="markdownIt-Anchor" href="#pytorch-resnet50转换为torchscipt"></a> PyTorch ResNet50转换为TorchScipt</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br><br><span class="hljs-comment"># 加载预训练好的ResNet-50</span><br>resnet = models.resnet50(pretrained=<span class="hljs-literal">True</span>)<br>resnet.<span class="hljs-built_in">eval</span>()<br><br><span class="hljs-comment"># 输入参数为[1,3,224,224]</span><br>ipt = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>)<br><br>jit_model = torch.jit.trace(resnet, ipt)<br>jit_model.save(<span class="hljs-string">&#x27;../weight_param/resnet50.pth&#x27;</span>) <br></code></pre></td></tr></table></figure><p>在utils下运行<code>python resnet50.py</code>后,在weight_param文件夹下得到<code>resnet50.pth</code></p><h3 id="pnnx转torchscipt为ncnn"><a class="markdownIt-Anchor" href="#pnnx转torchscipt为ncnn"></a> pnnx转TorchScipt为ncnn</h3><p>在weight_param下运行<code>pnnx resnet50.pth [1,3,224,224]</code></p><div class="note note-info">            <p>注: 在命令行中通过输入<code>pnnx</code>后运行,可以看到一些<code>Sample Usage</code>,里面有举例说明用法</p>          </div><p>运行指令后可以在当前文件夹下得到多个<code>.bin</code>,<code>.param</code>文件</p><p><code>.bin</code>文件内部存储的是模型的权重;</p><p><code>.param</code>文件存储的是计算图的详细信息</p><h3 id="编写推理文件"><a class="markdownIt-Anchor" href="#编写推理文件"></a> 编写推理文件</h3><p>在开始编写推理文件前,需要看一下<strong>pnnx转ncnn</strong>中的<code>resnet50.ncnn.param</code>,我们需要从该文件内获取输入输出对应的blob:</p><p><img src="https://s2.loli.net/2024/07/17/umnT5Uze1aRfql6.png" alt="resnet50.ncnn.param" /></p><p>推理文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(USE_NCNN_SIMPLEOCV)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;simpleocv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">detect_resnet50</span><span class="hljs-params">(<span class="hljs-keyword">const</span> cv::Mat&amp; bgr, std::vector&lt;<span class="hljs-keyword">float</span>&gt;&amp; cls_scores)</span></span><br><span class="hljs-function"></span>&#123;<br>    ncnn::Net resnet50;<br><br>    resnet50.opt.use_vulkan_compute = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 加载模型的计算图参数和权重</span><br>    <span class="hljs-keyword">if</span> (resnet50.<span class="hljs-built_in">load_param</span>(<span class="hljs-string">&quot;weight_param/resnet50.ncnn.param&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (resnet50.<span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;weight_param/resnet50.ncnn.bin&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 图片格式转换 BGR-&gt;RGB</span><br>    ncnn::Mat in = ncnn::Mat::<span class="hljs-built_in">from_pixels_resize</span>(bgr.data, ncnn::Mat::PIXEL_BGR2RGB, bgr.cols, bgr.rows, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>);<br>    <br>    <span class="hljs-comment">// 图像归一化,这里做的是:(x/255 - 0.485) / 0.229 ,上下同时乘255可得</span><br>    <span class="hljs-comment">// (x - 0.485*255) / 0.229*255 ,而在substract_mean_normalize中的标准差是倒数</span><br>    <span class="hljs-comment">// 因此norm_vals的标准差取了倒数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> mean_vals[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0.485f</span>*<span class="hljs-number">255.f</span>, <span class="hljs-number">0.456f</span>*<span class="hljs-number">255.f</span>, <span class="hljs-number">0.406f</span>*<span class="hljs-number">255.f</span>&#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> norm_vals[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>/<span class="hljs-number">0.229f</span>/<span class="hljs-number">255.f</span>, <span class="hljs-number">1</span>/<span class="hljs-number">0.224f</span>/<span class="hljs-number">255.f</span>, <span class="hljs-number">1</span>/<span class="hljs-number">0.225f</span>/<span class="hljs-number">255.f</span>&#125;;<br>    in.<span class="hljs-built_in">substract_mean_normalize</span>(mean_vals, norm_vals);<br><br>    ncnn::Extractor ex = resnet50.<span class="hljs-built_in">create_extractor</span>();<br><br>    ex.<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;in0&quot;</span>, in);<br><br>    ncnn::Mat out;<br>    ex.<span class="hljs-built_in">extract</span>(<span class="hljs-string">&quot;out0&quot;</span>, out);<br><br>    cls_scores.<span class="hljs-built_in">resize</span>(out.w);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; out.w; j++)<br>    &#123;<br>        cls_scores[j] = out[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print_topk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">float</span>&gt;&amp; cls_scores, <span class="hljs-keyword">int</span> topk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 前topk的局部排序</span><br>    <span class="hljs-keyword">int</span> size = cls_scores.<span class="hljs-built_in">size</span>();<br>    std::vector&lt;std::pair&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>&gt; &gt; vec;<br>    vec.<span class="hljs-built_in">resize</span>(size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        vec[i] = std::<span class="hljs-built_in">make_pair</span>(cls_scores[i], i);<br>    &#125;<br><br>    std::<span class="hljs-built_in">partial_sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">begin</span>() + topk, vec.<span class="hljs-built_in">end</span>(),<br>                      std::greater&lt;std::pair&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>&gt; &gt;());<br><br>    <span class="hljs-comment">// 打印topk及对应的分数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; topk; i++)<br>    &#123;<br>        <span class="hljs-keyword">float</span> score = vec[i].first;<br>        <span class="hljs-keyword">int</span> index = vec[i].second;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%d = %f\n&quot;</span>, index, score);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Usage: %s [imagepath]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* imagepath = argv[<span class="hljs-number">1</span>];<br><br>    cv::Mat m = cv::<span class="hljs-built_in">imread</span>(imagepath, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;cv::imread %s failed\n&quot;</span>, imagepath);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    std::vector&lt;<span class="hljs-keyword">float</span>&gt; cls_scores;<br>    <span class="hljs-built_in">detect_resnet50</span>(m, cls_scores);<br><br>    <span class="hljs-comment">// 打印得分前三的类别</span><br>    <span class="hljs-built_in">print_topk</span>(cls_scores, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完推理文件后,进行CMakeLists.txt的编写:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(NCNN_DEMO)<br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>.<span class="hljs-number">12</span>)<br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<br><br><br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;CMAKE_PREFIX_PATH&#125;</span> <span class="hljs-string">&quot;/path/to/ncnn/build/install&quot;</span>)<br><span class="hljs-keyword">find_package</span>(ncnn   REQUIRED)<br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><br><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-keyword">add_executable</span>(resnet50 src/infer.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(resnet50 ncnn <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span>)<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 上面的<code>CMAKE_PREFIX_PATH</code>加上的搜索路径是你编译安装好ncnn后,build文件夹内的install文件夹</p>          </div><h3 id="构建及测试"><a class="markdownIt-Anchor" href="#构建及测试"></a> 构建及测试</h3><p>进入build文件夹下,执行<code>cmake ..</code>构建项目,而后执行<code>make</code>以生成可执行文件</p><p><code>cd ..</code>退到项目根目录下</p><p>运行<code>./bin/resnet50 ./images/cat.jpg</code>以查看推理结果:</p><img src="https://s2.loli.net/2024/07/17/BT85sEXMcSyNCU3.png" alt="pnnx2ncnn_infer" style="zoom:50%;" /><p>这里输出的283,154一类的数字是训练用的标签,因为采用的ResNet-50是在ImageNet数据集上进行预训练的,其中上述标签对应具体类别为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">154: &#x27;Pekinese, Pekingese, Peke&#x27;, // 哈巴狗<br>283: &#x27;Persian cat&#x27;, // 波斯猫<br>284: &#x27;Siamese cat, Siamese&#x27;, // 暹罗猫<br></code></pre></td></tr></table></figure><p>可以看出来,它确实正确预测了是只猫(虽然具体的种类错了)</p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/367042545">AI 框架部署方案之模型部署概述</a></li><li><a href="https://github.com/HuPengsheet/use-ncnn/blob/main/notes/ncnn02-onnx%E8%BD%ACncnn%E6%A8%A1%E5%9E%8B%E8%B7%91resnet18.md">onnx2ncnn</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pnnx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA优化技巧</title>
    <link href="/2024/07/09/CUDA%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/09/CUDA%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="向量化访存指令在smem中的机制"><a class="markdownIt-Anchor" href="#向量化访存指令在smem中的机制"></a> 向量化访存指令在SMEM中的机制</h2><blockquote><p>When you store (or load) more than 4 bytes per thread, which is like saying more than 128 bytes per warp, the GPU does not issue a single transaction. The largest transaction size is 128 bytes.</p></blockquote><p>上面这段话是在Nvidia论坛上官方回复的一句话，可以这么理解：<strong>所谓的访存请求是会被拆分为memory transaction来执行的，如果是每个线程取/存4B的元素，则整个warp是处理128B的数据，这正好是单次memory transaction可以处理的最大数据</strong></p><p>如果单次访存请求超过了128B，则不会只发射1条transaction</p><p>GPU会进行拆分，比如你采用LDS.64访存，会被拆成两条memory transaction，[T0-T15],[T16,T31]各自承担1个memory transaction。每一个都是128B的位宽，而后的bank conflict是根据每个memory transaction中涉及到的线程所产生的，而不是所谓的请求/warp/指令。</p><h3 id="lds32"><a class="markdownIt-Anchor" href="#lds32"></a> LDS.32</h3><p>这是最朴素的一种访存机制，因为在warp内的32个线程，每个线程去访问共享内存中的32bit，即4B的一个元素。存在以下情况：</p><ul><li>线程访问到各自对应的共享内存上的元素，即访问到不同bank，无bank conflict;</li><li>某些个线程访问到同一个bank上的同一地址，发起广播机制（这某些个线程里：其中1个线程取数，然后广播给另几个线程），无bank conflict;</li><li>某些个线程访问到同一个bank上的不同地址，产生bank conflict。所谓的某些个线程有n个，则为n way bank conflict，会将访存转换为串行的n条指令进行（应该就是n条memory transaction）</li></ul><h3 id="lds64"><a class="markdownIt-Anchor" href="#lds64"></a> LDS.64</h3><p>采用类似于float2/uint2的向量化访存对shared memory进行访存时，1个warp被拆成了2个half warp，如T0-T15、T16-T31，1个活跃的half warp进行1次memory transaction，活跃即意味着里面有至少一个线程是有访存需求的。</p><p>因此如果1个warp里的2个half warp都是活跃的，则要进行2次memory transaction，是串行执行的。</p><p><strong>当有以下情况发生时，则2次memory transaction可以合并成1次</strong>：</p><ul><li>对于整个warp，活跃的第i号线程，与不活跃的第i^1号线程  || 活跃的第i号线程和活跃的第i^1号线程访问同一块地址;</li><li>对于整个warp，活跃的第i号线程，与不活跃的第i^2号线程  || 活跃的第i号线程和活跃的第i^2号线程访问同一块地址;</li></ul><div class="note note-info">            <p>注：上面的合并memory transaction的情况是<strong>针对整个warp而言的</strong>，如果两个half warp一个满足规则1（就是第一条），一个满足规则2，也是无法合并的</p>          </div><h3 id="lds128"><a class="markdownIt-Anchor" href="#lds128"></a> LDS.128</h3><p>采用类似于float4/uint4的向量化访存对shared memory进行访问，1个half warp被拆分成2个quarter warp，如T0-T7、T8-T15，1个活跃的quarter warp进行1次memory transaction</p><p>可见当4个quarter warp都活跃时需要进行4次串行的memory transaction，它的合并策略和LDS.64的一样，这里重复一次，并注明它的注意事项：</p><ul><li>对整个warp：(活跃的第i号线程与不活跃的第i^1号线程) || (活跃的第i号线程和活跃的第i^1号线程均访问同一地址);</li><li>对整个warp：(活跃的第i号线程与不活跃的第i^2号线程) || (活跃的第i号线程和活跃的第i^2号线程均访问同一地址);</li></ul><div class="note note-info">            <p>注：</p><ul><li>只有T0-T7,T8-T15活跃，并且满足条件1，则合并为1个half warp，1次memory transaction</li><li>只有T8-T15,T16-T23活跃，且满足条件1，由于分属不同half warp，无法合并，2次memory transaction</li><li>T0-T7,T8-15满足条件1，T16-T23,T24-T31满足条件2，无法合并，4次memory transaction</li><li>T0-T7,T8-T15,T16-T23,T24-T31均满足同一合并条件，则合并为两个half warp，2次memory transaction，注意，俩half warp不可再合了，没有这种cascade操作</li></ul>          </div><h3 id="实验部分"><a class="markdownIt-Anchor" href="#实验部分"></a> 实验部分</h3><h4 id="lds64-2"><a class="markdownIt-Anchor" href="#lds64-2"></a> LDS.64</h4><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t1</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">if</span>(tid&lt;<span class="hljs-number">16</span>)&#123;<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid]= <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t2</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">if</span>(tid&lt;<span class="hljs-number">15</span> || tid==<span class="hljs-number">16</span>)&#123;<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid==<span class="hljs-number">16</span>?<span class="hljs-number">15</span>:tid];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t3</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid/<span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t4</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">uint32_t</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">uint32_t</span> idx = (tid&gt;&gt;<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// printf(&quot;0:[tid:%d]:[idx:%d]\n&quot;,tid,idx);</span><br>    idx = (idx == <span class="hljs-number">0</span>) ? idx+tid&gt;&gt;<span class="hljs-number">1</span> : (idx + (tid&amp;<span class="hljs-number">1</span>) + (((tid&gt;&gt;<span class="hljs-number">2</span>)<span class="hljs-number">-4</span>)&lt;&lt;<span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// printf(&quot;1:[tid:%d]:[idx:%d]\n&quot;,tid,idx);</span><br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[idx];<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t5</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span> + tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">uint32_t</span> idx = tid&gt;&gt;<span class="hljs-number">4</span>==<span class="hljs-number">0</span> ? tid : tid<span class="hljs-number">-16</span>;<br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[idx];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>* dA;<br>    <span class="hljs-keyword">size_t</span> sizedA = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint32_t</span>) * <span class="hljs-number">128</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        相当于:</span><br><span class="hljs-comment">        bank    0   1  ... 31 </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   - </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   -</span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   - </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">cudaMalloc</span>(&amp;dA,sizedA);<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<br><br>    smem_t1&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t2&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t3&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t4&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t5&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br><br>    <span class="hljs-built_in">cudaFree</span>(dA);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是对着第三个参考文件里的图LDS.64的图写的，并采用Nsight Compute的shard_op_ld进行bank conflict和memory transaction次数的查看，实验结果如下(其中wavefront代表memory transaction的次数，这里没有产生bank  conflict的例子)：</p><img src="https://s2.loli.net/2024/07/26/aCX3xBLzIPFDiV4.png" alt="lds64_smem_t1" style="zoom:50%;"/><img src="https://s2.loli.net/2024/07/26/Pieh8Jpfb7ad9nM.png" alt="lds64_smem_t2" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/8GczNsDFakHBoJR.png" alt="lds64_smem_t3" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/25PqRkyQHugMYFs.png" alt="lds64_smem_t4" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/iaJXFLNsQfvbk9m.png" alt="lds64_smem_t5" style="zoom:50%;" /><p><strong>参考文件：</strong></p><ul><li><a href="https://forums.developer.nvidia.com/t/how-to-understand-the-bank-conflict-of-shared-mem/260900">how-to-understand-bank-conflict-of-shared-memory</a></li><li><a href="https://forums.developer.nvidia.com/t/unexpected-shared-memory-bank-conflict/77228">LDS.128-how-to-increase-bandwidth</a></li><li><a href="https://code.hitori.moe/post/cuda-shared-memory-access-mechanism-with-vectorized-instructions/">CUDA Shared Memory 在向量化指令下的访存机制</a></li></ul><h2 id="ampere架构的异步拷贝"><a class="markdownIt-Anchor" href="#ampere架构的异步拷贝"></a> Ampere架构的异步拷贝</h2><p>异步拷贝的作用是<code>global mem -&gt; shared mem</code>而无需借助register中转，在说异步拷贝前，先需要说下state space这个玩意</p><h3 id="关于state-space的一些理解"><a class="markdownIt-Anchor" href="#关于state-space的一些理解"></a> 关于state space的一些理解</h3><p>在ptx/sass级别，cuda内部有一个状态空间(state space)的系统,这玩意是一个分区的寻址结构(<mark>给我一种ptx上的namespace的感觉</mark>),按照<strong>参考文件2</strong>的解释:</p><blockquote><p>A state space is a storage area with particular characteristics.</p></blockquote><p><strong>状态空间这个存储区域有着自己的特性,所有的变量都是驻留在一些状态空间中的</strong>.状态空间的特性有:<u>大小,可否寻址,访问速度,访问权限,以及线程间的共享级别</u></p><p>下图是所有的状态空间:</p><img src="https://s2.loli.net/2024/08/15/UoxzYPOJhvrLMQc.png" alt="state-space" style="zoom:80%;" /><p>下图是各状态空间对应的特性:</p><img src="https://s2.loli.net/2024/08/15/E8DzujRVlGAQNXU.png" alt="properties of state space" style="zoom:80%;" /><p>说完state space,回到异步拷贝上来</p><p>我们在cuda中对其中一个state space进行访问可以使用以下两种类型的指针的任意一种：</p><ul><li><strong>被修饰的适合于该空间的指针</strong>；</li><li><strong>generic pointer</strong>，这种类型的指针没有携带任何的state或者额外的信息去声明它所属于的state space；</li></ul><p>在CUDA C<ins>中，指针就是指针，没有额外的修饰或者说元信息,当使用c</ins>中公开的方法去进行异步拷贝，不需要显式的转换；</p><p>而当你使用PTX指令(比如内联汇编)去做比如异步拷贝的时候就需要一个shared state space pointer，而不是generic pointer。就比如你用c++取得这个需要的state space地址，然后用ptx内联汇编去发射这条指令.你可以用<code>__cvta_generic_to_shared()</code>来进行地址的转换,从而获得shared state space的pointer</p><p>在ptx/sass中的state space pointer在c++中没有可以用来模拟的东东，因此使用了<code>size_t</code>的返回类型来识别64位的数量,虽然好像共享内存state space的pointer它是32位的(<mark>?</mark>)</p><blockquote><p><strong>shared state space pointer seems to easily fit in 32 bits</strong></p></blockquote><h3 id="cpasync指令详情"><a class="markdownIt-Anchor" href="#cpasync指令详情"></a> <code>cp.async</code>指令详情</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cp.async.ca.shared&#123;::cta&#125;.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;<br>                         [dst], [src], cp-size&#123;, src-size&#125;&#123;, cache-policy&#125; ;<br>cp.async.cg.shared&#123;::cta&#125;.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;<br>                         [dst], [src], 16&#123;, src-size&#125;&#123;, cache-policy&#125; ;<br>cp.async.ca.shared&#123;::cta&#125;.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;<br>                         [dst], [src], cp-size&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;<br>cp.async.cg.shared&#123;::cta&#125;.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;<br>                         [dst], [src], 16&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;<br><br>.level::cache_hint =     &#123; .L2::cache_hint &#125;<br>.level::prefetch_size =  &#123; .L2::64B, .L2::128B, .L2::256B &#125;<br>cp-size =                &#123; 4, 8, 16 &#125;<br></code></pre></td></tr></table></figure><ul><li><code>dst</code>shared state space的地址</li><li><code>src</code>: global state space的地址</li><li><code>cp-size</code>: byte为单位的整型常量,表示的是拷贝的数据的大小,可选值为4,8,16</li></ul><div class="note note-warning">            <p>没用到的先没细看,用到再look别的可选operand是啥意思</p>          </div><p>因为是异步拷贝,异步是nonblock的,所以你要拿个东西阻塞它,如果需要在某些代码执行前获取到结果的话:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cp.async.wait_all;<br></code></pre></td></tr></table></figure><p>也可以:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cp.async.commit_group;<br>cp.async.wait_group 0;// 这个0实际上是一个整型常量的operand N,别的意思没看懂,只看懂了0的,当N=0,执行线程等待所有先前的cp.async-group完成<br></code></pre></td></tr></table></figure><p><strong>上下这俩wait的语句块是等价的</strong></p><p><mark>这里没搞懂官网的按组提交异步拷贝指令(说是执行了<code>cp.async.commit_group</code>就标记了这一个异步拷贝组的结束(就是划分组的意思)),但是这个等待又好像不是一一对应的等待,好像是一个范围?没看懂举的例子,后面遇到再回来look</mark></p><h3 id="小实验"><a class="markdownIt-Anchor" href="#小实验"></a> 小实验</h3><p>这里的小实验的目的是用异步拷贝,把A的值给它异步拷贝到共享内存去,然后再从共享内存放到B中去,其中:</p><ul><li>A原有的值<code>A: [0,1,2,3,4,5,...,31]</code></li><li>B期望的结果<code>B:[31,30,29,28,...,0]</code></li></ul><p>我们每个线程(这里就是只开了1个block且只有32个线程)负责1个int类型的数据的移动,恰好只有32个数,1个线程也只需要搬运1次~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">test_cp_async</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* __restrict__ A,<span class="hljs-keyword">int</span>* __restrict__ B)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    __shared__ <span class="hljs-keyword">int</span> smem[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">size_t</span> smemAddr = __cvta_generic_to_shared(smem + tid);<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cp.async.ca.shared.global [%0],[%1],4; \n&quot;</span> ::<span class="hljs-string">&quot;l&quot;</span>(smemAddr),<span class="hljs-string">&quot;l&quot;</span>(A+<span class="hljs-number">31</span>-tid))</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cp.async.commit_group; \n&quot;</span> ::)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cp.async.wait_group 0;  \n&quot;</span> ::)</span></span>;<br>    B[tid] = smem[tid];<br>&#125;<br></code></pre></td></tr></table></figure><p>实验结果如下图所示:</p><p><img src="https://s2.loli.net/2024/08/15/dwjsovzxFD7lWQ9.png" alt="test_cp_async" /></p><h3 id="怎么就支持了gmem-smem呢"><a class="markdownIt-Anchor" href="#怎么就支持了gmem-smem呢"></a> 怎么就支持了GMEM-&gt;SMEM呢</h3><p><strong>参考文件：</strong></p><ul><li><a href="https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-cp-async">Nvidia-PTX-cp.async</a></li><li><a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#state-spaces">Nvidia-PTX-state-spaces</a></li><li><a href="https://forums.developer.nvidia.com/t/problem-about-ptx-instruction-cp-async-ca-shared-global/224219/2">Nvidia-forum-PTXinstructionCP_ASYNC_CA_SHARED</a></li><li><a href="https://stackoverflow.com/questions/76992939/confusion-about-cvta-generic-to-shared">Confusion about __cvta_generic_to_shared</a></li><li><a href="https://zhuanlan.zhihu.com/p/666438274">跟着样例学CUDA PTX(1)</a></li></ul><h2 id="smem-bank-conflict-free的一些方式"><a class="markdownIt-Anchor" href="#smem-bank-conflict-free的一些方式"></a> smem bank conflict free的一些方式</h2><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/722286440">bank conflict free的几种方式</a></li><li><a href="https://zhuanlan.zhihu.com/p/671419093">cute 之 Swizzle</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>OpDev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake简易使用</title>
    <link href="/2024/06/03/CMake%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/03/CMake%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><p><strong>通过编写平台无关的CMakeLists.txt文件来定制整个编译流程,然后执行之,根据目标平台生成所需的Makefile文件</strong>.流程如下:</p><ol><li>编写CMake配置文件CMakeLists.txt;</li><li>执行命令<code>cmake path</code>或选择带交互式界面的<code>ccmake path</code>,<code>path</code>是CMakeLists.txt所在的目录;</li><li>生成Makefile后使用<code>make</code>命令进行编译;</li></ol><p>因此采用CMake进行C++项目工程编译的关键在于编写CMakeLists.txt配置文件</p><p><strong><code>CMakeLists.txt</code>主要由命令,注释,空格组成,其中命令不区分大小写,<code>#</code>后跟着注释</strong><br /><strong>命令由命令名称,小括号,参数组成,参数用空格间隔开</strong></p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><ul><li><p><code>cmake_minimum_required(VERSION X.X)</code>: 运行此配置文件所需的cmake最低版本;</p></li><li><p><code>project(projectName)</code>: 指明项目名称;</p></li><li><p><code>add_executable()</code>: 将源文件(放后面)编译成可执行文件(放前面)</p></li><li><p><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code>: 指定dir,会获取该目录下的所有源文件,将结果存入变量variable中(通过${}调用变量)</p></li><li><p><code>add_subdirectory()</code>: 增加编译子目录,会去编译子目录下的<code>CMakeLists.txt</code>文件</p></li><li><p><code>target_link_libraries()</code>: 参数第一个放可执行文件,后面放链接库的库名,可能是自己的库</p></li><li><p><code>add_library()</code>: 生成链接库,跟add_executable一样,生成的库名放前面,后面放的是源文件</p></li><li><p><code>configure_file(&lt;input&gt; &lt;output&gt;)</code>: 将输入的配置文件,一般是<code>config.h.in</code>,里面编写了一些<code>#cmakedefine ...</code>语句,让<code>CMakeLists.txt</code>中的变量转换为宏定义,转换后的文件为<code>output</code>,里面的宏定义可以在代码中通过<code>#include ...</code>引入</p></li><li><p><code>option(&lt;variable&gt; &quot;&lt;help_text&gt;&quot; [value])</code> 定义一个变量,中间的是描述变量的作用,value可以写ON/OFF,不写则默认OFF,可以跟<code>CMakeLists.txt</code>中的<code>if()...endif()</code>一类的搭配使用,还可以和上面的配置文件搭配使用</p></li><li><p><code>set(&lt;variable&gt; value1 value2 ...)</code> 用来定义变量</p></li><li><p><code>include_directories()</code> 用以增加需要扫描的头文件路径</p></li><li><p><code>find_package(&lt;variable&gt; library_name HINTS &lt;dir&gt;)</code> 查找指定目录下的名为<code>library_name</code>的库,在编译前便会进行查找,而非到链接阶段再去看有没有库</p><div class="note note-info">            <p>注:实质上<code>find_package</code>一般用作寻找系统中安装的第三方库并进行链接,找的是<code>xxxConfig.cmake</code>这种包配置文件,比如找OpenCV的<code>OpenCVConfig.cmake</code>.一般的使用形式是:<code>find_package(OpenCV REQUIRED) # 查找名为opencv的包,找不到就报错,会终止当前的cmake进程不再执行.</code></p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/631259689">find_package</a></li></ul>          </div></li><li><p><code>message()</code>可以在打印<code>CMakeLists</code>中的变量或是提示信息</p></li></ul><h2 id="预定义变量"><a class="markdownIt-Anchor" href="#预定义变量"></a> 预定义变量</h2><p>参见最后一篇的参考文件,预定义变量对我们的项目工程排布有很大作用,需要记住常用的</p><h2 id="通用模板"><a class="markdownIt-Anchor" href="#通用模板"></a> 通用模板</h2><p>目前所采用的项目目录结构如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>├── bin<br>│   └── main<br>├── build<br>├── CMakeLists.txt<br>├── config.h.in<br>├── include<br>│   ├── config.h<br>│   └── xmath.h<br>├── lib<br>│   └── libxmath.a<br>└── src<br>    └── main.cpp<br></code></pre></td></tr></table></figure><ul><li>bin目录用来存放生成的可执行文件</li><li>build目录用以执行<code>cmake .. &amp;&amp; make</code></li><li>include目录用以放置头文件,故基本上扫描的头文件路径就是它</li><li>lib目录放置的是自己编写的静态/动态库,这是由另外的进行生成,我试着把库生成和main.cpp写在一个项目,但是在执行make的时候总出错,应该是我编写的问题,后续修改这个问题</li><li>src目录用以放置源文件</li><li><code>config.h.in</code>文件装放的是一些对源文件编译有影响的cmake中的变量,在<code>cmake .. </code>的时候会生成config.h,转换为C可用的宏定义</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">project</span>(final_demo)<br><span class="hljs-keyword">add_compile_options</span>(-Wall -std=c++<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">option</span>(MYMATH <span class="hljs-string">&quot;USE MY POW FUNCTION&quot;</span> <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">configure_file</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/config.h.in <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/config.h)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">if</span>(MYMATH)<br>    <span class="hljs-comment"># add_subdirectory($&#123;PROJECT_SOURCE_DIR&#125;/src/math)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_CPP)<br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SRC_CPP&#125;</span>)<br><span class="hljs-keyword">if</span>(MYMATH)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/libxmath.a)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/534439206">全网最细的CMake教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/664125090">[C++]Cmake使用教程(看这一篇就够了)</a></li><li><a href="https://blog.csdn.net/b1049112625/article/details/136501488">cmake的configure_file的用法</a></li><li><a href="https://www.jianshu.com/p/2946eeec2489">Cmake命令之configure_file介绍</a></li><li><a href="https://blog.csdn.net/weixin_44688770/article/details/128857512">CMake常见的预定义变量</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>C++项目编译工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>armV8架构及指令集知识</title>
    <link href="/2024/04/10/armV8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/10/armV8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="neon-intrinsic入门"><a class="markdownIt-Anchor" href="#neon-intrinsic入门"></a> Neon intrinsic入门</h2><h3 id="两个例子学习自arm的neon-intrinsic教程"><a class="markdownIt-Anchor" href="#两个例子学习自arm的neon-intrinsic教程"></a> 两个例子(学习自ARM的neon intrinsic教程)</h3><p>其实还有个collision detection的例子,但感觉那个例子不如前两个例子好,因此没编程实现</p><ol><li><strong>RGB deinterleaving</strong></li></ol><img src="https://s2.loli.net/2024/04/18/9BJZxrGLgn1Sepm.png" alt="RGB image pixel array" style="zoom:50%;" /><p>我们知道一个像素有三个颜色通道,R,G,B.每个像素点的颜色通道顺序排列,但如果我们想逐通道进行处理,则需要进行像素通道的分离,即从<code>rgb</code>这个数组中,分离三色通道,获得<code>r</code>,<code>g</code>,<code>b</code>三个单独的数组</p><p>用C实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_c</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *r,<span class="hljs-keyword">uint8_t</span> *g,<span class="hljs-keyword">uint8_t</span> *b,<span class="hljs-keyword">uint8_t</span> *rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;color_length;i++)&#123;<br>        r[i] = rgb[i*<span class="hljs-number">3</span>];<br>        g[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>];<br>        b[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样逐个元素取出然后放入数组是很容易联想到的一种方法,但是我们arm的通用寄存器是64位,每次处理都是64位的寄存器从内存load一个8位的数,又store回去.寄存器是宝贵的计算机资源,如此使用很浪费.</p><p>因此选择用neon实现,可以用向量寄存器来处理,128位则可以一次性处理16个8位的无符号整数(颜色范围[0,255]),但这样显然有问题,因为一次处理三个通道的数据,需要是3的倍数,因此可以选择用一个<code>uint8x16x3_t</code>的矩阵型数据类型来处理,这样一次采用三个向量寄存器处理即可.</p><p>用neon实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arm_neon.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_neon</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* r,<span class="hljs-keyword">uint8_t</span>* g,<span class="hljs-keyword">uint8_t</span>* b,<span class="hljs-keyword">uint8_t</span>* rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br><span class="hljs-keyword">int</span> num8x16 = color_length/<span class="hljs-number">16</span>;<br><span class="hljs-keyword">uint8x16x3_t</span> intlv_rgb;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num8x16;i++)&#123;<br>intlv_rgb = vld3q_u8(rgb+<span class="hljs-number">3</span>*<span class="hljs-number">16</span>*i);<br>vst1q_u8(r+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">0</span>]);<br>vst1q_u8(g+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">1</span>]);<br>vst1q_u8(b+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">2</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中因为一次是处理了16个像素点(48个通道信息),所以像素长度要除以16(也可以让控制像素长度的步长每次走16步)</p><p><code>vld3q_u8</code>是第一个接触到的neon intrinsic函数,v表示vector操作,ld表示这个函数的基本功能load,3q表示用到3个qword的寄存器,即是3个128位的向量寄存器,u8表示寄存器里的一个通道的数据是u8类型的,即unsigned int 8类型的.</p><p>它的返回值是一个<code>uint8x16x3_t</code> 的数据类型,将该类型的数据逐个取出,通过<code>vst1q_u8</code>的操作写到对应的数组中去</p><ol start="2"><li><strong>matrix multiplication</strong></li></ol><p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=A*B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>来考虑,其中是列主序的存储方式,C的维度是<code>n*m</code>,则普通的C矩阵乘如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_c</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span>* A,<span class="hljs-keyword">float32_t</span>* B,<span class="hljs-keyword">float32_t</span>* C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,p;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            C[i+j*n] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// Inner Product</span><br>            <span class="hljs-keyword">for</span>(p=<span class="hljs-number">0</span>;p&lt;k;p++)&#123;<br>                C[i+j*n] += A[i + p*n] * B[p + j*k]; <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然,这样的矩阵乘是最朴素的,那怎么优化呢?</p><p>不妨先从一个固定大小,然后维度比较小的矩阵来思考,我们的向量寄存器的宽度是128,那就是对于float32_t可以放4个,因此考虑一个<strong>4x4的小矩阵的乘法</strong>先,那么优化的过程如下图示:</p><img src="https://s2.loli.net/2024/04/18/l6nvdY2sVQALmaJ.jpg" alt="ARM-matrix multiply neon 4x4" style="zoom:60%;" /><p>如图,我们想算C阵的一列数据,则按照A逐行与B的某一列做内积,则经过多次内积,可以得出C阵的一列数据;</p><p>但是这样对于A阵会频繁发生cache miss的问题,频繁访存导致latency,因此A阵最好也以列的方式取数据,通过分析我们知道,若要求C0(C阵的第一列),则A0通通要乘于<code>B0[0]</code>(B阵第一列的第一个数据),A1要乘于<code>B0[1]</code>,如此遍历完A阵(逐列)与B0列(逐元素)的数据,则可以计算出C0,大大减少了cache miss,且可以用neon intrinsic实现(减少指令数量,并有利于编译器做循环展开),代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_4x4_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// 先把A,B,C的列都给用float32x4_t表示</span><br>    <span class="hljs-keyword">float32x4_t</span> A0 = vld1q_f32(A);<br>    <span class="hljs-keyword">float32x4_t</span> A1 = vld1q_f32(A+<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A2 = vld1q_f32(A+<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A3 = vld1q_f32(A+<span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br><br>    <span class="hljs-comment">// 给结果的中间值逐列设置初值0(因为要累加嘛)</span><br>    <span class="hljs-keyword">float32x4_t</span> C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C3 = vmovq_n_f32(<span class="hljs-number">0</span>); <br><br>    B0 = vld1q_f32(B);<br>    C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>    C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>    C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>    C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br>    vst1q_f32(C,C0);<br><br>    B1 = vld1q_f32(B+<span class="hljs-number">4</span>);<br>    C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>    C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>    C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>    C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">4</span>,C1);<br><br>    B2 = vld1q_f32(B+<span class="hljs-number">8</span>);<br>    C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>    C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>    C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>    C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">8</span>,C2);<br><br>    B3 = vld1q_f32(B+<span class="hljs-number">12</span>);<br>    C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>    C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>    C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>    C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">12</span>,C3);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码思路与上面画图的思路是一样的,由此便完成了一个4x4的neon intrinsic实现的矩阵乘</p><p>那么对于大的矩阵呢?如何处理?</p><p>其实可以划分为4x4的块,用我们上面优化后的矩阵乘进行计算,当然这样的情况针对的是行列两个维度均是4的倍数的,如果不是4的倍数,比如A的维度是514x515这样的,就可以做padding处理,这样也不用改动4x4的矩阵乘的代码</p><p>以下是一般阵的情况(这里没做padding):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// A,B,C三个阵的逐列数据</span><br>    <span class="hljs-keyword">float32x4_t</span> A0,A1,A2,A3;<br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br>    <span class="hljs-keyword">float32x4_t</span> C0,C1,C2,C3;<br><br>    <span class="hljs-comment">// A,B,C三个阵的地址偏移值</span><br>    <span class="hljs-keyword">int</span> a_offset,b_offset,c_offset;<br>    <br>    <span class="hljs-comment">// 迭代变量</span><br>    <span class="hljs-keyword">int</span> i_idx,j_idx,k_idx;<br>    <br>    <span class="hljs-keyword">for</span>(i_idx=<span class="hljs-number">0</span>;i_idx&lt;n;i_idx+=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">for</span>(j_idx=<span class="hljs-number">0</span>;j_idx&lt;m;j_idx+=<span class="hljs-number">4</span>)&#123;<br>            C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C3 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 得等这一个循环完成了才算做完4x4次内积,因此里面的C的值得累加,出循环再store</span><br>            <span class="hljs-keyword">for</span>(k_idx=<span class="hljs-number">0</span>;k_idx&lt;k;k_idx+=<span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-comment">// 计算偏移值</span><br>                a_offset = i_idx + n*k_idx;<br>                b_offset = k_idx + k*j_idx;<br>                <span class="hljs-comment">// 获取当前基址+偏移值的位置处的列值</span><br>                A0 = vld1q_f32(A+a_offset);<br>                A1 = vld1q_f32(A+a_offset+n);<br>                A2 = vld1q_f32(A+a_offset+<span class="hljs-number">2</span>*n);<br>                A3 = vld1q_f32(A+a_offset+<span class="hljs-number">3</span>*n);<br><br>                B0 = vld1q_f32(B+b_offset);<br>                C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>                C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>                C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>                C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br><br>                B1 = vld1q_f32(B+b_offset+k);<br>                C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>                C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>                C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>                C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);                                <br><br>                B2 = vld1q_f32(B+b_offset+<span class="hljs-number">2</span>*k);<br>                C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>                C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>                C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>                C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br><br>                B3 = vld1q_f32(B+b_offset+<span class="hljs-number">3</span>*k);<br>                C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>                C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>                C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>                C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>            &#125;<br>            <span class="hljs-comment">// 计算偏移值</span><br>            c_offset = i_idx + n*j_idx;<br>            vst1q_f32(C+c_offset,C0);<br>            vst1q_f32(C+c_offset+n,C1);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">2</span>,C2);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">3</span>,C3);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出,n,m,k三个维度的步距都改作了4,注意C阵的值是需要累加完整个k维的循环,才可以得到C的一个小块(4x4)的结果,因此C的摆放位置有了变化,别的基本差不多.</p><h3 id="函数规范"><a class="markdownIt-Anchor" href="#函数规范"></a> 函数规范</h3><p>在说起函数规范前,先学一下<strong>用于neon的数据类型</strong>:</p><ul><li><code>baseW_t</code>: <strong>base表示基本的数据类型</strong>,然后<strong>W表示该类型的位宽</strong>,比如int8,uint8,float32这些,后面跟着的t是表示typedef的意思;</li><li><code>baseWxL_t</code>:这在上面的基础上加上了个L,实际上就是用了向量寄存器,<strong>L表示数据的个数</strong>,比如128位的寄存器,对于float32_t来说,就可以存4个,即float32x4_t(类似一维数组);</li><li><code>baseWxLxN_t</code>: 这个较上面的方法则类似二维数组,<strong>N表示baseWxL的个数</strong>,就比如分离RGB的例子,uint8x16x3_t表示的是有3个uint8x16的一维数组.</li></ul><div class="note note-info">            <p>其实x86中比如avx2的数据类型也差不多,虽然看起来是__m256d,__m256i这样高深莫测的样子,但是内部的结构体也差不多</p>          </div><p>在ARM neon intrinsic入门的教程里,函数规范定义如下:</p><p><strong><code>return_type v[p][q][r]opname[u][n][q][x][_high][_lane | _laneq][_n][_result]_type(args) </code></strong></p><p>非常复杂,从左往右开始说</p><ul><li><p><code>reture_type:</code> 返回类型,就是我们上面说到的neon的数据类型;</p></li><li><p>v: <strong>在所有intrinsic中必有</strong>,表示是一个vector操作</p></li><li><p>p: pair,成对操作</p></li><li><p>q: 饱和操作,就是数值溢出,不是对它做如取余(上溢),加上边界值(下溢)的操作,而是暂停在边界值</p></li><li><p>r: rounding向下取整</p></li><li><p>opname: <strong>具体操作的名字</strong>,比如add,mul,sub之类的</p></li><li><p>u:</p></li><li><p>n: narrow,窄指令,输入操作数的向量是128位的,结果向量是64位的,类型相同,但是宽度减半,例子:</p><ul><li>``</li></ul><div class="note note-info">            <p>我在网上看到还有w(wide,宽指令),l(long,长指令)</p><ul><li>l: long,长指令,输入操作数的向量是64位的,结果向量是128位的,类型相同,但是宽度加倍,例子:</li></ul><p>``</p><ul><li>w: wide,宽指令,输入操作数1个是64位的,1个是128位的,结果向量是128位的,类型相同,宽度上64位的是128位的一半,例子:</li></ul><p><code>uint64x2_t vaddw_u32 (uint64x2_t a, uint32x2_t b) </code></p>          </div></li><li><p>q: <strong>表示用到是128的向量寄存器</strong>,<strong><u>q</u>uad word</strong>,<strong>默认是64位的double word</strong></p></li><li><p>x:</p></li><li><p>_high:</p></li><li><p>_lane | _laneq: 表示<strong>从一个向量的通道中取一个标量操作数</strong>.<strong>有q和无q的区别就是向量寄存器是用128位还是64位</strong>(感觉就默认的向量寄存器(不加q)就是用64位).下面是官网的两个例子:</p><ul><li><img src="https://s2.loli.net/2024/04/19/ZwBocAkCQxyn2jI.png" alt="vfmaq_laneq_f32" style="zoom:50%;" /></li><li><img src="https://s2.loli.net/2024/04/19/DTApiKL1HOl8aUf.png" alt="vfmaq_lane_f32" style="zoom:50%;" /></li></ul></li><li><p>_n: 表示<strong>有一个标量操作数</strong>,是<strong>要从参数中获取</strong></p></li><li><p>_result:</p></li><li><p>_type: 表示<strong>每个通道的具体的数据类型</strong></p></li><li><p>args: 输入参数</p></li></ul><h2 id="neon相关的体系结构"><a class="markdownIt-Anchor" href="#neon相关的体系结构"></a> Neon相关的体系结构</h2><p>下面的内容主要摘自ARM的Neon introducing:</p><hr /><p><strong>Neon技术为指令集体系结构提供了一个专门的扩展</strong>,提供的额外指令能<strong>在多个数据流上并行的执行数学运算(SIMD)</strong></p><p>为什么需要用到这个Neon呢?</p><p>处理大量数据集,主要的性能限制因素是<strong>执行数据处理指令</strong>所花费的大量<strong>CPU时间</strong> -&gt; 这个<strong>CPU时间</strong>取决于<strong>处理整个数据集的指令数量</strong> -&gt; 这个<strong>指令数量</strong>又取决于<strong>每条指令所能处理的数据项</strong></p><blockquote><p>When processing large sets of data, a major performance limiting factor is the amount of CPU time taken to perform data processing instructions. This CPU time depends on the number of instructions it takes to deal with the entire data set. And the number of instructions depends on how many items of data each instruction can process.</p></blockquote><p><strong>如果你现在处理的数值是小于最大位的大小,用SISD的话,额外的潜在的带宽是被浪费掉的</strong></p><blockquote><p>If the values you are dealing with are smaller than the maximum bit size, that extra potential bandwidth is wasted with SISD instructions.</p></blockquote><p>即是我要对8位的数值去做一个ADD操作,那么每个8位的数值会被加载到一个单独的64位的寄存器.这样去处理数据,对硬件资源并没有很好的利用到.</p><p><strong>SIMD指令是对多个数据项同时执行相同的操作.在一个较大的寄存器里,这些数据项会作为单独的通道被打包.</strong>(通道lane是完全隔离的,互相影响不到的)</p><blockquote><p>Single Instruction Multiple Data (SIMD) instructions perform the same operation simultaneously for multiple data items. These data items are packed as separate lanes in a larger register.</p></blockquote><p><strong>Neon寄存器有128位的,也有64位的(就是把128位的高64位给置零,只用低64位</strong>,跟AVX兼容SSE差不多)</p><hr /><p><strong>AArch64:Armv8-A架构的64位的执行状态</strong>.有时候一些GNU/Linux文档会把AArch64叫做ARM64.在AArch64状态下,处理器执行<strong>A64指令集</strong>(包含Neon指令)</p><p><strong>AArch32:就是Armv8-A架构的32位执行状态,和Armv7几乎是一样的</strong>.在AArch32状态下处理器可以执行<strong>A32</strong>(在早期架构版本中是叫ARM)/<strong>T32</strong>(Thumb)<strong>指令集</strong>.这俩指令集向下兼容Armv7也有Neon指令</p><hr /><p>Armv8是64位的架构和用的是64位的寄存器,而我们的Neon用的是128位的寄存器,是因为Neon单元是在一个<strong>单独的128位寄存器的寄存器文件</strong>(硬件,可以参照RISC-V内有一个参考文件提及了处理器设计)上进行的操作</p><p><strong>Neon寄存器包含了相同数据类型的元素的向量,这些相同数据类型的元素在输入输出寄存器中的位置是被称为通道lane</strong>(其实就跟数组一个样,不过更加具象化)</p><p><strong>通道数n</strong>:就是指Neon指令会使得n个操作并行执行,这个n就是通道数,比如我们对一个float32x4_t,做加法操作,那这个4就是通道数,因为做了4个float32的加法操作(不过是一条指令).也就是说操作是针对通道lane的</p><p>显然,Neon向量的通道数就取决于向量大小(64位还是128位)和每个通道的数据类型(<strong>8位-B(byte) | 16位-H(halfword) | 32位-S(word,感觉single precision也可以) | 64位-D(doubleword)</strong>)</p><p>以128位的向量来说有:</p><ul><li><strong>16个8位的元素(汇编中寄存器后缀会呈现为<code>.16B</code>)</strong></li><li><strong>8个16位元素(汇编中寄存器后缀会呈现为<code>.8H</code>)</strong></li><li><strong>4个32位元素(汇编中寄存器后缀会呈现为<code>.4S</code>)</strong></li><li><strong>2个64位元素(汇编中寄存器后缀会呈现为<code>.2D</code>)</strong></li></ul><p>以64位向量来说有:</p><ul><li><strong>8个8位的(<code>.8B</code>)</strong></li><li><strong>4个16位的(<code>.4H</code>)</strong></li><li><strong>2个32位的(<code>.2S</code>)</strong></li></ul><p>下图右侧的<code>V0.4S</code>是在汇编中向量寄存器作为操作码的写法(<strong>0表示V0,有32个向量寄存器</strong>)</p><p><img src="https://s2.loli.net/2024/04/18/uckhg4E7wfvAYVF.jpg" alt="ARM-neon vector (64and128)" /></p><p><strong>在向量中元素是从LSB(最低有效位)开始放置的,就是element0(lane0的数据)会用到寄存器的LSB</strong></p><p>有些指令是向量跟一个向量里面的某一个位置的元素进行操作的,比如<code>mul v0.4s v2.4s v3.s[2]</code>就是V2寄存器里的4个float32_t和V3寄存器的lane2处的元素做乘法.如下图示:</p><img src="https://s2.loli.net/2024/04/18/r2SY7ToR5fzQjan.png" alt="ARM-neon instruction using scalars" style="zoom:80%;" /><h2 id="一些arm的基础知识"><a class="markdownIt-Anchor" href="#一些arm的基础知识"></a> 一些ARM的基础知识</h2><p>ARMv8有31个64位的通用寄存器,有32个128位的向量寄存器</p><h2 id="neon-assembly入门"><a class="markdownIt-Anchor" href="#neon-assembly入门"></a> Neon Assembly入门</h2><h3 id="神奇的指令"><a class="markdownIt-Anchor" href="#神奇的指令"></a> 神奇的指令</h3><ul><li><p>预取指令</p><p><code>prfm pldl1keep,[Rn,#imm]</code>,一般见到的是这样的格式</p></li><li></li></ul><p><strong>具体代码参考可见<a href="https://github.com/ayyHA/OperatorDev">opDev</a>中的数组加权和和<code>box_filter</code>盒子滤波的例子</strong></p><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><p><strong>Neon intrinsic系列</strong>:</p><ul><li><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">intrinsic-set reference</a></li><li><a href="https://developer.arm.com/documentation/102467/0201">Learn the architecture - Optimizing C code with Neon intrinsics</a></li><li><a href="https://developer.arm.com/documentation/102474/0100/">Learn the architecture - Introducing Neon</a></li></ul><p><strong>Neon Assembly系列:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/143328317">neon assembly教程-移动端arm cpu优化学习笔记第4弹–内联汇编入门</a></li><li><a href="https://zhuanlan.zhihu.com/p/451014220">ARM Cortex-A 系列ARMv8-A程序员指南： 第6章 A64指令集</a> <mark>未看完</mark></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>assembly</tag>
      
      <tag>armv8</tag>
      
      <tag>ARM architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V汇编知识</title>
    <link href="/2024/04/10/RISC-V%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/10/RISC-V%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a class="markdownIt-Anchor" href="#写在开头"></a> 写在开头</h2><p>在大致查阅了网上社交媒体的一些关于主流芯片的架构的评价后,<strong>x86</strong>,<strong>arm</strong>,<strong>RISC-V</strong>这三个讨论热度最大.其中x86比较闭塞,且从8086出发,学习成本略高,冗余度也高(有部分内容在后续芯片设计开发中被废弃);arm的话生态最好,但是指令集授权(虽然也不是我该关心的事😂)比较hard,有些厂商没有v9的架构,只能用v8一套的生态,但是ARM架构的芯片有应用于PC的(MAC),也有应用移动设备上的,总体前景和生态是优于x86的;RISC-V的话开源,简单,且UC Berkeley在cs61c的课程中教授的就是这个芯片架构及指令集,国内浙大也跟着开授了相关的课程;</p><p>因此决定先从RISC-V学习起一些基础的汇编知识,然后再转到ARMv8上,主体的学习成本依旧放在ARMv8上,<strong>RISC-V只是作为汇编初入门的一个过渡阶段,以及对体系结构知识的温习</strong>;</p><p>关于之前学习的x86下的intrinsic编程,其实在arm中的neon intrinsic也是有类似的知识,知识总是具有相通性,因此也不能说之前如SSE,AVX的编程知识就废弃了,从某种意义上说,思想本质是一样的.借用浮点寄存器/向量寄存器去做SIMD,不过相关的命名规范,指令名称一类的换个样子适配到arm架构上去罢了.也算是一种知识迁移吧~</p><h2 id="与别的isa不同之处"><a class="markdownIt-Anchor" href="#与别的isa不同之处"></a> 与别的ISA不同之处</h2><p>RISC-V与别的指令集架构不同之处在于，它被设计为<strong>模块化ISA</strong>，而如x86是<strong>增量ISA</strong></p><p>增量ISA：在支持原有的指令集的基础上增加新的指令和功能，就是向下兼容的意思（那感觉操作码的位置空间都被占的差不多了…）</p><p><strong>模块化ISA：由1个基本的整数指令集（如RV32I/RV64I）+可选的扩展指令集</strong></p><p><img src="https://s2.loli.net/2024/04/11/LzxNYwOvQ3Kmsoa.png" alt="RISC-V IS basic" /></p><p><img src="https://s2.loli.net/2024/04/11/KpsvP2FqOofh8mr.png" alt="RISC-V IS extension" /></p><div class="note note-info">            <p><strong>注意：在下文的讨论中，我们所采用的基础指令集是RV32I，关于扩展指令集，本文不涉及</strong></p><p>如果想要使用<code>mul</code>,<code>div</code>,<code>rem</code>表示乘，除，取余操作，这些需要加上扩展指令集M才可以用，即RV32IM</p>          </div><h2 id="单位度量"><a class="markdownIt-Anchor" href="#单位度量"></a> 单位度量</h2><p>在RISC-V中,一个字节是8位,16位的被称作半字,32位则称作字(word),64位则是双字</p><div class="note note-info">            <p>注意：在8086的学习中，关于堆栈段里涉及到的字（word）这个的大小是2个字节，所以不同的处理器架构乃至说不同的生态，在一些没有统一定论的数据格式的规范上，是很混乱的，所以这些东西遇到了要查一查文档。</p>          </div><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p>采用32位寄存器（RV32I）,有<strong>32个</strong>,常用别名(一般用别名,有特殊含义)见下表:</p><p><img src="https://s2.loli.net/2024/04/11/lMyUdCmc15LovRQ.png" alt="RISC-V register info" /></p><p>一般在进行数据传输的时候,若是把一个字节的数搬到寄存器中去的话,需要做<strong>符号位扩展</strong>,<strong>即需要将8位的数扩展为32位,且不改变数值本身的大小</strong>.在计算机中是以补码存储,比如<code>(-2)=(10000010)b</code>的补码形式为<code>(11111110)b</code>将其扩展为32为则是用符号位补足剩余的位数<code>(11111111 11111111 11111111 11111110)b </code>,则成功扩展,对补码取补码即得原码,可见依旧是-2</p><h2 id="操作码"><a class="markdownIt-Anchor" href="#操作码"></a> 操作码</h2><p>先给出RV32I的指令集指令表,方便后续查看(其实指令条数不多)</p><p><img src="https://s2.loli.net/2024/04/13/FvdrPtTm5gUQBY3.png" alt="RV32I instruction table" /></p><div class="note note-info">            <p>注释中说的zero-extends指的是零扩展,msb-extends指的是最高有效位扩展(符号位扩展)</p>          </div><h3 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h3><p>在RISC-V中，一般涉及到多个寄存器的操作时，<strong>第一个寄存器一般都是目标寄存器</strong></p><p>RISC-V的<strong>指令</strong>集很清晰，它都是一些<strong>明确语义的英文单词的首字母拼接而成</strong>，如分支指令的<code>bne</code>，表示<u>b</u>ranch <u>n</u>ot <u>e</u>qual</p><p>RISC-V指令集针对不足32位的数的写入会做符号位扩展，而如<code>lw</code>(<u>l</u>oad <u>w</u>ord)一类的则不扩展，因为一个word就是32位，可以满足寄存器的要求，如<code>lb</code>(<u>l</u>oad <u>b</u>yte)则需要做符号位扩展</p><h4 id="基本指令"><a class="markdownIt-Anchor" href="#基本指令"></a> 基本指令</h4><p><code>op rd rs1 rs2</code> (rd: register destination; rs: register source)</p><p>比如一些基础的算术，逻辑运算，如：</p><p><code>add t0 t1 t2 # 将t1,t2寄存器的值相加，放置到t0寄存器中</code></p><p><code>sll t0 t0 t2 #将t0寄存器的值逻辑左移t2值位，放置到t0寄存器中</code></p><h4 id="立即数指令immediate-instruction"><a class="markdownIt-Anchor" href="#立即数指令immediate-instruction"></a> 立即数指令(immediate instruction)</h4><p><code>opi rd rs imm</code></p><p>比如<code>addi t0 x0 2</code> t0的值被置位2，<strong>x0这个寄存器的值永远是0</strong></p><p>立即数指令基本上都是在相应的操作码后面加个<strong>i</strong>（immediate）</p><h4 id="分支指令branch-instruction有条件的跳转"><a class="markdownIt-Anchor" href="#分支指令branch-instruction有条件的跳转"></a> 分支指令(branch instruction)[有条件的跳转]</h4><p><code>bop rs1 rs2 label</code></p><p>分支指令是<code>rs1 bop rs2</code>时，则会跳转到label的位置（条件跳转），当然后面的label也可以换做是数字，比如是个100，那就表示条件满足则令pc=pc+2*100</p><div class="note note-info">            <p>注意：pc是程序计数器，指示的是下一条指令的位置，修改pc即是指示程序下一条指令应该取哪的。我们的指令都是4字节的，合理来说应该*4才对，但好像是为了兼容16位的，所以*2</p><p>而作为一个标签,比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x1c |beq rs1 rs2 loop # 前面那|是用来分隔下地址和指令<br># ...<br># ...<br>0x38 |loop: ...<br></code></pre></td></tr></table></figure><p>这里我们当<code>rs1==rs2</code>会跳转到loop这个标签**,loop实际上指代的就是<code>loop:...</code>这条指令的地址**,实际在运行的时候它会被转换成一个偏移值,即分支指令的标签会被替换为:<strong>下一条指令地址相较于loop所指代指令地址的值</strong>,这个值是以字节为单位的,比如上面那里的值是0x38-0x20(0x1c + 0x4) = 0x18 = 24(10)字节,而按照上面说的会对数字*2处理,因此实际这个偏移量会是12(以2字节,也即是半字为偏移量的系数)</p><p><mark>但实际上我在模拟器上试的时候显示的是6,即是以字为偏移量系数</mark></p><img src="https://s2.loli.net/2024/04/15/qrVfZ6ARzBLdwsC.png" alt="RISC-V strange label offset" style="zoom:65%;" />          </div><p>分支指令可以用来做for,while一类的循环</p><p>示例for(while差不多)：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs as"><span class="hljs-comment">/* C码:</span><br><span class="hljs-comment">// t0 -&gt; i,t1 -&gt; 10</span><br><span class="hljs-comment">for(int i=0;i&lt;10;i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br># RISC-V assemble<br>addi t0 x0 <span class="hljs-number">0</span><br>addi t1 x0 <span class="hljs-number">10</span><br>loop: bge t0 t1 end<br>...<br>addi t0 t0 <span class="hljs-number">1</span><br>beq x0 x0 loop # 也可以这么写jal x0 loop <br>end:<br># 跳出循环了<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意：因为我们的分支指令是有条件的跳转，满足条件则跳到指定标签，即跳出循环；而对于循环而言是符合条件就在循环里面，因此<strong>写分支指令的时候，条件反着写更好</strong>，比如i&lt;10则在循环内，那我们可以写作i≥10再跳到标签（跳出循环），然后需要注意<strong>循环条件的变化</strong>以及<strong>重新跳回循环的判断处</strong>（循环开始的标签）</p>          </div><h4 id="数据传输指令内存和寄存器的交流"><a class="markdownIt-Anchor" href="#数据传输指令内存和寄存器的交流"></a> 数据传输指令[内存和寄存器的交流]</h4><p>现在CISC和RISC指令集其实都很纷繁复杂，一种比较明显的区别是CISC中的访存操作存在隐式的，而RISC中则是显式的进行访存操作（通过访存取值如load，将值从寄存器写回内存的store）</p><ul><li><code>lw rd imm(rs)</code>rs里的值作为基址，imm作为偏移,从(rs+imm)表示的内存地址开始，依次取1个<u>w</u>ord的数据放到rd中去</li><li><code>sw rd imm(rs) </code>跟上面一样，不过是把rd里的32位的值，放置到以(rs+imm)表示的内存地址所指向的空间，一个地址指向的空间可以存放的是一个字节的数据，这里要放4个字节的数据，即(rs+imm)~(rs+imm+3)的空间内放的都是rd的值（具体放的顺序看大小端）</li><li><code>lb rd imm(rs)</code> 跟lw差不多，不过这里取的是一个字节，要做符号位扩展，放到rd中去（如果是lbu这种，就是无符号扩展，前面填0补够位数就好了）</li><li><code>sb rd imm(rs)</code>跟sw差不多，不过因为是一个字节，直接塞到(rs+imm)指向的空间里面去就好</li></ul><h4 id="跳转指令无条件的跳转"><a class="markdownIt-Anchor" href="#跳转指令无条件的跳转"></a> 跳转指令[无条件的跳转]</h4><p><code>jal rd label</code> jump and link,一般这个rd是ra(return address)这个寄存器。在调用这条指令的时候会先把pc的值+4再存入ra，然后无条件跳转到label处，当然这个label可以是我们的函数名，也可以是100这样的东西，就相当于pc= pc + 2*100，将pc换成这个值，然后执行下一条指令的时候就会去取这个pc，就会跳到我们期望的位置了，label实际上也是这样，就是改变pc，让它跳到我们的函数区域。</p><h3 id="伪指令"><a class="markdownIt-Anchor" href="#伪指令"></a> 伪指令</h3><p><strong>伪指令易于记忆和使用</strong>,会被<strong>汇编器翻译成一条或多条对应的汇编指令</strong>,本身并不具备扩展指令集的功能,类似于我们在C中喜欢用<code>typedef / #define</code></p><ul><li><code>mv rd rs</code>，这个是让rd寄存器获取rs寄存器的值（register copy）</li><li><code>li rd imm</code> li表示load immediate，往rd里放立即数的值</li><li><code>la rd symbol</code>la表示load address,对应<code>auipc rd,symbol[31:12]</code>和<code>addi rd,rd,symbol[11:0]</code>这两条指令,看起来就是把symbol的所有位数与PC相加然后放到了rd里面.之所以这样做,是因为我们的I型指令的立即数位数只有12位,U型指令的立即数位数有20位,通过这样操作,才可以让pc加上完整的symbol,然后放置到rd中去(这个symbol应该是偏移量,这样pc+symbol就是期望的地址)</li><li><code>ret</code>即pc从当前位置返回到ra所指向的指令位置，实际是通过<code>jalr x0 ra 0</code>即pc=ra+0，这是一条I型指令即<code>jalr rd rs imm</code>表示rd=pc+4,pc=rs+imm</li></ul><img src="https://s2.loli.net/2024/04/12/SWBmroywzQViFpM.png" alt="RISC-V pseudo instruction" style="zoom:67%;" /><h3 id="伪操作"><a class="markdownIt-Anchor" href="#伪操作"></a> 伪操作</h3><p><strong>伪操作用于指导汇编器去理解汇编程序的行为</strong>.<strong>以<code>.</code>作为伪操作的开头</strong></p><ul><li>声明当前属于哪个段<ul><li><code>.data</code> 已初始化的全局变量静态变量</li><li><code>.text</code> 代码段</li><li><code>.bss</code>未初始化的全局变量静态变量</li></ul></li><li>声明字串<ul><li><code>str1: .string &quot;哈哈哈哈哈2\n&quot;</code></li></ul></li><li>定义符号<ul><li><code>.set tmp,100</code></li></ul></li><li>定义字节/半字/字数组<ul><li><code>byte_list: .byte 1,2,3</code></li><li><code>word_list:.word 0x12345678,0x111 </code></li></ul></li><li>做地址对齐<ul><li><code>.align 3</code></li><li><code>.balign 4</code></li></ul></li></ul><div class="note note-info">            <p><strong>标签和符号实际上都是代表内存地址</strong>(如<code>str1:</code>代表这里的(数据)地址和<code>loop:</code>代表这里的(指令)地址,本质上是一样的,只不过内存被分了段),然后易于记忆和使用,但是标签应该更多的是指用于流程控制(比如<code>bne x0,x0,loop</code>),而符号则是如变量这些(比如<code> li t0,tmp</code>,其中tmp在数据段被定义<code>.set tmp,100</code>)</p><p>二者之后都会被弄到<strong>符号表</strong>去</p>          </div><h3 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h3><p><strong>宏实际上是由伪操作组成的</strong></p><p>用<code>.macro macro_name,para1,para2,...</code>定义宏,用<code>.endm</code>结束宏,通过利用宏定义,我们可以弄出一些属于自己的频繁使用的伪指令,调用时直接宏名作为指令名,然后传入需要的参数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 采用宏声明一个乘加操作,以实现a+b*c,将结果存在t1寄存器中<br>.macro mul_add, a,b,c<br>mul t0,b,c<br>add t1,a,t0<br>.endm<br><br>.text<br>mul_add a0,a1,a2<br></code></pre></td></tr></table></figure><p>汇编器处理宏时,会进行宏替换,把宏体里的形参用实参替换,生成的指令插入到对应的位置</p><h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2><p>从jal这一条指令来看，函数调用即是我们在调用前把需要传入的参数放入a0~a7这些参数寄存器中，然后通过jal把下一条指令的地址放到ra中去，以便return,然后就跳转到jal中标定的label，即是我们的函数名，执行完毕后可以把要返回的值放入a0，然后ret。</p><p>实际中我们的函数调用涉及到栈帧概念.</p><h3 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h3><h2 id="关于嵌套的函数"><a class="markdownIt-Anchor" href="#关于嵌套的函数"></a> 关于嵌套的函数</h2><p>函数P调用函数Q，P称为调用者(caller)，Q称为被调用者（callee），它们两个各自有需要保存的寄存器，只需要压栈保护自己要保存的东西即可，然后可以用另一方的寄存器。</p><h2 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h2><p>在RISC-V中，每一条指令都是<strong>4字节</strong>，这跟那种指令不定长的指令集不同，每条指令均为4个字节的设计，PC自动增4，以跳到下一跳指令的内存位置，同时也方便我们的硬件解析指令的设计，因为32位的指令中，哪个位置是放寄存器的，哪个位置是放操作码的是固定的。</p><p>以下是RV32I的指令集格式，共有六种类型的指令。其中<strong>opcode</strong>代表的是<strong>操作码</strong>，<strong>rd</strong>(register destination)代表的是<strong>目标寄存器</strong>,<strong>rs</strong>(register source)代表的是<strong>源操作器</strong>，funct3代表的是3位的用来指示该操作码具体指令的功能，funct7同理，<strong>imm</strong>代表的是<strong>立即数</strong>，有的imm是分为高低位被拆开的，imm有12位的，也有20位的，具体是针对不同的指令类型而言。</p><ul><li><p>R-type代表的是三种寄存器的指令类型;</p></li><li><p>I-type代表的是load指令和有立即数的指令.而这里的立即数只取低12位,因此取值范围是[-2048,2047];</p></li><li><p>S-type代表的是store类型的指令;</p></li><li><p>SB-type代表的是分支指令;</p></li><li><p>U-type代表的是upper immediate，有LUI(load upper immediate)和AUIPC(add upper immediate PC)这两条指令，前者表示<code>lui rd imm # rd = imm &lt;&lt; 12</code>,后者为<code>auipc rd imm # rd = pc + imm &lt;&lt; 12</code>.为什么需要这一个类型的指令呢?上面讲<code>la</code>伪指令讲了.因此如果想要将一个高于12位的立即数放入到寄存器中可以通过移位的指令达成,也可以通过LUI达成,如想要将<code>0x00009000</code>这个值放入寄存器中,通过<code>lui t0 0x00009</code>即可.如果想获得如<code>0x12345abc</code>,则</p><p><code>lui  t0 0x12345</code> <code>addi t0 t0 0xabc</code>即可.</p></li><li><p>UJ-type代表的是无条件跳转指令</p></li></ul><p><img src="https://s2.loli.net/2024/04/11/O2UbnNtp8XPx1Ki.png" alt="RISC-V instruction format" /></p><div class="note note-info">            <ul><li>有的版本会把SB类型写成B类型,把UJ写成J类型</li><li><strong>立即数之所以被拆开来(比如S型指令)</strong>,是因为整体的体系结构在设计的时候尽量让所有位置少变动,比如opcode一直在[0,6]位,<strong>保持尽可能相似的指令格式以降低硬件的设计复杂性</strong></li><li>SB型指令的立即数写作<code>imm[12|10:5]</code>表示的是,指令格式的第31位存储的是立即数的第12位,指令格式的[25,30]位存储的是立即数的[5,10]位,之所以这么设计,我猜测跟硬件电路设计有关系</li><li>我们所有指令都是4字节的,需要做<strong>偶数对齐</strong>,即指令跳转的时候令PC+奇数肯定是错误的,因此PC+上的一定是偶数,因此SB型指令的第0位恒定是0(其实<code>PC+= imm*2</code>,为啥乘2而不是4,感觉不是前面说的兼容16位,没找到有16位的RV16I这种东东,或许是从加上的是偶数这个地方出发,从而*2)</li></ul>          </div><h2 id="内存布局"><a class="markdownIt-Anchor" href="#内存布局"></a> 内存布局</h2><p>我们整个程序都是存在内存中的，无论是指令还是数据（函数本质上也是指令和数据的复合体），因此将内存划分成了几个区域来存储我们的程序</p><p>有一部分数据是运行的时候不会变的，比如字符串，比如代码，这些就放在ROM区，而函数的调用涉及到的栈帧开销，对象创建涉及到的新内存开辟，统一成员信息的静态变量，全局可见的全局变量，则放在RAM区。</p><p>为此对于代码段给它起个名字叫text，对字符串这种只读的常量放置在rodata(<mark>这个在RISCV中还没有,用伪操作别用它,直接用data</mark>)处，它俩都是ROM区的；</p><p>对已初始化的全局变量，静态变量则放置在data处；对未初始化的全局变量静态变量则放在bss(block started by symbol segment)处；再往上就是heap，堆区，用于存放malloc等方式分配出来的变量；再往上就是stack区，用来存放函数。整体的内存布局如下图所示：</p><img src="https://s2.loli.net/2024/04/11/vOx8CgkTUuWeHsb.png" alt="memory allocation" style="zoom:50%;" /><img src="https://s2.loli.net/2024/04/11/bUkD25KZzONXPRt.png" alt="RISC-V-memory allocation" style="zoom:67%;" /><p>而在RISC-V内存分配图的右边则是一个栈帧的图,可以看到它的fp用作ebp的功能，sp用作esp的功能（这里的ebp和esp是x86系列里关于栈帧的俩指针）</p><h2 id="关于代码编写"><a class="markdownIt-Anchor" href="#关于代码编写"></a> 关于代码编写</h2><p>若想在以RISC-V架构的处理器上进行编程,需要一套对应的编程工具链(编译器,汇编器,链接器,加载器)</p><p>而目前大多数的处理器是x86架构或是ARM架构,因此需要先用QEMU模拟器,模拟对应的处理器,然后搭建对应的编译环境,相关信息请参阅参考文件中关于环境搭建的文章进行执行</p><p>本文考虑到学习成本,先不予搭建(其实有云服务器的话会好很多,不然太麻烦了)</p><p>后期有时间再搭建,玩一玩~</p><hr /><p>谷歌的colab有用于RISC-V的汇编学习的教程，在此编程~</p><p>主要是编程完后用clang和lld生成可执行文件，再提交可执行文件给<strong>RISC-V-ALE</strong>（RISC-V-assemble language environment）解析及运行</p><h2 id="risc-v的特权架构"><a class="markdownIt-Anchor" href="#risc-v的特权架构"></a> RISC-V的特权架构</h2><p>RISC-V有三级特权架构，<strong>U-User S-Supervisor M-Machine</strong>，越往后的则权限等级越高</p><p>之所以会学到特权架构，是因为在使用colab的helloworld程序时，看到了一个叫做ecall的指令，这个指令很奇怪，就光秃秃一个操作符，没有操作数</p><p>ecall叫做environment call,是一个环境调用指令，调用它的时候，我们会从U模式切换到更高级的模式，在更高级的模式有一类称为CSR(control state register，控制状态寄存器)的寄存器，这是在S和M模式才有的寄存器，在进行模式切换的时候，会对我们的PC进行保存，保存在sepc/mepc，这个e实际上是exception，即是<strong>异常</strong>的意思，跟x86一样，<strong>RISC-V也存在中断和异常的处理</strong>。程序会在stvec/mtvec找到中断的基址，然后在scause/mcasue中找到这次异常对应的号码（见下图）,然后发现是环境调用异常事件（发生地址跳转），就会去寄存器a7（参数寄存器那个a7）里看你想要处理的是什么系统调用（我们在a7存放的值被称为<strong>系统调用号</strong>，见再下一个图），然后a0~a6传入的是参数，处理好后会把返回值放到a0寄存器里面去。</p><img src="https://s2.loli.net/2024/04/12/UD4uEVdS1fjKJbX.png" alt="[m,s]cause code" style="zoom:67%;" /><img src="https://s2.loli.net/2024/04/15/RLWbIwSiBEvkDCj.png" alt="RISC-V syscall number" style="zoom:67%;" /><p>详细了解中断可以从这篇文章去看<a href="https://blog.csdn.net/weixin_42031299/article/details/134033246?spm=1001.2014.3001.5502">RISC-V中断处理和中断控制器</a></p><h2 id="关于x86中的intel规范和att规范"><a class="markdownIt-Anchor" href="#关于x86中的intel规范和att规范"></a> 关于X86中的Intel规范和AT&amp;T规范</h2><img src="https://s2.loli.net/2024/04/15/EiXF1kgNthYS8Uu.png" alt="at&t and intel assembly style" style="zoom:65%;" /><p><a href="https://www.cnblogs.com/wanghuizhao/p/16388198.html">at&amp;t和Intel汇编风格</a></p><h2 id="关于clang和lld"><a class="markdownIt-Anchor" href="#关于clang和lld"></a> 关于clang和lld</h2><p>在colab提供的clang和lld中，大致说一下它二者的作用：</p><ul><li>clang</li><li>lld 用作链接器</li></ul><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://www.zhihu.com/column/c_1747638745254453248">UCB CS61C课程笔记</a></li><li><a href="https://blog.csdn.net/m0_62730135/article/details/126799687">一文学懂RISC-V汇编操作</a></li><li><a href="https://zhuanlan.zhihu.com/p/337147166">RISC-V 汇编语言程序设计基础简析</a></li><li><a href="https://www.zhihu.com/column/c_1215698269139152896">一起学习RISC-V编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/259305354">RISC-V编译环境的搭建</a></li><li><s><a href="https://riscv-programming.org/">RISC-V汇编学习环境</a></s></li><li><a href="https://creatorsim.github.io/creator/">在线RISC-V汇编学习环境(有样例,以及优秀的调试面板,但是系统调用号啥的好像不一样)</a></li><li><s><a href="https://antoniocgj.github.io/RISC-V-ALE/">RISC-ALE</a></s></li><li><a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf">RISC-V card</a></li><li><a href="https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf">RISC-V card2(有扩展指令集，伪指令等的解析，更全面)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些奇奇怪怪的hpc技术栈</title>
    <link href="/2024/04/09/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84hpc%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2024/04/09/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84hpc%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>因为大多数知识都是通过网络了解,有一些奇怪且必须了解且有前景的技术或是与HPC相关的技术栈会被记录在此</p><h2 id="模型压缩"><a class="markdownIt-Anchor" href="#模型压缩"></a> 模型压缩</h2><ul><li>量化</li><li>蒸馏</li><li>剪枝</li><li>二值化</li></ul><h2 id="模型转换"><a class="markdownIt-Anchor" href="#模型转换"></a> 模型转换</h2><ul><li>onnx</li></ul><h2 id="模型推理"><a class="markdownIt-Anchor" href="#模型推理"></a> 模型推理</h2><ul><li><strong>tensorRT</strong></li><li><strong>TVM</strong></li></ul><h2 id="推理优化"><a class="markdownIt-Anchor" href="#推理优化"></a> 推理优化</h2><h2 id="算子开发"><a class="markdownIt-Anchor" href="#算子开发"></a> 算子开发</h2><ul><li><strong>JIT:</strong> just in time,一款编译器</li><li><strong>xbyak</strong>: 类汇编的C</li><li><strong>RISC-V</strong>: 一个初学的精简指令集</li><li><strong>ARMv8</strong>: 之后主体采用armv8的汇编指令进行算子ILP</li><li><strong>cutlass</strong>: 主要对运用TensorCore对密集计算进行优化.编写算子本质上是密集计算的性能问题,要写一个极致优化的算子is hard,cutlass可以提供一个模板库来实现高性能的密集计算算子<ul><li>参考资料: <a href="https://zhuanlan.zhihu.com/p/677616101">cutlass相关教程系列</a></li></ul></li></ul><p><strong>AscendC</strong>是华为公司开发的一款编程语言</p>]]></content>
    
    
    
    <tags>
      
      <tag>hpc</tag>
      
      <tag>cutlass</tag>
      
      <tag>tvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OperatorDev常见优化方案</title>
    <link href="/2024/04/05/OperatorDev%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/2024/04/05/OperatorDev%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h2><p>减少函数调用带来的栈帧开销,适用于那些简单的函数</p><h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2><p>对于GPU来说,没有分支预测功能,循环展开可以帮助它少做判断,少走分支,规避掉warp divergence.</p><p>比如<code>for(int i=0;i&lt;tid;i++)&#123;...&#125; // 其中tid代表block内的线程号</code>可以看出对于[0,31]这一个warp内的线程来说,有很严重的线程束分化.通过循环展开的话,可以减少条件判断的次数;</p><h2 id="分块打包"><a class="markdownIt-Anchor" href="#分块打包"></a> 分块打包</h2><p>分块的意义在于充分的利用其多层缓存机制,数据放在正确的位置,可以在存取的时候减少延迟,同时可以使得数据被复用;</p><p>打包又叫数据重排,把数据放在连续的内存地址,既有利于预取,还有利于少占用TLB条目的数量</p><h2 id="指令级并行ilp"><a class="markdownIt-Anchor" href="#指令级并行ilp"></a> 指令级并行(ILP)</h2><p>指令执行是在不同CPU部件上的,单一的串行执行不能很好发挥各部件的性能,为了使得各部件一直处于繁忙状态,由此出现了流水线技术.经典的五级流水线结构是:<strong>取指(Instruction Fetch),译码(Instruction Decode),执行(EXE),访存(MEM),写回(Write Back)</strong>.各部分的详细功能如下:</p><ul><li>取指: 从L1-ICache中取出指令;</li><li>译码: 将取出的指令按照相应架构的指定读取方式进行翻译,读出操作数,操作类型等;</li><li>执行: 交由具体的功能单元如ALU来执行相应操作;</li><li>访存: 从内存中取数据到寄存器(load)或将数据写入内存中(store),这里是L1-DCache;</li><li>写回: 将指令执行结果写回RegisterFile中去</li></ul><hr /><p>CPI(Cycle Per Instruction):每个指令的时钟周期数</p><p>IPC(Instruction Per Cycle):每个时钟周期能流出的指令数</p><ul><li><p><strong>时钟周期</strong></p><p>最小的时间单位,也叫振荡周期,也叫节拍,以主频10GHZ为例,表示1s内能振荡10<sup>10</sup>次,也就是说一个时钟周期即是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow></mfrac><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{1}{10^{10}}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">s</span></span></span></span>,即是0.1ns</p></li><li><p><strong>机器周期</strong></p><p>由多个时钟周期组成,<strong>用来表示流水线阶段的基本单位</strong>,所包含时钟周期个数叫做机器周期的<strong>时间宽度</strong>.如果每个机器周期时间宽度相等则为<strong>定长机器周期</strong>,反之为<strong>变长机器周期</strong></p></li><li><p><strong>指令周期</strong></p><p>由多个机器周期组成</p></li></ul><p>流水线级数增加对指令执行时间的影响在于增加了很多小的流水段,这些流水段把任务更加细分,实际上是<strong>追求机器周期尽可能等于时钟周期</strong>*(即是期望CPI-&gt;1),从单个指令的完整执行上看,时间是被拉长了的,因为中间的结果你可以要用一些锁存器一类的进行存储,但是指令的吞吐量增大了</p><p>比如一个操作4级流水线,每个流水段假设80ns,变成11级流水线,每个流水段30us,整体的执行时间是多了10us,但在无流水线的情况下该指令执行完成需要280us.通过流水线可以看出来明显的增加了吞吐量:<code>280/80≈3.5</code>可以看出来四级流水线相较于无流水线的情况增加了3.5倍的吞吐,若是11级流水线则是<code>280/30≈9.3</code>9.3倍的吞吐量的增加!</p><p>因此流水线处理的好处在于指令的吞吐增大了非常多,因为我们指令不需要完整等待上一个指令完成才进入.但是单一流水线无论如何优化,它的界限就是<code>IPC=1</code></p><hr /><p>指令级并行意味着一个时间周期内可以同时并行执行超过1条指令的能力</p><p>为了支持指令级并行,有多发射技术,如下图示:</p><img src="https://s2.loli.net/2024/05/10/OuTSmIepjndhwD9.png" alt="Multi Issue" style="zoom:67%;" /><p>多发射并不意味着会有多套重复的流水线部件,但它具备同时并行执行多条指令,也即是执行部件会增多,执行部件被称作FU(functional unit),比如ALU,AGU(address generation unit),BRU(branch unit),FPU等,都是FU中的一种(SIMD的部件也是)</p><p>而取指则通过增强取指部件,一次取多条指令,译码器则通过增加部件进行译码,如此来实现多流水线,从而达到<code>IPC&gt;1</code>的效果</p><p>从这张图来说,多发射包括静态多发射和动态多发射:</p><p>静态多发射即是指的超长指令字(VLIW)一类的方式,一次性将多个指令给它弄成一个指令包,然后在取指译译码的时候都是针对这一个大大指令包,它是静态的在于它是通过编译器来实现多发射,是软件层面的实现而非硬件层面的实现;</p><p>动态多发射是指超标量,它通过一次读取多条指令,通过多个译码器进行译码,后续根据执行的时候是乱序的还是顺序再进行细分</p><p>以下给出一张A76的微架构图,它的多发射采用的是超标量乱序执行的方式:</p><p><img src="https://s2.loli.net/2024/07/13/IvPHtFbCN1GTKR9.png" alt="A76-micro-architecture" /></p><p><strong>乱序执行</strong></p><p>想要同时执行指令,则前后的指令不应有相关性,相关性类型有以下三种:</p><ul><li><strong>WAR 读后写</strong></li><li><strong>WAW 写后写</strong></li><li><strong>RAW 写后读</strong></li></ul><p>前面两种可以通过Rename,即重命名寄存器的方式解决,而后面的一种则是真正的依赖,因为不按这个顺序处理你会脏读,它是通过<strong>旁路</strong>来处理的</p><p>还有一种相关性是<strong>控制相关性</strong>,即分支指令引起的,这是<strong>分支预测</strong>负责的任务</p><p>主要参见参考文件2,没整理好</p><div class="note note-info">            <p>在理解的时候忽然想到了超线程,即一个核心内,同时有两套寄存器和缓存以保留两份工作现场,这样可以丝滑切换线程.而如果是一个核心内,普通情况下(即只有一套寄存器,缓存)进行多线程,则需要涉及到工作现场的切换,这种多线程(单核心)是不丝滑的</p>          </div><h2 id="指令重排"><a class="markdownIt-Anchor" href="#指令重排"></a> 指令重排</h2><p>一般来说指令重排是发生在<strong>编译时期(静态)<strong>和</strong>运行时期(动态)</strong></p><ul><li><p>编译时期的指令重排:当前后指令存在相关性时,顺序执行则会发生阻塞,可以把后续一些无相关性的指令提前执行,以减少阻塞等待的时间.如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a++;<br>b = a + <span class="hljs-number">2</span>;<br>c--;<br></code></pre></td></tr></table></figure><p>则b对于a是有数据依赖(RAW)的,必须等<code>a++</code>执行完才才能执行b的语句,若是顺序执行,则在五级流水线中,当第二条语句处于exe的流水段时,第一条语句是处于mem流水段,并没有到wb到相应的寄存器文件中去,所以此时会发生流水线停顿.而通过指令重排,则可以规避掉这个停顿</p><div class="note note-info">            <p>注:实际上,上面的这个例子并不太好,因为处理器设计的时候考虑到了这个问题,有一个叫做forwarding的前递设计,会把执行后的结果传递给有依赖的指令</p><p>但并不是说指令重排就不重要了,事实上比如<code>a=b+c</code>,以汇编的形式写出就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm__ volatile(<br>ldr w0,[%b]// IF   ID   EXE  MEM   WB<br>ldr w1,[%c]//     IF   ID   EXE   MEM    WB<br>add w2,w0,w1//        IF   ID    EXE(×) EXE WB<br>str w2,[%a]<br>: [a] &quot;+r&quot;(a)<br>: [b] &quot;+r&quot;(b),<br>  [c] &quot;+r&quot;(c)<br>: &quot;cc&quot;,&quot;memory&quot;,&quot;w0&quot;,&quot;w1&quot;,&quot;w2&quot;<br>);<br></code></pre></td></tr></table></figure><p>从上面的内联汇编中可以看出,这样会导致流水线停顿,因此可以把后面不相关的指令提前(则重排了指令)以规避停顿的问题</p>          </div></li><li><p>运行时期的指令重排即是上面所说的乱序执行,是动态的,由硬件控制的</p></li></ul><p>从单线程的角度出发,指令重排并不会对最终的结果产生什么影响,它的结果和顺序执行是一样的,目的只是为了优化流水线并行,提升程序的执行效率</p><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://www.cnblogs.com/openix/p/4085666.html">发射Issue</a></li><li><a href="https://zhuanlan.zhihu.com/p/195008675">超标量处理器流水线</a></li><li><a href="https://www.zhihu.com/column/c_1534317687497138176">超标量处理器设计</a></li><li><a href="https://blog.csdn.net/zongza/article/details/82874937">指令级并行</a></li><li><a href="https://zhuanlan.zhihu.com/p/676396222">CPU微架构</a></li><li><a href="https://blog.csdn.net/qq_39815222/article/details/111471063">计算机并行性的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/461519409">时钟周期、机器周期与指令周期</a></li><li><a href="https://www.cnblogs.com/myseries/p/14458367.html">CPU流水线</a></li><li><a href="https://blog.51cto.com/u_16213606/9632493">A76-A77-A78微架构对比</a></li><li><a href="https://blog.csdn.net/qq_29768741/article/details/105224252">体系结构小白笔记</a></li><li><a href="http://www.360doc.com/content/14/1104/15/13336430_422441127.shtml">SandyBridge MicroArchitecture</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GEMM</tag>
      
      <tag>Conv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>review-CS-basic-knowledge</title>
    <link href="/2024/04/03/review-CS-basic-knowledge/"/>
    <url>/2024/04/03/review-CS-basic-knowledge/</url>
    
    <content type="html"><![CDATA[<h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2><p>参考资料：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp">ms智能指针</a></li><li><a href="https://blog.csdn.net/qq_45445740/article/details/134520594">C++智能指针</a></li></ul><h2 id="总线相关"><a class="markdownIt-Anchor" href="#总线相关"></a> 总线相关</h2><p>CPU内部和cache是通过<strong>本地总线</strong>(<strong>local bus</strong>,又叫<strong>后端总线</strong>)连接的,而访存是通过接口连上<strong>系统总线</strong>,系统总线又连上<strong>IO桥接器</strong>(<strong>北桥芯片</strong>),桥接器一端是IO总线,一端是内存总线(又叫<strong>前端总线</strong>)</p><img src="https://s2.loli.net/2024/05/16/Ih2SJvQTrjWnf65.png" alt="bus-arch-rough" style="zoom:67%;" /><ul><li><strong>北桥芯片主要控制CPU内存显卡等高速设备</strong></li><li><strong>后南桥芯片被加入,是用来负责IO总线之间的通信</strong></li></ul><img src="https://s2.loli.net/2024/05/16/27JjqrCkyudGpXb.png" alt="bus-arch-rough-south" style="zoom:67%;" /><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/675605402">揭秘计算机内部通信：探秘数据、地址与控制信号的奥秘</a></li></ul><h2 id="cpu的三级缓存"><a class="markdownIt-Anchor" href="#cpu的三级缓存"></a> CPU的三级缓存</h2><p>CPU的三级缓存:<strong>L1Cache,L2Cache,L3Cache</strong></p><p>其中L1,L2是核心(core)内的缓存,而L3则是多核心共用的缓存,也在片内</p><img src="https://s2.loli.net/2024/05/16/YhIQ6XFWfeu9OaZ.png" alt="3level-cache-arch" style="zoom:80%;" /><p>L1Cache是分离缓存,分为L1 D-Cache和L1 I-Cache可以避免访存冲突(总不可能流水线处理的时候IF和MEM这俩个流水段打起来吧)</p><p>L2Cache则变为统一缓存,毕竟分离缓存的size不好掌握,cache资源又宝贵,如果分离的话,又cache没用满就吃亏了</p><img src="https://s2.loli.net/2024/05/16/v8coAk6V4GFzudN.png" alt="cache-arch" style="zoom:80%;" /><p>从<strong>单核的缓存一致性</strong>来讲,有**写直达(Write through)和写回(Write back)**两种策略来确保缓存一致性</p><ul><li><strong>Write through</strong>无论你这个更新的数据在不在cache内都得写回内存;</li></ul><img src="https://s2.loli.net/2024/05/16/Dpk2J5VFNM6AHwv.png" alt="cache-write-through" style="zoom:80%;" /><ul><li><strong>Write back</strong>则是多了个dirty标志位,标识cache line中的数据和内存中的是否一致,不过这会使得读cache line进去,且cache已满,且交换出去的cache块是dirty的,就要执行一次写操作</li></ul><img src="https://s2.loli.net/2024/05/16/sfurLUeI3XVTElW.png" alt="cache-write-back" style="zoom:80%;" /><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/669258217">一文吃透CPU三级缓存</a> 只讲了单个核心的缓存一致性问题，对于多个核心的缓存一致性问题没有描述</li><li><a href="https://zhuanlan.zhihu.com/p/584128599">我把 CPU 三级缓存的秘密，藏在这 8 张图里</a></li></ul><h2 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐"></a> 内存对齐</h2><h2 id="c语言的存储层次"><a class="markdownIt-Anchor" href="#c语言的存储层次"></a> C语言的存储层次</h2><p>参考资料:</p><ul><li><a href="https://blog.csdn.net/xiandang8023/article/details/126036564">C语言的内存层次</a></li></ul><h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2><p>关于虚存,<strong>每个进程都有虚存</strong>,比如32位的os就给每个进程弄个4GB的虚存,用虚存可以相较于用真实的物理地址:</p><ul><li>可以给人制造扩大内存的假象(无限大),<strong>规避内存不足的问题</strong>(当然如果真的物理内存不足了,就会通过内存页面置换策略,把久没用到的页帧放到swap分区里面,然后把要用的页帧替上去,不过这个过程涉及到硬盘读取,slow);</li><li>然后也<strong>不存在</strong>同时<strong>访问同一地址</strong>修改造成的<strong>数据冲突</strong>;</li><li>也可以对<strong>碎片化的内存</strong>进行使用;</li></ul><p>通过<strong>MMU(Memory Management Unit)<strong>这个部件来实现</strong>VA -&gt; PA</strong>(CPU收到VA交给它翻译成PA),它是通过<strong>TLB(快表)<strong>和</strong>页表(Page Table)<strong>这俩个表来实现VA-&gt;PA的(<strong>页表是放在进程的内存里面的</strong>),TLB里面放置的是Page Table的常用页表项(局部性原理)<br />这俩表里面放的都是叫做&quot;<strong>页表项</strong>&quot;的东东,是</strong>VA-&gt;PA的映射</strong><br /><strong>每个物理页和虚拟页是大小相等的4KB,它们的映射关系就是一对页表项</strong></p><p>什么时候会出现<strong>缺页异常</strong>呢?显然是在我们的TLB和Page Table都找不到映射关系或没有权限,就报异常(Page Fault)了,而这个异常,会让你的CPU读不到数据,它就罢工,进程就出现了缺页中断,用户态就切换到了内核态,就交由内核的PageFaultHandler来处理:<br />分三类缺页中断:</p><ul><li><strong>Hard Page Fault/Major Page Fault</strong>: 就是找不到这个映射关系了(页帧),要CPU去打开磁盘设备读取到物理内存中,再让MMU建立VA-&gt;PA的映射关系;</li><li><strong>Soft Page Fault/Minor Page Fault</strong>: 实际上物理内存有这个页帧,是被别的进程调入的,我们这个进程不知道而已.只需要MMU建立VA-&gt;PA的映射关系即可.(一般出现在多进程共享内存区域);</li><li><strong>Invalid Page Fault</strong>: 内存地址越界,解空指针引用,权限问题,那么内核就会报Segment Fault,中断你的进程(挂掉你的进程)</li></ul><p><strong>内存的惰性分配(或者叫延时分配),malloc并无真正分配,只是用到你申请的物理内存时,发现没有才会启动申请,这期间就会出现Page Fault</strong></p><p>参考资料:</p><ul><li><a href="https://blog.csdn.net/fwb330198372/article/details/107343468">深入浅出：操作系统之虚拟内存</a></li><li><a href="https://blog.csdn.net/Mind_programmonkey/article/details/116722530">【计算机操作系统-内存管理】-内存的缺页异常是什么？现在有逻辑地址，但是物理地址没有加载到内存会怎么样？</a></li></ul><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2><p>死锁的四个必要条件:</p><ul><li>互斥</li><li>占有并等待</li><li>不可抢占</li><li>循环等待</li></ul><p>避免死锁的方法:</p><ol><li><p>死锁预防,破坏以上后三种条件(因为是非共享资源,互斥是必须的);</p></li><li><p>避免死锁,开始前判断,只允许不会产生死锁的进程申请资源,主要是<strong>银行家算法</strong></p></li><li><p>死锁的检测和解除,检测到运行系统进入死锁,进行恢复(抢占资源/终止进程(全部终止和逐个终止))</p></li></ol><p>参考文件:</p><p><a href="https://cloud.tencent.com/developer/article/2065162">死锁的四个必要条件和解决办法_半暖的博客_活锁和死锁的概念</a></p><h2 id="计算机中的浮点数"><a class="markdownIt-Anchor" href="#计算机中的浮点数"></a> 计算机中的浮点数</h2><p>浮点数在计算机中通过S(Signed),E(Exponent),M(Mantissa),即符号位,指数/阶码,尾数三者来表示.表示出来的浮点数类型有以下三种:</p><ul><li><strong>规格化浮点数</strong></li><li><strong>非规格化浮点数(非常接近0的数以及0)</strong></li><li><strong>特殊的数(±infinity以及NAN)</strong></li></ul><p>这三类数如何区分的呢?</p><p><strong><mark>规格化浮点数的指数部分不能够取到全0或全1,只能取其中的部分,全0则跳到了非规格化浮点数,全1则跳到了特殊的数</mark></strong></p><p><strong>规格数</strong></p><p>此外,以FP32为例,E8M23,则意味着它的指数位是<code>[0000 0000,1111 1111]</code>这么一个范围,显然你如果这样取,取到的指数为都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>的,即范围是[0,255],为了让指数位平均分配在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span></span></span></span>之间,提出了一个exponent bias,它的计算公式是:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">exponent\_bias= 2^{E-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,这里就是127,因此指数的取值范围落在了[-127,128].<mark>实际上,应该是[-126,128],为了实现<u>逐渐溢出</u>的特性,非规格数的指数数值的计算方式与别的不同</mark></p><p>对于规格化浮点数来说,它的取值很平庸,由符号位决定正负,由指数位决定范围,由尾数位决定精度,表示了浮点数中的绝大部分数,但是它无法表示很小的数以及0,也无法表示infinity,它的取数是在±[1,2) ** [-126,127]  <mark>这里写得很简略,都是区间,从左到右依次包括了S,M,E</mark></p><p><strong>非规格数</strong></p><p>非规格数的特点是阶码全取0</p><p>其中规格化浮点数和非规格化浮点数的区别在于两个:</p><ul><li>隐藏的前置1 or 0</li><li>阶码所表示的值是阶码对应的十进制位减去exponent bias,或是1 - exponent bias(阶码全是0)</li></ul><p>其中关于第二点,之所以不采取和规格化数一样的计算方式,是因为为了让规格化数的最小值和非规格化数的最大值,可以紧密的衔接在一起,通过这种溢出的思想,由非规格化数丝滑连接到规格化数</p><p>再通过一种抽象的方式表示非规格化数的范围:±[0,1) ** (-126),这里的0,1表示的是不同尾数的取值导致的,显然尾数取全0就是正负零,取全1,就是此刻的最大值,但由于非规格数前置为0因此到不了1,只是一个很大的很接近1的数,然后再乘于对应的指数(对于非规格数而言,指数就是<code>1-exponent_bias</code>)</p><p><strong>特殊的数</strong></p><p>特殊的数的特点是exponent全取1,当尾数全零,则根据符号位来区分正无穷还是负无穷;否则则为NAN</p><p>可以通过以下表格查看三者分布:</p><img src="https://s2.loli.net/2024/09/05/ATKo4dBScW8bpsw.png" alt="FP32-E8M23" style="zoom:67%;" /><div class="note note-warning">            <p>特别注意: N卡的一些数据类型不遵循IEEE754标准嗷,比如FP8的一个E4M3的类型,它为了取值更大,规格数可以取到448(1.110<sub>(2)</sub> * 2<sup>8</sup>),舍弃了精度,与754的规格数阶码不能全1相反,它阶码全1了,尾数的最后一位空了出来</p>          </div><p><strong>参考文件</strong>:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/343049681">IEEE754规范: 四, 非规格数, ±infinity, NaN</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OperatingSystem</tag>
      
      <tag>ComputerNetwork</tag>
      
      <tag>ComputerComposition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GEMM-intrinsic优化</title>
    <link href="/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/"/>
    <url>/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面:</h2><p>对于一个想<strong>自行实现的GEMM算子</strong>,需要<strong>结合芯片的体系结构考虑</strong>,主要分为两步:<strong>①外层循环</strong>;<strong>②微内核</strong></p><ul><li>外层循环主要做的是:<strong>分块+移动数据</strong>,这里<strong>分块要仔细考虑片上缓存和片外缓存的大小</strong>,如CPU就考虑L3 cache,L2 cache,L1 cache的大小来进行大小合适的分块,并且<strong>分块怎么分也有讲究,以提高数据重用率</strong>;然后就是移动数据到缓存上;这里的计算和访存是可以overlap的,下文统一叫<strong>存算重叠</strong>(当然数据预取,双缓冲其实意思差不大多)</li><li><strong>微内核则主要考虑存算重叠(取指,计算,写回),指令重排,指令打包,以发挥硬件的最大性能</strong></li></ul><p>而我们这里的微内核没有精细到ILP(Instruction Level Parallel),而是采用向量intrinsic编程,来实现汇编上一层的优化,因此最终并不能完全将硬件的性能发挥到巅峰</p><p>但是intrinsic function是在如AVX2指令集上封装了一层的类C的可无缝兼容于C/C++函数的function,编写起来更加顺手一些,因此先在这之上进行算子编写,之后再转用内联汇编~</p><h2 id="内积和外积"><a class="markdownIt-Anchor" href="#内积和外积"></a> 内积和外积</h2><p>在矩阵乘中的内积和外积,与我们数学物理中所认识的内积外积不同,如下图所示:</p><img src="https://s2.loli.net/2024/04/01/9jZVnSvBcqyEoQ2.jpg" style="zoom:50%;" /><p>在矩阵中所说的内积外积取决于我们对矩阵乘的操作。在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>M</mi><mo>∗</mo><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{M*K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>K</mi><mo>∗</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{K*N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这两个矩阵上，我们做矩阵乘可以得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>M</mi><mo>∗</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{M*N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>拿出A的第一行与B的第一列相乘，可以得到C阵的第一行第一列的元素，如<code>C[0][0] = A[0][:] * B[:][0]</code>。这种矩阵乘的方式叫<strong>内积</strong>，按如此方式（如图式）计算矩阵有下列伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设矩阵的存储是行优先/行主序的 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123; <span class="hljs-comment">// a_row -&gt; M</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123; <span class="hljs-comment">// b_col -&gt; N</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;K;k++)&#123; <span class="hljs-comment">// a_col == b_row -&gt; K</span><br>            C[i*N + j] += A[i*K + k]*B[k*N + j]; <span class="hljs-comment">//这里采用一维数组存储矩阵的值，可以结合行主序列主序一起理解</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拿出A的第一列与B的第一行相乘，此时可以得到一个跟C阵规模一样的子阵C1：<code>C1=A[M][0]*B[0][N]</code>。这种矩阵乘依次滑动k即可，得到K个子阵，累加起来便是最终的C阵。这种矩阵乘的方式叫做<strong>外积</strong>，伪码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设矩阵的存储是按行优先存储的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;K;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>            C[i*N + j] += A[i*K + k] * B[k*N + j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外积的方式显然更适合把两个矩阵按K这个维度对应拆分给多个核心计算，然后最后再AllReduce；</p><p>而两者从单一核心上计算来看，其实都没有很好的利用内存局部性这一性质，不过对于外积，它算完了就切到下一个维度，并没有反复的cache miss，而对于内积，对于B矩阵的来说，cache miss在反复的发生着，因为计算一行C阵的数据，就要过一遍B阵的数据，而每次B阵的数据还得重新拿，且矩阵按行存储，并不能一下就直接拿到一整行的数据，因此对于这种内积方式，需要进行<strong>循环重排以优化内存局部性</strong>，提升性能（不然大量时间耗费在访存上了），重排也很简单，就是由原先的M-&gt;N-&gt;K的遍历方式换成M-&gt;K-&gt;N，如下图式：</p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/InnerProduct-LoopChange.jpg" style="zoom:40%;" /><h2 id="cpu算力"><a class="markdownIt-Anchor" href="#cpu算力"></a> CPU算力</h2><p>单颗CPU{单精度/双精度}flops = 核心数 * 单个核心flops</p><p>单个核心flops = 主频 * 单周期{双精度/单精度}计算性能</p><p>单周期单精度的计算性能 =（ FMA计算单元数目 * 2（一次两条指令）* 寄存器位宽 ）/ 32（单精度）</p><p>主频可以通过<code>lscpu</code>里面查看</p><p>FMA数目应该要翻阅处理器的手册或去官网查详细的参数</p><p>寄存器位宽需要配合FMA支持情况查看，有<code>YMM</code>256位的寄存器，也有<code>ZMM</code>512位的寄存器</p><h2 id="flame的矩阵优化"><a class="markdownIt-Anchor" href="#flame的矩阵优化"></a> FLAME的矩阵优化</h2><p>在学习的时候，跟着参考资料三的项目进行了一些基础的矩阵优化<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="(简易的GEMM优化)[https://github.com/flame/how-to-optimize-gemm]">[3]</span></a></sup>，主要包括的优化思想是<strong>循环展开(loop unroll)，内联函数(inline function)，矩阵分块(blocking)，矩阵打包(packing)，intrinsic编程</strong>。因为原项目的优化有点点啰嗦，我给它重写并合并了一些优化手段</p><p>主要思想：</p><ul><li>通过朴素的矩阵乘，将内积的函数单独<code>add_dot</code>提取出来，然后由<strong>1x1</strong>,即一行乘一列的1次内积变换为<strong>1x4</strong>，即一次做4次内积，取A阵的一行，与B阵的四列分别进行相乘，则一次可以完成四次内积；</li><li>在此之上对<code>add_dot</code>进行<strong>内联</strong>，以减少函数调用次数，和减少循环次数以及利用空间局部性；</li><li>利用<strong>寄存器存储</strong>频繁使用的值</li><li><strong>循环展开</strong></li><li>在<strong>1x4</strong>思想上变为<strong>4x4</strong>，即一次完成十六次内积</li><li>采用<strong>intrinsic编程</strong>（SSE指令集，由于只有128位长的向量寄存器，其实对于64位的双精度浮点数有点不是很够用…）</li><li><strong>分块</strong>，<strong>打包</strong></li></ul><p>相关代码细节：<a href="https://www.github.com/ayyHA/OperatorDev">OperatorDev</a></p><h2 id="矩阵分块"><a class="markdownIt-Anchor" href="#矩阵分块"></a> 矩阵分块</h2><p>针对行主序的矩阵进行计算,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>M</mi><mo>×</mo><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{M×K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>K</mi><mo>×</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{K×N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{M×N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>我们以BLAS(基本的线性代数函数接口规范)有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>α</mi><mi>A</mi><mi>B</mi><mo>+</mo><mi>β</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">C = \alpha AB + \beta C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>接口声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><p>在进行矩阵计算的时候，我们一个很大的矩阵无法放进寄存器里，也可能无法放进L1,L2cache中，因此需要对矩阵分块放置在这些</p><h2 id="micro-kernel"><a class="markdownIt-Anchor" href="#micro-kernel"></a> micro-kernel</h2><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:0" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">intel-intrinsic</a><a href="#fnref:0" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/593537184">x64 CPU GEMM优化</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/myseries/p/14458367.html">CPU流水线并行</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>(简易的GEMM优化)[<a href="https://github.com/flame/how-to-optimize-gemm">https://github.com/flame/how-to-optimize-gemm</a>]<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>GEMM</tag>
      
      <tag>intrinsic优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型量化</title>
    <link href="/2024/03/21/%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96/"/>
    <url>/2024/03/21/%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="llmint8论文没读"><a class="markdownIt-Anchor" href="#llmint8论文没读"></a> LLM.int8(论文没读)</h2><p>fp16-&gt;int8,需要用scale放缩到对应的值域范围</p><h3 id="最大绝对值量化"><a class="markdownIt-Anchor" href="#最大绝对值量化"></a> 最大绝对值量化</h3><p>本种量化方式scale为127除以张量的最大绝对值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[1]</span></a></sup></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mrow><mi>i</mi><mn>8</mn></mrow></msub><mo>=</mo><msub><mi>s</mi><msub><mi>x</mi><mrow><mi>f</mi><mn>16</mn></mrow></msub></msub><mo>∗</mo><msub><mi>X</mi><mrow><mi>f</mi><mn>16</mn></mrow></msub></mrow><annotation encoding="application/x-tex">X_{i8} = s_{x_{f16}} * X_{f16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.81836em;vertical-align:-0.35307999999999995em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><msub><mi>x</mi><mrow><mi>f</mi><mn>16</mn></mrow></msub></msub><mo>=</mo><mfrac><mn>127</mn><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msubsup><mi>X</mi><mrow><mi>f</mi><mn>16</mn></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">s_{x_{f16}} = \frac{127}{\max({X_{f16}^{ij}})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7836399999999999em;vertical-align:-0.35307999999999995em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5914279999999996em;vertical-align:-1.269988em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.167428em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.3986920000000005em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4374159999999999em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.269988em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="零点量化"><a class="markdownIt-Anchor" href="#零点量化"></a> 零点量化</h3><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>large model</tag>
      
      <tag>inference</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-learning</title>
    <link href="/2024/02/29/leetcode-learning/"/>
    <url>/2024/02/29/leetcode-learning/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2><p>🔴 -&gt; 一般是指hard的题目,且没pass出来的,就是连暴力解法都想不到的</p><p>🔵 -&gt; 表示十拿九稳的题目</p><h2 id="c的字符数组和c的string转换以及常用函数"><a class="markdownIt-Anchor" href="#c的字符数组和c的string转换以及常用函数"></a> C的字符数组和C++的string转换以及常用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c_s = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>c++中通过导入iomanip,可以用fixed来使浮点数定位(无论double d 里的值是整数浮点数,统统给它输出浮点数形式)<br />通过setprecision(n)来确定整体数字位数,若没有结合fixed使用,则代表的位数是整数位+小数位n;<mark>结合fixed使用则代表的位数是小数位n</mark></p>          </div><h2 id="c一些流"><a class="markdownIt-Anchor" href="#c一些流"></a> C++一些流</h2><p><code>istream&amp; getline(istream&amp; is,string&amp; s,char delim)</code></p><ul><li><code>is</code>是输入流对象, 可以是<strong>标准输入cin</strong>,可以是<strong>输入文件流对象ifstream</strong>,可以是<strong>输入字符串流对象istringstream</strong>等等</li><li><code>s</code>存储读到的一行文本的字串</li><li><code>delim</code>分隔符,<strong>表示在哪个字符处停止读取,默认是<code>\n</code></strong></li><li>返回值是输入流对象的引用</li></ul><p>参考文件:</p><ul><li><a href="http://vcsos.com/article/pageSource/160122/20160122233408.shtml">io流,文件流,字串流</a></li></ul><h2 id="algorithm一些算法"><a class="markdownIt-Anchor" href="#algorithm一些算法"></a> algorithm一些算法</h2><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3><p>排序算法,很经典,c++里用的是快排实现的,我们的容器可以通过如下方式使用它:</p><p><code>sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</code></p><ul><li>第一个参数是迭代器的起始地址</li><li>第二个参数是迭代器的结束地址(就是那个<code>end()</code>,结束位置的下一位)</li><li>第三个参数是排序规则</li></ul><p>这里主要讲自定义排序规则,<strong>默认是升序(即默认采用<code>&lt;</code>运算符进行比较,谁小谁排前面)</strong>.可以通过:</p><ul><li><p><strong>lambda表达式(本质上是定义一个返回值为bool的两个待比较参数的比较函数)</strong></p></li><li><p><strong>重载运算符</strong></p><p><strong>主要运用在结构体里,以指示如何对结构体里的成员进行比较</strong>,然后调用c++自带的仿函数<code>less&lt;T&gt;()</code>/<code>greater&lt;T&gt;()</code>(头文件是<code>&lt;functional&gt;</code>)来对序列中的<code>T</code>类型排序,示例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>  <span class="hljs-comment">// 重载&gt;运算符</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> Person&amp; other) <span class="hljs-keyword">const</span>&#123;<br>  <span class="hljs-keyword">if</span>(score != other.score)<br>  <span class="hljs-keyword">return</span> score &gt; other.score;<br>  <span class="hljs-keyword">return</span> id &lt; other.id;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">// 使用greater仿函数来通过&#x27;&gt;&#x27;运算符进行比较,则会调用到Person里重载的&#x27;&gt;&#x27;运算符里的规矩来进行排序</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:people)<br>    cout &lt;&lt; p.id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; p.score &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png" alt="cpp_functional_greater" style="zoom:80%;" /></li><li><p><strong>仿函数</strong></p><p><strong>仿函数(functor)是一个类/结构体,里面重载了<code>operator()</code>,从而仿函数的对象可以像函数一样被调用,大致如下:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greater</span>&#123;</span><span class="hljs-comment">// 定义一个仿函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&gt;y;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>&#125;;<br>Greater g;<span class="hljs-comment">// 仿函数的对象</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),g); <br><br>    <span class="hljs-comment">// 下面这种也可以,跟c++提供的仿函数greater&lt;int&gt;()一样,这里的greater是个struct</span><br>    <span class="hljs-comment">//sort(v.begin(),v.end(),Greater());</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>以上三种方式的任一方式来实现自己的排序功能,乃至多级排序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是对vector降序排序*/</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; j)-&gt;<span class="hljs-keyword">bool</span>&#123;<span class="hljs-keyword">return</span> i&gt;j;&#125;);<br></code></pre></td></tr></table></figure><p>可以这么理解i&gt;j就是谁大谁排前面(i是第一个参数,j是第二个参数),当然上面的也可以写成普通的函数;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是多级排序,对自定义结构体Person*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    排序规则:</span><br><span class="hljs-comment">    1.先按分数由高到低排</span><br><span class="hljs-comment">    2.分数相同的id小的排前面</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> Person&amp; a,<span class="hljs-keyword">const</span> Person&amp; b)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score != b.score)<br>            <span class="hljs-keyword">return</span> a.score &gt; b.score;<br>        <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料:</p><ul><li><a href="https://www.jb51.net/article/263333.htm">c++自定义sort()函数的排序方法介绍</a></li></ul><h3 id="iota"><a class="markdownIt-Anchor" href="#iota"></a> iota</h3><p>这是一个区间填充函数,所在头文件为<code>numeric</code>,函数原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iota</span><span class="hljs-params">(ForwardIt first, ForwardIt last, T value)</span></span>;<br></code></pre></td></tr></table></figure><p>前两个参数用迭代器指定区间范围,最后的参数用来指示起始值,可以迅速的填充好一个区间,比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> size = n;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>); <span class="hljs-comment">// [0, ..., n-1]</span><br></code></pre></td></tr></table></figure><h2 id="一些stl容器回顾"><a class="markdownIt-Anchor" href="#一些stl容器回顾"></a> 一些STL容器回顾</h2><p>这里主要记着主要方法,后续有新的会来补充,以便于一开始训练的时候查方法,当然也会说一下不同容器/相似容器间的差别</p><p>参考资料:</p><ul><li><a href="https://www.cnblogs.com/lvshen/p/17839484.html">STL容器</a></li><li><a href="https://blog.csdn.net/m0_57190374/article/details/127042161">C++常用容器介绍</a></li></ul><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>因为字符串涉及的函数非常多,且有些函数很少用,但在一些机试的时候会遇到,而且自己重写非常繁琐,因此这里记录一下一些函数,这里会混杂字符的内容</p><p><strong>数字,字母,大小写部分:</strong></p><ul><li><code>isalpha()</code>用于判断一个字符是否是字母</li><li><code>isalnum()</code>用于判断一个字符是否是字母或数字</li><li><code>isupper()</code>用于判断一个字符是否是大写的</li><li><code>islower()</code>用于判断一个字符是否是小写的</li><li><code>toupper()</code>将一个字符转为大写</li><li><code>tolower()</code>将一个字符转为小写</li></ul><p>上面的是针对字符的,源自<code>&lt;ctype.h&gt;</code></p><p>对于字串来说的话,导入algorithm库可有以下转换方式:</p><ul><li><strong><code>transform(s.begin().s.end(),s.begin(),::tolower)</code></strong> 转换整个字串为小写,其中第一二个参数是输入容器的起始和终止迭代器(终止不含),第三个参数是输出容器的开始迭代器,第四个参数是一元函数对象</li><li><strong><code>transform(s.begin(),s.end(),s.begin(),::toupper)</code></strong> 转换整个字串为大写</li></ul><p><strong>字符串和整型的转换:</strong></p><ul><li><strong><code>stoi(string,nullptr,base)</code></strong> 字串转整数,base是string的进制,比如string是二进制的,则这里就写个2,会自动做进制转换</li><li><strong><code>to_string(int/long/float)</code></strong> 将一个数字常量转为字符串</li></ul><p>还有一种<code>atoi()</code>,<code>itoa</code>的字串和整型的转换,但是需要注意这种针对的是字符数组,而非string</p><p><strong>字符串做切片</strong></p><ul><li><strong><code>substr(start,len)</code></strong> 从<code>start</code>处,切len这么长的子串,不指定len则到结尾</li><li><s><code>substring(start,end)</code> 从start处开始,切到end,其中不包括end索引的字符,不指定end则到结尾</s><mark>[这是java/js才有的,搞错了= =]</mark></li></ul><p><strong>初始化函数</strong></p><p>在结构体或者类中,需要对一些为指针的成员实现初始化(别的也尽量初始化),不然会报内存不对齐的错误,传统的C在<code>cstring</code>这个库里有**<code>memset(void* s,int c,size_t n)</code>**可以对一块内存进行初始化,如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        isEnd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意:由于<code>memset</code>是按字节对内存块进行初始化,也就是说第二个参数c只会取低八位,然后赋值给一块地址(一块地址是一字节).比如int是4字节,那如果给的c是1,就会变成<code>0x01010101</code>,每个字节分别是<code>0000 0001</code>这么一个情况,所以一般第二位填0或-1就好了,它跟那种<code>vector&lt;int&gt;v(10,5) // 十个数,每个都是5</code>不一样</p><div class="note note-info">            <p>由于LeetCode检测机制更加严格，所以我们在创建节点是，还需将指针域赋值。</p><p>参考文件:<a href="https://blog.csdn.net/Zhenyu_Coder/article/details/132273442">runtime error: member access within misaligned address(力扣最常见错误之一)</a></p>          </div><h3 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h3><h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4><ul><li><code>push_back()</code></li><li><code>emplace_back()</code></li></ul><div class="note note-info">            <p>上面两个函数都是向容器尾部添加元素</p><p>push_back():1. 创建元素; 2. 调用移动构造函数/拷贝构造函数,将元素弄到容器中</p><p>emplace_back(): 1. 直接在容器尾部创建元素,减少了拷贝/移动的开销</p><p>其中<strong>移动构造函数</strong>和<strong>拷贝构造函数</strong>是不同的:<strong>后者是将一个已存在的对象复制到一个新的对象中;前者是将一个对象的资源移动到一个新的对象中</strong>.因为一般自己写的拷贝构造是深拷贝(为了避免浅拷贝指向同一块内存的问题)所以涉及到<strong>内存分配</strong>,而拷贝又涉及到<strong>数据复制</strong></p><p>而其中移动构造涉及到右值引用的知识,可以看看参考文件</p><p>参考文件:</p><ul><li><a href="https://gitcode.csdn.net/65eed6611a836825ed79f6e7.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NTk3OTAyMCwiZXhwIjoxNzE3MTIwNTQyLCJpYXQiOjE3MTY1MTU3NDIsInVzZXJuYW1lIjoid2VpeGluXzQ1Mzg4MzEyIn0.NhR7qBK3BAP_eFFZfFm1NLr7JxVF3TFaKd_tDLsOZ-4">【C++11】之 emplace_back() 与 push_back() 的区别</a></li><li><a href="https://blog.csdn.net/weixin_44355021/article/details/129369368">移动构造函数与拷贝构造函数对比</a> (未看完)</li></ul>          </div><h4 id="queue容器适配器"><a class="markdownIt-Anchor" href="#queue容器适配器"></a> queue[容器适配器]</h4><ul><li><code>push()</code></li><li><code>pop()</code></li></ul><div class="note note-info">            <p>push,pop遵循FIFO</p>          </div><ul><li><code>size()</code></li><li><code>empty()</code></li><li><code>front()</code></li><li><code>back()</code></li></ul><p>queue参考资料:<a href="https://blog.csdn.net/m0_59068776/article/details/130549065">queue基本方法</a></p><h4 id="deque双端队列"><a class="markdownIt-Anchor" href="#deque双端队列"></a> deque(双端队列)</h4><p>相比于vector,可以更好更迅速的处理头部元素</p><h4 id="list双向链表"><a class="markdownIt-Anchor" href="#list双向链表"></a> list(双向链表)</h4><h4 id="forward_list单链表"><a class="markdownIt-Anchor" href="#forward_list单链表"></a> forward_list(单链表)</h4><h4 id="stack栈容器适配器"><a class="markdownIt-Anchor" href="#stack栈容器适配器"></a> stack(栈)[容器适配器]</h4><ul><li><code>push()</code> #压入</li><li><code>pop()</code> # 弹出</li><li><code>top()</code> # get栈顶</li><li><code>back()</code> # get栈底</li><li><code>empty()</code></li><li><code>size()</code></li></ul><p>不能通过索引遍历,用<code>while(!s.empty())</code>遍历</p><p>stack参考资料:<a href="https://blog.csdn.net/H1727548/article/details/130857503">stack基本方法</a></p><h4 id="priority_queue优先队列容器适配器"><a class="markdownIt-Anchor" href="#priority_queue优先队列容器适配器"></a> priority_queue(优先队列)[容器适配器]</h4><p><strong>底层是通过堆实现的优先队列,常数时间的最大/最小元素查找,默认是大顶堆(<code>less&lt;T&gt;</code>),则最大元素位于<code>top()</code>,当调用<code>pop()</code>则会发生类似<code>adjust_down()</code>一类的内部函数的操作</strong></p><p>具备<strong>自动排序</strong>的特性,所以对如<strong>前k个…最大/最小</strong>的题目都很适用</p><p>优先队列的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq; <span class="hljs-comment">// 其中只有第一个是要具体定义的,三个分别是:元素类型,容器类型,比较函数类型</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注:这里传入的是比较函数的类型,而不是具体的对象,因此不用像sort里的加多个<code>()</code>; 这个跟自定义map的key的比较方式很相似,传的是类型而不是匿名对象</p>          </div><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>top()</code></li><li><code>size()</code></li><li><code>empty()</code></li></ul><p>有一个比较可能会遇到的问题就是<strong>重写比较函数</strong>,这里给出一个模板:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b)&#123;<br>    <span class="hljs-keyword">return</span> a.xxx &gt; b.xxx;<span class="hljs-comment">//这样构造的是该规则下的小顶堆,可以按sort理解为这是降序,然后堆排序降序的话是小顶堆弄的</span><br>&#125;<br>priority_queue&lt;T,vector&lt;T&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure><p>这么一个模板可以重写比较规则,使得出来的大顶堆/小顶堆(也就是最大值/最小值)符合我们的需求</p><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/weixin_68278653/article/details/131015181">priority_queue</a></li><li><a href="https://zhuanlan.zhihu.com/p/498045886">[C++STL] Priority Queue 介绍及源码分析</a></li></ul><h3 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h3><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4><p>内部是通过<strong>红黑树</strong>实现的,<strong>去重且递增</strong>(自动有序),<strong>遍历只可以通过iterator遍历</strong>,插入值是insert的方式</p><p><img src="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png" alt="set方法大全" /></p><p>以下这俩函数是针对的容器中的数值是有序的,而set有序,故可以用:</p><ul><li><code>lower_bound()</code>:实参用个val,会找到set容器中&gt;=val的iterator,找不到就滑到<code>end()</code>了</li><li><code>upper_bound()</code>:实参用个val,会找到set容器中&gt;val的首个iterator,找不到就滑到<code>end()</code></li></ul><p>set参考资料:<a href="https://blog.csdn.net/H1727548/article/details/130800542">set</a></p><h4 id="unordered_map"><a class="markdownIt-Anchor" href="#unordered_map"></a> unordered_map</h4><p>底层是通过<strong>哈希表实现的无序map</strong></p><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4><ul><li><code>insert()</code></li><li><code>begin()</code></li><li><code>end()</code></li><li><code>clear()</code></li><li><code>count()</code> # 返回指定元素出现的次数,key唯一就是0/1</li><li><code>empty()</code></li><li><code>erase()</code> # 删除一个元素,并返回下一个元素的迭代器(使用特别注意,要承接这个return值,而不是自增)</li><li><code>find()</code> # 查找一个元素,找得到返回对应位置迭代器,否则滑倒<code>end()</code>去</li><li><code>size()</code></li><li><code>rbegin()</code></li><li><code>rend()</code></li><li><code>lower_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>给定元素的第一个位置</li><li><code>upper_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">\gt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>给定元素的第一个位置</li><li><code>swap()</code> # 交换两个map</li></ul><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/m0_58086930/article/details/120393227">map和multimap的解释c++</a></li><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法详解</a></li><li><a href="https://www.cnblogs.com/nntzhc/p/14606368.html">erase神奇用法!</a></li></ul><h4 id="multimap"><a class="markdownIt-Anchor" href="#multimap"></a> multimap</h4><p><strong>允许key重复,没有重载<code>operator[]</code>,底层红黑树</strong></p><ul><li><code>insert()</code></li></ul><div class="note note-info">            <p>注:只可以用这个加值,不像map可以用<code>[]</code>来加值,需要注意</p>          </div><h2 id="一些板子"><a class="markdownIt-Anchor" href="#一些板子"></a> 一些板子</h2><p>写题记录总结,并记忆一些板子,以便后期快速完成题目</p><h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3><p><em><strong>不撞南墙不回头</strong></em></p><p>实现手段: 递归</p><p>适用于: 树,图</p><p>经典题目: 迷宫找通路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-comment">/*状态*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*递归结束条件*/</span>)&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*找寻新状态*/</span>)&#123;<br>        <span class="hljs-comment">// 定义新状态</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*新状态满足边界条件*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足标志位*/</span>)&#123;<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置标志位</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-comment">/*新状态*/</span>);<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置为旧的flag以回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>状态是指比如迷宫里的坐标xy一类的东西</p>          </div><h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h3><p><em><strong>像波一样,由近及外</strong></em></p><p>实现手段: 队列</p><p>适用于: 最短路径</p><p>因为广度优先搜索和层序遍历概念很像,这里举的模板是按着层序遍历的写的,可以在这基础上根据题意进行变通,变通版本在下面:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(node); <span class="hljs-comment">// 这里push的是类似于&quot;头节点&quot;或&quot;符合题目要求的!首类节点!&quot;</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">// 遍历队列里的点</span><br>    <span class="hljs-comment">/*跳出条件*/</span> <span class="hljs-comment">// 有些题目需要设置跳出条件</span><br>    <span class="hljs-keyword">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<span class="hljs-comment">// 一层层的遍历,这个sz代表的是这一次波及到的点,可以从树的层序遍历和矩阵中点逐个向外扩散进行想象</span><br><span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>         q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*候选点*/</span>)&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            获取一个候选点</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*满足边界*/</span> &amp;&amp; <span class="hljs-comment">/*满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*满足标志位*/</span>)&#123;<span class="hljs-comment">// 筛选符合状态的点</span><br>        flags[candidateNode] = ... <span class="hljs-comment">// 设置标志位</span><br>                 q.<span class="hljs-built_in">push</span>(candidateNode);<span class="hljs-comment">// 满足条件的点加入队列中(这是下一层)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><p>使用场景:原数组不变动,但需要对子数组进行频繁的累和操作(频繁查询区间和),则可以构建<strong>前缀和数组</strong></p><p>前缀和数组即<code>prefix[i]</code>表示的是原数组nums在<code>[0,i-1]</code>这个区间的元素的累和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设题目给的数组是:vector&lt;int&gt;&amp; nums</span><br><span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span>* prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要多一个位置</span><br>prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=len; i++)<br>    prefix[i] = prefix[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">... 对前缀和数据的操作,如想获得[i,j]区间的累和,则可以通过prefix[j+1] - prefix[i]获得</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> []prefix;<br></code></pre></td></tr></table></figure><p><strong>前缀和+哈希表</strong></p><p>这里以560题<u>和为k的子数组</u>为例,前缀和一般喜欢考某一个区间的和是k值的情况(会变形),如果按照暴力的思路,开个前缀和数组,计算每一个<code>[i,j]</code>区间的和,判断是否为k,如此处理,则需要两重循环,时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,其实跟暴力做没太大区别</p><p>这时要怎么优化呢?首先我们期望求**<code>[i,j]</code>区间值为k的个数,即等价于<code>prefix[j+1] - prefix[i] = k</code>**,就是上面二重循环的循环判断条件</p><p><strong>这其实跟两数之和:<code>i + j = target</code>是一样的,对于两数之和,我们是转换成<code>i = target-j</code>,然后遍历得到j,通过哈希表判断存不存在<code>target-j</code>,存在则返回,不存在则把j加入哈希表中来处理</strong></p><p>对于利用前缀和求区间和满足题意的个数的题目(就是上面那个题),也可以这样转换:<strong><code>prefix[i] = prefix[j+1] - k</code>,即求满足这样条件的<code>prefix[i]</code>的数量,也即等价于求满足<code>prefix[j+1]-k</code>的数量</strong>,所以遍历就<strong>可以只遍历一个维度,同时利用<code>prefix[j+1]-k</code>去哈希表里看,有没有match的,match就加上去,最后统计<code>prefix[j+1]</code>:<code>ump[prefix[j+1]]++;</code>,这里统计的是<code>prefix[j+1]</code>的次数,也即前缀和为某一个值的个数</strong></p><p>由此则利用哈希表,把时间复杂度降到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>当然,也可以只利用一个变量<code>preSum</code>去统计当前区间的和(比如[0:j-1])然后利用<code>ump.count(preSum-k)</code>来判断是否存在区间[i,j-1]满足区间和(由于累和顺序是从左到右,依次把值加入哈希表中,所以保证了区间i&lt;j),满足则加上满足的区间数量.这样的话,开前缀和的空间复杂度就降到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p><strong>典型例题</strong></p><ul><li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></li><li>724 寻找数组的中心下标</li></ul><h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3><p>当我们需要对一个数组的区间批量的进行数据增改操作时,可以考虑使用差分数组~</p><p>数组<code>a  = [1,2,3,4,5]</code>转换为差分数组则为<code>diff=[1,1,1,1,1]</code>,其中diff[0]=a[0];别的则是通过<code>a[i]-a[i-1]</code>项获得的,具体构造见下方:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(n)</span></span>;<br>diff[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    diff[i] = a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure><p>那差分数组diff怎么变回a呢只需要第<code>i</code>项加上第<code>i-1</code>项,见下方(这里用数组b代替):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>b[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    b[i] = diff[i] + b[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>那差分数组是如何发挥作用的,当面对批量对区间元素进行增改,比如我们需要对数组a的[1,3]这个区间每个元素加3(这里的区间从0开始),[0,2]每个元素减5:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>&#125;&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [i,j,val]:vec)&#123;<br>    diff[i]+=val;<br>    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n)&#123;<br>    diff[j+<span class="hljs-number">1</span>]-=val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过修改有:<code>diff=&#123;-4,4,1,6,-2&#125;</code>,根据题意我们直接翻译出a被修改为<code>a=&#123;-4,0,1,7,5&#125;</code>,将diff还原出b有:<code>b=&#123;-4,0,1,7,5&#125;</code></p><p>以上,便是差分数组的概念,我们可以通过原数组经过处理得到差分数组,同时差分数组可以变换回原数组,并且对区间的操作[i,j,val],是对<code>diff[i]+=val;</code>,<code>diff[j+1]-=val;</code>,因为[i,j]的元素在变回去的时候会加到<code>diff[i]</code>上多出来的<code>val</code>,我们只需要加到<code>j</code>即可,因此在<code>j+1</code>的时候要把累加的这个val给它收回去,则保证了只有<code>[i,j]</code>区间的数增加了<code>val</code></p><p>典型例题:</p><ul><li>1109 航班预定统计</li><li>1094 拼车</li></ul><h3 id="反转链表系列"><a class="markdownIt-Anchor" href="#反转链表系列"></a> 反转链表系列</h3><p>&quot;反转链表,反转链表Ⅱ,K个一组链表进行翻转&quot;这三道题目本质上是针对反转链表的层层深入,如果采用朴素的头插法进行实现,其实罗里吧嗦要写比较多的代码.因此有了这个模板系列:</p><p>针对反转链表,主要需要建立三个指针,<code>pre</code>,<code>cur</code>,<code>nxt</code>,用以进行反转,最终返回<code>pre</code>指针即可,而判断循环终止的条件是<code>cur!=nullptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 反转链表</span><br>ListNode* pre,*cur,*nxt;<br>pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br></code></pre></td></tr></table></figure><p>针对反转链表Ⅱ,是针对区间<code>[left,right]</code>进行的反转,因此我们还需要一个前序节点<code>p0</code>来在left对应的节点前面,以在最后反转结束时,将区间反转的结果与链表中未进行反转的节点进行拼接.但是left如果是1,即是头节点,那么就相对麻烦,因此可以<code>new</code>1个dummy节点,这样一来整体代码就统一了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2. 反转链表Ⅱ</span><br>ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>ListNode* p0 = dummy;<br>ListNode* pre = <span class="hljs-literal">nullptr</span>,*cur,*nxt;<br><span class="hljs-keyword">int</span> sz = right - sz + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">1</span>)&#123;<br>    p0 = p0-&gt;next;<br>    left--;<br>&#125;<br>cur = p0-&gt;next;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br>p0-&gt;next-&gt;next = cur;<br>p0-&gt;next = pre;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br></code></pre></td></tr></table></figure><p>针对K个一组链表进行反转,实际上就是在上面的反转链表Ⅱ的基础上,①每次需要满足剩余节点大于K才可以进行反转;②并且p0应该指向的是下一个cur的前序节点(原先就是p0-&gt;next指向的那个点),你得后面给p0指回去.把这两点满足了这题就出来了</p><p>典型套题:</p><ul><li></li></ul><h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3><p>滑动窗口常见于字符串匹配一类的题目,通常暴力求解会遇到TLE的问题,因此需要借助滑动窗口这一算法思想来实现</p><p><strong>滑动窗口本质上是左右指针,通过右端的指针不断扩张,直至满足一定条件,再经由左端的指针不断收缩,收缩到一定条件,则继续右端指针扩张,循环往复,直至右端指针越了字串的界</strong></p><p>右端指针扩张的过程,可以看作是正在寻找可行解,<strong>当满足可行解的条件,则停止扩展</strong>,通过左端指针收缩,来<strong>优化可行解,寻找到当前小区间里的局部最优解</strong>,当不再满足可行解的条件,则不再收缩,而是还给右端指针继续扩张.如此遍历完整个数组,我们便在局部最优解中挑选出了全局最优解(<mark>有些题目是要找全局最优解,有些是要收集所有符合条件的解,因题而异,这里只是说一种思想</mark>)</p><p>模板如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s,string t)</span></span>&#123;<br>    <span class="hljs-comment">// need表示需要满足的条件,window表示的是滑动窗口内的数据</span><br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; need,window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)<br>        need[c]++;<br>    <span class="hljs-comment">// 左右指针,左闭右开[left,right)</span><br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// valid表示符合要求的字符数目,比如t=&quot;aabc&quot;; need = &#123;&#123;&#x27;a&#x27;,2&#125;,&#123;&#x27;b&#x27;,1&#125;,&#123;&#x27;c&#x27;,1&#125;&#125;;</span><br>    <span class="hljs-comment">// 则当&#x27;a&#x27;的数目window中收集满了2个,才会给valid自增(后续还可能收集到a,且没有达到进入收缩区间的条件,即a的数目&gt;=2),因此当valid数目和need.size()相等时,则表明t中的字符都在我们的滑动区间里,且可能是&quot;aaabaababc&quot;的形式,则需要收缩区间,找到符合题意的!</span><br>    <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 1.对c处理,怎么个扩张法</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-comment">/* 2.满足条件,开始收缩*/</span>)&#123;<br>            <span class="hljs-comment">// 3.怎么更新局部最优解</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 4.对d处理,怎么收缩法</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个模板,在写同类型题目的时候要思考以下四个问题:</p><ol><li><p>右端指针扩张,怎么更新值;</p></li><li><p>满足什么条件开始收缩;</p><p>一般来说,如果是字串匹配系列的题目,我们会有两个字串,一个字串s(source)要包含另一个字串t(target),当<code>valid==need.size()</code>的时候,则说明目前滑动窗口[left,right)里面已经包含了该字串t(滑动窗口是在s上滑动的)</p><ul><li>[<strong>76-最小覆盖字串</strong>] : 目的最小覆盖,则意味着覆盖(包含)之后再收缩,并在里面更新局部最优解,收缩至不再覆盖为止,则跳出收缩.即此时的收缩条件是<code>valid == need.size()</code></li><li>[<strong>567-字符串的排列</strong> <strong>438-找到字符串的所有字母异位词</strong>] : 明确要找匹配到字串t的别的排列形式(即<code>t=&quot;abc&quot;</code>,s里有<code>&quot;cab&quot;</code>也满足),即意味滑动窗口里的尺寸如果比字串t大,必不满足字串t的排列,因此收缩条件应该是<code>right-left == t.size()</code>,而判断是不是满足排列(这里就不是局部最优解的问题了,因为没有最…之类的限定词),就是<code>valid==need.size()</code></li><li>[<strong>3-无重复字符的的最长子串</strong>] : 这个题目它只有s没有t,则不要need这个容器了,直接在滑动窗口里统计就好,当window[c]&gt;1则表明有重复的了,那就要开始收缩,直至没有重复的,此刻则需要在收缩循环的外面统计最长字串</li></ul></li><li><p>怎么更新局部最优解;(结合2看)</p></li><li><p>左端指针收缩,怎么更新值;</p></li></ol><p>参考资料:</p><ul><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-">leetcode评论区大佬对于滑动窗口的高见</a></li></ul><p>典型例题:</p><ul><li>3 无重复字符的最长字串</li><li>438 找到字符串中的所有字母异位词</li><li>76 最小覆盖字串</li><li>567 字符串的排列</li><li>239 滑动窗口最大值(搭配单调队列食用)</li><li>209 长度最小的数组</li><li>219 存在重复元素Ⅱ</li><li>30 串联所有单词的子串(滑动窗口以一种技巧被应用,优化算法)</li><li>1004 最大连续1的个数Ⅲ</li></ul><h3 id="dp系列"><a class="markdownIt-Anchor" href="#dp系列"></a> DP系列</h3><h4 id="递归-记忆化搜索-递推"><a class="markdownIt-Anchor" href="#递归-记忆化搜索-递推"></a> 递归-&gt;记忆化搜索-&gt;递推</h4><p>对于这一类题目,比如涉及到子序列,最长递增子序列,最长上升子序列一类的问题,可以采用dp来进行思考,那如何思考出动规的状态/子问题呢?</p><p>我们思考的时候先按照**<u>递归</u>**的思路来思考:</p><p><strong>考虑最后一个索引或最前一个的索引对应的子问题</strong>,这个子问题dfs(…)的表述与所求的结果相关,比如组合数/最大值/最小值,然后根据题目类型:</p><ul><li><strong>背包/LCS</strong>,则是<strong>选和不选的问题</strong>,可以<u>定义为[0,i]这个区间的最大/最小</u>,此时这个状态需要对索引i对应的值进行选/不选的处理;</li><li><strong>LIS</strong>,则是<strong>枚举选哪个</strong>,可以<u>定义为以第i个索引作为结尾的最大上升子序列长度</u>,然后就是以这个索引定了区间的右端,来枚举看前面的最大上升子序列选哪个,然后计算完毕要+1,即加上以第i个索引作为结尾的长度</li></ul><p>由上则可以写出对应的<strong>子问题</strong>和<strong>转移方程</strong>(<strong>选和不选 / 枚举选哪个</strong>)</p><p>递归边界,递归入口则根据题目而定</p><p>之后可以<u><strong>采用与状态同维的<code>memo</code>用作记忆化</strong></u>,选取一个永远不会计算到的值作为初值,当它为初值则update它,下次遇到同样的状态则直接获取并return即可</p><p>完成了记忆化搜索后,可以**<u>通过以下方法将递归翻译成递推</u>**(就是DP):</p><ul><li>dfs -&gt; f(可能需要放缩一下,避免索引为负数)</li><li>递归 -&gt; 循环</li><li>边界 -&gt; 初值</li></ul><p><mark>空间优化暂时忽略,一般不会爆内存,不管!</mark></p><h4 id="背包系列"><a class="markdownIt-Anchor" href="#背包系列"></a> 背包系列</h4><p>在说起背包系列的问题前,先说下动规题的四大步骤:</p><ol><li><strong>确定子问题/状态</strong>,这一步需要好好分析,一般是<strong>前k个…/直到第k个…的最大/最小…</strong>,要保证<strong>无后效性</strong>,<strong>后来的结果不会影响前面的结果</strong>,可以通过叠定语或增加数组维度来实现,如果读起来自己觉得有问题的一般就是有问题;子问题是具备<strong>最优子结构</strong>的,<strong>可以通过求解子问题,最终获得原问题的解</strong>,如果奔头不是这个,那求来也没用</li><li><strong>推导出状态转移方程</strong>,DP具备<strong>子问题重叠</strong>的性质,也就是说状态转移方程会出现至少两个dp的某种转移的等式</li><li>确定初值</li><li>确定原问题的答案</li></ol><p>其中当涉及到多维dp的时候,遍历的顺序也是一个考虑的点,如0/1背包滚动数组版本和完全背包滚动数组版本,内嵌循环的正向遍历和倒序遍历就是这两个问题的关键区别,即取的物品可否重复</p><h5 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 0/1背包</h5><p>有一个承重为W的背包,N件物品,第i件物品对应的重量是weight[i],对应的价值是value[i],<strong>每件物品只能被取一次</strong>,问如何能使得背包的物品总价值最大?</p><p>遍历顺序:<mark>需要好好思考</mark>(说是先遍历物品数量,再遍历背包容量;和反过来的情况是否符合题意)</p><p>以二维的为例:</p><p><strong><code>dp[i][j]</code>表示从以<code>[0,i]</code>为下标的物品中任取,但每个物品只可以取一次,放到容量为j的背包里,所能达到的最大价值</strong>.要获得<code>dp[i][j]</code>的值可以从以下两个状态中转移过来,并取其中最大的进行转移:</p><ul><li><code>dp[i-1][j]</code>,表示<strong>不取第i个物品</strong>,不取可能是背包容量不够,也可能是此时的最大价值更大;此时的最大价值延用<code>dp[i-1][j]</code></li><li><code>dp[i-1][j-weights[i]] + value[i]</code>,表示<strong>取第i个物品</strong>,value[i]是第i个物品的价值,前面的一串则表示放入第i个物品的话,<br />此时的背包(<code>j-weight[i]</code>)的最大价值是多少,以加上物品i的价值</li></ul><p><strong>本质上01背包就是选和不选问题,用回溯法来处理复杂度为O(2^n)(物品数目)</strong></p><p>经上面分析可以得到转移方程:</p><p><strong><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weights[i]] + values[i]);</code></strong></p><p>关于<strong>初值设置</strong>,求最大值,若物品价值都是正数,则初值置为0;若物品价值有负数,则初值置为负无穷(根据题意设置)</p><p>关于<strong>遍历顺序</strong>,对于二维dp来说其实遍历物品先还是遍历容量先,对于一个二维的表格来说,就是行主序列主序的那个折线图,实质无影响,因为都构建出了下一步需要的数据</p><p>但<strong>为了易于理解和记忆,之后关于01背包统一先遍历物品后遍历背包容量</strong></p><p><strong>在考虑第i个物品的加入时,是从[0,i-1]个物品任取的情况下出发考虑的,也就是说: 第i行的数据是基于第i-1行而创建的</strong></p><p>正因如此,所以可以把第i-1行的数据拷贝到第i行,如此的话,不如舍去i这个维度,则引出了<strong>一维的01背包dp</strong>(<strong>只是dp这个数组是一维的,实质遍历还是两层for</strong>)</p><p>以一维的为例:</p><p><strong><code>dp[j]</code>,表示容量为j的背包,所能存放的最大价值</strong></p><p>显然,它要么维持<code>dp[j]</code>,要么则取<code>dp[j-weights[i]] + values[i]</code>,表示为容量为j-weights[i]的背包所能获得的最大价值加上第i件物品的价值;</p><p>由此得出<strong>转移方程:<code>dp[j] = max(dp[j],dp[j-weights[i]] + values[i]);</code></strong></p><p><strong>初值选取跟二维的一样</strong></p><p>遍历顺序,在二维dp中,我们的背包容量是正序遍历(从小到大),但是如果这里从小到大遍历,则会存在小容量背包先更新,后面大容量背包更新时则会用到更新后的小容量背包的值,即物品被重复取了</p><p>因此它得<strong>倒序遍历</strong>,即<strong>从大到小遍历</strong>,这样<strong>大容量的背包用到的是上一个状态的小容量背包</strong></p><p>同时<strong>两个for循环也得是先物品再容量,把一个物品正确放入后,再滑到下个物品</strong>,若是先容量再物品,则存在大容量背包会取到价值最高且能放入的一个物品,因为小容量背包的状态没有更新,所以它只会取能放入自己背包的最大价值的单个物品</p><p>模板代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;  <span class="hljs-comment">// 物品对应的权重</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>&#125;;  <span class="hljs-comment">// 物品对应的价值</span><br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;<span class="hljs-comment">// 背包容量</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 01bag problem,1-dimension</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= <span class="hljs-number">0</span>; j--)<br>&#123;<br><span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>&#125;<br>&#125;<br>cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h5><p>在01背包的基础上,<strong>允许重复取</strong>,也就是对于一维的01背包dp而言,<strong>正序遍历</strong>,则此时<strong>小容量的背包先更新,大容量的背包后更新,会用到更新后的小容量背包,恰好是满足无限次取(重复取),求得最大价值</strong></p><p>它的<strong>两个for的遍历顺序则无所谓,都可以了</strong></p><p>模板代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/09/18/yCZi7WxrEN2SsnJ.png" alt="package change" /></p><h4 id="最长公共子序列lcs"><a class="markdownIt-Anchor" href="#最长公共子序列lcs"></a> 最长公共子序列(LCS)</h4><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></li></ul><h4 id="最长递增子序列lis"><a class="markdownIt-Anchor" href="#最长递增子序列lis"></a> 最长递增子序列(LIS)</h4><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li></ul><h4 id="树状dp"><a class="markdownIt-Anchor" href="#树状dp"></a> 树状DP</h4><p><strong>树具有天然的递归性,树的问题可以拆分到树的左子树和树的右子树,这种天然的子问题的特性,很容易让我们代入DP的思想</strong></p><ul><li><p><strong>树的直径</strong></p><p>树的直径是一类DP题目(后序遍历),<strong>可以从二叉树推广到一般树</strong></p><p>比如你求一个树的直径(有些以边定义,有些以点定义,<u>此处以543题为例,以边定义</u>),其实就是<strong>求它的左子树的最大链和右子树的最大链,再加上左右子树与当前根节点的两条边,则为此根节点的直径</strong></p><p><strong>向上更新的话则更新的是链</strong>,什么意思呢?就是<strong>更新这个节点所在的链的最大值,就是左子链和右子链找到一个最大的+1,向上更新即为此节点的最大链</strong>(链是用来计算直径的!)</p></li><li></li><li></li></ul><p>典型例题:</p><ul><li><strong>树的直径</strong><ul><li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></li><li><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">2246. 相邻字符不同的最长路径</a></li><li><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></li></ul></li></ul><h4 id="状态机dp"><a class="markdownIt-Anchor" href="#状态机dp"></a> 状态机DP</h4><p>状态机DP,即通过<strong>状态机</strong>来清晰地描述一些状态转换关系,因为这些关系可能比较多,比较复杂,用状态机可以更好地描述</p><p>这里的典型例题是股票系列的题目,可以分为无限次交易和至多k次交易两种情况:</p><ul><li><p>以122题为例子,它代表了<strong>无限次交易</strong>的情形<br />我们可以从最后一天考虑,dfs(n-1)表示到最后一天的最大利润,它是由dfs(n-2)和到第n-1天的利润决定的,那么第n-1天的利润有买入/卖出/什么也不做,而这个买入卖出又依赖于前面的,因此需要增设1个状态用以表示现在是持有股票还是未持有股票,因此可以用状态机进行表示!见下图:</p><img src="https://s2.loli.net/2024/10/05/TFOilYVa1yLGPrz.png" alt="statusDP-unlimited sell" style="zoom:67%;" /><ul><li><strong><code>dfs(i,0)</code>表示到第i天不持有股票最大利润;</strong></li><li><strong><code>dfs(i,1)</code>表示到第i天持有股票的最大利润;</strong></li></ul><p>这两个状态可以什么都不做,或发生买入/卖出,得出以下的<strong>状态转移方程</strong>:</p><ul><li><strong><code>dfs(i,0) = max(dfs(i-1,0),dfs(i-1,1)+prices[i]); // 第i天卖出</code></strong></li><li><strong><code>dfs(i,1) = max(dfs(i-1,1),dfs(i-1,0)-prices[i]); // 第i天买入</code></strong></li></ul><p><strong>递归边界</strong>是i&lt;0:</p><ul><li>若是未持有股票,则返回0;</li><li>若是持有股票,则是非法的状态,返回INT_MIN</li></ul><p><strong>递归入口</strong>:<br />显然最后肯定不可能自己还藏一股股票,肯定卖出去利润更大,因此是<code>dfs(n-1,0)</code></p></li><li><p>以123,188题为例子,它代表了另一类,<strong>至多交易k次</strong>:<br />需要<strong>加多一个状态用以表示至多允许进行j次交易</strong>,因此状态修改为:</p><img src="https://s2.loli.net/2024/10/05/K69fzbjt7yrANoG.png" alt="statusDP-mostlyKth sell" style="zoom:67%;" /><ul><li><strong><code>dfs(i,j,0)</code>表示至多允许j次交易,到第i天未持有股票的最大利润;</strong></li><li><strong><code>dfs(i,j,1)</code>表示至多允许j次交易,到第i天持有股票的最大利润;</strong></li></ul><p><strong>状态转移方程</strong>也跟上面的差不多,但是需要注意,因为限制了至多允许的交易次数,买入卖出算一次交易,因此我们可以在买入的时候修改交易次数:<br /><code>dfs(i,j,1) = max(dfs(i-1,j,1),dfs(i-1,j-1,0)-prices[i]);</code><br /><strong>递归入口</strong>一致,只是增加了个维度<br /><strong>递归边界</strong>多了个j&lt;0,直接return INT_MIN即可,因为至多允许负数次交易,一听就很非法状态</p></li></ul><p>需要注意,这类问题加上记忆化搜索一般维度比较多,要细细做;若是翻译成递推形式,更要注意塞入头部的状态,以及从而影响到的初始值(对应递归边界)和答案(对应递归入口)的空间开辟的大小</p><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></li><li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li></ul><h4 id="区间dp"><a class="markdownIt-Anchor" href="#区间dp"></a> 区间DP</h4><h4 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h4><p>模板如下,此模板可以用于求方案数(这里是对着2376题写的),此类型的变形题可以在此模板上进行修改得到,详细内容见代码及注释:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  子问题被表示成&quot;在第i位及其之后,在集合为mask情况下的方案数&quot;</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  is_limit用于标识当前第i位的上限,比如123,i=1表示第2位，如果is_limit是true则说明前1位选了1，那么你上限up就是2;否则是9.用此标志位规定每一位的选数的上限</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  is_num用于标识前面的数据是否选了,如果没选则为false.以123为例,如果第一位和第二位都是false,则表示第三位是: _ _ ? 在这样的情况下选的话,选的值是从1开始选的.用此标志位是为了规避前导零</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  mask是集合的体现,主要是通过位运算体现的:mask = &#123;0,0,0,0,0,0,0,0,0,0&#125;</span><br><span class="hljs-comment">  - 当0被选了,则mask=&#123;0,0,0,0,0,0,0,0,0,1&#125;,转换为二进制的形式:0000000001(b),转换成十进制:1==1&lt;&lt;0</span><br><span class="hljs-comment">  - 当9被选了,则mask=&#123;1,0,0,0,0,0,0,0,0,0&#125;,转换为二进制的形式:1000000000(b),转换成十进制:512==1&lt;&lt;9</span><br><span class="hljs-comment">  因此可以通过判断`mask&gt;&gt;d &amp; 1 ==0 (d∈[0,9])`来判断某一数位是否已经在集合中了,为0则表示不在,通过`mask | 1&lt;&lt;d`来使得某一个数位加入集合中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; dfs,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> mask,<span class="hljs-keyword">bool</span> is_limit,<span class="hljs-keyword">bool</span> is_num)&#123;<br><span class="hljs-keyword">if</span>(i == m)&#123;<span class="hljs-comment">// m是题目所给数据的总位数    </span><br><span class="hljs-keyword">return</span> is_num;<br>    &#125;<br>    <br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  res =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!is_num)&#123;<br>        res = <span class="hljs-built_in">dfs</span>(dfs,i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> up = is_limit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;<span class="hljs-comment">// 当前第i位取数的上限</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = is_num ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; d&lt;=up ; d++)&#123;<br>        <span class="hljs-keyword">if</span>( (mask &gt;&gt; d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>            res += <span class="hljs-built_in">dfs</span>(dfs,i+<span class="hljs-number">1</span>,mask | <span class="hljs-number">1</span>&lt;&lt;d, is_limit&amp;&amp;d==up, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这种类型的题目加上记忆化搜索的话,需要注意,并不一定所有状态都要用上,就比如这一题,它的is_limit状态其实只会走一遍,is_num即前面所选数字为空也只会走一遍,因此只需要记忆:memo[i][mask]的状态即可!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></li><li><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></li><li><a href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></li></ul><h3 id="多路归并"><a class="markdownIt-Anchor" href="#多路归并"></a> 多路归并</h3><p>以丑数Ⅱ来说,所构造的丑数序列中的数,都是从2,3,5的倍数中变幻出来的,即:丑数序列:<code>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...]</code>中的数是:</p><ul><li>丑数序列中的数是2的倍数<code>1*2,2*2,3*2,4*2,5*2,...</code></li><li>丑数序列中的数是3的倍数<code>1*3,2*3,3*3,4*3,5*3,...</code></li><li>丑数序列中的数是5的倍数<code>1*5,2*5,3*5,4*5,5*5,...</code></li></ul><p><strong>是上面这三条路径经过一定规则的归并从而获得了丑数序列</strong>,针对于这道题的规则,即是丑数序列是按照升序的规则进行排列的,因此从三条路径中取数要每次取最小的,取完了这个数,你就滑到丑数序列的下一位,继续滑到该路径的最前面,跟另外两条路经的最前面的数进行对比</p><p>这里的意思就是:比如丑数序列初始化为:[1]对于三条路径是:</p><ul><li><code>1*2</code>; (这里的1是通过指向丑数序列第0位的索引得到的)</li><li><code>1*3</code></li><li><code>1*5</code></li></ul><p>找出最小的放入丑数序列并滑动,则变为:<code>[1,2]</code></p><ul><li><code>2*2</code>(滑动到丑数序列的下一位索引1,对应丑数是2)</li><li><code>1*3</code> (上次的数你不是最小的,你没滑动,保持原样)</li><li><code>1*5</code></li></ul><p>而针对于比如373题这种两个数组<code>nums1</code>和<code>nums2</code>,比如<code>nums1</code>是m,<code>nums2</code>是n,从俩数组对应的组合出m*n个数,从这里取第k个最小的,而<code>nums1</code>,<code>nums2</code>又是升序排列的,显然这些个数可以看作是m条路径,每个路径首先取自己的数(就是<code>nums1</code>对应的)和<code>nums2</code>的第0位;然后依据规则:取最小的,而后弹出最小的数,最小的数后面的数顶上来,假设当前最小的数是第i条路径产生的,则下一个数就是第i条路径的[i,1];由此取数即可</p><p>当然后面这个题目相对于丑数Ⅱ的题目而言不是固定的路径数,因此不可以通过具体的多少个指针来滑动,可以结合优先队列一起做~</p><p>综上,个人总结的多路归并是:<strong>题目所要求的结果可以通过多条路径经过一定规则的归并而获得某一个具体的序列,序列中的某个数,是题目所求的</strong>,则可以采用多路归并+优先队列的思想来做</p><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数Ⅱ</a></li><li><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的k对数字</a></li><li><a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786.第k个最小的质数分数</a></li><li>23 合并K个升序链表</li></ul><h3 id="dijkstra-单源最短距离"><a class="markdownIt-Anchor" href="#dijkstra-单源最短距离"></a> dijkstra-单源最短距离</h3><p>dijkstra算法是用与寻求单个源点到所有顶点的最短路径,或者说是最短耗时(因题而异,但是都是求最短的~)</p><p>这里提供一种利用优先队列来使用dj算法的模板,其中,dj算法如果只用求最短路径,就只需要</p><ul><li><strong><code>adjacency</code></strong> 邻接矩阵</li><li><strong><code>dist</code></strong> 用以表示<strong>源点到所有顶点的最短距离</strong>的数组</li><li><strong><code>pq</code></strong> 优先队列,一般求最短最少一类的,用的是<code>greater&lt;&gt;</code>这个比较类型,即小顶堆,一般的参数类型选用<code>pair&lt;int,int&gt;</code>,<strong>first是最短距离,second表示的是某一个结点</strong></li></ul><p>当需要打印出源点到某一点的最短距离所经过的点时,可以借助</p><ul><li><strong><code>prev</code></strong> 数组,用于统计每个节点的前序节点</li></ul><p>以下是很粗糙的模板(<mark>后续看需不需要改一下</mark>):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// start表示起始点; n表示顶点个数; paths表示边的关系,内含&lt;u,v&gt;=w;</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n,INT_MAX)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;paths.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">auto</span> vec = paths[i];<br>    <span class="hljs-keyword">int</span> u = vec[<span class="hljs-number">0</span>], v = vec[<span class="hljs-number">1</span>], w = vec[<span class="hljs-number">2</span>];<br>    adjacency[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>&#125;<br>dist[start]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,start&#125;); <span class="hljs-comment">// 表示从start到start最短距离是0</span><br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-keyword">auto</span> [cost,u] = pq.<span class="hljs-built_in">top</span>();<br>    pq.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(cost&gt;dist[u])<br>        <span class="hljs-keyword">continue</span>;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-keyword">auto</span>&amp; [v,w]:adjacency[u])&#123;<br>        <span class="hljs-keyword">int</span> newCost = cost + w;<br>        <span class="hljs-keyword">if</span>(newCost&lt;dist[v])&#123;<br>            dist[v] = newCost;<br>            pq.<span class="hljs-built_in">push</span>(&#123;newCost,v&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至此就得到了一个从start到所有顶点的最短路径dist数组~</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>网络上可能还充斥着另外一种写法,就是把优先队列替换成一个<code>visited</code>数组用以显示尚未处理过的节点,其实visited结合dist就是<strong>寻求尚未处理过且当前最短距离的点</strong></p><p>而优先队列本质上就隐含这一种关系:出队的是最短距离的点,如果是处理过的点,则会看是不是最小的,因为有可能先入队的并不是最短的,后续更新时一个更短的入了队,则同时它也会更早的出队,更新邻接的点的最短距离,则处理过的点存在不一定是最短距离的情况,就是    <code>auto [cost,node] = pq.top();pq.pop(); if(cost&gt;dist[node]) continue;</code>所以由于这一条件语句的设定,实际上pq寻求的也是没处理过的最短距离的点,因此visited和pq这俩二选一就好,但是用pq更方便~</p>          </div><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/network-delay-time/description/">743 网络延迟时间</a></li><li><a href="https://leetcode.cn/problems/path-with-maximum-probability/description/">1514 概率最大的路径</a></li><li><a href="https://leetcode.cn/problems/DFPeFJ/description/">LCP35 电动车游城市</a></li><li><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">2290. 到达角落需要移除障碍物的最小数目</a> <em>可特化为01BFS</em></li><li><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a> <em>可特化为01BFS</em></li><li><a href="https://leetcode.cn/problems/find-a-safe-walk-through-a-grid/">3286. 穿越网格图的安全路径</a> <em>可特化为01BFS</em></li></ul><h3 id="floyd-多源最短距离"><a class="markdownIt-Anchor" href="#floyd-多源最短距离"></a> floyd-多源最短距离</h3><p>构建一个矩阵<code>vector&lt;vector&lt;int&gt;&gt; adjacency(n,vector&lt;int&gt;(n,INF))</code>(大概长这样,一开始假设都不可达,就是INF远嘛),通过已有的距离更新这个阵(就是直接相邻的点,邻接点嘛),然后利用松弛的思想,就是<code>a-&gt;c</code>顶点a到顶点c的距离,可能是这样最近,也可能是<code>a-&gt;b-&gt;c</code>,先途径顶点b再到达顶点c会更快,通过一个min即可比较出来,如何进行n个点的松弛呢</p><p>对一个二维阵操作,需要两重for,再进行n个点的松弛,显然需要套多一层循环,即三重循环可以完成</p><p>模板如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            adjacency[i][j] = <span class="hljs-built_in">min</span>(adjacency[i][j],adjacency[i][k] + adjacency[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>典型例题</p><ul><li><a href="https://leetcode.cn/problems/evaluate-division/description/">399 除法求值</a></li></ul><h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3><p>并查集它的名字指示了它的功能:支持合并(union)以及查找(find)功能的集合</p><p>集合用树来表示,许多集合即许多树构成了森林.当然如果真的整个树形结构蛮麻烦的,因此都是转成数组来处理</p><p>我们可以对这些集合中的元素进行如下操作:</p><ul><li>该元素所属的集合(即这个元素所属哪一棵树,树用其根来代表);</li><li>查看两个元素是否属于一个集合(这俩元素是否是一棵树上,即根节点是否相同);</li><li>合并两个集合(让其中一棵树的根节点指向另一棵树的根节点);</li></ul><p>主要思想:通过一个数组<code>vector&lt;int&gt; parent</code>来使得数组中的元素指向它们所属树的父节点,一开始的时候各自以自己为父节点,且只有自己这个节点,此时父节点等于元素本身,即体现了它是根节点.通过:<code>iota(parent.begin(),parent.end(),0);</code>初始化,然后通过模板下的<code>_union</code>操作可以使得两棵树合并成一棵树,这时会找到某一元素的根节点,修改该元素所属父节点的指向,则此时<code>parent[rootx]</code>这棵树就指向了以<code>rooty</code>为根的树,如此操作可以使得想合并的元素给它弄到一颗树上.树的总数则可以通过遍历<code>parent</code>数组,利用<code>x==parent[x]</code>则<code>cnt++;</code>来统计树的总数</p><p>因为存在层数/节点数目太多导致效率变低,可以借助如<code>vector&lt;int&gt; size</code>或是<code>vector&lt;int&gt; rank</code>来处理:</p><ul><li><code>vector&lt;int&gt; size(n,1);</code>表示以<code>i</code>为根节点的<code>size[i]</code>的元素个数,更新(unite)的时候让元素少的挂在元素多的根节点上,同时把元素少的根节点的元素吃掉;</li><li><code>vector&lt;int&gt; rank(n,1);</code>表示以<code>i</code>为根节点的<code>rank[i]</code>的深度,更新(unite)的时候让深度小的挂在深度大的根节点上,如果深度相等,则深度需要+1;</li><li><code>int setCount;</code>初始化为n,表示有n个集合,合并的时候setCount自减,该变量用来表示这个并查集里的连通分量的个数;</li></ul><p>模板如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unionFindSet</span>&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> n;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unionFindSet</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n))&#123;<br>        <span class="hljs-comment">// 初始化,使得每个节点以自己为根节点</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])&#123;<br>parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<span class="hljs-comment">// 这里做了路径压缩,在查找的时候会修改元素的父节点,使得元素的父节点直接指向根节点,把树的高度尽量控制在2   </span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">//  不含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">no_compress_find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(x!=parent[x])&#123;<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<span class="hljs-comment">// 这里没有做路径压缩,直接返回根节点</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span>(rootx == rooty)<br>           <span class="hljs-keyword">return</span>;<br>        parent[rootx] = rooty;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 路径压缩的和无路径压缩的别写混了,写混了可能出现TLE,比如路径压缩那个分支条件给弄成了while,就不对了</p>          </div><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/number-of-provinces/description/">547.省份数量</a></li><li><a href="https://leetcode.cn/problems/redundant-connection/description/">684.冗余连接</a></li></ul><h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3><p><strong>单调栈就是具备单调性的栈</strong>即栈内元素:</p><ul><li>从栈底到栈顶呈现单调递增性的则是单调递增栈;</li><li>从栈底到栈顶呈现单调递减性的则是单调递减栈;</li></ul><p><strong>一般求解题目,可以转换为求解下一个更大元素,则可以利用上单调栈的方法</strong></p><p>那栈内存放的是元素的值吗?一般来说根据题目具体目的而定,但通常存放的是值对应的索引,因为索引包含的信息更多,比如可以求出下一个更大元素和本元素之间的索引差,乃至是最大宽度.</p><p>需要注意,我们这里的单调性体现在的是值上,而存在栈中的一般是索引~</p><p>而且单调栈的写法还分为从左到右以及从右到左,这里的左和右指的是遍历的顺序:</p><ul><li><strong>从左到右,栈内的元素还没有寻求到下一个更大元素,通过在出栈时寻求到最大元素,出栈也维护了栈内的单调性;</strong></li><li><strong>从右到左,栈内的元素是候选项,是当前索引到的元素的最大元素的候选项,通过出栈来维护栈内的单调性,通过栈内非空的判断来确定当前元素的最大元素;</strong></li></ul><p>经典模板:</p><p>从左到右:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* nums是题目输入的数据,是一个vector&lt;int&gt;的datatpye */</span><br>stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 初值根据题目而定</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">// 维持栈内单调性,并且进循环帮助栈顶元素找到下一个&quot;更大&quot;元素</span><br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断以维持栈内需要的单调性)&#123;<br>        <span class="hljs-keyword">int</span> idx = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans[idx] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) // 某些情况下需要的条件判断 */</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>从右到左:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br> <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断,以维持栈内需要的单调性)&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-comment">/*某些情况下需要一定的题目条件*/</span>)&#123;<br>        ans[i] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) 某些情况下需要的条件判断*/</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>一些小技巧:</p><ul><li>在需要的时候,可以通过前后补0来避免一些corner case的编写,如84题</li></ul><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/next-greater-element-i/description/">496 下一个更大元素Ⅰ</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">503 下一个更大元素Ⅱ</a></li><li><a href="https://leetcode.cn/problems/daily-temperatures/description/">739 每日温度</a></li><li><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84 柱状图中最大的矩形</a></li><li><a href="https://leetcode.cn/problems/maximal-rectangle/description/">85 最大矩形</a></li></ul><h3 id="最小生成树minimal-spanning-tree"><a class="markdownIt-Anchor" href="#最小生成树minimal-spanning-tree"></a> 最小生成树(Minimal  Spanning  Tree)</h3><p><strong>当我们需要连接一个图中所有顶点并使得总路径开销最小时，可以使用最小生成树算法</strong></p><p>普通的图可能会存在环，而树不会存在，所谓的生成树，就是将图中的顶点集弄成一个连通分量，像树一样，不会有环；而最小生成树，则是生成树中，代价最小的，所谓代价可以理解为权重和,即找出权重和最小的生成树</p><p>有两种算法可以用来解决此类问题,一个是prim算法,一个是kruskal算法;</p><h4 id="prim"><a class="markdownIt-Anchor" href="#prim"></a> prim</h4><p>从点集的角度出发,要把原来属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的顶点全部移到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就完成了prim算法,初始的时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是所有的点的点集,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是个空集,这个点什么时候从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>呢?初始化的时候随机选一个点移入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的点到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的点的最短距离的向量,从其中选择到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最短权重/代价最少的点进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后更新这个距离向量,重复这个过程,直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空;</p><p>具体做法:创建好邻接矩阵<code>adjacency</code>,并且初始化好距离数组<code>vector&lt;int&gt; dist(n,INT_MAX);</code>,以及一个是否访问过的标志位数组<code>visited</code>,还有一个<code>vector&lt;int&gt; vertexNew;</code>用以记录新集合的节点数目,由这四者通过一个二重循环去<strong>更新距离</strong>,找到<strong>最近的点</strong>,<strong>打下标记</strong>,直至新集合的节点数目为<code>n</code>则说明算法完成~</p><p><mark>此算法只用过1次,模板不好总结</mark></p><h4 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> kruskal</h4><p>从边集的角度出发,这种方法无需创建邻接矩阵,直接用<code>vector&lt;vector&lt;int&gt;&gt;</code>或是<code>vector&lt;Edge&gt;</code>来把所有的边信息存起来,边的信息有啥呢,就像下方结构体所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>  <span class="hljs-keyword">int</span> x,y;<br>  <span class="hljs-keyword">int</span> weight;<br>  <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>  <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> _x,<span class="hljs-keyword">int</span> _y):<span class="hljs-built_in">x</span>(_x),<span class="hljs-built_in">y</span>(_y)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上所示,两个端点,一个权重/长度(曼哈顿距离/欧式距离,具体依题意而定),构成了一条边,然后对边按照<code>weight</code>进行升序排序,挑选两个不同源(即所属根不同,也就是不同的连通分量)的点进行unite,然后把权重累加到<code>ans</code>(存储权重和的变量),如此进行,借助并查集的unite功能,合并不同的连通分量,直至得到一颗最小生成树~</p><p>代码模板:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// 节点数目</span><br>    <span class="hljs-keyword">int</span> setCount; <span class="hljs-comment">//  连通分量数目</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <br>    <span class="hljs-built_in">UnionFindSet</span>(n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">setCount</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n)),<span class="hljs-built_in">size</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>       <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> x2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> root1 = <span class="hljs-built_in">find</span>(x1);<br>        <span class="hljs-keyword">int</span> root2 = <span class="hljs-built_in">find</span>(x2);<br>        <span class="hljs-keyword">if</span>(root1==root2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 同源</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(root1)&lt;<span class="hljs-built_in">size</span>(root2))&#123;<br>            <span class="hljs-built_in">swap</span>(root1,root2);<br>        &#125;<br>        size[root1] += size[root2];<br>        parent[root2] = root1;<br>        setCount--;<span class="hljs-comment">// 合并了,连通分量-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,weight;<br>    <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> weight):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y),<span class="hljs-built_in">weight</span>(weight)&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br>   <span class="hljs-comment">// n是节点数目,points是其中的关系,包括(x1,x2)以及它们之间的weight</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mst_kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; points)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = points.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 这是边数的意思</span><br>        <span class="hljs-function">vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-comment">// 遍历points,填充边集edges</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:points)&#123;<br>            edges.<span class="hljs-built_in">push_back</span>(&#123;p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 边集排序,依据权重升序排序</span><br>        <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(),edges.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>            <span class="hljs-keyword">return</span> e1.len &lt; e2.len;<br>        &#125;);<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-function">UnionFindSet <span class="hljs-title">ufs</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">int</span> minVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:edges)&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">unite</span>(e.x,e.y))&#123;<br>                minVal+=e.len;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ufs.setCount==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 只有一个连通分量则跳出</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>典型例题:</p><ul><li><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584 连接所有点的最小费用</a></li><li><a href="https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/">1489 找到最小生成树里的关键边和伪关键边</a></li></ul><h3 id="st表"><a class="markdownIt-Anchor" href="#st表"></a> ※ST表</h3><p><strong>ST表(Sparse Table)可以用于解决RMQ(Range Maximum/Minimum Query)问题</strong>(就是区间最大最小值查询),<strong>当你需要对区间快速的进行最大最小值查询的时候,就可以用到这个数据结构</strong></p><div class="note note-info">            <p>注:ST表不修改原数组信息,只负责查询区间的最大最小值</p>          </div><p>这个数据结构的构建总共分为两个步骤:</p><ul><li><strong>预处理</strong> O(nlogn);</li><li><strong>查询</strong> O(1);</li></ul><p>在具体说之前,先说下这个算法的特色:</p><p>算法采用<strong>倍增</strong>思想:<strong><code>f[i][j]</code>表示<code>[i,i+2^j-1]</code>这么一个区间</strong>.啥意思呢,为啥区间长这样😲?**实际上就是以i作为区间起点,区间长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>**的意思~</p><ul><li><p><strong>预处理</strong></p><ul><li><p><strong>初始化</strong>:<code>f[i][0]=...;</code>此时表示的区间是<code>[i,i]</code>,也即是给第i个元素赋值,显然如果有N个元素,那么这个二维数组的首个维度就要开到N;</p></li><li><p><strong>确定边界范围</strong>: N个元素,f的第二个维度表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>,即当前区间有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>个元素,即显然存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup><mo>&lt;</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2^j &lt;= N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.863764em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>,取对数就有:<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j&lt;=floor(log2(N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></strong></p></li><li><p><strong>状态转移方程</strong>:(这不是DP的东东吗,实际上就是个递推的关系式)</p><p><strong><code>f[i][j] = max(f[i][j-1],f[i+2^(j-1)][j-1])</code></strong> (怎么这么复杂?<strong>实际上就是把一个区间[i,i+2^j-1]分成两半</strong>(两个区间)取max).</p><p>同时,通过<em>状态转移方程</em>和<em>边界范围</em>不难知道,我们每个起点元素<code>i</code>也对应不同的<code>j</code>,即:<strong><code>i+2^j-1&lt;=N</code></strong>;</p><p>那么在实施状态状态方程的时候,这个二维数组应该先遍历i还是j呢?应当<strong>先遍历j,内部遍历i</strong>,因为我们是一个一个小区间取max,这样合并到<code>f[i][j]</code>这样一个大区间,然后区间内部的元素再扩增(指j变化),这个过程就像是归并排序里分而治之最后一个一个小区间往上合并的过程~</p></li></ul></li><li><p><strong>查询</strong></p><p>查询区间是<code>[l,r]</code>;</p><p>计算出k:  <code>k=log2(r-l+1); //这里区间是[l,r]</code>,这个k实际上用log2给它缩回去,后面用作f的第二维度来用嘛,表示一个区间的元素的个数;</p><p><code>f[l][k]</code> 和<code>f[r-2^k+1][k]</code>,对它俩取max,即: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(f[l][k],f[r-2^k+1][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>,就可以求出区间<code>[l,r]</code>的最大值了</p></li></ul><div class="note note-info">            <p>注: 为啥max右边那个左端点是这个长长的式子呢?可以这样想<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">x+2^k-1 = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>,则求出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">x=r+1-2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>,因为<code>f</code>的第一个维度是区间起始端点,计算好了这个端点,第二维度选k(表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>个元素),即可以从左端点到右端点r,中间有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le r-l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>zh这么多个元素</p><p>显然这样的max的两个区间,中间是存在重叠的,但因为是求max,所以无所谓~</p>          </div><p><strong>算法模板</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<span class="hljs-comment">// 表示元素个数</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">31</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 第一个维度开元素个数这么多个,考虑有些题目的index_base是1而不是0,加多了1位,下面按照index_base=1的开始计算;</span><br>       <span class="hljs-comment">// 第二个维度可以用范围算出来,比如元素个数上限是10e9,则一个区间的上限就按这个来   // 算,j即为31,2^31是</span><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; f[i][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// 边界范围</span><br><span class="hljs-keyword">int</span> jRight = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">log2</span>(n));<br><span class="hljs-comment">// 预处理</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=jRight;j++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>        f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询[l,r]区间的最大值</span><br><span class="hljs-keyword">int</span> l,r;<br>cin &gt;&gt; l &gt;&gt; r;<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> mx = <span class="hljs-built_in">max</span>(f[l][k],f[r+<span class="hljs-number">1</span>-(<span class="hljs-number">1</span>&lt;&lt;k)][k]);<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure><p><strong>参考文件</strong></p><ul><li><a href="https://oi-wiki.org/ds/sparse-table/">OI-WIKI-ST表</a></li><li><a href="https://www.cnblogs.com/zwfymqz/p/8581995.html">浅谈ST表</a></li><li><a href="https://www.luogu.com.cn/article/61z2lumk">[模板]ST表图解</a></li></ul><p><strong>典型例题</strong></p><ul><li><a href="https://www.luogu.com.cn/problem/P3865">P3865</a></li></ul><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><p><strong>线段树(Segment Tree)是一种数据结构,它可以以<code>O(logn)</code>的时间复杂度,进行<u>区间修改</u>和<u>区间查询</u></strong>,是一般CSP考试中末尾两题或是leetcode周赛的题目中常见的数据结构</p><p>它的本质是树,但是构建一棵树来管理也太复杂了,因此简化成<strong>利用数组来管理一棵完全二叉树</strong>,在根节点的索引为1的时候,左子树的根节点为其2倍,右子树的根节点为其2倍再加1;(有的人喜欢写成<code>p&lt;&lt;1</code>和<code>p&lt;&lt;1|1</code>,其中<code>p</code>是父节点的索引)</p><p><strong>这一棵树<code>vector&lt;T&gt; tree</code>中的每一个元素代表的是一个范围内的数据的某一种信息,比如值的累和,最大最小值,众数等;</strong><mark>具体根据题意而定</mark></p><p>考虑到区间修改的时候,如果频繁的递归进行修改,很耗费时间的,因此有个<strong>懒惰标记</strong>,来延迟修改,这个过程被精简为一个函数:<strong><code>push_down()</code>意思是下放懒惰标记</strong>,同时<strong>在区间修改的末尾,需要向上更新(父节点)区间信息,因此对称地有:<code>push_up()</code>函数</strong></p><p>一棵线段树的构建过程分为:</p><ul><li>初始化+建树;</li><li>区间查询;</li><li>区间修改;</li><li><code>push_up()</code>和<code>push_down()</code>;</li></ul><p>模板如下(提供的是区间和的,具体求区间的啥信息,根据题意灵活处理~):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">int</span> n,n4;<span class="hljs-comment">// n是给定的数组的元素大小,开空间要开到4倍,如果不想浪费空间可以动态开点,具体看参考文件的内容</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tree,lazy;<span class="hljs-comment">// tree是线段树,里面的值代表的是一个范围的所求信息,这里是区间和;lazy是懒惰标记</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt;* arr;<span class="hljs-comment">// 用于初始化;</span><br>    <span class="hljs-keyword">int</span> root,end;<span class="hljs-comment">// root表示起始检索的下标,这里选择1,这样左右子树都2*i,2*i+1,如果选择0,则各自还要加个1</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(vector&lt;<span class="hljs-keyword">int</span>&gt; a)&#123;<br>        n = a.<span class="hljs-built_in">size</span>();<br>        n4 = n&lt;&lt;<span class="hljs-number">2</span>;<br>        tree = vector&lt;<span class="hljs-keyword">int</span>&gt;(n4,<span class="hljs-number">0</span>);<br>        lazy = vector&lt;<span class="hljs-keyword">int</span>&gt;(n4,<span class="hljs-number">0</span>);<br>        arr = &amp;a;<br>        root =<span class="hljs-number">1</span>;<br>        end = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>,end,root);<br>        arr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 建树</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s==t)&#123;<span class="hljs-comment">// 叶子节点,装的是数组中的确切值</span><br>            tree[p] = (*arr)[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;  <span class="hljs-comment">// 为啥不直接相加除呢,遇到越界的数据就会老实这么写了</span><br>        <span class="hljs-built_in">build</span>(s,mid,p*<span class="hljs-number">2</span>);    <span class="hljs-comment">// [s,mid]区间</span><br>        <span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<span class="hljs-comment">// [mid+1,t]区间</span><br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br>    <span class="hljs-comment">// 向上更新</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        tree[p] = tree[p*<span class="hljs-number">2</span>] + tree[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 下放标记</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(!lazy[p] &amp;&amp; s!=t)&#123;<span class="hljs-comment">// s!=t是因为叶子节点没得下放,它也被人update过了</span><br>            tree[p*<span class="hljs-number">2</span>] += (mid-s+<span class="hljs-number">1</span>)*lazy[p];<br>            tree[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += (t-mid)*lazy[p];<br>            lazy[<span class="hljs-number">2</span>*p] += lazy[p];<br>            lazy[<span class="hljs-number">2</span>*p+<span class="hljs-number">1</span>] += lazy[p]; <br>            lazy[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 区间查询 所查询的区间是[l,r] 当前p节点所对应的区间是[s,t]</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(l&lt;=s &amp;&amp; r&gt;=t)&#123;<span class="hljs-comment">// [s,t]是[l,r]的一部分,直接返回tree[p]</span><br>           <span class="hljs-keyword">return</span> tree[p];<br>       &#125; <br>       <span class="hljs-comment">// 下放懒惰标记</span><br>       <span class="hljs-built_in">push_down</span>(s,t,p);<br>       <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<br>           sum+=<span class="hljs-built_in">range_query</span>(l,r,s,mid,p*<span class="hljs-number">2</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(r&gt;mid)&#123;<br>          sum+=<span class="hljs-built_in">range_query</span>(l,r,mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);    <br>       &#125;<br>   <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 区间修改,这里是区间和的累加</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;=s &amp;&amp; r&gt;=t)&#123;<br>            tree[p] += (t-s+<span class="hljs-number">1</span>)*val;<span class="hljs-comment">// 区间更新,求和嘛,那就是这个[s,t]区间的数都加个val</span><br>            lazy[p] += val;    <span class="hljs-comment">// 懒惰标记,表明它的修改还没有落实到左右子树,乃至更下方的节点</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 下放懒惰标记</span><br>        <span class="hljs-built_in">push_down</span>(s,t,p);<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<br>            <span class="hljs-built_in">range_add</span>(l,r,val,s,mid,p*<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&gt;mid)&#123;<br>            <span class="hljs-built_in">range_add</span>(l,r,val,mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 向上更新</span><br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 此类题目灵活性高,根据题意确定区间查询的值的类型,然后还可能需要附加别的算法知识进行题意处理,例题中首个题目是洛谷的模板题,但第二个题目是leetcode的题目,里面就结合了线段树和摩尔投票的算法思想来解决问题</p><p>同时,上面的模板也相对粗糙,比如你真正丢给外面的接口,应该是只有(l,r)或者(l,r,value)的接口</p>          </div><p><strong>参考文件:</strong></p><ul><li><a href="https://oi-wiki.org/ds/seg/">OI-WIKI-线段树</a></li></ul><p><strong>典型例题:</strong></p><ul><li><a href="https://www.luogu.com.cn/problem/P3372">P3372</a></li><li><a href="https://leetcode.cn/problems/online-majority-element-in-subarray/">1157. 子数组中占绝大多数的元素</a></li></ul><h2 id="排序系列"><a class="markdownIt-Anchor" href="#排序系列"></a> 排序系列</h2><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><p>一种<strong>选择算法</strong>,<strong>不稳定</strong>(相同值的元素的相对位置可能发生改变),<strong><code>O(nlogn)</code></strong></p><p><strong>堆排序步骤:</strong></p><ol><li><strong>构建大顶堆(升序排序)</strong></li><li><strong>根节点与末尾元素交换</strong></li><li><strong>在除去末尾元素的剩余元素中,重新下沉根节点,以构建大顶堆</strong></li></ol><p>重复以上步骤,直至整个序列有序</p><p>代码(给出的是小顶堆的构建,是降序):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 左孩子节点</span><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (child &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// 在两个孩子节点找最小的</span><br>        <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[child + <span class="hljs-number">1</span>] &lt; nums[child])<br>        &#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-comment">// 孩子节点中最小的那个比父节点还小,则这个更小的值要上浮到父节点</span><br>        <span class="hljs-keyword">if</span> (nums[child] &lt; nums[parent])<br>        &#123;<br>            <span class="hljs-comment">// swap(nums[child], nums[parent]);</span><br>            <span class="hljs-keyword">int</span> tmp = nums[child];<br>            nums[child] = nums[parent];<br>            nums[parent] = tmp;<br>            <span class="hljs-comment">// 检查孩子节点往下是不是满足小顶堆结构,因为值的上浮可能会破坏原有的小顶堆结构</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从最后一个非叶子节点开始,直至根节点;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">adjustDown</span>(nums, i, heapSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMinHeap</span>(nums, n);<br>    <span class="hljs-comment">// 交换首尾元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// swap(nums[0], nums[i]);</span><br>        <span class="hljs-keyword">int</span> tmp = nums[<span class="hljs-number">0</span>];<br>        nums[<span class="hljs-number">0</span>] = nums[i];<br>        nums[i] = tmp;<br>        <span class="hljs-comment">// 上面的交换破坏了根节点的堆结构,重新构建小顶堆</span><br>        <span class="hljs-built_in">adjustDown</span>(nums, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>大顶堆是一棵完全二叉树,每个节点的值都大于等于其左右孩子节点的值</strong>(反之小于等于的则是小顶堆,用于降序排列)</p><p><strong>完全二叉树第<code>i</code>个节点的</strong>(这里的**<code>i</code>是根据层序遍历得到的编号,从0开始**)<strong>左右孩子节点分别是<code>2*i+1</code><strong>和</strong><code>2*i+2</code></strong>(这是它的性质)</p><p>用数组表示,即有<code>arr[i] &gt;= arr[2*i+1]</code>和<code>arr[i] &gt;= arr[2*i+2]</code></p><p>也正因为完全二叉树的性质,所以整棵树可以通过简单的数组表示而非复杂的树结构</p><p>在构建堆结构的时候,我们要从最后一个非叶子节点开始,从右往左,从下往上(就是最后一个非叶子节点的编号自减1,直至根节点),对它和它的孩子节点实现交换以满足堆有序(大顶堆或小顶堆的父子节点的性质).而这个<strong>最后一个非叶子节点是通过整个数组的size除以2再减1得到(如果编号从0开始,则要-1;如果编号从1开始,则不用-1</strong>)</p>          </div><p>参考资料:<a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解堆排序</a></p><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p><strong>核心:分治算法</strong></p><p><strong>稳定的<code>O(nlogn)</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 左区间的左端点,右区间的左端点</span><br>    <span class="hljs-keyword">int</span> l = left, r = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = left;<br>    <span class="hljs-comment">// 构建一个临时数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right-left+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// l不大于左区间的右端点,r不大于右区间的右端点</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid &amp;&amp; r&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[l]&lt;nums[r])&#123;<br>            tmp[k++] = nums[l++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[r++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对区间剩余的数值搬到tmp上去</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid)&#123;<br>        tmp[k++] = nums[l++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r &lt;= right)&#123;<br>        tmp[k++] = nums[r++];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 把结果从临时数组搬运到nums中去</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=left; q&lt;=right; q++)&#123;<br>        nums[q] = tmp[q];<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">: nums - 待排序数组</span><br><span class="hljs-comment">: left - 区间左端点</span><br><span class="hljs-comment">: right - 区间右端点,即整个区间是[left,right]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">if</span>(left&gt;=right)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 这里是划分区间为更小的区间</span><br>    <span class="hljs-built_in">mergeSort</span>(nums,left,mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-comment">// 这里是区间合并</span><br>    <span class="hljs-built_in">merge</span>(nums,left,mid,right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p><strong>核心:左右指针+分治算法</strong></p><p><strong>交换排序中的一种,不稳定的<code>O(nlogn)</code></strong></p><p>思想:根据选定的基准(一般是最初确定左指针后,左指针指向的值),将数据分为大于基准的放在右侧,小于基准的放在左侧,然后对左侧和右侧的列表分别重复上述步骤(此刻即分治),最后直至整个序列有序.</p><p>快速排序步骤:</p><ol><li>确定当前的左右指针,并选择基准(注意:取得是基准的索引);</li><li>循环,先处理右指针,右指针一直自减,除非遇到小于基准的值(得&gt;=),则暂停处理右指针,开始处理左指针;左指针一直自增,除非遇到大于(得&lt;=,之所以=是得跳过基准,不然左指针指向的不符合的就一直是基准了)基准的值,则暂停处理左指针,此刻左右指针指向的是各自均错误的值,交换,继续循环,直至左指针不再小于右指针;</li><li>交换基准和左指针;</li><li>对未排序好的左右列表进行快排</li></ol><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// left是左指针,right是右指针+1,即整个区间是:[left,right)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 选定基准索引</span><br>    <span class="hljs-keyword">int</span> key = left;<br>    <span class="hljs-comment">// 确定左右指针</span><br>    <span class="hljs-keyword">int</span> l = left,r=right<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;= nums[key])<br>            r--;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt;= nums[key])<br>            l++;<br>        <span class="hljs-built_in">swap</span>(nums[l],nums[r]);<br>    &#125;<br>    <span class="hljs-comment">// 把基准交换到属于它的位置,此刻索引&lt;基准的是值&lt;=它的,索引&gt;基准的是值&gt;=它的</span><br>    <span class="hljs-built_in">swap</span>(nums[l],nums[key]);<br>    <span class="hljs-keyword">if</span>(l &gt; left)<br>        <span class="hljs-built_in">quickSort</span>(nums,left,l); <span class="hljs-comment">// [left,l),其中l是基准确定的位置</span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span> &lt; right)<br>        <span class="hljs-built_in">quickSort</span>(nums,l+<span class="hljs-number">1</span>,right); <span class="hljs-comment">// [l+1,right)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shell排序"><a class="markdownIt-Anchor" href="#shell排序"></a> shell排序</h3><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3><p>拓扑排序是用于有向无环图(下称DAG)来生成一个线性序列,这个序列满足:</p><ul><li>序列中的每个顶点有且仅出现一次</li><li>在图中如果存在u到v的一条路径,那么在序列中u一定出现在v之前</li></ul><p>对于拓扑排序,经典的应用问题是AOV图(Activity Of Vertex),用于给一个活动网络进行排序,以获取其执行的序列</p><p>对于拓扑排序,此处采用的是BFS算法进行实现: 通过邻接矩阵装载图信息,并构建一个入度列表,对入度列表中入度为0的点,push进队列,然后依次执行如下步骤:</p><ul><li>出队,放入toplo数组</li><li>根据邻接矩阵找到以它作为弧尾的点,对它们的入度-1</li><li>若有节点入度为0,则push进队列</li></ul><p>重复以上三个步骤,则当队列为空时,说明以拓扑排序完毕</p><p>需要注意:拓扑排序仅针对DAG图,同时也可以利用上述方法增加一些条件来检查有向图中是否有环(有环的节点,入度无法通过上述操作减为0,但队列会跳出,即意味着toplo数组中的节点数量肯定少于图中给出的节点数量,否则的话是相等的)</p><p>板子代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    B</span><br><span class="hljs-comment">  /  \ </span><br><span class="hljs-comment">A      D</span><br><span class="hljs-comment">  \  /</span><br><span class="hljs-comment">   C</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> vertexNum; <span class="hljs-comment">// 顶点数</span><br><span class="hljs-keyword">int</span> edgeNum;   <span class="hljs-comment">// 边数</span><br><span class="hljs-comment">// 4 4</span><br>cin &gt;&gt; vertexNum &gt;&gt; edgeNum;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(vertexNum); <span class="hljs-comment">// 邻接矩阵</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(vertexNum,<span class="hljs-number">0</span>)</span></span>;   <span class="hljs-comment">// 入度列表 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   A B</span><br><span class="hljs-comment">   A C</span><br><span class="hljs-comment">   B D</span><br><span class="hljs-comment">   C D</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edgeNum;i++)&#123;<br><span class="hljs-keyword">char</span> a,b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-keyword">int</span> A;<br><span class="hljs-keyword">int</span> B;<br>A = a - <span class="hljs-string">&#x27;A&#x27;</span>;<br>B = b - <span class="hljs-string">&#x27;A&#x27;</span>;<br>adjacency[A].<span class="hljs-built_in">push_back</span>(B);<span class="hljs-comment">// 记录有向图的边信息&lt;a,b&gt;</span><br>indegrees[B]++;   <span class="hljs-comment">// b的入度增加</span><br>&#125;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;  <span class="hljs-comment">// 将入度为零的点,即源点放入队列中</span><br><span class="hljs-keyword">if</span>(!indegrees[i])<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; toplo;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">// BFS</span><br><span class="hljs-keyword">int</span> pre = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>toplo.<span class="hljs-built_in">push_back</span>(pre);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:adjacency[pre])&#123;<br><span class="hljs-keyword">if</span>(--indegrees[i] == <span class="hljs-number">0</span>)<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125; <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:toplo)&#123;<br><span class="hljs-keyword">char</span> c = i + <span class="hljs-number">65</span>;<br>cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h2><h2 id="一些数据结构回顾"><a class="markdownIt-Anchor" href="#一些数据结构回顾"></a> 一些数据结构回顾</h2><h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3><p>二叉搜索树(BST)是二叉树的一个特别概念,可以理解为排了序的二叉树</p><p>左孩子 &lt;= 根节点 &lt;= 右孩子</p><p>详细可见<a href="https://ayyha.github.io/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/">BST,AVL,B,B+,RBT</a></p><h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile简易使用</title>
    <link href="/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>因为在linux上编译多个cpp文件时,需要分别<code>g++ -c</code>生成<code>.o</code>文件,然后将所需的<code>.o</code>文件一起链接以生成可执行文件,比较繁琐且冗余.因此需要使用到makefile工具来帮助我们进行多文件编译(甚至文件可以指定不同目录,更有利于工程项目管理),故有此篇文章</p><h2 id="linux下编译多个cpp的过程"><a class="markdownIt-Anchor" href="#linux下编译多个cpp的过程"></a> linux下编译多个cpp的过程</h2><p>在开始说makefile的一些基本语法前,先说一下在linux下编译多个cpp的过程</p><p>我们通常编译一个<code>.cpp</code>文件都是经过<strong>预处理</strong>---生成<code>.i</code>文件---&gt;<strong>编译</strong>---生成<code>.s</code>文件---&gt;<strong>汇编</strong>---生成<code>.o</code>文件---&gt;<strong>链接</strong>---&gt;生成可执行文件<code>.exe</code>,然后在执行的过程中,会被<strong>加载器</strong>将程序放置到内存上,并通过<strong>动态链接器</strong>链接<code>.dll</code>或<code>.so</code>动态库,以实现程序运行</p><div class="note note-info">            <p><strong>静态链接器</strong>(如<code>ld</code>)负责链接的是<code>.a</code>或<code>.lib</code>这些静态库,这些静态库是通过<code>ar</code>这个工具将多个<code>.o</code>文件构成的.静态链接是构建可执行文件时的最后一步.主要功能是<strong>符号解析</strong>(通过符号表找到.o文件的只声明无定义的函数的定义位置)和<strong>重定位</strong>(定位到虚拟地址(有OS的机子)/物理地址(裸机))</p><p><strong>动态链接器</strong>(如<code>ld-linux.so.2</code>)负责链接的是<code>.so</code>或<code>.dll</code>这些动态库或者叫共享库,要使用到这个工具的时候,我们的程序已经被加载器加载到内存上了,当我们遇到如<code>printf</code>这些动态库定义的函数时,会去检查内存中有没有加载对应的动态库(<a href="http://xn--libc-zi0i964s23c.so">这里是libc.so</a>),没有的话就加载到内存上,有得话就不用加载,取得该动态库在内存中的起始地址,然后我们编译过<code>printf</code>这个函数时,它的调用方式形如<code>call 0xaaaa </code>这样,这里的地址是相对于动态库的地址,因此由获得的动态库起始地址加这个偏移地址就可以得到<code>printf</code>在内存中的真正地址了.这一类库的生成是我们在利用<code>g++</code>编译时通过<code>-shared</code>选项实现的.</p><p>静态链接后的<code>exe</code>文件会包含别的<code>.o</code>文件(静态库)的代码,比较占地方,而动态链接的则没有算到<code>exe</code>文件里面去,毕竟它(动态库)只是在<code>exe</code>运行时动态加载到内存中去的,但是这个动态库要是没有,那就跑不起来,而静态链接的则没事,因为代码已经拷贝到<code>exe</code>里了</p>          </div><p>每个<code>.cpp</code>文件都可以单独用如下方式<code>g++ -c xx.c -o xx.o</code>生成<code>.o</code>形式的目标文件,该文件里的内容是机器码,但是这个文件不能被执行,因为存在两个问题:</p><ol><li>调用了别的<code>.cpp</code>文件定义的函数,但是我们只包含了该函数声明的.h文件:即在其中,<strong>只有符号的引用,而没有实际的定义,这里所说的符号即是函数,需要进行<u>符号解析</u></strong>;</li><li><strong>这里的地址是不对的,并不是实际运行的地址(虚拟地址/物理地址),而是一个标志,是逻辑地址,需要进行<u>重定位</strong></u></li></ol><p>我们这里着重讲第一点,比如我在<code>a.cpp</code>文件中调用了<code>hello()</code>,而只包含了头文件<code>hello.h</code>,而实际实现是在<code>hello.cpp</code>中,我们各自通过<code>g++ -c ...</code>编译得到<code>a.o hello.o</code>,<strong>其中<code>a.o</code>中所有关于<code>hello()</code>的函数调用,会跳到同一个地址,在该地址会<code>call hello</code></strong>,这个<code>call hello</code>的真正地址,需要在<code>hello.o</code>中获得</p><p>这些<code>.o</code>文件有自己的<strong>符号导入表</strong>和<strong>符号导出表</strong>,这些表对应的是<strong>符号---地址</strong>,因此这需要<strong>静态链接器</strong>去在<code>hello.o</code>的符号导出表找到<code>hello</code>这一项对应的地址,并作偏移(两个<code>.o</code>要合并,地址难免有冲突,因此需要偏移),然后写到<code>a.o</code>的符号导入表中<code>hello</code>那一项对应的地址中去,由此<code>call hello</code>这里的hello就可以找到对应的实际的地址了.</p><p>之后的重定位则是将逻辑地址换成实际运行的地址.</p><p><strong>实际上,链接这一过程,解决的就是上面所说的两个问题</strong>,因此,对于一个庞大的工程项目来说,我们可以保留需要的<code>.o</code>文件,然后若有部分cpp有修改,则将之重新编译为<code>.o</code>,没改的则不重新编译(因为对于一个大项目来说,编译的时间可能也很长),然后将所有需要的<code>.o</code>一起链接成一个可执行文件即可,这个过程若是手动管理,繁琐且复杂,还容易出错,因此需要一个工具来进行管理,由此便需要<strong>makefile</strong></p><h2 id="makefile基本语法"><a class="markdownIt-Anchor" href="#makefile基本语法"></a> makefile基本语法</h2><h3 id="makefile三要素"><a class="markdownIt-Anchor" href="#makefile三要素"></a> makefile三要素</h3><p>在makefile中有三要素:<strong>目标</strong>(target),<strong>依赖</strong>(prerequisite)和<strong>执行语句</strong>(recipe)</p><p><img src="https://s2.loli.net/2024/05/02/DJUrKgnVy1qAlY8.png" alt="makefile 3 element" /></p><p><strong>目标<code>main</code>的生成依靠于依赖<code>main.c</code>,当目标不存在或依赖被修改,则执行下方执行语句</strong></p><p>这三要素的描述原文如下(本文关于makefile的部分主要参考参考文件中的一篇blog,不过行文按自己的理解展开):</p><blockquote><p>A <em>target</em> is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see <a href="https://link.zhihu.com/?target=https%3A//www.gnu.org/software/make/manual/make.html%23Phony-Targets">Phony Targets</a>).<br />A <em>prerequisite</em> is a file that is used as input to create the target. A target often depends on several files.<br />A <em>recipe</em> is an action that <code>make</code> carries out. A recipe may have more than one command, either on the same line or each on its own line. <strong>Please note:</strong> you need to put a tab character at the beginning of every recipe line!</p></blockquote><h3 id="关于变量"><a class="markdownIt-Anchor" href="#关于变量"></a> 关于变量</h3><p>我们可以通过一些方式定义变量,变量可以使得我们的操作更加简洁,通过以下方式定义和<code>$(变量)</code>方式引用</p><h4 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h4><ul><li><p><strong>简单赋值</strong><code>:= </code> 与python中的<code>a=4</code>一样</p><p><code>SOURCE_DIR := .</code></p></li><li><p><strong>追加赋值</strong><code>+=</code> 与python中的<code>s = 'a'</code>,<code>s += 'b' #最终s为'ab'</code>,但是makefile中的追加赋值会自动用空格隔开两个值,显示为<code>a b</code></p><p><code>SOURCE_DIR += ./objects #结合上面的. 这里的SOURCE_DIR是. ./objects</code></p></li><li><p><strong>条件复制</strong><code>?=</code> 只在变量未定义时创建变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VAR ?= one<br><span class="hljs-comment"># VAR变量为one</span><br>VAR := two<br>VAR ?= one<br><span class="hljs-comment"># VAR变量为two</span><br></code></pre></td></tr></table></figure></li><li><p><strong>递归赋值</strong><code>=</code>  <mark>使用变量赋值时,会优先展开引用的变量</mark>(没用过,不是很清楚)</p></li></ul><h4 id="变量引用"><a class="markdownIt-Anchor" href="#变量引用"></a> 变量引用</h4><p>通过<code>$(TARGET)</code>一类的方式引用变量</p><h3 id="一些函数"><a class="markdownIt-Anchor" href="#一些函数"></a> 一些函数</h3><p>函数使用的时候和变量的引用差不多,都是通过<code>$()</code>的方式引用,不过函数引用时要在里面加上函数名和对应参数</p><h4 id="wildcard函数"><a class="markdownIt-Anchor" href="#wildcard函数"></a> wildcard函数</h4><p>通配符匹配函数,使用形如:<code>$(wildcard pattern)</code></p><p>比如可以通过:<code>$(wildcard *.c)</code>匹配当前目录下的所有<code>.c</code>结尾的文件</p><h4 id="foreach函数"><a class="markdownIt-Anchor" href="#foreach函数"></a> foreach函数</h4><p>跟c++里的foreach差不多,使用形如:<strong><code>$(foreach var,list,text)</code><strong>其中</strong>list是列表,是某一个变量的引用,var会取得列表的每一个元素,然后交由text进行展开</strong></p><p>例子如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br>SUBDIR += ./object<br><br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(f)</span>)</span><br></code></pre></td></tr></table></figure><p>上面的例子使得INCS的值为:<code>-I. -I./object</code>,这个**<code>-I</code>选项用于gcc编译过程中指定头文件所在路径**</p><h4 id="patsubst函数"><a class="markdownIt-Anchor" href="#patsubst函数"></a> patsubst函数</h4><p>起到替换作用的一个函数，使用形如:<strong><code>$(patsubst pattern,replace,list)</code></strong></p><p>会<strong>从list中取匹配pattern的元素，然后替换为replace</strong></p><p>在举例说明前先说下**<code>%</code><strong>和</strong>自动变量**</p><p>**<code>%</code>**的示例如下(例子好说明):<code>%.o : %.c</code>作为目标的<code>%</code>(就是第一个<code>%</code>)会匹配所有结尾为<code>.o</code>的目标,然后这里比如是有<code>a.o</code>和<code>b.o</code>则会匹配到这俩,然后作为依赖的<code>%</code>(第二个<code>%</code>)会把前面的<code>a</code>和<code>b</code>和<code>.c</code>构成<code>a.c</code>和<code>b.c</code></p><p><strong>自动变量</strong>有(引用无需()):</p><ul><li><strong><code>&lt;</code>表示取依赖列表的第一个依赖,通过<code>$&lt;</code>的方式引用;</strong></li><li><strong><code>@</code>表示取目标(target),通过<code>$@</code>的方式引用;</strong></li><li><strong><code>^</code>表示取依赖列表的所有依赖,通过<code>$^</code>的方式引用</strong></li></ul><p>通过自动变量和<code>%</code>可以简化生成目标文件的语句为:</p><figure class="highlight plaintext"><figcaption><span>: %.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs %.o">%.o : %.c<br>gcc -c $&lt; -o $@<br></code></pre></td></tr></table></figure><p>说回<code>patsubst</code>函数,示例如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br>SUBDIR += ./object<br><br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(f)</span>)</span> <span class="hljs-comment"># 头文件的搜索目录,有的喜欢叫cflags</span><br>SRCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(f)</span>/*.cpp)</span>) <span class="hljs-comment"># 匹配所有cpp</span><br>OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp,%.o,<span class="hljs-variable">$(SRCS)</span>)</span> <span class="hljs-comment"># 把上面的.cpp后缀统一换成.o后缀</span><br><br>test : <span class="hljs-variable">$(OBJS)</span>:<br>g++ <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br>%.o : %.cpp<br>g++ -c <span class="hljs-variable">$(INCS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> <br></code></pre></td></tr></table></figure><p>这其中把所有的CPP文件的后缀通过SRCS换成了<code>.o</code>(通过<code>%</code>),并放置在OBJS这个变量中</p><h4 id="dir函数"><a class="markdownIt-Anchor" href="#dir函数"></a> dir函数</h4><p>获取目标文件路径的一个函数,可以配合<code>mkdir -p</code>这样的shell语句使用(是的,<strong>makefile里面可以写shell语句</strong>)</p><p>这样我们可以通过makefile来更好的管理工程文件,比如头文件放哪,目标文件放哪这样子,而这其中牵扯到的目录创建,也可以一并交由makefile来做</p><p>dir函数形如:<code>$(dir basedir/file)</code>,它可以从后面的这一坨文本中获取路径,即<code>basedir</code>而去掉<code>file</code>,因此可以这么用:</p><p><code>mkdir -p $(dir $@)</code></p><p>这里我们取的是目标文件的路径</p><h3 id="伪目标phony"><a class="markdownIt-Anchor" href="#伪目标phony"></a> 伪目标<code>.PHONY</code></h3><p>我们之前在配一些项目的时候,不免会用到如<code>make clean</code>一类的指令来清除项目文件夹下多余的内容,然后重新<code>make</code>来构建内容</p><p><strong>在makefile中,我们可以利用target去执行一些动作</strong>,如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">clean :<br>rm -r <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>则可以通过**<code>make clean</code>**来执行对应的执行语句(默认执行第一条target,因此我们前面的都是直接<code>make</code>就行,没有指明target)</p><p>但我们知道!一个目标文件不存在或者依赖文件有修改才会去执行对应的执行语句,若当前目录有个clean文件,那么这个<code>make clean</code>就发挥不了作用,因为它也没依赖,而目标文件又存在</p><p>此问题可以通过<strong>伪目标</strong>来解决,<strong>将clean声明为伪目标,表明它不是文件的命名</strong></p><p><strong>伪目标的声明是通过将fake target声明为<code>.PHONY</code>这个特殊的内置目标的依赖来实现的</strong>,如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br>clean : <br>rm -rf <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><h3 id="通过简化输出"><a class="markdownIt-Anchor" href="#通过简化输出"></a> 通过<code>@</code>简化输出</h3><p>不难发现,我们前面在make的过程中,所有的执行语句都打印在了终端上,看起来乱乱的,如果不希望它被打印,可以在执行语句的前面加一个<code>@</code>来不让它打印,示例如下:</p><p><code>@rm -rf $(OBJS) $(TARGET)</code></p><p>这样执行<code>make clean</code>的时候,就不会有<code>rm -rf ...</code>这么一句话被打印了</p><h3 id="自动生成依赖"><a class="markdownIt-Anchor" href="#自动生成依赖"></a> 自动生成依赖</h3><p>我们上面通过<code>wildcard</code>函数匹配到了对应目录(这个<u>对应目录</u>是采用了<code>foreach</code>函数实现的)下的源文件,然后通过<code>patsubst</code>函数替换这些源文件为对应的<code>.o</code>文件,然后通过一些规则去生成最终想要的可执行文件,如<code>test</code>,其中它的一些<code>.o</code>文件如果找不到,则会去匹配到对应的规则利用<code>.cpp</code>文件编译生成<code>.o</code>文件,同时这其中任意一环的依赖被修改或是目标文件不存在,则会去update,去把它生成出来.</p><p>但这时你如果改动了头文件咋办呢?它不在我们的依赖中,改了咋知道要重新生成呢?</p><p>显然我们可以给头文件依次加入我们的依赖中去,但其中若是用了如<code>algorithm</code>(我假设它是静态库啊,这个看具体编译和链接的情况,因为好像有<code>libstdc++.a</code>也有<code>libstdc++.so</code>这样的库),那我岂不是还得去放这个库的比如<code>/usr/lib</code>或什么<code>/usr/local/lib</code>去加入<code>-I</code>选项来扫一下,这样不大方便;若是手动添加,更加痛苦</p><p><strong>gcc提供了一种<u>自动生成依赖</u>的选项<code>-MMD</code>,我们一般还搭配<code>-MP</code>选项来使用</strong>:</p><p><strong><code>MMD</code>作用:①生成依赖关系;②保存依赖关系到<code>.d</code>文件</strong>,其中这个文件是和我们的target即是<code>%.o</code>处在同一目录下</p><p><strong>这里生成的依赖关系是包含了目标文件它的源文件和头文件,比如:<code>a.o : a.cpp head/a.h</code></strong></p><p><strong><code>MP</code>作用是避免头文件删除了(不用了,把它删了),然后因为我们的makefile脚本里又有这么个头文件依赖在,它如果找不到匹配的规则,则会报错,因此,它的作用是生成头文件的没有任何依赖的伪目标</strong></p><div class="note note-info">            <p>为什么需要给头文件也生成一个伪目标呢?这说来话长:</p><p>我的理解是我们make的时候:如针对<code>$(TARGET) : $(OBJS)</code>,我们如果缺少某一些<code>.o</code>文件,则会<strong>先找到匹配的规则</strong>(rule),如<code>%.o : %.c</code>去生成对应的<code>.o</code>文件,<strong>如果遍历所有规则都找不到的话就会报错</strong>(<strong>正是这样,才可以改依赖,比如改头文件,才会影响到我们目标的生成,且是最小程度的影响,只会影响被改动的依赖的目标,然后该目标若是作为某一条规则的依赖,则依次影响,是一个层层递进的过程</strong>);</p><p>那你的头文件如果不用了,从目录下删掉了,那么找不到头文件,会去遍历可以match它的rule,如果找不到,就报错,但显然,我就是想把头文件给它删了,因为没用,实际程序是能运行的,那在编译时增加了<code>-MP</code>选项,则生成头文件的伪目标,这个伪目标很单纯,没有依赖,此时,我的头文件虽然找不到了,但是可以找到与它match的rule,告知我们怎么处理,则可以<strong>规避掉报错的问题</strong>.</p>          </div><p>那我们通过在编译的时候增加<code>-MMD</code>,<code>-MP</code>选项来实现自动生成依赖并存于<code>.d</code>文件中,<strong>怎么将文件中的内容引入makefile脚本中呢?</strong></p><p><strong>通过<code>include</code>即可引入</strong>,但是因为第一次编译的时候<code>.d</code>文件还不存在,这时候include会报错,<strong>通过<code>-include</code>来避免报错</strong>,使得makefile脚本正常运行,使用示例如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">DEPS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,<span class="hljs-variable">$(OBJS)</span>)</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEPS)</span><br></code></pre></td></tr></table></figure><h3 id="通用模板"><a class="markdownIt-Anchor" href="#通用模板"></a> 通用模板</h3><p>通用模板中的内容上面都介绍过,是我目前用的一个通用模板,要改的话在上面改就行了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br><br>OUTPUT := ./obj<br>TARGET := test<br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(dir)</span>)</span><br>INCS += `pkg-config --cflags opencv4` <span class="hljs-comment"># 通过pkg-config指令,将opencv4的头文件路径列出</span><br><br>SRCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SUBDIR)</span>,$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.cpp)</span>)<br><br>OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp,<span class="hljs-variable">$(OUTPUT)</span>/%.o,<span class="hljs-variable">$(SRCS)</span>)</span><br>DEPS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,<span class="hljs-variable">$(OBJS)</span>)</span><br><br>LIBS := `pkg-config --libs opencv4` <span class="hljs-comment"># 通过pkg-config指令,将opencv4的库文件路径列出</span><br><br><span class="hljs-variable">$(TARGET)</span> : <span class="hljs-variable">$(OBJS)</span><br>@echo linking...<br>@g++ <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(LIBS)</span><br>@echo complete!<br><br><span class="hljs-variable">$(OUTPUT)</span>/%.o : %.cpp<br>@echo compling...<br>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>@g++ -MMD -MP -c <span class="hljs-variable">$(INCS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>@echo complete!<br><br>.PHONY : clean<br><br>clean :<br>@echo cleaning...<br>@rm -rf <span class="hljs-variable">$(OUTPUT)</span> <span class="hljs-variable">$(TARGET)</span><br>@echo complete!<br><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEPS)</span> <br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>注意: Please note: you need to put a tab character at the beginning of every recipe line!</strong></p><p><strong>在每个执行语句要用tab字符(制表符)开头!</strong></p>          </div><h2 id="关于gcc编译选项的一些补充"><a class="markdownIt-Anchor" href="#关于gcc编译选项的一些补充"></a> 关于GCC编译选项的一些补充</h2><ul><li><code>-I</code> 指定搜索头文件的路径</li><li><code>-L</code> 指定搜索库文件的路径</li><li><code>-l</code> 指定链接的库文件如<code>-lm</code>链接数学库</li><li><code>-D</code> 类似于c中的宏定义,在-D中出现的变量在C中可使用,如<code>-D DEBUG=1</code>,然后在C中打印出<code>DEBUG</code>这个变量会显示1的值</li></ul><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/dreamerway/article/details/24991099">C++程序组织：.h .cpp与分离式编译</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/618350718">写给初学者的Makefile入门指南</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_43916755/article/details/128503446">深入理解计算机系统_静态链接和动态链接以及静态库和动态库</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/xieyihua1994/article/details/134782826">一文搞懂系列——动态库的加载方式及应用场景</a> (未细看)<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>C++项目编译工具</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量intrinsic编程</title>
    <link href="/2024/01/24/%E5%90%91%E9%87%8Fintrinsic%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/01/24/%E5%90%91%E9%87%8Fintrinsic%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="simd指令集的发展"><a class="markdownIt-Anchor" href="#simd指令集的发展"></a> SIMD指令集的发展</h2><h3 id="什么是simd"><a class="markdownIt-Anchor" href="#什么是simd"></a> 什么是SIMD</h3><p>我们接触的传统的程序，一般是SISD，即Single Instruction Single Data，单指令单数据流，它是传统的串行计算机架构，即相当于在该计算机上，任何时刻都是从指令流里取一条指令来处理数据流中的一个数据，交由一个核心来处理。</p><p>SIMD则是利用到了计算机的多个核心的较新的并行架构，采用控制器来控制多个处理器，对多个核心的不同数据执行同一条指令，从而实现并行。</p><p>SIMD有对应SIMD指令集，而支持这些SIMD指令集的CPU在设计的时候增加了专用的<strong>向量寄存器</strong>，</p><p>就好像之前一条指令只能处理一个单精度浮点数，而现在采用一条SIMD指令能处理如4个，8个甚至更多个的单精度浮点数，这些数据就存储于向量寄存器中，显然，<strong>向量寄存器较通用寄存器其能容纳更多的位数</strong>。当然，<strong>放入向量寄存器的多个数据的数据类型是一致的</strong>。</p><h3 id="simd指令集的历史进程"><a class="markdownIt-Anchor" href="#simd指令集的历史进程"></a> SIMD指令集的历史进程</h3><p>下图是SIMD指令集随CPU的发展：</p><p><img src="https://s2.loli.net/2024/02/27/ofa25ckdz9A1iwP.jpg" alt="SIMD_Instruction_development" /></p><ul><li>MMX(Multi Media eXtension)，伴生64位的MM寄存器</li><li>SSE(Streaming Simd Extension)，伴生128位的XMM寄存器，XMM0-XMM15，一共十六个寄存器</li><li>AVX/AVX2(Advanced Vector eXtension)，伴生256位的YMM寄存器，YMM0-YMM15,一共十六个寄存器。AVX2增加了乘加融合指令（FMA，这同时也是一个硬件）。低128位对应XMM</li><li>AVX512，伴生512位的ZMM寄存器，ZMM0-ZMM31,一共32个寄存器，还有8个操作掩码寄存器，K0-K7，低128位和低256位对应XMM和YMM</li></ul><h3 id="simd指令集的数据类型"><a class="markdownIt-Anchor" href="#simd指令集的数据类型"></a> SIMD指令集的数据类型</h3><p>虽说有好像很多种指令集，但毕竟都是一家公司发行的，有一定规律可遵循：</p><p><code>__m+位宽+数据类型</code></p><p>其中位宽有128位（SSE），256位(AVX/AVX2)，512位（AVX512）</p><p>数据类型有三种：</p><ul><li>什么都不写，就代表单精度浮点数</li><li>d，代表double，双精度浮点数</li><li>i，整型，对应char,short,int,long这一堆定点数</li></ul><p>因此数据类型可以如下表示：</p><p><code>__m256</code>: 向量长度为256位的单精度浮点数，有8个32位的float</p><p><code>__m128i</code>: 向量长度为128位的整型，有多个整型数值</p><p><code>__m5121d</code>: 向量长度为512位的双精度浮点数，有8个64位的double</p><h3 id="simd指令集的方法"><a class="markdownIt-Anchor" href="#simd指令集的方法"></a> SIMD指令集的方法</h3><p>在说到SIMD指令集，如AVX指令集时，我们知道，可以采用指令集中的汇编指令去操纵YMM寄存器，但是，汇编难写难读难管理，因此有了<strong>Intrinsic Function</strong>。</p><p><strong>Intrinsic Function</strong>就跟C一样，是较于汇编的一种高级语言（但没到C那种高级程度，只是用类C的方式编写汇编），它又与C不同（毕竟面对的寄存器不是通用寄存器了，而是向量寄存器），但可以和C/C++无缝融合</p><p>需要注意：<strong>Intrinsic Function并非完全与指令集一一对应</strong></p><p>SSE/AVX的intrinsic function命名习惯如下:</p><p><code>__&lt;return_type&gt; _&lt;vector_size&gt;_&lt;intrin_op&gt;_&lt;suffix&gt;</code></p><ul><li>返回类型return_type就是上面对应的SIMD数据类型,如<code>__m256d</code>这些</li><li>向量长度vector_size就是代表<strong>函数操作的数据向量的位长度</strong>,如<code>mm</code>表示128位的数据向量(SSE),<code>mm256</code>表示256位的数据向量(AVX/AVX2),<code>mm512</code>表示512位的数据向量(AVX512)</li><li>代表函数具体功能的<code>intrin_op</code></li><li><strong>suffix是后缀,表示函数参数的数据类型</strong>,p=packed,s=single(fp32),d=double(fp64),ep=整型(具体英文指代词没找到)<ul><li>ps</li><li>pd</li><li>epi8/epi16/epi32/epi64</li><li>epu8/epu16/epu32/epu64</li><li>si128/si256: 未指定的128位/256位向量,si=unSpecIfied</li></ul></li></ul><h3 id="常规方法类型"><a class="markdownIt-Anchor" href="#常规方法类型"></a> 常规方法类型</h3><p>SET系列,LOAD系列,STORE系列,MATH系列,COMPARE系列,CONVERT系列,SHUFFLES系列,详情参见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup></p><p>注:load是往向量寄存器YMM里灌数据,而store给从向量寄存器写到内存去</p><p>其中shuffles中有个<code>_mm256_blendv_pd(__m256d a,__m256d b,__m256d mask)</code>中的v表示的是variable,否则是constant,且它可以这么理解:mask中的false由a填充,true的部分则由b填充</p><h2 id="第一个intrinsic的demo"><a class="markdownIt-Anchor" href="#第一个intrinsic的demo"></a> 第一个intrinsic的demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    __m256 a = _mm256_set_ps(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>,<br>                             <span class="hljs-number">5.4</span>, <span class="hljs-number">6.5</span>, <span class="hljs-number">7.6</span>, <span class="hljs-number">8.7</span>);<br><br>    __m256 b = _mm256_set_ps(<span class="hljs-number">3.8</span>, <span class="hljs-number">4.9</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.1</span>,<br>                             <span class="hljs-number">8.2</span>, <span class="hljs-number">9.3</span>, <span class="hljs-number">10.4</span>, <span class="hljs-number">11.5</span>);<br><br>    __m256 c = _mm256_add_ps(a, b);<br><br>    <span class="hljs-keyword">float</span> d[<span class="hljs-number">8</span>];<br><br>    _mm256_storeu_ps(d, c); <span class="hljs-comment">// 这里的u是unaligned的意思</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        cout &lt;&lt; d[i] &lt;&lt; ends;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>immintrin.h</code>是AVX的头文件,然后在编译的时候要加上<code>-mavx</code>以启用AVX指令集</strong></p><h2 id="avx2算子编写"><a class="markdownIt-Anchor" href="#avx2算子编写"></a> AVX2算子编写</h2><p>这部分的内容大量的参考了学习资料<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup>,其中内容编写部分是我看了之后自己重新编写的</p><h3 id="gelu"><a class="markdownIt-Anchor" href="#gelu"></a> GELU</h3><p>参照学习资料<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup>自行观看,过于直白,其中tanh是一种近似实现,当然也可以用别的轻量数学库来替换,好像是Intel C++ Compiler没有这个的实现(但是好像MKL是有的),用别的编译器可能存在不支持AVX2指令的情况.查了下百度,原因如下(<strong>要做优化,就别用cmath这些,当然icc针对这些数学公式也有优化的库:mkl</strong>):</p><p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/ICC-tanh%20ask.png" alt="icc-tanh" /></p><h3 id="softmax"><a class="markdownIt-Anchor" href="#softmax"></a> softmax</h3><h3 id="矩阵加"><a class="markdownIt-Anchor" href="#矩阵加"></a> 矩阵加</h3><h3 id="矩阵转置"><a class="markdownIt-Anchor" href="#矩阵转置"></a> 矩阵转置</h3><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:0" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">intel-intrinsic官网</a><a href="#fnref:0" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/591900754">玩转SIMD编程</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_17075011/article/details/130555559">AVX/AVX2,内存对齐学习</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/fengbingchun/article/details/18460199/">SSE2 Intrinsic function介绍</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>intrinsic编程</tag>
      
      <tag>AVX/AVX2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asm内联汇编</title>
    <link href="/2024/01/24/asm%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <url>/2024/01/24/asm%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a class="markdownIt-Anchor" href="#写在开头"></a> 写在开头</h2><p>本文所描述的内联汇编主要用于算子开发,因此涉及到的知识面相对可能较窄.如果有内容没涉及到,大概是作者还没使用到相关的知识~</p><p>文中对内联汇编的一些定义解释会引用<strong>GCC Extended-ASM</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="GNU Extended-ASM">[1]</span></a></sup>的原文,毕竟翻译过来容易变味,不利于使用者理解</p><h2 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">asm</span> <span class="hljs-keyword">asm</span>-<span class="hljs-built_in">qualifiers</span> ( AssemblerTemplate <br>                 : OutputOperands <br>                 [ : InputOperands<br>                 [ : Clobbers ] ])<br></code></pre></td></tr></table></figure><p>第一个asm是<strong>关键字</strong>,建议使用**<code>__asm__</code>**而非<code>asm</code>,原因如下:</p><blockquote><p>The <code>asm</code> keyword is a GNU extension. When writing code that can be compiled with -ansi and the various -std options, use <code>__asm__</code> instead of <code>asm</code> (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html">Alternate Keywords</a>).</p></blockquote><hr /><p>**asm的修饰符(qualifiers)**有三个</p><ul><li><p><strong>volatile</strong>: 告知GCC这里不用优化(就是这里禁用优化)</p><blockquote><p>The typical use of extended <code>asm</code> statements is to manipulate input values to produce output values. However, your <code>asm</code> statements may also produce side effects. If so, you may need to use the <code>volatile</code> qualifier to disable certain optimizations. See <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Volatile">Volatile</a>.</p></blockquote></li><li><p><strong>inline</strong>:</p></li><li><p><strong>goto</strong>:</p></li></ul><hr /><p><strong>AssemblerTemplate</strong>则用于放置汇编语句,用<code>&quot;&quot;</code>包裹住每一句汇编语句</p><hr /><p><strong>OutputOperands</strong>,这个列表以<code>:</code>开头,用于放置<strong>输出操作数</strong>,列表中的<strong>各个操作数以<code>,</code>分隔</strong>.输出操作数<strong>一般至少用于只写(覆盖)</strong>.操作数的格式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[ [asmSymbolicName] ] constraint (cvariablename)<br></code></pre></td></tr></table></figure><p>其中<code>[asmSymbolicName]</code>是C中变量<code>cvariablename</code>在汇编中的符号名,一般同名更有利于我们编写汇编,在AssemblerTemplate中可以通过**<code>%[asmSymbolicName]</code>**来进行调用</p><p>不想用符号名的话则按照输出操作数到输入操作数的变量名的顺序,依次为<code>%0</code>,<code>%1</code>,…</p><p><code>(cvariablename)</code>则用于填写我们C中的变量名</p><p>constraint约束,是一个<strong>字符串常量</strong>,<strong>指定操作数的约束条件</strong>.它需要以<code>=</code>(覆盖现有值的变量,即只写)或者<code>+</code>(既读又写时)作为字串开头</p><blockquote><p>Output constraints must begin with either ‘=’ (a variable overwriting an existing value) or ‘+’ (when reading and writing). When using ‘=’, do not assume the location contains the existing value on entry to the <code>asm</code>, except when the operand is tied to an input; see <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#InputOperands">Input Operands</a>.</p></blockquote><p>在上面的前缀后,须有一个或多个额外的约束,来<strong>描述值所在的位置</strong>.比如寄存器的<code>r</code>和内存的<code>m</code>.<strong>当列出多个可能的位置,则编译器会根据上下文选择最有效的位置</strong>.</p><blockquote><p>After the prefix, there must be one or more additional constraints (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Constraints.html">Constraints for <code>asm</code> Operands</a>) that describe where the value resides. Common constraints include ‘r’ for register and ‘m’ for memory. When you list more than one possible location (for example, <code>&quot;=rm&quot;</code>), the compiler chooses the most efficient one based on the current context. If you list as many alternates as the <code>asm</code> statement allows, you permit the optimizers to produce the best possible code. If you must use a specific register, but your Machine Constraints do not provide sufficient control to select the specific register you want, local register variables may provide a solution (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html">Specifying Registers for Local Variables</a>).</p></blockquote><hr /><p><strong>InputOperands</strong>用于放置<strong>输入操作数</strong>,列表中的各操作数以<code>,</code>分隔,<strong>只用做输入用,即只读</strong>.它的格式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[ [asmSymbolicName] ] constraint (cexpression)<br></code></pre></td></tr></table></figure><p>这里基本上跟OutputOperands一样,但是<strong>作为约束的字串常量没有<code>=</code>或者<code>+</code>这些prefix,只是用来指示值所在的位置</strong>,比如<code>r</code>或者<code>m</code>.也可以给出多个可能的位置,让编译器根据上下文选择最有效的位置</p><hr /><p><strong>Clobbers</strong>这个列表中的列表项,要么是<strong>寄存器名字</strong>,要么是<strong>特殊的clobber</strong>.每个列表项都是用<code>&quot;&quot;</code>括起来,用<code>,</code>分隔的字串常量</p><div class="note note-info">            <p>虽说编译器知道我们会修改输出操作数,但是这其中的内联代码也会用到额外的寄存器,用的时候一些寄存器的值被覆盖掉了,这些被用的寄存器我们要告知编译器</p><blockquote><p>While the compiler is aware of changes to entries listed in the output operands, the inline <code>asm</code> code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</p></blockquote>          </div><p>而且我们的输入输出操作数可能约束中指定了要用寄存器来存放值,编译器在选择它们要用的寄存器时,不会用clobber列表中提及到的寄存器.因此,clobber中提及的寄存器可以用于汇编代码中任何用途.</p><blockquote><p>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</p></blockquote><p><strong>clobber列表中不给用stack pointer寄存器!!</strong></p><p>特殊的clobber:</p><ul><li><p><code>cc</code>:表示汇编代码修改了标志寄存器.某些机器,gcc会将条件代码表示为一个特定的硬件寄存器,cc用来命名该寄存器</p><blockquote><p>The <code>&quot;cc&quot;</code> clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; <code>&quot;cc&quot;</code> serves to name this register. On other machines, condition code handling is different, and specifying <code>&quot;cc&quot;</code> has no effect. But it is valid no matter what the target.</p></blockquote></li><li><p><code>memory</code>: memory clobber告诉编译器,<strong>汇编代码对输入和输出操作数中列出的项以外的项执行内存读取或写入（例如，访问其中一个输入参数指向的内存）</strong>。<strong>为了确保内存包含正确的值，GCC可能需要在执行asm(内联汇编)之前将特定的寄存器值刷新到内存中</strong>。此外，编译器不假设在asm之前从内存读取的任何值在该asm之后保持不变；它会<strong>根据需要重新加载它们</strong>(根据需要做现场保护)。使用memory clobber有效地为编译器形成了一个读/写内存屏障。</p><blockquote><p>The <code>&quot;memory&quot;</code> clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the <code>asm</code>. Further, the compiler does not assume that any values read from memory before an <code>asm</code> remain unchanged after that <code>asm</code>; it reloads them as needed. Using the <code>&quot;memory&quot;</code> clobber effectively forms a read/write memory barrier for the compiler.</p></blockquote></li></ul><h2 id="两个例子"><a class="markdownIt-Anchor" href="#两个例子"></a> 两个例子</h2><h3 id="risc-v的例子通过内联汇编实现系统调用"><a class="markdownIt-Anchor" href="#risc-v的例子通过内联汇编实现系统调用"></a> RISC-V的例子(通过内联汇编实现系统调用):</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__buf, <span class="hljs-keyword">int</span> __n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> bytes;<br>    __asm__ __volatile__(<br>        <span class="hljs-string">&quot;mv a0, %1           # file descriptor\n&quot;</span><br>        <span class="hljs-string">&quot;mv a1, %2           # buffer \n&quot;</span><br>        <span class="hljs-string">&quot;mv a2, %3           # size \n&quot;</span><br>        <span class="hljs-string">&quot;li a7, 63           # syscall read (63) \n&quot;</span><br>        <span class="hljs-string">&quot;ecall \n&quot;</span><br>        <span class="hljs-string">&quot;mv %0, a0&quot;</span><br>        : <span class="hljs-string">&quot;=r&quot;</span>(bytes)                     <span class="hljs-comment">// Output list</span><br>        : <span class="hljs-string">&quot;r&quot;</span>(__fd), <span class="hljs-string">&quot;r&quot;</span>(__buf), <span class="hljs-string">&quot;r&quot;</span>(__n) <span class="hljs-comment">// Input list</span><br>        : <span class="hljs-string">&quot;a0&quot;</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a7&quot;</span>);<br>    <span class="hljs-keyword">return</span> bytes;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__buf, <span class="hljs-keyword">int</span> __n)</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__ __volatile__(<br>        <span class="hljs-string">&quot;mv a0, %0           # file descriptor\n&quot;</span><br>        <span class="hljs-string">&quot;mv a1, %1           # buffer \n&quot;</span><br>        <span class="hljs-string">&quot;mv a2, %2           # size \n&quot;</span><br>        <span class="hljs-string">&quot;li a7, 64           # syscall write (64) \n&quot;</span><br>        <span class="hljs-string">&quot;ecall&quot;</span><br>        :                                 <span class="hljs-comment">// Output list</span><br>        : <span class="hljs-string">&quot;r&quot;</span>(__fd), <span class="hljs-string">&quot;r&quot;</span>(__buf), <span class="hljs-string">&quot;r&quot;</span>(__n) <span class="hljs-comment">// Input list</span><br>        : <span class="hljs-string">&quot;a0&quot;</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a7&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">11</span>];<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, str, <span class="hljs-number">11</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We already read %d chars&quot;</span>, n);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, str, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> _start()<br>&#123;<br>    <span class="hljs-built_in">main</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="aarch64的例子加权和dstj-weighted1-array1j-weigthed2-array2j"><a class="markdownIt-Anchor" href="#aarch64的例子加权和dstj-weighted1-array1j-weigthed2-array2j"></a> aarch64的例子(加权和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>e</mi><mi>d</mi><mn>1</mn><mo>∗</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mn>1</mn><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>d</mi><mn>2</mn><mo>∗</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mn>2</mn><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dst[j] = weighted1 * array1[j] + weigthed2 * array2[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>):</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrayWeightSumInAsm</span><span class="hljs-params">(<span class="hljs-keyword">float</span>* array1,<span class="hljs-keyword">float</span> weighted1,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">float</span>* array2,<span class="hljs-keyword">float</span> weighted2,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">int</span> len,<span class="hljs-keyword">float</span>* dst)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> neon_len = len &gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> remain_len = len - (neon_len &lt;&lt; <span class="hljs-number">2</span>);<br> <span class="hljs-comment">// armv8</span><br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//  Instruction</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 取64位寄存器的低32位,并dup到向量寄存器上</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;mov x0, %[weighted1] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;dup v0.4s, w0 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;mov x1, %[weighted2] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;dup v1.4s, w1 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;0:            \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 预取数据,加载数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;prfm pldl1keep, [%[array1], #128] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;ld1 &#123;v2.4s&#125;, [%[array1]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;prfm pldl1keep, [%[array2], #128] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;ld1 &#123;v3.4s&#125;, [%[array2]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 做乘法</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fmul v4.4s, v0.4s, v2.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fmul v5.4s, v1.4s, v3.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 做加法</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fadd v4.4s, v4.4s, v5.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 存数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;st1 &#123;v4.4s&#125;, [%[dst]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 自减neon_len,并影响状态位</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;subs %[neon_len], %[neon_len], #1 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 满足条件则跳转</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;bgt 0b \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        :[array1]    <span class="hljs-string">&quot;+r&quot;</span>(array1),</span></span><br><span class="hljs-params"><span class="hljs-function">         [array2]    <span class="hljs-string">&quot;+r&quot;</span>(array2),</span></span><br><span class="hljs-params"><span class="hljs-function">         [dst]       <span class="hljs-string">&quot;+r&quot;</span>(dst),</span></span><br><span class="hljs-params"><span class="hljs-function">         [neon_len]  <span class="hljs-string">&quot;+r&quot;</span>(neon_len)</span></span><br><span class="hljs-params"><span class="hljs-function">        :[weighted1] <span class="hljs-string">&quot;r&quot;</span>(weighted1),</span></span><br><span class="hljs-params"><span class="hljs-function">         [weighted2] <span class="hljs-string">&quot;r&quot;</span>(weighted2)</span></span><br><span class="hljs-params"><span class="hljs-function">        :<span class="hljs-string">&quot;cc&quot;</span>,<span class="hljs-string">&quot;memory&quot;</span>,<span class="hljs-string">&quot;x0&quot;</span>,<span class="hljs-string">&quot;x1&quot;</span>,<span class="hljs-string">&quot;v0&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>,<span class="hljs-string">&quot;v4&quot;</span>,<span class="hljs-string">&quot;v5&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br>    <span class="hljs-comment">// 处理尾部数据</span><br>    <span class="hljs-keyword">while</span>(remain_len&gt;<span class="hljs-number">0</span>)&#123;<br>        *dst = *array1 * weighted1 + *array2 * weighted2;<br>        dst++;<br>        array1++;<br>        array2++;<br>        remain_len--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">GNU Extended-ASM</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_42031299/article/details/132917965">c内嵌汇编总结</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_42258222/article/details/116501867">【ATT 与 Intel】汇编与C语言相互调用及内联汇编</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/I_O_fly/article/details/127089091">RISCV汇编指令</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>内联汇编</tag>
      
      <tag>内嵌汇编</tag>
      
      <tag>assemble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorRT学习</title>
    <link href="/2024/01/20/TensorRT%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/20/TensorRT%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>高性能深度学习支持引擎TensorRT</p><p>在线部署对实时性要求很高,对latency敏感</p><p>TensorRT: GPU Inference Engine;TensorRT works at deploy stage</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CUDA学习积累(持续更新)</title>
    <link href="/2023/12/24/CUDA%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/12/24/CUDA%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2><p>在去重庆参会前，就已经自己构建了一套学习理论（算子编写，算子调度[分布式模型训练]）听了山城会议之后，觉得对于算子编写得尽快提上日程，因此打算结合视频和博客学习CUDA，每天花点时间学习整理，方便后续算子编写的工作。<br />目前第一部分的学习首先是结合B站的视频展开：<a href="https://www.bilibili.com/video/BV1vJ411D73S">CUDA 编程入门</a>，后续学习到的知识重复部分则不予更新，更新尚未了解的部分~</p><h2 id="cuda学习"><a class="markdownIt-Anchor" href="#cuda学习"></a> CUDA学习</h2><h3 id="什么是gpu计算"><a class="markdownIt-Anchor" href="#什么是gpu计算"></a> 什么是GPU计算</h3><p>介绍了CPU的一般架构，可能涉及到多个核心，然后有L1、L2、L3多级cache缓存。主要意思是说：<strong>CPU核心数目不会特别多，一般多的话也就几十个</strong></p><p>介绍GPU一般架构，<strong>有SM（Streaming MultiProcessor）,一个SM里面有多个SP（Streaming Processor），它内存有L1、L2多级cache，也有全局系统显存</strong></p><p><strong>一个SM里面会包含许多SP（也叫CUDA Core）,同时也有指令Cache，warp调度器，寄存器文件等</strong></p><p><strong>GPU和CPU一起做运算，GPU(device)负责计算密集型任务，CPU（host）负责控制密集型任务，它们通过PCIe相连接（拷贝数据到对方的存储空间，好像也有共享内存类型的）</strong></p><p>CPU所谓的线程其实是伪进程（云计算课老师说的），上下文切换开销大</p><p><strong>GPU的线程则是真正意义上的线程，是很轻量级的</strong></p><p>CUDA支持C/C++编程，也支撑Fortran，Python</p><ul><li>编译器：nvcc(nvidia cuda compiler)</li><li>调试器：nvcc-gdb</li><li>性能分析：nsight,nvprof <a href="https://docs.nvidia.com/nsight-compute/NsightCompute/index.html">NsightCompute</a></li><li>函数库：cuBLAS,cuSparse,…</li><li>二进制工具: cuobjdump,nvdisasm <a href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html">cuda-binary-utilities</a></li></ul><h3 id="gpu内存层次"><a class="markdownIt-Anchor" href="#gpu内存层次"></a> GPU内存层次</h3><img src="https://s2.loli.net/2024/07/03/iWIVfJknL79A1aD.png" alt="gpu-logical-memory-hierarchy" style="zoom:67%;" /><p>上图呈现的是GPU的逻辑内存层次结构,分为<strong>grid-block-thread</strong>,其中我们在CUDA中会通过**<code>dim3</code>**类型来对它们进行定义,<code>dim3</code>类型可以理解为结构体,内部有x,y,z三个值(空间直角坐标系),默认缺省值为1</p><p>grid(网格)内部有多个block(线程块),block内部有多个thread(线程),在编写CUDA程序时,会分为host端和device端(异构编程模型嘛),我们在调用核函数的时候,会通过执行配置参数,声明这一个核函数需要用到的grid和block</p><p>而在核函数内部,会有如<code>gridDim</code>,<code>blockDim</code>这两个内置参数来查看外部声明的配置参数的大小,并且可以通过<code>blockIdx</code>,<code>threadIdx</code>找到对应block属于grid的第几行第几列,对应thread在block内的线程号以及相对于整个grid它的线程号等信息</p><p>实际上GPU的内存层次并非上述的<strong>grid-block-thread</strong>,这一概念是为了将软硬件剥离,以提高程序员编写的简易性,但若是考虑到性能优化,就一定需要了解其真正的物理内存层次,下图展示的是Fermi架构的内存层次,gpu硬件的内存层次整体大同小异</p><img src="https://s2.loli.net/2024/07/03/DzW7bO2gwC91IJj.png" alt="gpuFermi-physical-memory-hierarchy" style="zoom:67%;" /><p>可以看到上述分为了两个层次,第一个层次是许多的SM由DRAM(全局内存,就是通俗意义的显存)围绕,而内部所有的SM共享一个L2Cache,也就是SM们可以通过L2Cache进行通信;</p><p>右侧展开了单个SM,可以看到内部有许多的CUDA Core(SP),还有L1Cache和Shared Memory所共享的64KB内存,以及一个超大的Regster File,其中内部还包括warp的调度器,发射单元等部件</p><p>实际上,我们的block它在运行的时候会被调度到SM上(<strong>SM是真正的核心组件</strong>),<strong>一个SM可以调度多个block</strong>,具体多少,看它的资源,因为我们<strong>线程的寄存器,线程块的共享内存,是用的SM的资源</strong>.而<strong>在SM上的一个block会被划分为多个warp,一个warp是32个线程,warp是最基本的执行单元,warp内部遵循SIMT,每个线程同时执行相同的指令</strong>,而每个线程它拥有自己独立的PC和寄存器状态,也即有自己的执行路径</p><p>因此block应该设置为32的倍数,如果不是32的倍数,余下的部分会单独划为1个warp,该warp除了需要的线程,剩余的线程都是inactive</p><p>下面是关于逻辑内存与对应的物理内存的关系,需要牢记哪些内存是片上内存,哪些是板载内存</p><p><img src="https://s2.loli.net/2024/07/03/p6JANBGKTlrvYMO.png" alt="gpu-memory-distribution" /></p><h3 id="gpu一些指标"><a class="markdownIt-Anchor" href="#gpu一些指标"></a> GPU一些指标</h3><ul><li><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>o</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>p</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mspace width="1em"/><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="1em"/><mi>o</mi><mi>f</mi><mspace width="1em"/><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mspace width="1em"/><mi>w</mi><mi>a</mi><mi>r</mi><mi>p</mi><mi>s</mi></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>i</mi><mi>m</mi><mi>u</mi><mi>m</mi><mspace width="1em"/><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="1em"/><mi>o</mi><mi>f</mi><mspace width="1em"/><mi>w</mi><mi>a</mi><mi>r</mi><mi>p</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">occupancy = \frac{actual\quad number\quad of\quad active\quad warps}{maximum\quad number\quad of\quad warps}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>占用率</p></li></ul><h2 id="基础的例子向量加"><a class="markdownIt-Anchor" href="#基础的例子向量加"></a> 基础的例子向量加</h2><p>通过向量加这一例子,了解cuda编程的大致形式</p><p>从下面开始,关于CUDA的讲解分为三个部分:<strong>硬件架构</strong>,<strong>库与函数</strong>,<strong>算子系列</strong>来进行展开,三个部分顺序不一定一一对应,可以从硬件部分开始看,也可以从算子系列开始看,遇到奇奇怪怪的函数或库在去库与函数里找解释会更好</p><h2 id="nvcc编译流程"><a class="markdownIt-Anchor" href="#nvcc编译流程"></a> NVCC编译流程</h2><img src="https://s2.loli.net/2024/10/07/YpuJt4hvRzo52QF.png" alt="cuda-compliation-from-cu-to-executable" style="zoom:80%;" /><p>CUDA编译流程就像上图所示:<code>.cu</code>文件进行两次预处理,左边的是纯C++的,右边的是CUDA的(又或者说是host端代码和devic端代码)</p><p>device端代码预处理后会被cicc编译得到ptx代码,然后被ptxas这个汇编器得到cubin,这个过程会重复多次,看你<code>--generate-code arch=compute_80,code=sm_80</code>就看你前面这个virtual architecture有哪些个(虚拟架构是向后兼容的,对应的sm_xy)的情况下优化效果更好</p><p>然后把这些个<code>.cubin</code>弄成一个<code>.fatbin</code>合并了多个版本的<code>.cubin</code>,然后用类似内联汇编的形式经由<code>fatbinary</code>指令弄成<code>fatbin.c</code>文件.被host端代码所include的一个stub文件包含,则此刻所有代码都是<code>.c</code>,经由gcc编译即可,编译得到<code>.o</code></p><p><mark>多个<code>.cu</code>文件都过一遍上面的流程得到<code>.o</code>,经由<code>nvlink</code>(设备端的链接器)对device端代码进行链接,形成一个.o文件,然后再与原先生成的<code>.o</code>文件进行主机端的链接,最终形成可执行文件</mark></p><p>上面是一坨,host端和device端一起编译,叫做<code>whole program compilation</code>,也可以分开编译,如下,叫做<code>separate compilation</code>:</p><p><img src="https://s2.loli.net/2024/10/07/IRvkAw9PMnqQNiY.png" alt="nvcc-options-for-separate-compilation" /></p><p>分开编译特指的是设备端的代码,设备端的代码可以复用,不用都写一块,一起编译了,可以写多个<code>.cu</code>,跨文件去访问设备端的函数和变量.那么其中用到的这些个<strong>符号</strong>,就需要通过<code>extern</code>(外部函数或别的文件可见的变量)和<code>static</code>(用于不同文件的同名变量)关键字来修饰其可见性了,这时最好用引用而非具体的变量名</p><div class="note note-warning">            <p><code>whole program compilation</code>的nvlink不是用于设备端的链接器吗?确实看到了:</p><blockquote><p>CUDA programs are compiled in the whole program compilation mode by default, i.e., the device code cannot reference an entity from a separate file. In the whole program compilation mode, device link steps have no effect. For more information on the separate compilation and the whole program compilation, see <a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#using-separate-compilation-in-cuda">Using Separate Compilation in CUDA</a>.</p></blockquote><p>那这是真的没用吗?(＠_＠;)还是说后面改了</p>          </div><img src="https://s2.loli.net/2024/10/07/NuD9gGoz7LqUScP.png" alt="virtual-architecture" style="zoom:80%;" /><p>2stage的编译过程,编译出来的是可以直接在CUDA Runtime上执行的二进制代码</p><blockquote><p>From this it follows that the virtual architecture should always be chosen as <em>low</em> as possible, thereby maximizing the actual GPUs to run on. The <em>real</em> architecture should be chosen as <em>high</em> as possible (assuming that this always generates better code), but this is only possible with knowledge of the actual GPUs on which the application is expected to run on.</p></blockquote><img src="https://s2.loli.net/2024/10/07/17X4RlwZy8qajtP.png" alt="just in time compliation" style="zoom:80%;" /><p>1stage的编译过程,得到了对应的ptx代码,运行的时候驱动取得了确定的GPU型号,再进行编译运行,这又称之为JIT Compilation(Just In Time,即时编译),通过<code>--generate-code arch=compute_80,code=compute_80</code>.对于某一些功能以及性能的追求,可以用这个,因为知道了具体的gpu型号可以生成最匹配的二进制代码</p><blockquote><p>By specifying a virtual code architecture instead of a <em>real</em> GPU, <code>nvcc</code> postpones the assembly of PTX code until application runtime, at which time the target GPU is exactly known.</p></blockquote><p><strong>参考文件:</strong></p><ul><li><a href="https://www.zhihu.com/question/535334673">nvcc编译原理</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/">CUDA-compiler-driver-NVCC</a></li></ul><h2 id="硬件架构"><a class="markdownIt-Anchor" href="#硬件架构"></a> 硬件架构</h2><h3 id="pascal前架构"><a class="markdownIt-Anchor" href="#pascal前架构"></a> Pascal前架构</h3><h3 id="volta"><a class="markdownIt-Anchor" href="#volta"></a> Volta</h3><h3 id="微架构"><a class="markdownIt-Anchor" href="#微架构"></a> 微架构</h3><p>CUDA的微架构一般指的是SM，不包括外围的辅助功能；<br />CUDA指令集：SASS（Streaming ASSembly）;还有个在SASS之上的虚拟中间代码指令集PTX（Parallel Thread eXecution）；<br />GPU所有指令都是从SM发出的</p><p>CUDA用<strong>Compute Capability</strong>（简称<strong>CC</strong>）来区分各个微架构，比如5.0，6.1，7.5，…通常用SM_50,SM_61,SM_75（有时也没有下划线）来表示<br />CC有大版本和小版本，大版本一般有代号，比如3.x叫做Kepler，5.x叫做Maxwell，6.x叫Pascal，7.x没有统一代号，7.0是Volta，7.5是Turning，ampere卡是8.0</p><p><strong>CC和SASS指令集有比较直接的对应关系</strong><br />很多指令的throughput和latency都与CC有关</p><p><strong>CC只与设备的SM架构版本有关，与设备绝对算力的强弱无关</strong></p><h2 id="pytorch中的cppcuda扩展"><a class="markdownIt-Anchor" href="#pytorch中的cppcuda扩展"></a> PyTorch中的CPP/CUDA扩展</h2><p>pytorch中调用cpp/cuda扩展有<strong>预编译</strong>和**即时编译(JIT)**两种模式</p><ul><li><p><strong>预编译</strong></p><p>通过一种神奇的方法将CPP/CUDA代码编译并构建成模块,从而可以在python代码中用上自己写的算子~</p><ol><li><p>基于预编译的扩展,望文生义👀,它是需要&quot;<strong>编译</strong>&quot;的,<strong><code>setup.py</code>是一个基于<code>setuptools</code>的编译脚本,需要编写它,以指明实际需要编译的扩展</strong>(<u>模块名也是在这个脚本中被指定的</u>).在这个脚本,可以指明**<code>CppExtension</code><strong>和</strong><code>CUDAExtension</code>**这两种不同的扩展,以适配不同的机子,还可以指明扩展的名字,扫描头文件的路径,库的路径,等等.<strong>通过这个脚本,我们会形成最终的nvcc/g++命令,对扩展文件进行编译</strong></p><p>最终执行指令以进行编译:<strong><code>python setup.py build_ext --inplace</code></strong></p><p>一个<code>setup.py</code>的模板👀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># setup.py</span><br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><span class="hljs-keyword">from</span> torch.utils.cpp_extension <span class="hljs-keyword">import</span> BuildExtension,CUDAExtension<br><br>setup(<br>name = <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment"># 包名</span><br>    ext_modules = [<br>        name = <span class="hljs-string">&#x27;&#x27;</span>,   <span class="hljs-comment"># 扩展模块名</span><br>        sources = [<span class="hljs-string">&#x27;&#x27;</span>],   <span class="hljs-comment"># 源文件 可以用glob.glob()找到match的文件</span><br>        include_dirs = [],     <span class="hljs-comment"># 头文件搜索路径</span><br>        extra_complile_args = &#123;<span class="hljs-string">&#x27;cxx&#x27;</span>:[<span class="hljs-string">&#x27;&#x27;</span>],<span class="hljs-comment"># 其他编译选项</span><br>                              <span class="hljs-string">&#x27;nvcc&#x27;</span>:[<span class="hljs-string">&#x27;&#x27;</span>],&#125;<br>    ],<br>    cmdclass = &#123;<span class="hljs-string">&#x27;build_ext&#x27;</span>:BuildExtension&#125;<br>)<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: <code>python setup.py</code>后面的<code>build_ext --inplace</code>是干啥的呢?可以把<code>build_ext</code>理解成是构建这么一个扩展模块;而<code>--inplace</code>则是编译后的扩展模块放在当前的目录中?</p><p><img src="https://s2.loli.net/2024/10/02/rkpb3it1BzDLVgh.png" alt="setuptools-cython2ext_module" /></p>          </div></li><li><p>扩展文件被编译了,即形成了二进制文件,这个二进制文件在python中是怎么调用到它的呢?通过<strong>pybind11</strong>这个库来实现的,它是一个用来在c<ins>代码中创建python的连接的库.宏定义**<code>PYBIND11_MODULE</code>**为c</ins>代码接入python解释器提供了入口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">PYBIND11_MODULE</span>(TORCH_EXTENTION_NAME,m)&#123;<span class="hljs-comment">// TORCH_EXTENSION_NAME是模块名称 // m是模块实例</span><br> m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;&quot;</span>,,,py::<span class="hljs-built_in">arg</span>(),);   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>TORCH_EXTENTION_NAME</code>是在<code>setup.py</code>脚本中的扩展模块名(即python中的module名),对应的是编译命令中的<code>-DTORCH_EXTENTION_NAME=...</code>这个宏</li><li><code>m</code>是扩展模块的实例,<strong><code>&#123;&#125;</code>中的每个<code>m.def</code>都定义了一个扩展模块的成员函数</strong>,一般形式为:<strong><code>m.def(&quot;函数名&quot;,具体函数的函数指针,&quot;文档&quot;,参数列表)</code></strong></li></ul></li></ol></li><li><p><strong>实时编译</strong></p><p><mark>未写</mark></p></li></ul><p>在PyTorch中增加CPP/CUDA扩展的操作说完了,但是我们知道PyTorch中有个很常用到的数据类型叫<code>Tensor</code>,那我们在CPP/CUDA扩展中怎么模拟或者说有没有得直接使用这个数据结构呢?</p><p><strong>我们可以通过<code>#include &lt;torch/extension.h&gt;</code>就可以在扩展中调用所有PyTorch支持的功能</strong>.有三大命名空间:<code>c10</code>(Caffe Tensor Library),<code>at</code>(A Tensor Library),<code>torch</code>.翻看别人项目或是算子的源码,多用的是torch这个namespace</p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/348555597">PyTorch 源码解读之 cpp_extension</a></li><li><a href="https://zhuanlan.zhihu.com/p/656762043">Pytorch+cpp/cuda extension</a></li><li><a href="https://pytorch.org/cppdocs/api/classat_1_1_tensor.html#exhale-class-classat-1-1-tensor">PyTorch_CPP_API_CLASS_TENSOR</a></li><li><a href="https://pytorch.org/cppdocs/api/library_root.html">PyTorch_CPP_API</a></li><li><a href="https://zhuanlan.zhihu.com/p/460233022">Python打包分发工具setuptools</a></li><li><a href="https://blog.csdn.net/xiqi4145/article/details/114216162">build_ext --inplace 是什么意思</a></li><li><a href="https://zhuanlan.zhihu.com/p/603275573">vscode配置&lt;torch/extension.h&gt;的include path</a></li></ul><h2 id="库与函数"><a class="markdownIt-Anchor" href="#库与函数"></a> 库与函数</h2><h3 id="cublas_v2"><a class="markdownIt-Anchor" href="#cublas_v2"></a> cublas_v2</h3><p>这里主要说下cublas咋用,以及会遇到的问题,以<strong>cublasSgemm</strong>为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">cublasStatus_t <span class="hljs-title">cublasSgemm</span><span class="hljs-params">(cublasHandle_t handle,</span></span><br><span class="hljs-params"><span class="hljs-function">                           cublasOperation_t transa, cublasOperation_t transb,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>           *alpha,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>           *A, <span class="hljs-keyword">int</span> lda,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>           *B, <span class="hljs-keyword">int</span> ldb,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span>           *beta,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">float</span>           *C, <span class="hljs-keyword">int</span> ldc)</span></span><br></code></pre></td></tr></table></figure><p>在提及具体的函数使用前,首先说下元素排放的问题</p><p><strong>cublas中的元素存储是列主序排放的(沿袭了Fortran的老习惯),那我们是以行主序构建的矩阵,怎么让cublas正确理解呢</strong>：</p><p>我们知道比如一个6个float的元素,排在数组里:[0,1,2,3,4,5]</p><ul><li><p>给它弄成2x3的行主序矩阵：[[0,1,2],[3,4,5]];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">0 1 2<br>3 4 5<br></code></pre></td></tr></table></figure></li><li><p>给它弄成2x3的列主序矩阵：[[0,2,4],[1,3,5]];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">0 2 4<br>1 3 5<br></code></pre></td></tr></table></figure></li><li><p>给它弄成3x2的列主序矩阵：[[0,3],[1,4],[2,5]]，则<strong>此时是行主序阵的转置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">0 3<br>1 4<br>2 5<br></code></pre></td></tr></table></figure></li></ul><p>显然,<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow></msub><mo>=</mo><msubsup><mi>A</mi><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">A_{col} = A_{row}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.088331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>,列主序的阵A和我们行主序阵A的转置,理解起来是一样的</strong></p><p>以下给出两个方案,在调用cublasSgemm时以得到期望的结果</p><ul><li><p>方案一</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>B</mi><mi>T</mi></msup><mo>×</mo><msup><mi>A</mi><mi>T</mi></msup><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mo>&lt;</mo><mo>=</mo><mo>=</mo><mo>=</mo><mo>&gt;</mo><msup><mi>C</mi><mi>T</mi></msup><mo>=</mo><msup><mi>B</mi><mi>T</mi></msup><mo>×</mo><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">C = A \times B = (B^T \times A^T)^{T} &lt;===&gt; C^T  = B^T \times A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><br />因此在传参的时候可以利用这种方法给它弄成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mi>T</mi></msup><mo>=</mo><msup><mi>B</mi><mi>T</mi></msup><mo>×</mo><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">C^T = B^T \times A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>，这样计算结果C阵就是原来阵的转置</p><p>根据上面的式子可以理解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">B^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>是传入的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>是传入的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,则有:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> : m,n,k<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">B^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">A^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>: n,m,k<br />也要把ld也换成对应的,这里<code>lda=n;ldb=k;ldc=n</code></p><p>由于C阵得到的是转置的,那我们直接拿出来按行主序读,就直接是符合预期结果的!</p></li><li><p>方案二<br />如果不想像上面操作，觉得有点绕，也可以将cublasSgemm的<code>cublasOperation_t transa</code>和<code>transb</code>给它开起来：<code>CUBLAS_OP_T</code>（不转是<code>CUBLAS_OP_N</code>）<br />这样做，我们就把行主序的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>转置了，那实际上恰巧就是列主序的cuBLAS的阅读顺序，同时需要注意，此时的lda,ldb,ldc传入的是转置后的行数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>T</mi></msup><mo stretchy="false">[</mo><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A^T [k,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span>  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>T</mi></msup><mo stretchy="false">[</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B^T [n,k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> ，即<code>lda=k;ldb=n</code>,ldc没有转，则为<code>ldc=m</code>;需要注意,得到的C阵是按列主序排的,因此我们外面需要手动给它转置一次,或者按列主序的方式把数据对应着读出</p></li></ul><div class="note note-info">            <p>注意: 在调用<strong>cublasSgemv</strong>的时候要注意row和col需要调换,因为对A的转置会影响到向量x和向量y</p>          </div><p><strong>参考文件</strong></p><ul><li><a href="https://docs.nvidia.com/cuda/cublas/index.html#cublas-t-gemm">Nvidia-cuBLAS</a></li><li><a href="https://zhuanlan.zhihu.com/p/520616601">cublas gemm 列主序</a></li><li><a href="https://zhuanlan.zhihu.com/p/666391239">cublas,tensor core矩阵乘法基本介绍</a></li></ul><h3 id="cusparse"><a class="markdownIt-Anchor" href="#cusparse"></a> cusparse</h3><p><strong>参考文件</strong></p><ul><li><a href="https://docs.nvidia.com/cuda/cusparse/">Nvidia-cuSPARSE</a></li></ul><h3 id="线程束shuffle指令优化"><a class="markdownIt-Anchor" href="#线程束shuffle指令优化"></a> 线程束shuffle指令优化</h3><p><strong>线程束洗牌(shuffle)指令是线程束内线程通信的极佳方式:延迟极低,不消耗内存,通过束内线程相互访问寄存器以传递数据,不用再走共享内存乃至全局内存</strong></p><p><strong><code>laneID</code>(束内索引),就是一个线程束内线程的索引;<code>warpID</code>,表示线程束的ID</strong></p><p>利用block内线程号分别<code>/32</code>,<code>%32</code>来获得<code>warpID</code>,<code>laneID</code></p><p>shuffle指令分为用于<strong>整型</strong>和<strong>浮点型</strong></p><ul><li><p>整型</p><ul><li><strong><code>int __shfl_sync(unsigned int mask,int var,int srcLane,int width=warpSize)</code></strong></li></ul><p><strong><code>mask</code>指示<code>width</code>大小内的线程有哪些线程参与运算</strong>;<strong><code>width</code>缺省值是32,即一个warp的大小,它可以取值为2,4,8,16,32</strong>;比如<code>mask</code>取<code>0xffffffff</code>,表示32个线程都参与运算,如果LSB取0则表示0号线程不参与计算;<strong><code>var</code>表示当前线程提供的值</strong>;<strong><code>srcLane</code>是进行广播的<code>laneID</code>,它广播的值通过返回值承接</strong></p><p>具体来说,比如<code>srcLane</code>选3,就是把线程束内 (之所以是线程束内,是因为默认的width是warpSize,是不是线程束内要看这个width,不然就是width+srcLane作为偏移值,比如width是16,则srcLane对于[0,15]是3,对于[16,31]是19(3+16)) 束内线程索引为3的变量var的值进行广播,给width内的所有线程;</p>  <div class="note note-info">            <p>注: 个人感觉这个width更像是分组,默认warpSize为一组,当然你想自定义也OK,就设置它的值(2,4,8,16,32这几个数里选).同时<strong>需要注意,这个srcLane本质上应该是<code>srcLane=srcLane%width</code></strong>,它可以做到环绕移动(通过<code>srcLane= threadIdx.x+offset</code>使得整个width内的数一起转圈圈,转的步数是offset)</p>          </div></li><li><p><strong><code>int __shfl_up_sync(unsigned int mask,int var,unsigned int delta,int width=warpSize)</code></strong><br /><strong>这个函数取的值是:当前调用线程的束内线程编号减去delta编号的线程的var值,如果变负值(取的数的束内线程号)则保持原来自己的值</strong>;</p><div class="note note-info">            <p>注: 叫up可能是因为前面的束内线程把值往前给</p>          </div><ul><li><p><strong><code>int __shfl_down_sync(unsigned int mask,int var,unsigned int delta,int width=warpSize)</code></strong><br />上面的反转版,这里变成了<strong>调用线程的束内线程号+delta(<code>warpId + delta</code>)</strong>,从这个束内线程号取值,当然<strong>如果越了width,则保持原值</strong>;</p><div class="note note-info">            <p>注: 叫down可能是因为后面的束内线程把值往后给</p>          </div></li><li><p><strong><code>int __shfl_xor_sync(unsigned int mask,int var, int laneMask,int width=warpSize)</code></strong><br />这个指令很神奇,<strong>调用线程的束内线程号和laneMask值做异或,得到的就是目标线程的束内线程号,然后目标线程会把它的var通过返回值给调用线程</strong><br />之所以说神奇,是因为laneMask比如取1,得到的是butterfly exchange</p></li></ul></li><li><p>浮点型</p><p>无需改函数名,已有重载,只需把var的int改成float即可</p></li></ul><p>​以下给出示例代码,其中使用了<code>__shfl_xor_sync()</code>指令来对一个总长度为32的数组,每个线程管理长度为4的数组做一个<code>laneMask=0x00000001</code>的大蝴蝶交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARRAY_SIZE 32</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST_SIZE 4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MASK 0xffffffff</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LANEMASK 0x00000001</span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* src,<span class="hljs-keyword">int</span>* dst)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> idx = threadIdx.x * TEST_SIZE;<br>    <span class="hljs-keyword">int</span> arr[TEST_SIZE];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;TEST_SIZE;i++)<br>        arr[i] = src[idx+i];<br>    __syncwarp();<br>    arr[<span class="hljs-number">0</span>] = __shfl_xor_sync(MASK,arr[<span class="hljs-number">0</span>],LANEMASK,warpSize);<br>    arr[<span class="hljs-number">1</span>] = __shfl_xor_sync(MASK,arr[<span class="hljs-number">1</span>],LANEMASK,warpSize);<br>    arr[<span class="hljs-number">2</span>] = __shfl_xor_sync(MASK,arr[<span class="hljs-number">2</span>],LANEMASK,warpSize);<br>    arr[<span class="hljs-number">3</span>] = __shfl_xor_sync(MASK,arr[<span class="hljs-number">3</span>],LANEMASK,warpSize);<br>    <span class="hljs-comment">// printf(&quot;arr[]:%d&quot;,arr[0]);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;TEST_SIZE;i++)<br>        dst[idx+i] = arr[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">size_t</span> sizeArray = ARRAY_SIZE * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>);<br>    <span class="hljs-keyword">int</span>* hSrc = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(sizeArray);<br>    <span class="hljs-keyword">int</span>* hDst = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(sizeArray);<br>    <span class="hljs-keyword">int</span>* dSrc,*dDst;<br>    <span class="hljs-built_in">cudaMalloc</span>(&amp;dSrc,sizeArray);<br>    <span class="hljs-built_in">cudaMalloc</span>(&amp;dDst,sizeArray);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ARRAY_SIZE;i++)<br>        hSrc[i] = i;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ARRAY_SIZE;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,hSrc[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">cudaMemcpy</span>(dSrc,hSrc,sizeArray,cudaMemcpyHostToDevice);<br><br>    shuffle&lt;&lt;&lt;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&gt;&gt;&gt;(dSrc,dDst);<br><br>    <span class="hljs-built_in">cudaMemcpy</span>(hDst,dDst,sizeArray,cudaMemcpyDeviceToHost);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ARRAY_SIZE;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,hDst[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">cudaFree</span>(dSrc);<br>    <span class="hljs-built_in">cudaFree</span>(dDst);<br>    <span class="hljs-built_in">free</span>(hSrc);<br>    <span class="hljs-built_in">free</span>(hDst);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实验结果如下:</p><p><img src="https://s2.loli.net/2024/07/07/DPN327Hiqd5QMp6.png" alt="test-__shfl_xor_sync" /></p><div class="note note-info">            <p>注: 上面的代码中的<code>__shfl_xor()</code>一类的函数,在CUDA11.x上进行编译的时候报warning,说要用<code>__shfl_xor_sync()</code></p>          </div><h2 id="算子系列"><a class="markdownIt-Anchor" href="#算子系列"></a> 算子系列</h2><h3 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce</h3><p>reduce即为所说的规约操作,较为正式的说法是在一串数据中采用满足结合律的二元操作符最终得到一个结果,而这个操作符一般是求和,求均值,求最大最小值.下面以求和操作为例</p><p>通俗的说就是给定一个长度为n的数组,对n个数进行累加,得到的结果便是规约的结果</p><h3 id="gemm"><a class="markdownIt-Anchor" href="#gemm"></a> GEMM</h3><h4 id="分块双缓冲smem-bank-conliftregister-bank-conflict待解决"><a class="markdownIt-Anchor" href="#分块双缓冲smem-bank-conliftregister-bank-conflict待解决"></a> 分块+双缓冲+smem bank conlift+register bank conflict[待解决]</h4><p>GEMM的优化主要有两个思想:<strong>分块</strong>以及<strong>双缓冲</strong>,同时在其中对A阵进行<strong>打包</strong>,并采用<strong>向量化访存</strong>.做到上述这些操作,已经可以达到cuBLAS的**93%**了.在讨论具体怎么做前，回顾下最朴素的做法：</p><p>朴素的做法是一个线程处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>阵的一个元素，<strong>这需要访问global memory:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi><mo>∗</mo><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2k*m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>次</strong>，很明显，你得频繁访问global memory，这是latency最大的一层存储,这样的开销很大</p><h5 id="分块思路"><a class="markdownIt-Anchor" href="#分块思路"></a> 分块思路</h5><p><strong>我们应该尽量利用GPU的<em>global memory - shared memory - register</em>的存储结构进行分块存储</strong></p><img src="https://s2.loli.net/2024/07/27/dxEze15Nh7Ywtro.png" alt="gpu_gemm_optimize" style="zoom:50%;" /><p>按照上图进行划分，<strong>1个block处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大小的阵</strong>（黄方格），我们可以把A阵的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的小矩阵和B阵的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的小矩阵（浅蓝块）移动到shared memory上，这样整个C阵被划分为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>m</mi><msub><mi>b</mi><mi>m</mi></msub></mfrac><mo>∗</mo><mfrac><mi>n</mi><msub><mi>b</mi><mi>n</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{m}{b_m} * \frac{n}{b_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.140492em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.140492em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个block,每个block需要访问global memory <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><mfrac><mi>k</mi><msub><mi>b</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">(b_m*b_k + b_k*b_n) * \frac{k}{b_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.330968em;vertical-align:-0.4508599999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4508599999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 次,化简一下可得:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>m</mi></msub><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">(b_m + b_n)*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p><p>因此可知,此时的访问global memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><msub><mi>b</mi><mi>m</mi></msub></mfrac><mo>+</mo><mfrac><mn>1</mn><msub><mi>b</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m*n*k*(\frac{1}{b_m} + \frac{1}{b_n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>.可见,随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的变大,访问global memory的次数越少</p><p>目前来说,一般是将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均取值为128,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则取值为8(<mark>为什么这样取值啊❓</mark>)</p><p>那既然我们可以把数据腾挪到shared memory上,如果移到register岂不更快,由此我们对黄方格进一步划分(以下针对block进行讨论),我们让1个线程处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub><mo>×</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_m \times t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大小的矩阵.则此时我们可以计算下如果不对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行分块,依旧是每个线程处理黄方格的一个元素,则需要访问shared memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">2 * b_k * b_m * b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而进行分块后,一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>b</mi><mi>m</mi></msub><msub><mi>t</mi><mi>m</mi></msub></mfrac><mo>×</mo><mfrac><msub><mi>b</mi><mi>n</mi></msub><msub><mi>t</mi><mi>n</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{b_m}{t_m} \times \frac{b_n}{t_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个线程,每个线程需要访问shared memory次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>m</mi></msub><mo>+</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">(t_m + t_n)*b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,则该block访问shared memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><msub><mi>t</mi><mi>m</mi></msub></mfrac><mo>+</mo><mfrac><mn>1</mn><msub><mi>t</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_m * b_n * b_k * (\frac{1}{t_m} + \frac{1}{t_n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>,显然随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的增大,单个block访问shared memory的次数会变少</p><p>根据经验<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均取8(<mark>为啥?</mark>)</p><p>梳理一下上面的信息:我们为了减少访问global memory以及shared memory的次数,对C矩阵进行了两次分块,分别将数据搬运到shared memory和register上去,一次的数据搬运量分别是$b_m * b_k $ + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k * b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(这是对于block的,将数据搬运到smem上去);<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(这是对于thread的,将数据从smem搬运到自己的register上去),而我们给出了详细的参数配置:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><msub><mi>b</mi><mi>n</mi></msub><mo>=</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">b_m=b_n=128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><msub><mi>t</mi><mi>m</mi></msub><mo>=</mo><msub><mi>t</mi><mi>n</mi></msub><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">b_k=t_m=t_n=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>,由此可以计算出来一个block里的线程数目是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>∗</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">16 * 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>,共计256个线程</p><h5 id="计算正确性"><a class="markdownIt-Anchor" href="#计算正确性"></a> 计算正确性</h5><p>谈论完分块,谈论一下<strong>计算的准确性</strong>,因为分块后的计算你得算得对才有意义,不然优化得再快也没用.</p><p>从外部来看,我们的黄方格是由多个对应的浅蓝块进行外积累加而成(上图左侧);而黄方格内部是通过每个线程计算对应的深绿块得到的,而深绿块是通过对应的天蓝色块的外积累加而成.由此得到的深绿色块是符合计算原理的,而由深绿色块组成的黄方格也是符合计算原理的,因此整个计算过程是可以得到与内积相同的结果,具备计算的正确性</p><h5 id="如何搬运所需的数据"><a class="markdownIt-Anchor" href="#如何搬运所需的数据"></a> 如何搬运所需的数据</h5><p>那计算是正确的,就要想想分块后的数据应该怎么拿到:</p><p>首先是怎么把数据从global memory搬运到shared memory上的,目前我所使用的是V100,得绕一圈才能把数据放到shared memory上:<strong>从global memory经由register再放到shared memory上,因此每个block内的线程就需要各自负责对应的数据搬运</strong>,把计算所需的A分块的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和B分块的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>搬运到临时的寄存器区域存储,然后放到共享内存去</p><p>这其中可以利用float4来进行向量化访存,同时A阵搬到reg后,再搬回smem时,可以做手动转置,以便于后续reg访问smem时可以利用向量化访存来获取数据;B阵则直接搬到reg,不用转置,直接存回smem即可</p><img src="https://s2.loli.net/2024/07/28/cqbdYjmQKMPW5yg.png" alt="tiled_gmem2smem_packedA" style="zoom:50%;" /><p>那么smem到reg中的数据,则是由每个线程从共享内存中取对应的数据,下图中展示的是block内的0号线程,它需要取左边的在smem上的A阵的8个元素,需要取右边的在smem上的B阵的8个元素,由于smem上的A阵已经转置了,所以可以理解为它重排成按列存储,然后沿着箭头的方向进行迭代,则可以算出0号线程负责的8x8矩阵的值</p><img src="https://s2.loli.net/2024/07/28/3fzoFhjaureYSiO.png" alt="tiled_smem2reg" style="zoom:50%;" /><h5 id="进行双缓冲"><a class="markdownIt-Anchor" href="#进行双缓冲"></a> 进行双缓冲</h5><p>如果按照上面的方式,我们需要定位到当前这个block负责的区域:<code>tmpA</code>和<code>tmpB</code>;</p><p>然后在大迭代中(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的迭代)先将数据搬运到smem上,然后再在小迭代中(每个线程1列数据和1行数据,直到滑到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)把数据从smem搬运到reg上,然后再计算出对应的8x8阵,并累加;</p><p>可以看出,这样的计算方式并不能很好的发挥出计算单元的性能,因为你每次都得取当前要用的数据,然后再计算;</p><p>因此可以用双缓冲来处理这个问题:每次预取下一轮要计算的数据,然后当前要用的数据已经准备好了,即整个流程变为:</p><ol><li>预取数据,放入smem和reg中,需要注意,我们的数组开了原先的两倍,用于分别存储下一轮要用的数据和当前轮使用的数据;</li><li>大迭代中先预取下一轮SMEM的数据;</li><li>小迭代中预取下一次计算的数据,放入reg中;</li><li>小迭代计算</li><li>直到大迭代计算完毕,则将数据存回C阵对应的区域中(tmpC)</li></ol><p>为什么双缓冲这种机制会被支持呢?因为ld/st单元和计算的单元是两个不同的部件</p><p><strong>当我们根据上述的做法进行优化后,我们自制的sgemm可达cuBLAS的93%</strong></p><h4 id="smem-bank-conflict解决"><a class="markdownIt-Anchor" href="#smem-bank-conflict解决"></a> smem bank conflict解决</h4><p>我们知道在定义一个block内线程数目的时候是16x16,即<code>blockDim.x</code>和<code>blockDim.y</code>均为16,这256个线程共需要8个warp,这8个warp根据朴素的思路是按照:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"> 0    1 ...  15 <br>16   17 ...  31  --&gt;  warp0<br>... ... ... ...  --&gt;  ...<br>240 241 ... 255  --&gt;  warp7<br></code></pre></td></tr></table></figure><p>这样的方式排列的.然后我们在用线程去处理值的时候(即把smem中的数据移到reg),是通过tx,ty(<code>threadIdx.x</code>,<code>threadIdx.y</code>)来处理的,并且如0号线程它连续取8个元素(A阵和B阵各八个),以B阵来说,那4号线程就会取到32-39这八个元素,因为是采用float4,即LDS.128的方式进行向量化访存,则T0-T7属于一个quarter warp,它里面的元素会发生一个2 way bank conflict,显然我们应该消除这个smem bank conflict带来的更长的访存时间;</p><p>需要知道,<strong>warp内部的排序,并不是按照上述朴素思路那样规规矩矩进行排列的,我们只需要在x和y这俩方向上各排够16个线程即可,warp内部的顺序,可以是朴素思路的那种规规矩矩2x8的排列,也可以是根据优化需要自己编排出来的如4x8/8x4的warp内线程排布方式,你只要按照你排布的方式去获取值,就会得到正确的结果</strong></p><p>因此我们将warp内的排布形式变成下图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"> 0  1 | 16 17<br> 2  3 | 18 19<br> 4  5 | 20 21<br> 6  7 | 22 23<br>-------------  <br> 8  9 | 24 25<br>10 11 | 26 27<br>12 13 | 28 29<br>14 15 | 30 31<br></code></pre></td></tr></table></figure><p>当我们按照这种z-order式以8x4的形式排列warp内部线程的时候,我们可以将整个warp的memory transaction由原先的8个变为2个(对B而言),减少了访存的时间开销</p><p>因此在这种warp内部的排列下,将8个warp排好,如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">warp0 | warp1 | warp2 | warp3<br>warp4 | warp5 | warp6 | warp7<br></code></pre></td></tr></table></figure><p>则满足了x和y方向上的线程各16的要求,然后求出对应的warpId和laneId,取对应的值进行计算,不过需要注意,这里我们把内部的8x8拆成了4个4x4计算,如下图示:</p><img src="https://s2.loli.net/2024/07/28/vtNbw7MP9BxlT1y.png" alt="resharp_warp" style="zoom:50%;" /><p><strong>当解决了shared memory bank conflict之后,我们的性能就能达到cuBLAS的95.6%了(M=N=K=4096)</strong></p><h4 id="register-bank-conflict"><a class="markdownIt-Anchor" href="#register-bank-conflict"></a> register bank conflict</h4><p><mark>暂时没有胆量去碰触SASS,还在积累,希望能看懂PTX和SASS</mark></p><p>这里简要说一下什么是register bank conflict,以便于我有朝一日突然兴起把这个给处理了</p><p>在Volta架构以前,我们每个SM上的RegisterFile是被分为4个bank的,对于Maxwell和Pascal架构而言,寄存器id%4得到的就是bank的id,当一条指令的源寄存器有2个以上来自同一bank,就会发生register的bank conflict,浪费1个cycle以重发射指令;</p><p>而在Volta架构开始,SM的RegisterFile被分为2个bank,只有当源寄存器id全为偶数或是奇数才会有bank conflict(<mark>?bank conflict为何会有这个东西(有的说是资源抢占问题(会影响到整体的并行性),有的说是一个cycle吞吐4B(指smem)),且2way bank和4way bank的bank conflict发生情况为何不同?</mark>)</p><p>针对于register bank conflict的解决方案有两点:</p><ul><li><p><strong>寄存器重映射</strong><br />重映射就是改变了原架构默认的register到bank的映射方式(<mark>这玩意要动哪个东西?好奇</mark>)</p></li><li><p><strong>FFMA顺序的调整</strong><br />进一步处理上述未处理完毕的寄存器bank conflict问题，通过<strong>指令重排</strong>来实现，并辅以<strong>reuse</strong>这个control code，类似于将某一个寄存器放进reuse cache，然后下一轮从reuse cache中获取，而避免了register的bank conflict</p><p>这一步是在sass汇编上进行操作的,操作完毕之后,找个大佬实现的汇编器给它生成机器码</p></li></ul><h3 id="gemv"><a class="markdownIt-Anchor" href="#gemv"></a> GEMV</h3><h3 id="spmv"><a class="markdownIt-Anchor" href="#spmv"></a> SPMV</h3><p>SpMV,即稀疏矩阵向量乘,在cuSPARSE中它的公式形式是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>α</mi><mo stretchy="false">(</mo><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">y = \alpha(op(A)x) + \beta y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,我们自己写的时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>直接用<code>1.0f</code>,<code>0.0f</code>;</p><p>稀疏矩阵A乘于稠密的x,得到稠密的y,这是SpMV的描述,跟上面写过的gemv不同的地方在于A阵是稀疏的了,那稀疏的A阵,就代表它里面的非零元素很少,那要用稀疏格式来进行存储,这里采用的是csr来存储</p><h4 id="csr"><a class="markdownIt-Anchor" href="#csr"></a> CSR</h4><p>CSR全称为Compressed Spared Row,具体的含义如下图示,可以这么理解,采用csr格式进行稀疏矩阵的存储,我们需要三个指针:<code>row offset</code>, <code>column idx</code>, <code>values</code></p><ul><li><code>values</code> 存储的是稀疏阵中的非零元素,是以行主序的方式对稀疏阵非零元素进行获取,size是非零元素的个数;</li><li><code>column idx</code> 存储的是<code>values</code>中对应的非零元素的列索引,显然这会在我们与<code>x</code>进行乘法操作时用上,size是非零元素的个数;</li><li><code>row offset</code>用于存储稀疏阵中每行第一次遇到的非零元素的在<code>values</code>中的索引,它的size是行数+1,最后一位表示的是非零元素的个数</li></ul><img src="https://s2.loli.net/2024/08/02/Gk6bmo1ihnepct9.png" alt="CSR" style="zoom:80%;" /><p>那么这些稀疏阵,要在哪里获取呢 -&gt; <a href="http://sparse.tamu.edu/">稀疏阵大全</a></p><h3 id="attention"><a class="markdownIt-Anchor" href="#attention"></a> Attention</h3><h3 id="ringattention"><a class="markdownIt-Anchor" href="#ringattention"></a> RingAttention</h3><h3 id="flashattention"><a class="markdownIt-Anchor" href="#flashattention"></a> FlashAttention</h3><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章:</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/462191421">GPU内存(显存)的理解与基本使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/423550197">从Fermi到Amphere架构演进的特点</a></li><li><a href="https://zhuanlan.zhihu.com/p/34587739">CUDA编程入门极简教程</a></li><li><a href="https://face2ai.com/program-blog">谭升blog</a></li><li><a href="https://blog.csdn.net/qccz123456/article/details/84971157">thrust库的使用</a></li><li><a href="https://www.zhihu.com/column/c_1437330196193640448">棍子哥-深入浅出GPU优化</a></li><li><a href="https://www.zhihu.com/column/c_1139113249399345152">cloudcore-CUDA编程方法论</a></li><li><a href="https://zhuanlan.zhihu.com/p/410278370">旷世天元-CUDA 矩阵乘法终极优化指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/372973726">旷世天元-MegEngine TensorCore 卷积算子实现原理</a></li><li><a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#c-language-extensions">NVIDIA CUDA C编程手册</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>C++</tag>
      
      <tag>HPC</tag>
      
      <tag>Operator Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重庆高性能会议记录</title>
    <link href="/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="graphset-high-performance-graph-mining-through-equivalent-set-transformations"><a class="markdownIt-Anchor" href="#graphset-high-performance-graph-mining-through-equivalent-set-transformations"></a> GraphSet : High Performance Graph Mining through Equivalent Set Transformations</h2><p>GraphSet是一个通过集合等价变换来实现高性能的图挖掘</p><p>图分析问题:①图处理;②※图挖掘(比如找三角形,矩阵)<br />Pattern-Oblivious<br />※Pattern-Aware(利用结构信息,能剪枝) -&gt; NPC问题<br />变换控制流(串行部分-&gt;容斥原理??(求∩∪一类的易于并行的))为集合操作(有无依赖)[这部分应该大多是公式]</p><p>基于架构的优化:</p><ul><li>warp内共做一个集合操作</li><li>warp间独立(通过DFS遍历树)执行</li><li>CPU-GPU协同计算(预测并行度,低的丢给CPU?)</li></ul><p>论文地址: <a href="https://dl.acm.org/doi/pdf/10.1145/3581784.3613213">GraphSet : High Performance Graph Mining through Equivalent Set Transformations</a></p><h2 id="optimizing-direct-convolutions-on-arm-multi-cores"><a class="markdownIt-Anchor" href="#optimizing-direct-convolutions-on-arm-multi-cores"></a> Optimizing Direct Convolutions on ARM Multi-Cores</h2><p>优化卷积算子<br />卷积的四种优化策略:</p><ol><li><p>直接优化:{<br />引入新的张量存储格式;<br />循环优化;<br />微内核设计;<br />并行化<br />}</p></li><li><p>Im2col + GEMM</p></li><li></li><li><p>FFT</p></li></ol><p>ARMv9对DL算子优化度不高</p><p>相关工作(18-23):<br />LIBXSMM-&gt;XNNPACK-&gt;Ansor-&gt;MOpt-&gt;mGEMM-&gt;MBDC</p><p>现有瓶颈:</p><ul><li>主流框架兼容性 -&gt; NCHW(实际上应该是NHWC)</li><li>转换开销 -&gt; 打包</li><li>连续访存降低性能 -&gt; 重叠</li><li>粗粒度的并行策略 -&gt; 细粒度</li><li>基于GEMM的微内核,寄存器复用次优 -&gt;(计算微内核+打包微内核)</li></ul><p>论文地址: <a href="https://eprints.whiterose.ac.uk/202768/1/sc23-2.pdf">Optimizing Direct Convolutions on ARM Multi-Cores</a></p><h2 id="dasp-specific-dense-matrix-multiply-accumulate-units-accelerated-general-sparse-matrix-vector-multiplication"><a class="markdownIt-Anchor" href="#dasp-specific-dense-matrix-multiply-accumulate-units-accelerated-general-sparse-matrix-vector-multiplication"></a> DASP: Specific Dense Matrix Multiply Accumulate Units Accelerated General Sparse Matrix-Vector Multiplication</h2><p>SpMV 稀疏矩阵A*稠密向量x = 稠密向量</p><p>SpMV三部分的开销:1.随机访问向量x;2.A的非零元和对应x的计算;3.读写其他数组</p><p>mma指令处理8*8矩阵</p><p>论文地址: <a href="https://www.ssslab.cn/assets/papers/2023-lu-DASP.pdf">DASP: Specific Dense Matrix Multiply Accumulate Units Accelerated General Sparse Matrix-Vector Multiplication</a></p><h2 id="optimizing-mpi-collectives-on-shared-memory-multi-cores"><a class="markdownIt-Anchor" href="#optimizing-mpi-collectives-on-shared-memory-multi-cores"></a> Optimizing MPI Collectives on Shared Memory Multi-Cores</h2><p>论文地址: <a href="https://eprints.whiterose.ac.uk/202767/1/sc23-1.pdf">Optimizing MPI Collectives on Shared Memory Multi-cores</a></p><h2 id="tetris-accelerating-sparse-convolution-by-exploiting-memory-reuse-on-gpu"><a class="markdownIt-Anchor" href="#tetris-accelerating-sparse-convolution-by-exploiting-memory-reuse-on-gpu"></a> Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU</h2><p>论文地址: <a href="">Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU</a></p><h2 id="liger-interleaving-intra-and-inter-operator-parallelism-for-distributed-large-model-inference"><a class="markdownIt-Anchor" href="#liger-interleaving-intra-and-inter-operator-parallelism-for-distributed-large-model-inference"></a> Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference</h2><p>论文地址: <a href="">Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference</a></p><h2 id="easyscale-elastic-training-with-consistent-accuracy-and-improved-utilization-on-gpus"><a class="markdownIt-Anchor" href="#easyscale-elastic-training-with-consistent-accuracy-and-improved-utilization-on-gpus"></a> EasyScale: Elastic Training with Consistent Accuracy and Improved Utilization on GPUs</h2><p>论文地址: <a href="https://dl.acm.org/doi/pdf/10.1145/3581784.3607054">EasyScale: Elastic Training with Consistent Accuracy and Improved Utilization on GPUs</a></p><div class="note note-info">            <p>以上有论文地址的都是中了SC的，中了PPoPP的好像没挂地址出来，这里没有去找arXiv</p>          </div><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>从目前的SC和PPoPP接收的情况来看,以下领域是高性能计算中的热点工作:</p><ul><li><strong>图挖掘、图处理</strong></li><li><strong>SpMV</strong></li><li><strong>算子优化</strong></li><li><strong>分布式推理</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Graph Mining</tag>
      
      <tag>Graph Processing</tag>
      
      <tag>MLSys Inference</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎知识(持续更新)</title>
    <link href="/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="python-u是啥"><a class="markdownIt-Anchor" href="#python-u是啥"></a> python -u是啥</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.stdout.write(<span class="hljs-string">&quot;correct1&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error1&quot;</span>)<br>sys.stdout.write(<span class="hljs-string">&quot;correct2&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error2&quot;</span>)<br></code></pre></td></tr></table></figure><p>stdout是标准输入,stderr是标准错误,一般来说,标准错误没有缓存区,会直接输出到屏幕上;而stdout会有缓存区,即当出现换行符或者到达一定长度才会输出到屏幕,而增加**-u<strong>这个短指令即是使得stdout变为</strong>unbuffered**,使得我们的代码顺序即为输出顺序</p><p><mark>在python3.6.8的解释器下执行,感觉好像默认了unbuffered</mark>😕</p><h2 id="pty何物是也为啥一些指令都有它"><a class="markdownIt-Anchor" href="#pty何物是也为啥一些指令都有它"></a> pty何物是也,为啥一些指令都有它</h2><p>关于tty(终端，是一种字符型设备，名字源于teletypewriter，电传打字机)：</p><p>pty:pseudo terminal伪终端</p><h2 id="串口并口"><a class="markdownIt-Anchor" href="#串口并口"></a> 串口并口</h2><p>串口（串行接口）：一次传输一位数据，较为稳定，可进行长距离通信（串行口COM1,COM2）<br />并口（并行接口）：一次传输八位数据，但受长度限制，因为长度越长会增加干扰，数据容易出错</p><p>详情可见<a href="https://zhuanlan.zhihu.com/p/622677267">硬件基础：硬件通信常见的串口介绍</a></p><h2 id="什么是异构"><a class="markdownIt-Anchor" href="#什么是异构"></a> 什么是异构</h2><p>异构计算（Heterogeneous Computing）是一种特殊的并行分布式计算系统。它能够经济有效地实现高计算能力，可扩展性强，能够非常高效地利用计算资源。与之相对的概念就是同构计算（Homogeneous Computing），也就是为大家熟知的多核理念。为了突破计算算力受制于功耗的瓶颈，多核CPU技术得到越来越多的应用。强大的CPU采用越来越多的CPU内核这就是传统同构计算系统。很快人们就发现在AI人工智能和自动驾驶爆炸式增长的计算需求下，传统同构计算系统已经无法满足要求，GPU、DSP、FPGA和ASIC由于特定需求下高效性越来越多的被应用。而异构计算技术应运而生，像一个大厨将CPU、GPU、DSP、FPGA和ASIC(Application Specific Integrated Circuit，应用专用集成电路，主流有TPU、NPU、VPU、BPU芯片等)这些优良食材制成一道融合各方口味特点的佳肴<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/63207620/answer/1707221853">[1]</span></a></sup>。</p><ol><li><p>计算场景异构（通俗意义上的异构计算）<br />CPU+GPU/DPU<br />DPU：是对网卡和存储等数据的高效处理<br />何为计算场景的异构呢，就是本来应该是CPU处理的场景，现在解耦出来由专门的芯片进行处理。</p></li><li><p>计算性能的异构<br />相比于传统的X86芯片的同构多核，ARM在芯片架构上进行创新，采用了异构多核的芯片架构，芯片里面的核心分了大小核</p></li><li><p>CPU架构的异构<br />应该就是采用X86，ARM，RISC-V，Alpha，LoongArch等不同的CPU架构</p></li></ol><h2 id="进制单位转换"><a class="markdownIt-Anchor" href="#进制单位转换"></a> 进制单位转换</h2><p><img src="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg" alt="multiple-byte units" /></p><p>左侧代表的是十进制前缀，右侧表示的是二进制前缀</p><p>一般是制造商采用十进制，对于我们来说<strong>存储一般指的是二进制</strong>的，而在说到<strong>带宽一类的速率时，指的是十进制的</strong></p><h2 id="local目录"><a class="markdownIt-Anchor" href="#local目录"></a> ./local目录</h2><p>.local相当于跟全局的python环境进行了一层的隔离，在这里我们可以安装自己需要的库（在本地范围内），而无需提权<br />类似的安装方式大致如下：<br /><code>pip install target=~/.local/lib/python3.8/site-packages &lt;package-name&gt;</code><br />参考自：<a href="https://blog.csdn.net/m0_67402026/article/details/125241407">https://blog.csdn.net/m0_67402026/article/details/125241407</a></p><p>当然，如果知道有多个解释器，也可以安装到对应的解释器的位置，如：<br /><code>D:\path\to\python.exe -m pip install --user &lt;package-name&gt;</code><br />参考自：<a href="https://blog.csdn.net/ThsPool/article/details/132809683">https://blog.csdn.net/ThsPool/article/details/132809683</a></p><p>参考:<a href="https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html">https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html</a></p><h2 id="linux软硬链接"><a class="markdownIt-Anchor" href="#linux软硬链接"></a> linux软硬链接</h2><p>关于linux软链接的创建删除更新，可以这么理解，Linux的软链接相当于快捷方式 ，硬链接好像会共享原来的inode<br />以下是参考文章：<a href="http://www.mobiletrain.org/about/BBS/151003.html">http://www.mobiletrain.org/about/BBS/151003.html</a></p><h2 id="site-packages和distpages区别"><a class="markdownIt-Anchor" href="#site-packages和distpages区别"></a> site-packages和distpages区别:</h2><p><a href="https://blog.csdn.net/weixin_40614261/article/details/90023807">https://blog.csdn.net/weixin_40614261/article/details/90023807</a></p><h2 id="vimrc配置"><a class="markdownIt-Anchor" href="#vimrc配置"></a> vimrc配置</h2><p>注意,要查看vimrc在哪可以在一个利用vim打开的文件内通过:version查看,往下滑动可以看到vimrc文件一般配置在:<br />/etc/vimrc<br />~/.vimrc</p><h2 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h2><p>module全称:<strong>module-environment</strong>是一个用于<strong>管理环境变量的工具</strong></p><h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3><ul><li><code>module avail</code>查看所有的模块</li><li><code>module load/add 需要加载的模块</code>加载需要加载的模块</li><li><code>module unload/rm 需要卸载的模块</code> 卸载需要卸载的模块</li><li><code>module list</code> 列出已加载的模块</li><li><code>module show 模块</code> 查看指定的模块信息</li></ul><p><a href="https://www.fasteda.cn/post/22.html0">Linux 下 Module 工具的介绍与使用</a></p><h2 id="iterableiteratorgenerator"><a class="markdownIt-Anchor" href="#iterableiteratorgenerator"></a> iterable,iterator,generator</h2><p>关于python中iterable,iterator,generator:<a href="https://blog.csdn.net/weixin_44966641/article/details/131501576">https://blog.csdn.net/weixin_44966641/article/details/131501576</a></p><h2 id="不同操作系统的多线程"><a class="markdownIt-Anchor" href="#不同操作系统的多线程"></a> 不同操作系统的多线程</h2><p>Windows用spawn,Unix用fork,主要区别见下文:</p><p><a href="https://www.cnblogs.com/CJTARRR/p/17742597.html">fork和spawn区别</a></p><h2 id="__getattr__-__getattribute_"><a class="markdownIt-Anchor" href="#__getattr__-__getattribute_"></a> __getattr__ __getattribute_</h2><h2 id="descriptor描述器之__get__-__set__-__delete__"><a class="markdownIt-Anchor" href="#descriptor描述器之__get__-__set__-__delete__"></a> descriptor(描述器)之__get__ __set__ __delete__</h2><p><a href="https://www.cnblogs.com/andy1031/p/10923834.html">一些魔法方法</a></p><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><p><a href="https://www.cnblogs.com/tobyqin/p/python-decorator.html">python装饰器1</a></p><p><a href="https://zhuanlan.zhihu.com/p/640193185">python装饰器2</a></p><h3 id="常用装饰器"><a class="markdownIt-Anchor" href="#常用装饰器"></a> 常用装饰器</h3><p>这里介绍三个常用的装饰器语法糖,需注意函数指的是非类方法,方法指的是类内的方法,分为实例方法,类方法,静态方法</p><p><a href="https://zhuanlan.zhihu.com/p/544021480">方法分类及三个常用装饰器语法糖</a></p><ul><li>@property</li></ul><p><a href="https://blog.csdn.net/yingxuanzhang/article/details/125071269">property装饰器详解</a></p><ul><li>@classmethod</li><li>@staticmethod</li></ul><h2 id="类属性和实例属性"><a class="markdownIt-Anchor" href="#类属性和实例属性"></a> 类属性和实例属性</h2><h2 id="一般属性和私有属性"><a class="markdownIt-Anchor" href="#一般属性和私有属性"></a> 一般属性和私有属性</h2><p>参考文章：</p><h2 id="常量表达式constexpr"><a class="markdownIt-Anchor" href="#常量表达式constexpr"></a> 常量表达式constexpr</h2><h2 id="c的lambda表达式"><a class="markdownIt-Anchor" href="#c的lambda表达式"></a> c++的lambda表达式</h2><p>c++11引入的,主要的写作构造如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) specifiers exception -&gt; type &#123; function body &#125; <br></code></pre></td></tr></table></figure><ul><li><code>capture list</code>,捕获列表,捕获我们作用域中的变量,有值捕获(=),引用捕获(&amp;),混合捕获:<ul><li>如[a,b]表示值捕获a,b变量,以const方式;</li><li>如[&amp;a]表示引用捕获a变量,可修改值;</li><li>如[=]/[&amp;]表示值/引用捕获作用域的所有变量</li></ul></li><li><code>parameter list</code>,参数列表,传参嘛</li><li><code>specifiers</code>,限定符,少用,可忽视</li><li><code>exception</code>,异常说明符,少用,可忽视</li><li><code>-&gt; type</code>,返回值</li><li><code>function body</code>,函数体</li></ul><p>使用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-keyword">int</span> i) -&gt; pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || i == n)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,nums&#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">get(i) 返回一个二元组/键值对,用来处理数组边界,比如nums[-1]/nums[n] (注:n == nums.size())</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="fma和mac"><a class="markdownIt-Anchor" href="#fma和mac"></a> FMA和MAC</h2><p>MAC(Multiply-Accumulation):乘积累加运算</p><p>FMA(fused-multiply-add):融合乘加运算</p><p>它俩实现的都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>←</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leftarrow a+b*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>这么一个操作,只用一条指令就可以完成(否则要用两条嘛),当然有相搭配的硬件(如乘数累加器)</p><p>不同之处在于MAC要规约2次,FMA规约1次即可(更精准,更快速,但也有一些问题)</p><p>参考文件:<a href="https://blog.csdn.net/qq_39444290/article/details/124939546">FMA和MAC区别</a></p><h2 id="ldd"><a class="markdownIt-Anchor" href="#ldd"></a> ldd</h2><p>这是一条神奇的指令,可以查看可执行文件所需要的动态库(<code>.dll</code>,<code>.so</code>)</p><p><code>ldd file</code></p><img src="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png" alt="ldd file" style="zoom:67%;" /><h2 id="神奇的环境变量名"><a class="markdownIt-Anchor" href="#神奇的环境变量名"></a> 神奇的环境变量名</h2><h3 id="ld_library_path"><a class="markdownIt-Anchor" href="#ld_library_path"></a> LD_LIBRARY_PATH</h3><p>在终端通过<code>echo $LD_LIBRARY_PATH</code>可以看到一些路径,这些路径是<strong>用于指定共享库/动态链接库的搜索路径</strong>.因此如果在运行可执行文件时报有<code>.so</code>或<code>.dll</code>库找不到的错误,可以通过ldd指令查看是否有库没有被找到</p><p>如果想添加一些别的动态库搜索路径,可以通过在<code>~/.bashrc</code>文件中导出环境变量,并用<code>source ~/.bashrc</code>刷新一下bashrc文件,即可实现</p><p>导出环境变量可以加在bashrc文件末尾,如:</p><p><code>export LD_LIBRARY_PATH=/lib:$LD_LIBRARY_PATH</code></p><p>其中:是路径的分隔符</p><p>参考文件:<a href="https://blog.csdn.net/qq_44534541/article/details/135500799">Linux环境变量LD_LIBRARY_PATH配置</a></p><h2 id="gdb小工具使用方法"><a class="markdownIt-Anchor" href="#gdb小工具使用方法"></a> GDB小工具使用方法</h2><p><strong>要使用GDB来进行代码调试以完成错误定位，在进行编译的时候要加上<code>-g</code>的选项</strong></p><p>生成可执行文件后，<strong>通过<code>gdb filename</code>的方式进行gdb调试程序</strong></p><p>首先<strong>通过<code>l</code>(list缩写)来查看当前程序的代码</strong></p><div class="note note-info">            <p>一般终端无输入即按回车是重复上一条指令</p>          </div><p><strong>通过<code>break funcName</code>来设置断点，也可以通过<code>break lineNum</code>行数来设置断点。可以通过<code>info break</code>来查看断点设置情况</strong></p><p><strong>执行<code>r</code>(run缩写)执行程序，程序会执行到端点处暂停，然后通过<code>n</code>(next缩写)单步越过执行/<code>s</code>(step缩写)单步步入执行，可以通过<code>c</code>(continue缩写)来直接执行到下一个断点处,又或者通过<code>u lineNum</code>(until缩写)来移动到执行的行数</strong></p><p><strong>通过<code>q</code>(quit退出调试程序)</strong></p><p>若是在执行到某一个函数内部,排查好了问题,想回到原函数,可以<strong>通过<code>finish</code>完成函数剩下的指令返回</strong>,也可以通过<code>return</code>立刻返回,不执行后面的指令</p><p>**如何调试内联汇编?**这是gdb对于算子开发的一个最重要的作用,因为别的错误我们好排查,而一旦牵扯到内联汇编,可能涉及到内存,寄存器的问题:</p><p>我们可以<strong>通过<code>layout asm</code>显示汇编代码的窗口</strong>,我们只需要打断点到指定的内联汇编开头,然后开启这个窗口,<strong>通过<code>si</code>(step instruction),单步执行指令</strong>,然后可以通过<code>p</code>(print)或display(更推荐)来指定一些想要观察的变量或寄存器(寄存器需要<code>display $v0</code>加个<code>$</code>),通过display的话每次执行一条指令都会打印我们跟踪的变量和寄存器的结果,这对于调试内联汇编代码非常有用,可以帮助我们观察一些寄存器和变量的实时变化情况</p><p><strong>参考文件:</strong></p><ul><li><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">GDB调试程序参考</a></li><li><a href="https://blog.csdn.net/litanglian9839/article/details/84966811">GDB-layout-1</a></li><li><a href="https://blog.csdn.net/zhangjs0322/article/details/10152279">GDB-layout-2</a></li><li><a href="https://blog.csdn.net/wohu1104/article/details/125083029">GDB一些参考</a></li></ul><h2 id="c之const的位置"><a class="markdownIt-Anchor" href="#c之const的位置"></a> c++之const的位置</h2><p><strong>const默认作用于其左边的东西,否则作用于其右边的东西</strong></p><blockquote><p>const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.</p></blockquote><p>例子:</p><ul><li><p><code>const int *</code>是一个指针指向一个常量整型 a pointer to a constant integer</p></li><li><p><code>int* const</code> 是一个常量指针指向一个整型 a constant pointer to an integer</p></li><li><p><code>int const * const</code> 是一个常量指针指向一个常量整型 a contanst pointer to a constant integer</p></li><li><p><code>...</code></p></li></ul><p>可以通过<strong>从右往左读</strong>的方式来理解,然后一般写的时候也建议按照<strong>eastern const style</strong>(把const放东边/右边)来写</p><div class="note note-info">            <p>注:看的时候脑子冒出来左结合右结合,搜了一下,<strong>结合性是为了处理具有相同优先级的运算符时,确定他们在表达式中结合的顺序</strong></p><p>左结合即是指在一个表达式中有多个具有相同优先级的运算符,它们在表达式中从左到右依次结合,如:<code>a + b + c</code> -&gt; <code>(a + b) + c</code></p><p>右结合即是指具有相同优先级的多个运算符在表达式中从右到左依次结合,如:<code>a = b = c</code> -&gt; <code>a = ( b = c)</code></p><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/weixin_47441055/article/details/131384865">结合性,左结合,右结合</a></li></ul>          </div><p><strong>参考文件:</strong></p><ul><li><a href="https://www.zhihu.com/question/443195492/answer/1723886545">const位置摆放</a></li></ul><h2 id="c之namespace"><a class="markdownIt-Anchor" href="#c之namespace"></a> C++之namespace</h2><ol><li><strong>全局范围内定义</strong>,通过<code>namespace ns_name&#123;...&#125;</code>这样定义,不可以局部范围内定义;</li><li><strong>namespace可嵌套</strong>;</li><li><strong>namespace目的:避免命名冲突</strong>;</li><li>我们要使用某一命名空间内的变量/函数时:<ul><li><strong>用::(作用域限定符)来获得,如std::cin</strong>;</li><li><strong>命名空间全部展开</strong><mark>不推荐</mark><code>using namespace std;</code>;</li><li><strong>命名空间部分展开</strong><code>using std::endl;</code></li></ul></li></ol><div class="note note-info">            <p>其中作用域限定符有:全局范围的,类范围的,也有namespace范围的,使用如下:</p><ul><li>global scope: <code>::var</code></li><li>class scope: <code>class::var</code></li><li>namespace scope: <code>namespace::var</code></li></ul><p>通过访问左侧的scope来知道想要访问的var是哪里的</p>          </div><p><strong>参考文件:</strong></p><ul><li><a href="https://blog.csdn.net/2202_75303754/article/details/131782875">c++ namespace</a></li><li><a href="https://www.cnblogs.com/holm/articles/13715169.html">作用域限定符</a></li></ul><h2 id="c之左值纯右值将亡值"><a class="markdownIt-Anchor" href="#c之左值纯右值将亡值"></a> C++之左值,纯右值,将亡值</h2><ul><li><strong>左值(left-hand-side value)简称lvalue</strong></li><li><strong>纯右值(pure right-hand-side value)简称prvalue</strong></li><li><strong>将亡值(expiring value)简称xvalue</strong></li></ul><p>三者的由来与函数返回值相关:</p><ul><li><strong>直接存在寄存器里返回</strong></li><li><strong>直接操作用于接收返回值的变量(函数返回值转换为出参,由函数内部直接操作外部的栈空间)</strong></li><li><strong>使用匿名空间接收函数返回值,这是一个临时的内存空间,用完即析构</strong></li></ul><p>prvalue,lvalue,xvalue对应上述三种情况.</p><p>这三种值的出现与C<ins>是C的extension有关,C</ins>的结构体乃至类增加了构造函数和析构函数,并将之与变量的生命周期进行绑定有关</p><p>详细情况参看参考文件中腾讯技术工程对这一块的讲解</p><p><strong>参考文件:</strong></p><ul><li><a href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C++要分左右值</a></li></ul><h2 id="c平凡类型与非平凡类型"><a class="markdownIt-Anchor" href="#c平凡类型与非平凡类型"></a> c++平凡类型与非平凡类型</h2><p><strong>参考文件:</strong></p><ul><li><a href="https://blog.csdn.net/vviccc/article/details/138089766">C++11 内存布局术语解读（平凡类型、平凡可复制类型、标准布局类型）</a></li></ul><h2 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h2><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/650986900">C++11新特性</a></li></ul><h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2><p>参考文件:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/670068158">智能指针</a></li></ul><h2 id="elf文件格式了解"><a class="markdownIt-Anchor" href="#elf文件格式了解"></a> ELF文件格式了解</h2><p>ELF(Excutable Linkable Format)是linux下可执行文件的存储格式,是COFF(Comman File Format)的一种变体</p><p>目标文件,动态库,静态库以及可执行文件都用ELF文件格式来进行存储</p><p>一般二进制文件的存储格式中都有文件头,是通过读文件头来确认如何解析文件(个人感觉文件头存储了许多的元数据)</p><p>补Elf64_Ehdr和Elf64_Shdr,前者是ELF文件头,里面有比如段表(节头表Section Header Table)的信息,比如有多少个段,段大小,段偏移;后者则是记录每个段表的元信息</p><p>参考文件:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/544198038">从零解析ELF目标文件(附源码)</a></li><li><a href="https://blog.csdn.net/qq_42570601/article/details/124695589">链接装载与库：第三章——ELF文件结构</a></li></ul><h2 id="decltype和auto"><a class="markdownIt-Anchor" href="#decltype和auto"></a> decltype和auto</h2><p>参考文件:</p><ul><li><a href="https://www.jianshu.com/p/17503803561e">深入解析decltype和decltype(auto)</a></li><li><a href="https://www.cnblogs.com/linxmouse/p/17567763.html">C++11容易遗忘的特性整理与理解</a></li></ul><h2 id="name-mangling的解释工具"><a class="markdownIt-Anchor" href="#name-mangling的解释工具"></a> name mangling的解释工具</h2><p>反汇编出的汇编代码,它会有一坨怪怪的东西,比如<code>_Z3addPiPb</code>之类的,这个东西又大概知道它应该是个函数名,这玩意可以通过<code>c++filt</code>或是<code>cu++filt</code>来给它还原,比如:</p><p><img src="https://s2.loli.net/2024/08/15/mIl78OekFQasEx1.png" alt="read-name-mangling-tool" style="zoom:67%;" /><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/63207620/answer/1707221853">https://www.zhihu.com/question/63207620/answer/1707221853</a><br /><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>little-knowledge-of-loadable-kernel-module</title>
    <link href="/2023/11/15/little-knowledge-of-loadable-kernel-module/"/>
    <url>/2023/11/15/little-knowledge-of-loadable-kernel-module/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>How-to-use-slurm</title>
    <link href="/2023/11/15/How-to-use-slurm/"/>
    <url>/2023/11/15/How-to-use-slurm/</url>
    
    <content type="html"><![CDATA[<h2 id="slurm是什么"><a class="markdownIt-Anchor" href="#slurm是什么"></a> slurm是什么</h2><p>slurm</p><h2 id="基础用法"><a class="markdownIt-Anchor" href="#基础用法"></a> 基础用法</h2><h2 id="slurm脚本编写"><a class="markdownIt-Anchor" href="#slurm脚本编写"></a> slurm脚本编写</h2><p>参考文章:<br />1.<a href="https://zhuanlan.zhihu.com/p/216153362">Slurm概述架构</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>slurm</tag>
      
      <tag>distribution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Initial bash usage</title>
    <link href="/2023/11/15/Initial-bash-usage/"/>
    <url>/2023/11/15/Initial-bash-usage/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PipeDream-Partition-Algorithm</title>
    <link href="/2023/11/03/PipeDream-Partition-Algorithm/"/>
    <url>/2023/11/03/PipeDream-Partition-Algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="pipedream划分算法理论部分"><a class="markdownIt-Anchor" href="#pipedream划分算法理论部分"></a> PipeDream划分算法理论部分</h2><p><strong>PipeDream会在可用的机器间自动划分模型的层以最小化整体的训练时间</strong></p><p>以下是PipeDream划分算法的工作流程图，不难看出PipeDream对输入的DNN采用PipeDream Profiler进行profile，会获得每一个层的相关数据（下面对profile过程会细讲），之后输入一定数目的机器给PipeDream optimizer，在其上面执行划分算法和确定重复因子。至此，便完成了PipeDream对DNN的划分。</p><p><img src="https://s2.loli.net/2023/11/28/IZoDzmGyEqfCjTB.png" alt="PipeDream partition algorithm workflow" /></p><p>PipeDream划分算法的大致流程如下：对一个给定的N层DNN和M台可用的机器</p><ol><li><strong>PipeDream首先在一个机器上对模型进行profile；</strong></li><li><strong>执行划分算法将层划分为stage；</strong></li><li><strong>同时确定每个stage的重复因子以最小化模型的整体训练时间。</strong></li></ol><h3 id="profile-dnn模型"><a class="markdownIt-Anchor" href="#profile-dnn模型"></a> Profile DNN模型</h3><p>profile是用来记录每个层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>的一些指标的，这里记录的是：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的前向和反向传递的总计算时间</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层在前向传递时的输出激活的大小/在反向传递时输入梯度的大小</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">w_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层参数的大小</li></ul><p>其中在PipeDream中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是通过多个mini-batch来统计得出的</p><p>而所有的通信都分三个步骤进行：</p><ol><li>将数据从GPU移到发送方的CPU；</li><li>发送数据，从发送到发送到接收方；</li><li>将数据从CPU移到接收方的GPU。</li></ol><p>显然2相较于1和3更耗时长，采用2来估计通信所需花费的时间，即是用该层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>除于对应的带宽，即可以得到层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>到层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>通信所需花费的时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">C_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>而每个worker（计算节点）在配置有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>台机子做数据并行的通信量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{4(m-1)*|w_l|}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，这个通信量是采用AllReduce计算而得的，则利用一个分布式参数服务器来为该层做权重同步所花费的时间为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>l</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">W_l^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9664379999999999em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span></p><div class="note note-info">            <p>因为朴素的AllReduce和Ring AllReduce一类的通信量是一样的，只是解决了存在的带宽瓶颈问题。这里就以AllReduce的来进行通信量计算</p><p>某一个server（本身也是一个worker，比如是rank0）接收所有worker的参数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，而后将更新后的参数返还给所有worker：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，其中该过程采用FP16来存储参数，故总通信量为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">4(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，每个worker的通信量则为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{4(m-1)*|w_l|}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>          </div><h3 id="划分算法"><a class="markdownIt-Anchor" href="#划分算法"></a> 划分算法</h3><p>划分算法是在profile完成后进行的，会用到profile的输出结果</p><p>我们的目标是<strong>最小化模型整体的训练时间即等价于最小化最慢stage的时间</strong></p><p>这里介绍划分算法中涉及到的几个概念：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表示在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">1\rightarrow j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层间使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个机子最优流水线的最慢stage所花费的时间；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>i</mi><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(i\rightarrow j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表示一个单独的stage在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\rightarrow j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层，采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个机子做数据并行所花费的时间，其中该时间计算公式如下：(之所以采用二取一是因为通信和计算存在重叠，不用add起来)<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p></li></ul><p>此外，这里还涉及了一个让流水线处于繁忙状态的**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>O</mi><mi>A</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NOAM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><strong>，即</strong>最优的mini-batch数目**，通过如下公式计算而得：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>O</mi><mi>A</mi><mi>M</mi><mo>=</mo><mfrac><mi>M</mi><mrow><mi>m</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>s</mi><mspace width="1em"/><mi>i</mi><mi>n</mi><mspace width="1em"/><mi>t</mi><mi>h</mi><mi>e</mi><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mspace width="1em"/><mi>s</mi><mi>t</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">NOAM=\frac{M}{machines\quad in\quad the\quad input\quad stage}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3534389999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>其中动规的公式分为只有一个stage和多个stage的情况：</p><ul><li><p>一个stage</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,m) = T(1\rightarrow j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>多个stage</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲\begin{split}…'>\begin{align*}\begin{split}A(j,m) = \min_{1\le i\lt j} \min_{1\le m` \lt m} \max \left \{\begin{array}{}A(i,m-m`) &amp;①\\ 2*C_i &amp;②\\T(i+1 \rightarrow j,m`) &amp;③\\ \end{array}\right .\end{split}\end{align*}</p></li><li></li></ul><p>显然我们是在①、②、③这三个公式，找到此时的最慢stage，而后改变行列（行对应层数，列对应数据并行的机子数），找到<strong>最优流水线的最慢stage</strong>。因为是采用动态规划处理，而动态规划具有<strong>最优子结构、无后效性和重叠子问题三大性质</strong>,因此即使是子问题，所求得的结果也是最优的(<strong>最优子结构</strong>)，最后的结果是在最优的子问题上进行叠加的，而后续问题的发展又不会影响到子问题的解(<strong>无后效性</strong>)，而采用表格存储可以避免重复计算(重叠子问题)。当然后续一些多维并行的也会用到动态规划，但会采取融合算子，剪枝等方式减少搜索空间，因为PipeDream的是二维的，且空间很小，所以没用到相应技巧。</p><p>以下是动规的初始化部分，当完成了初始化后，便可以代入上式的公式进行计算，计算到终止条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(N,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>时则会停止</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(1,m) = T(1\rightarrow 1,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m \in [1,M]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,1) =T(1\rightarrow j,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span></li></ul><h2 id="pipedream划分算法代码部分"><a class="markdownIt-Anchor" href="#pipedream划分算法代码部分"></a> PipeDream划分算法代码部分</h2><h3 id="profilesup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream-profile"><a class="markdownIt-Anchor" href="#profilesup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream-profile"></a> 🔷profile<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream-Profile</h3><p>&quot;&gt;[1]</span></a></sup></p><p>profile的目的是获得每个层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">w_l,T_l,a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，主要的函数调用步骤如下：</p><ol><li>在<strong>训练</strong>的时候先获取<code>summary</code>，这个函数(<code>torchsummary.summary()</code>)可以计算网络的参数信息，然后调用<code>create_graph()</code>，这个函数的目的在于通过内部的调用，生成模型的DAG图；</li><li><code>create_graph()</code>内部会调用<code>torchgraph.GraphCreator()</code>，构造一个<code>GraphCreator</code>实例，这个实例的类内部定义了相关的钩子函数<code>hook_modules()</code>，可以为模型的子模块设置钩子，以追踪其内部的关联信息，然后利用<strong>模型运行</strong>，获得该信息，最后<code>unhook_modules()</code>把给子模块设置的钩子撤掉，并将profile的结果通过该类内部的<code>persist_graph()</code>方法给持久化成.dot,.txt,.pdf等类型，便于后续使用；</li><li><code>GraphCreator</code>的实例记作<code>graph_creator</code>,在初始化的时候，会把<code>model</code>,<code>module_whitelist</code>,<code>summary</code>这些作为实例变量，同时增加了<code>forward_original_methods</code>这个字典用来存储子模块和子模块的原生<code>forward</code>方法，还增加了<code>graph</code>类的实例。还有个<code>inputs</code>字典，用来存储<mark>好像是</mark>子模块和子模块经由<code>TensorWrapper</code>包装后的tensor；</li><li><code>graph_creator</code>实例通过调用<code>hook_modules()</code>这个方法，该方法内部通过调用<code>forward_wrapper()</code>和<code>forward_wrapper_root()</code>方法，来将子模块和模型的<code>forward</code>进行替换：<code>sub_module.forward = forward_wrapper().__get__(sub_module,sub_module.__class__)</code>。而这俩方法内部，分别将子模块和模型设置为<code>Tensorwrapper</code>（<mark>这一块的代码看不大懂，输入的是<code>sub_module</code>，但好像用作tensor？（之后debug看下这部分内在怎么运行的）</mark>），并且为图构造边；</li><li>上面说到的<code>TensorWrapper</code>,它内部根据我们输入的<code>node_desc</code>，就是对节点的形容，来判断并从<code>summary</code>中获取对应元素，获取它的forward pass和backward pass的时间，激活大小，参数大小等，包装为<code>_node</code>这个成员变量；</li><li>当模型运行后，获得了profile信息（<strong>整个模型的内部DAG图的构造是在<code>forward_wrapper()</code>这个function里完成的</strong>），采用persist_graph()给持久化成.dot文件（可视化一下），也持久化成.txt，便于后续使用。</li></ol><h3 id="compute-partitionsup-idfnref2-classfootnote-refa-hreffn2-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream计算分区"><a class="markdownIt-Anchor" href="#compute-partitionsup-idfnref2-classfootnote-refa-hreffn2-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream计算分区"></a> 🔷compute partition<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream计算分区</h3><p>&quot;&gt;[2]</span></a></sup></p><p>在计算分区的部分有两个很重要的概念,一个是<strong>增强反链</strong>,一个是<strong>后继反链</strong></p><p><strong>计算增强反链的目的是,更好的计算节点的时间</strong>,即将一个节点的增强反链内的节点视作一个大节点(或者说视作统一的一个状态),它们的输出激活也统一看待.</p><p>**怎么样去找到一个节点的增强反链呢?**首先我们是将本节点纳入到它对应的增强反链的list中,然后在它这个节点的全部前序节点中,找到有分叉的节点,且分叉节点的出边目的节点不在全部前序节点中且也不是本节点,则这个分叉节点就可以加入到该节点的增强反链中去.</p><p>**为什么要找这样的分叉点呢?**我们的模型是可以流水线并行的,也就是说对于节点而言,它的运行时间实际上是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo stretchy="false">{</mo><mtext>输入时间</mtext><mo separator="true">,</mo><mtext>执行时间</mtext><mo separator="true">,</mo><mtext>输出时间</mtext><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">max{\{输入时间,执行时间,输出时间\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord"><span class="mopen">{</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">}</span></span></span></span></span>这三个时间中找到最大值,那么对于一个节点的输入,它如果前序节点中存在分叉节点,这个分叉节点要输出数据给至少两个节点,那么这其中是否存在依赖关系是不可而知的,就比如另一个传完了,我才可以将结果向本节点输出,那因为未知,所以把它当作一个整体来考虑则更为妥当.计算出来节点的时间会更加精准合适.</p><p><strong>计算后继反链的目的是找到下一个图分割点</strong></p><p>**怎么去找到一个节点的后继反链呢?**首先,找到该节点的增强反链,获取增强反链中节点的出边的目的节点(后继嘛,就是后面的节点,且这个后继反链是相对于增强反链而言的,所以用增强反链中的去找),根据输入的节点的<code>antichain</code>过滤一波,剩下的预备役后继节点,一个个抓出来,跟增强反链一起丢进一个函数判断是否能成为后继节点,即判断预备役后继节点的successor与增强反链是否存在交集,不存在则说明这个预备役后继节点后面走的路不会又绕回去,则它是一个真正的后继节点.如此判断,将它们加入到对应的dict中.</p><p>而把这两个概念使用在一起的时候是当我们**建立<code>antichain_dag</code>**的时候</p><p><strong>如何建立<code>antichain_dag</code></strong>:</p><p>在graph里有个<code>antichain_dag()</code>,通过这个建立,主要的逻辑是:</p><ol><li>获取sources中的第一个源点,构造其的<code>&#123;tuple(sorted(antichain)) : AntichainNode&#125;</code>(这里的<code>antichain</code>就是[node8]这样的东东,然后将这个antichain去实例化AntichainNode类,就得到了<code>antichain_mapping</code>中的一个item);</li><li>然后把这个用AntichainNode实例后的<code>source_node</code>加入到<code>antichain_dag.source</code>中</li><li>把antichain置入<code>antichain_queue</code>中,后期做类似bfs的操作用到它,把1中的item加入<code>antichain_mapping</code>中</li><li>在类bfs的循环中,通过pop出首个antichain,然后获取它的后继反链,遍历后继反链中的节点,如果没有在<code>antichain_mapping</code>中的话就给它实例化为反链节点(AntichainNode),然后加入mapping中,并将其与antichain构造边(antichain-&gt;next_antichain,反链DAG中的边,注意它的这个节点是antichain和next_antichain对应的AntichainNode实例),然后把这个后继节点加入队列中.</li></ol><p>如此循环,这个反链DAG就完成了,有以下需要注意的:</p><ul><li>因为构建顺序是先增强反链(AntichainNode)后后继反链,所以如果节点antichain在后继反链dict中说明已经被记录过了,则直接continue就好;</li><li>如果后继节点在<code>antichain_mapping</code>里面,说明前面给它构建过反链节点(AntichainNode)了(因为一个节点有可能是多个节点的后继节点),但依旧需要构建新的边,就是你新的大节点/状态,它们对这个后继节点都有指向,这也对应了前面说的找后继节点,就是找图分割点;</li></ul><p><strong>总的来说<code>antichain_dag</code>中的节点就是原生节点对应反链节点(增强反链形成的大节点/状态),而关系,即边的连接则是原dag中的antichain和next_antichain,就是原DAG中的原节点和后继反链节点形成的关系,不过是用反链节点link起来的</strong>(<mark>感觉就是原DAG去了环(其实也不是,因为DAG本来就没环…,只是一种形状上的描述,找不到好的词语形容,自己画图感受),所谓的环通过增强反链替代成大节点,后继反链则是找到大节点的出边节点</mark>)</p><p>计算分区初步做的事情分为以下四步:</p><ol><li>去掉输入的source.因为输入就在第一层,之后convert model再加上,不用让optimizer决定放哪;</li><li>去掉无用的输出,就是sink中<code>node_desc</code>为(<code>__getitem__</code>)这种的;</li><li>构建<code>antichain_dag</code>;</li><li>对<code>antichain_dag</code>进行拓扑排序</li></ol><p>在经过对<code>antichain_dag</code>进行拓扑排序后,可以得到<strong>顺序执行的线性序列</strong>,由<code>states</code>承载.</p><div class="note note-info">            <p>此处对上面的过程做一个总结:</p><p>在<code>antichain_dag()</code>中,我们通过对profile生成的DAG(注意此时已对作为输入的source和无用的sink进行删除)获取它结点的增强反链,并构成<code>AntichainNode</code>,然后找到它的后继反链,对后继反链的结点生成<code>AntichainNode</code>,然后构造<code>AntichainNode[antichain]=&gt;AntichainNode[next_antichain]</code>的边,循环迭代,构造完反链DAG</p><p>据上可知增强反链是反链DAG节点的一个重要属性,而原DAG是依据后继反链来划分的反链节点,而后对反链DAG做拓扑排序(实际就是对增强反链做拓扑排序),最终得到states,states是反链节点的一个list,拓扑排序好了的.</p>          </div><p>获得了states,就到了<strong>自动分区</strong>的部分</p><p>在开始正式自动分区的介绍前,就是进入<code>compute_partitioning()</code>之前,有如下举动:</p><ul><li>计算了每个state的<strong>输出激活值大小</strong>,就是<strong>根据它们的增强反链的节点的输出激活值大小,来累加到<code>states[i].output_activation_size</code></strong>.这里的<strong>输出激活值大小是state的必要前序节点给自己的输出</strong>;</li><li>计算了每个state的<strong>计算时间,激活值大小,参数值大小</strong>,通过遍历原dag每个state的前置节点以进行累加;</li></ul><p>上面这些都是作为state的属性/成员变量而存在的.比如:</p><p><code>state.output_activation_size</code> <code>state.compute_time</code> <code>state.activation_size</code> <code>state.parameter_size</code></p><p><mark>需要注意:<code>output_activation_size</code>和<code>activation_size</code>是不一样的</mark></p><ul><li>计算了个<strong>总输出激活值大小<code>output_activation_sizes</code></strong>;</li><li>计算了<strong>每个state在反链dag的前序节点<code>all_predecessor_ids</code></strong></li></ul><p><mark>需要注意:这里的前序节点是反链DAG的</mark></p><ul><li>计算了states之间的计算时间,激活值大小,参数值大小,这是一个二维数组,表示的是<code>i-&gt;j</code>的时间,激活值,参数值,大致形式如下:</li></ul><p><img src="https://s2.loli.net/2024/03/14/FyRl7a9Vv8Qm31Y.jpg" alt="states之间的差" /></p><p>比如第一行,表示的是<code>state0-&gt;state[0,...,n-1]</code>所花费的计算时间/激活值大小/参数值大小;</p><p>第二行则代表的是<code>state1-&gt;state[1,...,n-1]</code>所花费的计算时间/激活值大小/参数值大小;就是要减去<code>state0</code>的值.以此类推~</p><hr /><p>在开始进入到<code>compute_partitioning()</code>这个函数前,有两个变量不是很懂是干嘛的,希望看完之后可以弄懂==<code>counter</code> <code>num_machines_in_machine</code>==,通过遍历机器集和带宽,进行多次计算分区</p><p><strong>🔷 计算分区(根据dp找最优化结果)<code>compute_partitioning</code></strong></p><p><strong>🔷 分析分区(根据最优化结果做分区)<code>analyze_partitioning</code></strong></p><h3 id="convert-modelssup-idfnref3-classfootnote-refa-hreffn3-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream转换模型"><a class="markdownIt-Anchor" href="#convert-modelssup-idfnref3-classfootnote-refa-hreffn3-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream转换模型"></a> 🔷convert models<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream转换模型</h3><p>&quot;&gt;[3]</span></a></sup></p><h3 id="runtimesup-idfnref4-classfootnote-refa-hreffn4-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream运行时引擎"><a class="markdownIt-Anchor" href="#runtimesup-idfnref4-classfootnote-refa-hreffn4-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream运行时引擎"></a> 🔷runtime<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream运行时引擎</h3><p>&quot;&gt;[4]</span></a></sup></p><h2 id="pipedream划分算法代码中使用到的自定义类解析"><a class="markdownIt-Anchor" href="#pipedream划分算法代码中使用到的自定义类解析"></a> PipeDream划分算法代码中使用到的自定义类解析</h2><h3 id="graph类"><a class="markdownIt-Anchor" href="#graph类"></a> Graph类</h3><p>PipeDream中的Graph类有的属性和方法大致介绍:<br />涉及到的一些名字介绍:</p><ul><li>source -&gt; 源点,入度为0的点</li><li>sink -&gt; 汇点,出度为为0的点</li><li><strong>链是指节点集合,且里面的节点间是存在单向可达的关系</strong>,即要么x到y是可达的,或者y到x是可达的</li><li><strong>反链是指节点集合,且里面的节点间是不可达的</strong>,即x到y是不可达的且y到x是不可达的</li></ul><p>属性部分:</p><ul><li><p>edges 边dict(出边,key对应的是箭尾的点,value是个list,对应的是箭头的点)</p></li><li><p>in_edges 边dict(入边,key对应的是箭头的点,value是个list,对应的是箭尾的点)</p></li><li><p>nodes 节点dict</p></li><li><p>_predecessors 前序节点dict</p></li><li><p>_successors 后继节点dict</p></li><li><p>_augmented_antichains 增强反链dict <code>&#123;Tuple(Node.node_id) : List[Node.node_id]&#125;</code></p><div class="note note-info">            <p><strong>增强反链 = 当前节点 + 部分前序节点</strong></p><p>找增强反链的部分前序节点的方法:</p><ol><li>获取当前节点的全部前序节点</li><li>若前序节点的出边目的节点不在当前节点的全部前序节点中,也不是当前节点,则将其加入增强反链中</li></ol><p>总之,<strong>增强反链中的部分前序节点,是存在分叉的节点,且其分叉的去向与当前节点的已走过的路径无关</strong></p>          </div></li><li><p>_next_antichains 后继反链dict</p><div class="note note-info">            <p><strong>后继反链的查找方式如下：</strong></p><ol><li>对输入的反链寻找增强反链；</li><li>对其增强反链进行遍历，获取增强反链节点，获取其出边对应的箭头节点</li><li>遍历出边的箭头节点们，已在反链中则不予理睬，而后进入<code>is_next_antichain()</code>进行判断</li><li>若箭头节点的后续节点不在增强反链中，则证明其为后继反链节点</li><li>将其加入输入反链作key的后继反链中</li></ol>          </div></li><li><p>_antichain_dag 反链DAG</p><p>与其说_antichain_dag是反链DAG，其内部的节点是AntichainNode类的实例，它内部的antichain代表的该节点的增强反链，而图的结构关系体现的是后继反链的关系，我们保存了它的source，根据source即可遍历出每一个节点对应的后继反链，可以依次整理出<code>antichain_mapping</code>的关系，这个mapping即是<code>&#123;Tuple(Node.node_id) : AntichainNode&#125;</code>的关系</p></li></ul><p>方法部分:</p><ul><li>copy() # 复制一张新图</li><li>sources() # 返回一个源点列表</li><li>sinks() # 返回一个汇点列表</li><li>add_node()</li><li>remove_node()</li><li>reset() # 重置前序节点集和后继节点集</li><li>add_edge()</li><li>remove_edge()</li><li>to_dot() # 生成dot文件,即是训练模型的dag图</li><li>topological_sort() # 拓扑排序，下面那个helper也是，主要是helper递归，对antichain_dag进行拓扑排序，生成线性序列,利用<code>states</code>存储</li><li>topological_sort_helper()</li><li>augment_antichain # 根据输入的反链，寻找增强反链</li><li>deaugment_augmented_antichain() # 这个没搞懂</li><li>next_antichains() # 根据输入的反链，找到其后继反链</li><li>is_next_antichain() # 判断是否符合后继反链，通过获取输入的<code>new_node</code>的后续节点，来判断该节点的后续节点是否在输入给定的增强反链<code>augmented_antichain</code>中，若不在，则返回True，即是新的后继反链的节点</li><li>construct_antichain() # 构造新的反链，里面调用的是deaugment那个函数，然后这个方法是在后继反链节点被is_next_antichain()判断为True后调用的</li><li>antichain_dag() # 构造反链DAG，实际DAG结构体现后继反链关系，节点内部体现增强反链关系</li></ul><h3 id="node类"><a class="markdownIt-Anchor" href="#node类"></a> Node类</h3><p>属性部分:</p><ul><li>node_id 节点id号,比如<code>node58</code></li><li>node_desc 形容节点作用,比如<code>Add(inplace)</code>这样的</li><li>forward_compute_time</li><li>backward_compute_time</li><li>activation_size</li><li>parameter_size</li><li>stage_id</li><li>depth</li><li>height</li></ul><p>方法部分:</p><ul><li><p>__str__()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%s -- %s -- forward_compute_time=%.3f, backward_compute_time=%.3f, activation_size=%s, parameter_size=%.3f%s&quot;</span> % (<br>            self.node_id, node_desc, self.forward_compute_time, self.backward_compute_time,<br>            activation_size, self.parameter_size, stage_id_str)<br></code></pre></td></tr></table></figure><p>给出的一个例子:<code>node58 -- Add(inplace) -- forward_compute_time=0.000, backward_compute_time=0.000, activation_size=102760448.000, parameter_size=0.000</code></p></li><li><p>from_str() # 静态方法，</p></li></ul><h3 id="antichainnode类"><a class="markdownIt-Anchor" href="#antichainnode类"></a> AntichainNode类</h3><p><strong>该类继承了<code>Node</code>类</strong></p><p>该类在<code>antichain_dag</code>此方法内被频繁实例化，以<strong>构建后继反链节点对应的增强反链</strong>，因为<strong>后继反链节点它是要被用来作分割的</strong>，那么它如果有一些<strong>前序节点</strong>是存在<strong>分叉</strong>的，即<strong>可能存在执行的依赖关系</strong>，因此需要<strong>把这些点看作一个整体，把输出激活统一统计，存放于AntichainNode这个节点中，并且利用相关属性把增强反链涉及到的节点进行存储</strong>。</p><p>属性部分：</p><ul><li>antichain 反链，实际上这里是增强反链</li><li>output_activation_size 统计增强反链的输出激活大小</li></ul><p>方法部分：</p><ul><li><p>__str__() # 就把打印的格式给重构了一下</p><p><code>return &quot;%s -- %s&quot; % (self.node_id, self.antichain)</code></p></li></ul><h3 id="graphcreator类"><a class="markdownIt-Anchor" href="#graphcreator类"></a> GraphCreator类</h3><p>属性部分:</p><ul><li>model 模型,用于后面给子模块</li><li>module_whitelist 白名单,处于子模块白名单</li><li>summary 由torchsummary这个包的summary函数获得</li><li>forward_original_methods 以{sub_module: sub_module.forward}形式存储了原始的子模块的forward函数</li><li>graph Graph类的实例对象</li><li>inputs 这个inputs,它的kv大概是这样的:{sub_module: sub_module TensorWrapper类的实例}</li></ul><p>方法部分:</p><ul><li>hook_modules() # 给子模块加钩子函数,具体做法是通过遍历子模块,为无后继部分的子模块或是白名单中的子模块更换forward函数,通过<code>sub_module.forward = forward_wrapper.__get__(sub_module,sub_module.__class__)</code>方法来更换,此种即是使得<code>forward_wrapper(sub_module)</code>延迟触发.内部还定义了两个方法:<ul><li>forward_wrapper() # 把sub_module给包装成TensorWrapper</li><li>forward_wrapper_root()</li></ul></li><li>unhook_modules() # 利用<code>forward_original_methods</code>把<code>forward</code>函数还原</li><li>persist_graph() # 持久化图,生成<code>graph.dot</code>(可视化的dag图),生成graph.txt,保存为条状图和对应的pdf文件</li></ul><h3 id="tensorwrapper类"><a class="markdownIt-Anchor" href="#tensorwrapper类"></a> TensorWrapper类</h3><p>属性部分:</p><ul><li>tensor</li><li>object_id 这是一个全局参数</li><li>node_desc</li><li>graph_creator</li><li>activation_size</li><li>_node 这个是包装好的node</li></ul><h3 id="torchsummary库下的summary方法"><a class="markdownIt-Anchor" href="#torchsummary库下的summary方法"></a> torchsummary库下的summary方法</h3><p>这个方法是真正进行forward_compute_time等的部分,与pip的torchsummary库不一样,经由TensorWrapper整理(实际上它是把统计好的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l,a_l,w_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>信息给包装起来,通过Node类包装)</p><p>参考文章:</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/7010557652107264007">PipeDream-Profile</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/7003637901279887367">PipeDream计算分区</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://juejin.cn/post/7005168160466796552">PipeDream转换模型</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://juejin.cn/post/7006591502625275934">PipeDream运行时引擎</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>PipeDream</tag>
      
      <tag>Partition Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Read paper: ZeRO-Infinity</title>
    <link href="/2023/08/29/Read-paper-ZeRO-Infinity/"/>
    <url>/2023/08/29/Read-paper-ZeRO-Infinity/</url>
    
    <content type="html"><![CDATA[<h2 id="zero-infinity"><a class="markdownIt-Anchor" href="#zero-infinity"></a> ZeRO-Infinity</h2><h3 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h3><p>处理的是<strong>GPU内存墙</strong>的问题,是一个<strong>新的异构系统技术</strong>,利用了<strong>GPU,CPU,NVMe的内存</strong>,在有限的资源去达到史无前例的模型规模,而无需进行代码重构.同时,它能达到优异的训练吞吐量和可扩展性,<strong>不受CPU或者NVMe带宽的限制</strong></p><p>在现在的GPU集群中,能达到万亿乃至十万亿的参数量</p><p>在单个DGX-2节点上能微调万亿参数量级别的模型</p><p>超线性的可扩展性</p><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><h4 id="how-to-increase-model-scale"><a class="markdownIt-Anchor" href="#how-to-increase-model-scale"></a> How to increase model scale</h4><ul><li>训练模型的系统技术进步</li><li>并行技术如流水线并行,张量并行,ZeRO等的使用</li></ul><h4 id="why-gpu-memory-is-the-bottleneck"><a class="markdownIt-Anchor" href="#why-gpu-memory-is-the-bottleneck"></a> Why GPU memory is the bottleneck</h4><p>DeepSpeed实现的3D并行能在800张V100的卡上扩展到万亿级别的参数量,通过充分利用集群中聚合的GPU内存;对于A100的卡而言,则需要320张才可以做到万亿参数量;而若是想要训练百万亿参数量,即使GPU的内存可以翻5倍(指80GB -&gt; 400GB),也需要6K张卡才可以训练到.<strong>So GPU memory is the bottleneck</strong></p><h4 id="what-does-gpu-memory-wall-effect-data-scientist"><a class="markdownIt-Anchor" href="#what-does-gpu-memory-wall-effect-data-scientist"></a> What does GPU Memory Wall effect data scientist</h4><p>GPU内存墙也限制了Data Scientist对模型进行微调.由于模型量大,微调它们虽然比预训练的工作需要更少的GPU资源,但是也让人举步维艰.即使可以访问特定的计算资源,但是在计算节点上被分配的内存也有限,这又反过来使得想微调的模型大小受限.这样就使得没资源(大规模的GPU集群)的人,无法做大模型微调的工作</p><div class="note note-warning">            <p>原文有一句: For example fine-tuning GPT-3 would require over 8 DGX-2 nodes(128 GPUs) with 3D parallelism to just fit the model for training, even though a single DGX-2 node (16-GPUs) has enough compute to fine-tune it in a reasonable time.</p><p>不知道作者是想表达fine-tune比pre-train更cheap;</p><p>还是说即使更cheap,对大多数研究人员也内存墙;</p><p>还是指有些平台需要fine-tune的资源等价于pre-train的资源,即使可以有更合理更节省的方案</p>          </div><h4 id="3d-parallelism-lack-of-usability-and-flexibility"><a class="markdownIt-Anchor" href="#3d-parallelism-lack-of-usability-and-flexibility"></a> 3D parallelism lack of usability and flexibility</h4><p>3D并行性需要对代码重构,施加DP,PP,TP.但是PP即流水线并行它<strong>对于一些具有复杂依赖的模型无能为力</strong>,因为<strong>不能拆分为负载均衡的stage</strong></p><h4 id="unprecedented-model-scale"><a class="markdownIt-Anchor" href="#unprecedented-model-scale"></a> Unprecedented Model Scale</h4><ul><li><strong>infinity offload engine</strong></li></ul><p>GPU资源是有限,我们可以offload数据到CPU和NVMe上,以此支持训练大模型</p><ul><li><strong>memory-centric tiling</strong></li></ul><p>优化GPU内存,以支持超大参数的单个层放入GPU内存中</p><h4 id="excellent-training-efficiency"><a class="markdownIt-Anchor" href="#excellent-training-efficiency"></a> Excellent Training Efficiency</h4><ul><li><strong>bandwidth-centric partitioning</strong></li></ul><p>引入一种新的数据分区策略以利用所有设备的聚合内存带宽</p><ul><li><strong>communication overlap-centric design</strong></li></ul><p>应该是遮掩通信的开销</p><ul><li><strong>optimization for NVMe access</strong></li></ul><p>优化NVMe访问,应该是对offload数据,以及回传数据进行优化</p><h4 id="ease-of-use"><a class="markdownIt-Anchor" href="#ease-of-use"></a> Ease of Use</h4><p>无需重构代码(<mark>个人感觉是说pretrain的代码finetune无需调动</mark>),无需使用3D并行(<mark>根据contribution的说法来看,应该是不使用TP</mark>),对任意的模型架构均会自动执行训练时所需的所有通信和数据分区</p><h3 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h3><h3 id="memory-requirements"><a class="markdownIt-Anchor" href="#memory-requirements"></a> Memory Requirements</h3><p>用于深度学习训练,本文主要集中于分析基于transformer架构的模型,因为全部超过1billion参数的SOTA的模型都是基于transformer架构的.</p><p>本文的分析是基于<strong>混合精度训练</strong>以及采用<strong>Adam优化器</strong>(采用此optimizer已经变成了基于transformer模型的一个标准,因此用它)</p><p>将讨论的内存分类:</p><ul><li>model state: [optimizer state,gradient,model parameter]</li><li>residual state: 主要指的是激活(activation)内存</li></ul><p><strong>GPU的工作内存</strong>是指<strong>GPU必须的可用于支持训练的最小内存,<em>假设model and residual states可以从GPU内存中被成功的卸载</em></strong></p><h4 id="memory-for-model-states"><a class="markdownIt-Anchor" href="#memory-for-model-states"></a> Memory for Model States</h4><ul><li>parameter和gradient是用<strong>FP16</strong>来存储</li><li>optimizer states包含了momentum,variance,parameters和gradients,都是用<strong>FP32</strong>来存储</li></ul><p>因此我们可得知<strong>一个参数需要20个字节的内存</strong></p><p>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>来代表hidden dimension,用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">nl</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>表示transformer层的数目.<strong>考虑到在一个transformer块中几乎所有参数是来自块内的四个线性层</strong>:其中两个在多头注意力机制中①input -&gt; QKV ([<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">3hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]);②<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>O</mi></msup></mrow><annotation encoding="application/x-tex">W^O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span></span></span> ([<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]);剩下两个在FFN中③[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>];④[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>].因此<strong>总参数量</strong>可以表示为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>12</mn><mo>∗</mo><mi>n</mi><mi>l</mi><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">12 * nl *{hd}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>Model States所需的<strong>总内存则乘于每个参数所需的20个字节</strong>,即为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>240</mn><mo>∗</mo><mi>n</mi><mi>l</mi><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">240*nl*{hd}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="memory-for-residual-states"><a class="markdownIt-Anchor" href="#memory-for-residual-states"></a> Memory for Residual States</h4><p>Residual States主要包含的是activation memory,它的参数主要取决于模型的架构:批处理大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>s</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">bsz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>,序列长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">seq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></p><p>本文采用<strong>activation checkpoint</strong>的方式来对activation所需的内存进行减少,因此存储的是激活检查点的数据</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span></span></span></span>用于表示两个activation checkpoints间的transformer block的个数,因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mi>l</mi></mrow><mrow><mi>c</mi><mi>i</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{nl}{ci}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>表示的是激活检查点的个数</p><p>激活检查点所需的<strong>总内存</strong>为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>b</mi><mi>s</mi><mi>z</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>∗</mo><mi>h</mi><mi>d</mi><mo>∗</mo><mfrac><mrow><mi>n</mi><mi>l</mi></mrow><mrow><mi>c</mi><mi>i</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">2 * bsz * seq * hd * \frac{nl}{ci}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="model-state-working-memorymswm"><a class="markdownIt-Anchor" href="#model-state-working-memorymswm"></a> Model State Working Memory(MSWM)</h4><p>模型状态工作内存是在所有Model States卸载到CPU/NVMe上后,在最大的单个算子上执行forward/backward pass所需的最小的GPU内存</p><p>因此需要从backward pass的最大算子考虑,因为backward需要涉及到parameters和gradient</p><p>在基于transformer架构的模型中,最大的算子是[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi><mo separator="true">,</mo><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd,4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]的线性层,所需的内存大小为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>16</mn><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">16 * {hd}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>是通过FP16(2bytes)以及参数和梯度所需的参数量计算而得</p><h4 id="activation-working-memoryawm"><a class="markdownIt-Anchor" href="#activation-working-memoryawm"></a> Activation Working Memory(AWM)</h4><p>激活工作内存是在反向传播重计算时所需的内存(在执行真正的反向传播之前)</p><p>它的大小是取决于两个连续的activation checkpoints.(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表的是两个连续的激活检查点间的transformer block数目)</p><p>所需的内存大小为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mi>s</mi><mi>z</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mn>16</mn><mo>∗</mo><mi>h</mi><mi>d</mi><mo>+</mo><mn>2</mn><mo>∗</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bsz*seq*c_i*(16 * hd + 2 * attn\_heads * seq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>取1,即每个block都有个activation checkpoints</p><p><mark>其中本人并没有计算出来这个数目</mark>,计算过程如下图(仅供参考):</p><p><img src="https://s2.loli.net/2023/11/03/YlnHhujt6J9bNsG.jpg" alt="transformer_block_activation_computation" /></p><h3 id="bandwidth-requirements"><a class="markdownIt-Anchor" href="#bandwidth-requirements"></a> Bandwidth Requirements</h3><p>如果我们要将暂时用不上的数据先offload到CPU或NVMe对应的存储空间,为了确保训练效率不受影响,因此得确保带宽够用,满足带宽需求</p><p>定义以下的字符用来作为<strong>效率的度量指标</strong>:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">peak_{tp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>: 峰值计算吞吐量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>: 数据移动带宽</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>: 算术强度,是总计算量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">total\_computation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>与计算所需数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">total\_data\_movement</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>的比率,描述了每次数据移动的计算量,越高的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>则说明对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>要求越低,因为对每个加载的数据,加速器可以做更多的计算</li></ul><p>效率计算公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>+</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">efficiency = \frac{compute\_time}{compute\_time + comm\_time}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.35552em;vertical-align:-0.996em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3595199999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.996em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mrow><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">compute\_time = \frac{total\_computation}{peak_{tp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.366548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">comm\_time = \frac{total\_data\_movement}{bw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.08044em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">ait = \frac{total\_computation}{total\_data\_movement}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.39044em;vertical-align:-0.996em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.996em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>联立上述四个式子,可得:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>∗</mo><mi>b</mi><mi>w</mi></mrow><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>∗</mo><mi>b</mi><mi>w</mi><mo>+</mo><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">efficiency = \frac{ait * bw}{ait * bw + peak_{tp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.343548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在讨论<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>前,需要先量化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>.我们知道每一个transformer_block的操作都是相同的,因此可以从一个迭代中的总计算量和总数据移动量来考虑算术强度,其中model states和activation checkpoints的ait可以分开考虑(<mark>之所以分开考虑,是因为其相关的参数不同</mark>)</p><h4 id="total-computation-per-iter"><a class="markdownIt-Anchor" href="#total-computation-per-iter"></a> Total Computation per iter</h4><h4 id="ait-wrt-parameters-and-gradients"><a class="markdownIt-Anchor" href="#ait-wrt-parameters-and-gradients"></a> AIT w.r.t. Parameters and Gradients</h4><h4 id="ait-wrt-optimizer-states"><a class="markdownIt-Anchor" href="#ait-wrt-optimizer-states"></a> AIT w.r.t. Optimizer States</h4><h4 id="ait-wrt-activation-checkpoints"><a class="markdownIt-Anchor" href="#ait-wrt-activation-checkpoints"></a> AIT w.r.t. Activation Checkpoints</h4><h3 id="zero-infinity-design"><a class="markdownIt-Anchor" href="#zero-infinity-design"></a> ZeRO-Infinity design</h3>]]></content>
    
    
    
    <tags>
      
      <tag>ZeRO系列</tag>
      
      <tag>NVMe</tag>
      
      <tag>offload</tag>
      
      <tag>Data Parallelism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算卸载和计算迁移的简要介绍</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%81%E7%A7%BB%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%81%E7%A7%BB%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>边缘计算中有**计算卸载(offload)<strong>和</strong>计算迁移(migration)**这两个概念,通过翻阅网上资料以及部分论文内容,发现二者的概念非常相似,结合chatgpt3.5的说法,以下给出二者的主要区别,而关于其工作流程,性能指标,大致相似,因此则混为一谈</p><h2 id="计算迁移和计算卸载的主要区别"><a class="markdownIt-Anchor" href="#计算迁移和计算卸载的主要区别"></a> 计算迁移和计算卸载的主要区别</h2><p>计算迁移和计算卸载的主要区别在于<strong>任务去向</strong>和<strong>侧重点</strong>不同</p><ul><li><p><strong>任务去向</strong></p><ul><li>对于<strong>计算卸载</strong>,将任务的一部分或全部发送到外部设备(一般<strong>是云服务器或者别的高性能设备</strong>)来进行处理.一般进行卸载的是密集型计算的任务</li><li>对于<strong>计算迁移</strong>,将任务/应用程序从一个设备迁移到另一个设备.一般是因为<strong>资源限制,设备性能差异</strong>等因素导致的迁移</li></ul></li><li><p><strong>侧重点</strong></p><ul><li>对于<strong>计算卸载</strong>,重点在于将密集型的计算任务从本地设备移出,减轻设备负担,提高性能和能效.通过将任务卸载到强大的计算资源上,来实现任务加速和节省能耗</li><li>对于<strong>计算迁移</strong>,重点在于优化任务在不同设备间的分配,以实现更好的资源利用和性能.它着重于将任务从一个设备迁移到另一个设备上,以满足特定的需求,如资源均衡,能量管理或网络切换</li></ul></li></ul><h2 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h2><p>计算卸载/迁移为以下六个步骤:</p><ol><li>节点发现(MCC的高性能服务器或MEC服务器);</li><li>程序切割;</li><li>卸载决策(是否卸载?卸载到哪?卸载策略有静态卸载和动态卸载);</li><li>程序传输(流量/WIFI);</li><li>执行计算(服务器启动虚拟机开始计算);</li><li>计算结果回传</li></ol><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><p>目前,计算卸载/迁移的性能通常以**时间延迟(等待时间)<strong>和</strong>能量消耗(耗电)**作为衡量指标</p><p>在不执行计算卸载/迁移时:</p><ul><li>时间延迟指在移动设备执行本地计算所花费的时间;</li><li>能量消耗指在移动设备执行本地计算所消耗的能量;</li></ul><p>在执行计算卸载/迁移时:</p><ul><li><p>时间延迟指</p><p>①. 卸载数据到MEC节点的传输时间;</p><p>②. MEC节点执行处理时间;</p><p>③. 接收MEC节点的数据结果传输时间;</p></li></ul><p>① + ② + ③即是时间延迟</p><ul><li><p>能量消耗指</p><p>①. 卸载数据到MEC节点的传输能耗;</p><p>②. 接收来自MEC节点结果的传输能耗;</p></li></ul><p>① + ②即是能量消耗</p><p>一般来说,在做卸载/迁移决策时需要考虑到以上两种指标,使得最小化能耗(满足时延的约束条件下,最小化能耗)或者最小化时延(满足能耗的约束条件下,最小化时延),也可以根据需要,对时延和能耗分别赋权,使二者的加权和最小,即最大化收益的卸载/迁移决策</p>]]></content>
    
    
    
    <tags>
      
      <tag>offload</tag>
      
      <tag>migration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some-hardware-knowledge</title>
    <link href="/2023/07/28/Some-hardware-knowledge/"/>
    <url>/2023/07/28/Some-hardware-knowledge/</url>
    
    <content type="html"><![CDATA[<h2 id="导引"><a class="markdownIt-Anchor" href="#导引"></a> 导引</h2><p>为什么会想着写一篇关于硬件(SSD)的博文呢,在之前的一篇<strong>ZeRO-Infinity</strong>的论文中,讲到了利用<strong>NVMe</strong>来用作GPU,CPU内存的扩充,而对NVMe这个东西从未耳闻,因此看了一些资料来查缺补漏,便有了本文关于SSD这一硬件的简单讲解.其中主要涉及到的内容是<strong>PCIe</strong>的协议栈以及<strong>NVMe</strong>协议的讲解</p><h2 id="ssd"><a class="markdownIt-Anchor" href="#ssd"></a> SSD</h2><h3 id="物理接口"><a class="markdownIt-Anchor" href="#物理接口"></a> 物理接口</h3><p>常用的物理接口有<strong>PCIe接口</strong>,<strong>SATA接口</strong>,<strong>M.2接口</strong>等</p><p>前两个接口是根据通道而起的名字</p><p>M.2接口则可以跑PCIe或SATA通道,具体要看主板或硬盘的支持情况,主流的用于接入SSD的接口</p><h3 id="通道"><a class="markdownIt-Anchor" href="#通道"></a> 通道</h3><p>在谈及PCIe前,</p><p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/bus%20development(test).png" alt="bus%20development" /></p><h4 id="pcie"><a class="markdownIt-Anchor" href="#pcie"></a> PCIe</h4><h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3><h4 id="nvme"><a class="markdownIt-Anchor" href="#nvme"></a> NVMe</h4><p>NVMe(Non-Volatile Memory Express),非易失性内存主机控制器接口规范</p><h2 id="pcie-switch"><a class="markdownIt-Anchor" href="#pcie-switch"></a> PCIe Switch</h2><h2 id="hbm2"><a class="markdownIt-Anchor" href="#hbm2"></a> HBM2</h2><h2 id="nvlink"><a class="markdownIt-Anchor" href="#nvlink"></a> NVLink</h2><p>个人感觉是一个升级版的PCIe,双工双路信道</p><p><img src="https://s2.loli.net/2023/11/03/k314GUpmHgVtsRz.png" alt="NVLink Development" /></p><h2 id="nvswitch"><a class="markdownIt-Anchor" href="#nvswitch"></a> NVSwitch</h2><p>内部整合了多个NVLink</p><p><img src="https://s2.loli.net/2023/11/03/pjwqnB5CkEVDRIb.png" alt="NVSwitch Development" /></p><h2 id="dgx"><a class="markdownIt-Anchor" href="#dgx"></a> DGX</h2><p>DGX(Data Gpu eXtend,知乎捡回来的解释,NVIDIA也没有解释)系列产品(另还有HGX,EGX,分别对应HPC,Edge等领域):</p><ul><li><p>DGX Station</p><p>可自行DIY或购买的DGX工作站</p></li><li><p>DGX-1(卖点是P100和NVLink)</p><p>采用的是可以搭载8块GPU的SXM插槽,最初是P100(Pascal架构的,16GB),后面换成了V100(Volta架构,32GB)</p><p>DGX-1 Pascal架构的内部连接对AllGather优化没做好,但应该在DGX-1 Volta架构中增加了更多的NVLink通道解决了这个问题,P100有4个NVLink通道,V100有6个NVLink通道</p><p>以上参考:<a href="https://www.zhihu.com/question/42770716/answer/137835011">李沐关于DGX-1的描述</a></p><p>关于下方注释中的SXM的解释参考自<a href="https://en.wikipedia.org/wiki/SXM_(socket)">wiki-SXM</a></p><div class="note note-info">            <p><strong>SXM(Server pci eXpress Module),是一种高带宽的插槽</strong>,用于连接NVIDIA计算加速器到系统的一种解决方案,自P100以来,每一代的Nvidia Tesla,DGX计算系列,HGX板子都配有SXM插槽,可为匹配的GPU实现高带宽等功能</p><p><strong>在DGX系列中,SXM用于Pascal架构的GPU,SXM2,SXM3用于Volta架构,SXM4用于Ampere架构,SXM5用于Hopper架构的GPU</strong></p><p><strong>这些插槽是对应于特定的加速器型号</strong></p>          </div></li><li><p>DGX-2(卖点是V100和NVSwitch)</p></li><li><p>DGX A100</p></li><li><p>DGX H100</p><ul><li>8个H100GPU,总显存高达640GB</li></ul></li><li><p>DGX BasePOD</p></li><li><p>DGX SuperPOD</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/26172972">PCI和PCIe硬件讲解</a></p><p><a href="https://www.syrr.cn/news/291472.html?action=onClick">DGX-1和DGX-2以及其中架构</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>NVMe</tag>
      
      <tag>PCIe</tag>
      
      <tag>GPU</tag>
      
      <tag>SSD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pipeline Parallelism GPipe And PipeDream</title>
    <link href="/2023/05/17/Pipeline-Parallelism-GPipe-And-PipeDream/"/>
    <url>/2023/05/17/Pipeline-Parallelism-GPipe-And-PipeDream/</url>
    
    <content type="html"><![CDATA[<h2 id="从模型并行讲起"><a class="markdownIt-Anchor" href="#从模型并行讲起"></a> 从模型并行讲起</h2><p>模型并行有两种并行方式,一种是<strong>层间并行(inter-layer)</strong>,一种是<strong>层内并行(intra-layer)</strong>.</p><p><img src="https://s2.loli.net/2023/11/27/4ObapWrEQudJ97j.png" alt="inter-layer parallelism and intra-layer parallelism" /></p><p><strong>流水线并行属于层间并行的一种特殊情况</strong>,下文在讲解GPipe的时候会进行提及</p><p>层内并行可以看作是张量并行,张量并行的经典文章Megatron-LM是对transformer的三个维度之一[batch_size,sequence_length,hidden_dimmension]中的hidden_dimension进行划分,从而并行</p><p>后续也有一些文章是对sequence_length进行划分来达到并行的目的</p><p>不难看出,传统的数据并行是对数据集进行划分,即比如数据集有3200张图片,一个batch_size取32,则一个epoch有100个iteration,</p><h2 id="gpipe"><a class="markdownIt-Anchor" href="#gpipe"></a> GPipe</h2><h3 id="micro-batch"><a class="markdownIt-Anchor" href="#micro-batch"></a> micro-batch</h3><h3 id="re-materialization"><a class="markdownIt-Anchor" href="#re-materialization"></a> re-materialization</h3><h3 id="可挖掘的创新点"><a class="markdownIt-Anchor" href="#可挖掘的创新点"></a> 可挖掘的创新点</h3><ol><li>在文章<em><strong>Performance Optimization</strong></em>这一部分提及了可以更早安排反向传递时的recompute,我们知道,要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">B_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的梯度,需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>层的梯度以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">F_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的激活值,因此<strong>如果可以较为精准的提前开始重新计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">F_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的激活值,当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>的值通过PCI-E也好,通过Infiniband,甚至用NVLink也好,要是可以适应各类设备,而遮掩掉recompute的时间的话(大约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>),那跟别的模型比起来,等于白赚了recompute而节省的那一堆内存</strong></li><li>在文章<em><strong>Design Features and Trade-Offs</strong></em>这一部分中提及了GPipe假设的是单个层符合单个加速器的内存需求,因此**如果单个加速器无法满足单个层的需求,应该如何处理?**文中提出的是可以通过把矩阵乘拆分来解决</li><li>不同层内存需求不平衡,因此<strong>需要更好的分区算法,以达到负载均衡</strong>,如果实在无法通过分区达到平衡,可以<strong>通过合适的卸载计算,将计算卸载到周边的计算节点处理,感觉这里可以借鉴MEC(移动边缘计算)一类的方法</strong></li><li><strong>micro-batch划分需要复杂的策略以支持需要跨micro-batch(即在mini-batch中)计算的层(如BN层)</strong></li></ol><h2 id="pipedream"><a class="markdownIt-Anchor" href="#pipedream"></a> PipeDream</h2><h3 id="weight-stashing"><a class="markdownIt-Anchor" href="#weight-stashing"></a> weight stashing</h3><h3 id="vertical-sync"><a class="markdownIt-Anchor" href="#vertical-sync"></a> vertical sync</h3>]]></content>
    
    
    
    <tags>
      
      <tag>distributed system</tag>
      
      <tag>pipeline parallelism</tag>
      
      <tag>data parallelism</tag>
      
      <tag>model parallelism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSD理解及代码解析</title>
    <link href="/2023/03/23/SSD%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/23/SSD%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="ssd理解"><a class="markdownIt-Anchor" href="#ssd理解"></a> SSD理解</h2><p>SSD(Single Shot MultiBox Detector)是一个one-stage的目标检测模型,它的网络结构如下:</p><p><img src="https://s2.loli.net/2023/11/03/obM92IFdutTJzAV.png" alt="ssd-yolo-arch-contrast" /></p><p>根据上面的网络结构图,有:</p><ul><li>SSD的<strong>backbone采用的是VGG的前五层</strong>,后面的maxpool以及fc层都被换成卷积层</li><li>SSD有6个feature map用于预测分类和回归,即<strong>多尺度检测</strong></li><li>SSD是<strong>通过卷积操作来预测分类和定位回归</strong>,而YOLO则是通过全连接层变换到指定维度</li><li>SSD是<strong>基于anchor来预测</strong>的,而<strong>不同feature map的cell/grid是对应不同的anchor数目</strong></li></ul><p>SSD具体的操作,如<strong>default box(就是anchor)生成,正负样本匹配策略</strong>等会在下面结合代码一起理解</p><h2 id="写于代码分析前"><a class="markdownIt-Anchor" href="#写于代码分析前"></a> 写于代码分析前</h2><p>我们知道,目标检测由以下组件组成:<strong>backbone,neck,head</strong></p><ul><li>backbone: <strong>骨干网络</strong>,用来进行<strong>特征提取</strong>.我们之前学习的分类任务中提及的网络都有良好的特征提取能力,因此用来充当backbone</li><li>neck: 用于<strong>特征融合</strong>,以<strong>获取不同尺度的感受野信息</strong></li><li>head: <strong>检测头</strong>,用来<strong>预测目标类别和定位回归</strong></li></ul><h2 id="ssd代码分析"><a class="markdownIt-Anchor" href="#ssd代码分析"></a> SSD代码分析</h2><p>整体流程如下:</p><ol><li><p>ResNet50基础网络</p></li><li><p>backbone用于提取特征</p></li><li><p>ssd_model完成整个训练及预测的流程</p><ol><li>构建多尺度特征图用于预测分类和回归</li><li>default_box生成</li><li>正负样本匹配</li></ol><ul><li>训练<ul><li>loss计算<ul><li>定位loss</li><li>分类loss(hard negative mining)</li></ul></li></ul></li><li>预测<ul><li>后处理,如nms</li></ul></li></ul></li></ol><p>因此本文将以上述顺序进行分析</p><p>注:本文分析的是输入为300*300的SSD</p><h3 id="resnet-50"><a class="markdownIt-Anchor" href="#resnet-50"></a> ResNet-50</h3><p>由于这是16年的模型,所以当时作者用的是VGG,但在本文,我们用ResNet-50来作为backbone(ResNet具体信息查看<a href="https://ayyha.github.io/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/#resnet">image-classification的一些常用模型</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bottleneck</span>(<span class="hljs-params">nn.Module</span>):</span><br>    expansion = <span class="hljs-number">4</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channel, out_channel, stride=<span class="hljs-number">1</span>, downsample=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(Bottleneck, self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channel)<br>        self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.conv2 = nn.Conv2d(in_channels=out_channel, out_channels=out_channel, kernel_size=<span class="hljs-number">3</span>, stride=stride,<br>                               bias=<span class="hljs-literal">False</span>, padding=<span class="hljs-number">1</span>)<br>        self.bn2 = nn.BatchNorm2d(out_channel)<br>        self.conv3 = nn.Conv2d(in_channels=out_channel, out_channels=out_channel * self.expansion, kernel_size=<span class="hljs-number">1</span>,<br>                               stride=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.bn3 = nn.BatchNorm2d(out_channel * self.expansion)<br>        self.downsample = downsample<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        identity = x<br>        <span class="hljs-keyword">if</span> self.downsample <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            identity = self.downsample(x)<br>        residual = self.conv1(x)<br>        residual = self.bn1(residual)<br>        residual = self.relu(residual)<br><br>        residual = self.conv2(residual)<br>        residual = self.bn2(residual)<br>        residual = self.relu(residual)<br><br>        residual = self.conv3(residual)<br>        residual = self.bn3(residual)<br><br>        residual += identity<br>        residual = self.relu(residual)<br><br>        <span class="hljs-keyword">return</span> residual<br></code></pre></td></tr></table></figure><p>我们知道,ResNet-50相较于ResNet-18/34,其残差结构块是由三个卷积构成,分别:<strong>降维-&gt;卷积-&gt;升维</strong>这三个步骤,呈现两头大中间细,因此称为<strong>Bottleneck结构</strong>,而对于每一次的卷积操作,都是要经历<strong>卷积-&gt;Batch Normalization-&gt;Non Linearity(ReLU)<strong>这几步操作.以上便是Bottleneck的代码部分,其中</strong>expansion</strong>是用于标识第三层卷积的卷积核数目相较于第一层卷积的卷积核数目的<strong>膨胀系数</strong>;<strong>downsample</strong>则是用于<strong>identity mapping的维度变换</strong>(因为同样shape才可以和residual mapping进行相加)</p><p>下图中<strong>绿色框标识</strong>的则为每一个Bottleneck的<code>out_channel</code>,<strong>黄色框标识</strong>则为<code>in_channel</code>,而右边灰色框框住的则为每一个Bottleneck需要迭代的次数,因此我们需要定义一个方法用来逐层执行(一层有多个Bottleneck)</p><p><img src="https://cdn.staticaly.com/gh/ayyHA/imageBed@main/img/resnet-arch-for-code.png" alt="resnet-arch-for-code" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_layer</span>(<span class="hljs-params">self, block, channel, block_num, stride=<span class="hljs-number">1</span></span>):</span><br>    downsample = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> stride != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> self.in_channel != channel * block.expansion:<br>        downsample = nn.Sequential(<br>            nn.Conv2d(self.in_channel, channel * block.expansion, kernel_size=<span class="hljs-number">1</span>, stride=stride, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(channel * block.expansion)<br>        )<br>    layers = []<br>    layers.append(block(self.in_channel, channel, downsample=downsample, stride=stride))<br>    self.in_channel = channel * block.expansion<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, block_num):<br>        layers.append(block(self.in_channel, channel))<br><br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br></code></pre></td></tr></table></figure><p><code>_make_layer</code>便是逐层执行的方法,其中<code>block</code>是<code>Bottleneck</code>类,而<code>block_num</code>代表的是一个Bottleneck迭代的次数</p><p>由此,可以根据<code>_make_layer</code>方法构建出整个网络的结构,ResNet类的<code>__init__</code>和<code>forward</code>方法如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, block, blocks_num, num_classes=<span class="hljs-number">1000</span>, include_top=<span class="hljs-literal">True</span></span>):</span><br>    <span class="hljs-built_in">super</span>(ResNet, self).__init__()<br>    self.include_top = include_top<br>    self.in_channel = <span class="hljs-number">64</span><br><br>    self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, self.in_channel, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>, bias=<span class="hljs-literal">False</span>)<br>    self.bn1 = nn.BatchNorm2d(self.in_channel)<br>    self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br><br>    self.maxpool = nn.MaxPool2d(<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>)<br><br>    self.layer1 = self._make_layer(block, <span class="hljs-number">64</span>, blocks_num[<span class="hljs-number">0</span>])<br>    self.layer2 = self._make_layer(block, <span class="hljs-number">128</span>, blocks_num[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>    self.layer3 = self._make_layer(block, <span class="hljs-number">256</span>, blocks_num[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>    self.layer4 = self._make_layer(block, <span class="hljs-number">512</span>, blocks_num[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">if</span> self.include_top:<br>        self.avgpool = nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        self.fc = nn.Linear(<span class="hljs-number">512</span> * block.expansion, num_classes)<br><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self.modules():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(m, nn.Conv2d):<br>            nn.init.kaiming_normal_(m.weight, mode=<span class="hljs-string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="hljs-string">&#x27;relu&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>    x = self.conv1(x)<br>    x = self.bn1(x)<br>    x = self.relu(x)<br>    x = self.maxpool(x)<br><br>    x = self.layer1(x)<br>    x = self.layer2(x)<br>    x = self.layer3(x)<br>    x = self.layer4(x)<br><br>    <span class="hljs-keyword">if</span> self.include_top:<br>        x = self.avgpool(x)<br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br>        x = self.fc(x)<br>    <span class="hljs-keyword">return</span> x<br><br></code></pre></td></tr></table></figure><p>至此,便完成了ResNet50的代码部分</p><h3 id="backbone"><a class="markdownIt-Anchor" href="#backbone"></a> backbone</h3><p>在开始介绍之前,我们先看下用Resnet-50作为backbone的SSD的网络结构图:(图源B站up:<a href="https://space.bilibili.com/18161609/">霹雳吧啦Wz</a>)</p><p><img src="https://s2.loli.net/2023/11/03/NcUbuve9rpKgMR2.png" alt="res50-backbone-ssd-arch" /></p><p>由图中可知:并非整个ResNet-50都用做backbone,我们选取<code>conv4</code>这一层作为第一个做预测的特征图(<code>conv5</code>及后面的层全部抛弃).因此backbone便是截取到<code>conv4</code>,也即是对于<code>nn.Module.children()</code>而言,即是取到索引的第7位,然后根据SSD论文,需要对第四层的步距修改为1,因此也需要对identity mapping的<code>stride</code>也进行修改,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Backbone</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, pretrain_path=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(Backbone, self).__init__()<br>        net = resnet50()<br>        <span class="hljs-comment"># 用于后面的特征图的channel</span><br>        self.out_channels = [<span class="hljs-number">1024</span>, <span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>]<br><br>        <span class="hljs-keyword">if</span> pretrain_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            net.load_state_dict(torch.load(pretrain_path))<br><br>        self.feature_extractor = nn.Sequential(*<span class="hljs-built_in">list</span>(net.children())[:<span class="hljs-number">7</span>])<br><br>        conv4_block1 = self.feature_extractor[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># 这一行代码不是必须的,是用于ResNet-18/34的</span><br>        conv4_block1.conv1.stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        conv4_block1.conv2.stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        conv4_block1.downsample[<span class="hljs-number">0</span>].stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.feature_extractor(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>由此,我们便完成了backbone的构造,当我们通过如下方式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">image_test = torch.randn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">300</span>,<span class="hljs-number">300</span>)<br>backbone = Backbone()<br>feature_extractor = backbone(image_test) <br></code></pre></td></tr></table></figure><p>便可以得到<code>1*1024*38*38</code>这样大小的tensor</p><h3 id="ssd_model"><a class="markdownIt-Anchor" href="#ssd_model"></a> ssd_model</h3><h4 id="多尺度特征图的构建"><a class="markdownIt-Anchor" href="#多尺度特征图的构建"></a> 多尺度特征图的构建</h4><p>根据上面的网络结构图,可知六个特征图分别为:<code>[38*38*1024,19*19*512,10*10*512,5*5*256,3*3*256,1*1*256]</code>,在经过backbone后,我们即可以得到<code>38*38*1024</code>尺寸的特征图,而后的特征图中,均需要经过两个卷积层后得到其尺寸,因此以下的方法便是为获取后续的特征图做的操作,并将相应操作存于模型容器中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_build_addtional_features</span>(<span class="hljs-params">self, input_size</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param input_size [1024,512,512,256,256,256]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    additional_blocks = []<br>    middle_channels = [<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>]<br>    <span class="hljs-keyword">for</span> i, (in_ch, out_ch, mid_ch) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(input_size[:-<span class="hljs-number">1</span>], input_size[<span class="hljs-number">1</span>:], middle_channels)):<br>        padding, stride = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>        layer = nn.Sequential(<br>            nn.Conv2d(in_ch, mid_ch, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(mid_ch),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Conv2d(mid_ch, out_ch, kernel_size=<span class="hljs-number">3</span>, padding=padding, stride=stride, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(out_ch),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        )<br>        additional_blocks.append(layer)<br>    self.additional_blocks = nn.ModuleList(additional_blocks)<br></code></pre></td></tr></table></figure><h4 id="多尺度特征图预测分类和回归"><a class="markdownIt-Anchor" href="#多尺度特征图预测分类和回归"></a> 多尺度特征图预测分类和回归</h4><p>在提及预测分类和回归前,我们先需要知道每一个特征图对应的grid/cell有几个default box</p><p>在论文关于<strong>scale和aspect ratio</strong>中,作者所提及的scale的计算公式如下示:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub><mo>=</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mfrac><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s_{k}=s_{min}+\frac{s_{max}-s_{min}}{m-1}(k-1),k\in[1,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.0296600000000002em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>根据<em>Suppose we want to use m feature maps for prediction</em>原文这句话可以知道是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>,即多尺度特征图的个数,但由于下面的aspect ratio即default box的长宽比部分,提及了除了某些比例外,每个特征图还有一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><msqrt><mrow><msub><mi>s</mi><mi>k</mi></msub><msub><mi>s</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msqrt></mrow><annotation encoding="application/x-tex">s^{\prime}_{k}=\sqrt{s_{k}s_{k+1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.3438855em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6961145em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.6561145em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3438855em;"><span></span></span></span></span></span></span></span></span>,显然至少需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而以下是作者的<a href="https://github.com/weiliu89/caffe/blob/ssd/examples/ssd/ssd_pascal_resnet.py">GitHub代码部分</a>关于此处的处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">min_dim = <span class="hljs-number">300</span><br><span class="hljs-comment"># res3b3_relu ==&gt; 38 x 38</span><br><span class="hljs-comment"># res5c_relu ==&gt; 19 x 19</span><br><span class="hljs-comment"># res5c_relu/conv1_2 ==&gt; 10 x 10</span><br><span class="hljs-comment"># res5c_relu/conv2_2 ==&gt; 5 x 5</span><br><span class="hljs-comment"># res5c_relu/conv3_2 ==&gt; 3 x 3</span><br><span class="hljs-comment"># pool6 ==&gt; 1 x 1</span><br>mbox_source_layers = [<span class="hljs-string">&#x27;res3b3_relu&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv1_2&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv2_2&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv3_2&#x27;</span>, <span class="hljs-string">&#x27;pool6&#x27;</span>]<br><span class="hljs-comment"># in percent %</span><br>min_ratio = <span class="hljs-number">20</span><br>max_ratio = <span class="hljs-number">95</span><br>step = <span class="hljs-built_in">int</span>(math.floor((max_ratio - min_ratio) / (<span class="hljs-built_in">len</span>(mbox_source_layers) - <span class="hljs-number">2</span>)))<br>min_sizes = []<br>max_sizes = []<br><span class="hljs-keyword">for</span> ratio <span class="hljs-keyword">in</span> xrange(min_ratio, max_ratio + <span class="hljs-number">1</span>, step):<br>  min_sizes.append(min_dim * ratio / <span class="hljs-number">100.</span>)<br>  max_sizes.append(min_dim * (ratio + step) / <span class="hljs-number">100.</span>)<br>min_sizes = [min_dim * <span class="hljs-number">10</span> / <span class="hljs-number">100.</span>] + min_sizes<br>max_sizes = [[]] + max_sizes<br></code></pre></td></tr></table></figure><p>我们将它稍加修改用torch打印出来即是:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>30</mn><mo separator="true">,</mo><mn>60</mn><mo separator="true">,</mo><mn>114</mn><mo separator="true">,</mo><mn>168</mn><mo separator="true">,</mo><mn>222</mn><mo separator="true">,</mo><mn>276</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>60</mn><mo separator="true">,</mo><mn>114</mn><mo separator="true">,</mo><mn>168</mn><mo separator="true">,</mo><mn>222</mn><mo separator="true">,</mo><mn>276</mn><mo separator="true">,</mo><mn>330</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min\_sizes[30,60,114,168,222,276] \\ max\_sizes[60,114,168,222,276,330]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">6</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span></p><p>显然,跟上面论文给出的计算方法及结果均不一样,估计是后期又调了参,而在本文讲解中,采用的是如下这一组scale:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>21</mn><mo separator="true">,</mo><mn>45</mn><mo separator="true">,</mo><mn>99</mn><mo separator="true">,</mo><mn>153</mn><mo separator="true">,</mo><mn>207</mn><mo separator="true">,</mo><mn>261</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>45</mn><mo separator="true">,</mo><mn>99</mn><mo separator="true">,</mo><mn>153</mn><mo separator="true">,</mo><mn>207</mn><mo separator="true">,</mo><mn>261</mn><mo separator="true">,</mo><mn>315</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min\_sizes[21, 45, 99, 153, 207, 261]\\max\_sizes[45, 99, 153, 207, 261, 315]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">1</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></span></p><p>来源<a href="https://github.com/amdegroot/ssd.pytorch/blob/master/data/config.py">amdegroot/ssd.pytorch</a></p><p>而关于aspect ratio,在Experiment中作者说到<em>For conv4_3,conv10_2 and conv11_2, we only associate 4 default boxes at each feature map location–omitting aspect ratios of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>and 3</em></p><p>也即是1,5,6这三个特征图中只有对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,\frac{1}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>这几个宽高比例以及刚刚提及的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">s^{\prime}_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span>,即1,5,6这三个特征图的grid上只有4个default box,而2,3,4则是6个default box</p><p>而在我们预测分类和回归的时候,我们需要将多尺度特征图的channel转换为<code>k*(4+num_classes)</code>,其中k表示的是该特征图grid对应的default box数目,4是用于分类的四个回归参数(偏移值),num_classes则是用于分类的类别数目</p><p>因此,构建用于分类和定位的module如下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">self.num_defaults = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>   location_extractors = []<br>   confidence_extractors = []<br>   <span class="hljs-keyword">for</span> nd, oc <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.num_defaults, self.feature_extractor.out_channels):<br>       location_extractors.append(nn.Conv2d(oc, nd * <span class="hljs-number">4</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>       confidence_extractors.append(nn.Conv2d(oc, nd * num_classes, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br><span class="hljs-comment"># 用于定位回归的位置提取器</span><br>self.loc = nn.ModuleList(location_extractors)<br><span class="hljs-comment"># 用于预测分类的分类提取器</span><br>self.conf = nn.ModuleList(confidence_extractors)<br></code></pre></td></tr></table></figure><p>我们结合构建好的多尺度特征图以及上述用于预测分类和回归的module,则有下述代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox_view</span>(<span class="hljs-params">self, features, loc_extractor, conf_extractor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param features: 多尺度特征图</span><br><span class="hljs-string">    :param loc_extractor: self.loc</span><br><span class="hljs-string">    :param conf_extractor: self.conf</span><br><span class="hljs-string">    :return: locs:Tensor[N,4,8732] confs:Tensor[N,num_classes,8732] N-&gt;batch_size</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    locs = []<br>    confs = []<br>    <span class="hljs-keyword">for</span> f, l, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(features, loc_extractor, conf_extractor):<br>        <span class="hljs-comment"># view-&gt;给tensor做维度变换,不改变数据</span><br>        <span class="hljs-comment"># [batch_size,n*4,feature_size,feature_size] -&gt; [batch_size,4,-1]</span><br>        locs.append(l(f).view(f.size(<span class="hljs-number">0</span>), <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>))<br>        confs.append(c(f).view(f.size(<span class="hljs-number">0</span>), self.num_classes, -<span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 将每一张图的不同尺度的矩阵给拼接起来,然后改变其内存的存储结构 [batch_size,4,8732], [batch_size,num_classes,8732]</span><br>    locs, confs = torch.cat(locs, <span class="hljs-number">2</span>).contiguous(), torch.cat(confs, <span class="hljs-number">2</span>).contiguous()<br>    <span class="hljs-keyword">return</span> locs, confs<br></code></pre></td></tr></table></figure><p>其中代码中注解的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8732</mn></mrow><annotation encoding="application/x-tex">8732</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mord">3</span><span class="mord">2</span></span></span></span>是所有尺寸的特征图的default box的总数目</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>38</mn><mo>∗</mo><mn>38</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>19</mn><mo>∗</mo><mn>19</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>10</mn><mo>∗</mo><mn>10</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>5</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>3</mn><mo>∗</mo><mn>3</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>1</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>8732</mn></mrow><annotation encoding="application/x-tex">38*38*4+19*19*6+10*10*6+5*5*6+3*3*4+1*1*4=8732</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mord">3</span><span class="mord">2</span></span></span></span></span></p><p>以上便是SSD利用多尺度特征图预测分类和定位回归的过程</p><h4 id="default-box生成"><a class="markdownIt-Anchor" href="#default-box生成"></a> default box生成</h4><p>在训练和预测前,①需要利用匹配策略将default box与ground truth box进行匹配,从而得到正负样本,②而得到了正负样本我们才可以执行论文里的hard negative mining(即使得正负样本比例<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1:3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>),用以处理密集检测中的正负样本极不平衡的情况,③之后才可以计算训练需要用的loss;④而之于预测阶段,我们需要利用回归参数对default box移动到对应的位置,得到预测框,⑤而后再进行NMS去除冗余框,得到最终的结果</p><p>因此在开展后续的代码讲解前,需要先对default box的生成做一个讲解</p><p>在上面的介绍中,我们知道了每个feature map的grid对应不同数目的default box,而每个default box又由scale和aspect ratio决定,这里补充一下如何利用scale和aspect ratio计算对应default box的宽高</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>=</mo><msub><mi>s</mi><mi>k</mi></msub><msqrt><msub><mi>a</mi><mi>r</mi></msub></msqrt><mspace linebreak="newline"></mspace><msub><mi>h</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>s</mi><mi>k</mi></msub><msqrt><msub><mi>a</mi><mi>r</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">w_{k}=s_{k}\sqrt{a_{r}} \\h_{k}=\frac{s_{k}}{\sqrt{a_{r}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.265845em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.774155em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.734155em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.265845em;"><span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1082799999999997em;vertical-align:-1.00072em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.72528em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.68528em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31472em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.00072em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是该feature map的scale,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是对应的宽高比,至此,我们便可以计算出不同特征图的default box不同宽高比的尺寸大小,而每个default box都是在其所属的grid的中心,因此我们可以计算出每一个default box的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo separator="true">,</mo><mi>c</mi><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">{cx,cy,w,h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span></span></span></span></span>坐标</p><p>由此可以得出生成default box的代码,如下示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultBoxes</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, fig_size, feature_size, steps, scales, aspect_ratios, scale_xy=<span class="hljs-number">.1</span>, scale_wh=<span class="hljs-number">.2</span></span>):</span><br>        <span class="hljs-comment"># 输入图像的大小300</span><br>        self.fig_size = fig_size<br>        <span class="hljs-comment"># 多尺度特征图的大小[38,19,10,5,3,1]</span><br>        self.feature_size = feature_size<br><br>        <span class="hljs-comment"># 用于后期加速loss收敛</span><br>        self.scale_xy_ = scale_xy<br>        self.scale_wh_ = scale_wh<br><br>        <span class="hljs-comment"># 特征图在原图上的跨度 [8,16,32,64,100,300]</span><br>        self.steps = steps<br>        <span class="hljs-comment"># 每一个特征图对应的default_box的大小 [21,45,99,153,207,261,315]</span><br>        self.scales = scales<br>        <span class="hljs-comment"># 每一个特征图对应的default_box的宽高比 [[2],[2,3],[2,3],[2,3],[2],[2]]</span><br>        self.aspect_ratios = aspect_ratios<br>        <span class="hljs-comment"># 每一个特征图的fk,按原论文应是featur_size,但是这里用了别的方法</span><br>        fk = fig_size / np.array(steps)<br><br>        self.default_boxes = []<br>        <span class="hljs-comment"># 计算每一个特征图的default box</span><br>        <span class="hljs-keyword">for</span> idx, single_feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.feature_size):<br>            <span class="hljs-comment"># 计算相对坐标</span><br>            sk1 = scales[idx] / fig_size<br>            sk2 = scales[idx + <span class="hljs-number">1</span>] / fig_size<br>            sk3 = sqrt(sk1, sk2)<br>            <span class="hljs-comment"># 添加两个宽高比为1的default box的宽高</span><br>            all_sizes = [(sk1, sk1), (sk3, sk3)]<br><br>            <span class="hljs-comment"># 处理feature_map不同宽高比</span><br>            <span class="hljs-keyword">for</span> alpha <span class="hljs-keyword">in</span> aspect_ratios[idx]:<br>                w, h = sk1 * sqrt(alpha), sk1 / sqrt(alpha)<br>                all_sizes.append((w, h))<br>                all_sizes.append((h, w))<br><br>            <span class="hljs-comment"># 计算default_box对应的坐标</span><br>            <span class="hljs-keyword">for</span> w, h <span class="hljs-keyword">in</span> all_sizes:<br>                <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">range</span>(single_feature), repeat=<span class="hljs-number">2</span>):<br>                    <span class="hljs-comment"># 计算每一个小格子对应的default box的中心坐标</span><br>                    cx, cy = (j + <span class="hljs-number">0.5</span>) / fk[idx], (i + <span class="hljs-number">0.5</span>) / fk[idx]<br>                    self.default_boxes.append((cx, cy, w, h))<br>        <span class="hljs-comment"># 转换数据类型为Tensor</span><br>        self.dboxes = torch.as_tensor(self.default_boxes, dtype=torch.float32)<br>        <span class="hljs-comment"># 把范围夹紧在[0,1],超出1的划为1,小于0的划为0</span><br>        self.dboxes.clamp_(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 将(cx,cy,w,h)转换为(xmin,ymin,xmax,ymax) left top right bottom,便于IoU计算</span><br>        self.dboxes_ltrb = self.dboxes.clone()<br>        self.dboxes_ltrb[:, <span class="hljs-number">0</span>] = self.dboxes[:, <span class="hljs-number">0</span>] - <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">2</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">1</span>] = self.dboxes[:, <span class="hljs-number">1</span>] - <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">3</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">2</span>] = self.dboxes[:, <span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">2</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">3</span>] = self.dboxes[:, <span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">3</span>]<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_xy</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.scale_xy_<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_wh</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.scale_wh_<br><br>    <span class="hljs-comment"># 要用哪个形式的default box,任君选择</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, order=<span class="hljs-string">&#x27;ltrb&#x27;</span></span>):</span><br>        <span class="hljs-keyword">if</span> order == <span class="hljs-string">&quot;ltrb&quot;</span>:<br>            <span class="hljs-keyword">return</span> self.dboxes_ltrb<br><br>        <span class="hljs-keyword">if</span> order == <span class="hljs-string">&quot;xywh&quot;</span>:<br>            <span class="hljs-keyword">return</span> self.dboxes<br></code></pre></td></tr></table></figure><p>从上面我们知道default box有两种格式,其中一种是<code>xywh​</code>,即是位于grid的中心,因为我们预测的是回归参数,即偏移值,是相对于这一格式而言的,因此想要得到最终的预测框,需要在这种格式上对其进行变换得到</p><p>另一种格式为<code>ltrb​</code>,此种格式便于我们计算IoU,同时也是VOC数据集提供的GTbox的格式.而计算IoU这一metric,即存在于正负样本匹配,也存在于最后的非极大值抑制中</p><p>因此这两种格式在求解目标检测问题时是时常相互转换的,二者均不可或缺</p><h4 id="正负样本匹配"><a class="markdownIt-Anchor" href="#正负样本匹配"></a> 正负样本匹配</h4><p>在完成了default box的生成后,我们要开始训练前,需要根据匹配策略,区分什么样的default box为正样本,什么样的default box为负样本</p><p>在论文中,作者提出了两步的匹配策略:</p><p><img src="https://s2.loli.net/2023/11/03/s5HMxcgn4FaLIfD.png" alt="ssd-matching-strategy" /></p><p>即是按照以下策略匹配:</p><ol><li>每个GTbox匹配到的最大IoU的default box为正样本</li><li>每个default box匹配到的最大IoU的GTbox,其IoU&gt;阈值(0.5)则为正样本</li></ol><p>即一张图片比如有<code>2</code>个GTbox,有4个default box,其IoU如下所示:</p><table><thead><tr><th></th><th>dbox1</th><th>dbox2</th><th>dbox3</th><th>dbox4</th></tr></thead><tbody><tr><td>GTbox1</td><td>0.4</td><td>0.3</td><td>0</td><td>0</td></tr><tr><td>GTbox2</td><td>0.2</td><td>0.8</td><td>0.6</td><td>0.3</td></tr></tbody></table><p>根据第一条匹配策略,匹配到的:(GTbox1,dbox1)=0.4和(GTbox2,dbox2)=0.8,这俩为正样本</p><p>根据第二条匹配策略,匹配到的:(GTbox2,dbox3)=0.6&gt;阈值(0.5),也为正样本</p><p>若是没匹配到,则为负样本,则其匹配到的是背景类,而该default box的位置信息则无意义(定位loss只算正样本的)</p><p>因此,有以下代码,注意,传入<code>encode</code>的<code>bboxes_in</code>和<code>labels_in</code>是通过对数据集标注文件进行解析得到的GTbox的真实位置和真实标签(如对VOC数据集进行解析)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Encoder</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-comment"># [8732,4]</span><br>        self.dboxes = dboxes(order=<span class="hljs-string">&quot;ltrb&quot;</span>)<br>        <span class="hljs-comment"># [1,8732]</span><br>        self.dboxes_xywh = dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).unsqueeze(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 8732</span><br>        self.nboxes = self.dboxes.size(<span class="hljs-number">0</span>)<br>        self.scale_xy = dboxes.scale_xy<br>        self.scale_wh = dboxes.scale_wh<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">self, bboxes_in, labels_in, criteria=<span class="hljs-number">0.5</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        正负样本匹配,其中nboxes是ground truth boxes</span><br><span class="hljs-string">        :param bboxes_in: [nboxes*4]</span><br><span class="hljs-string">        :param labels_in: [nboxes]</span><br><span class="hljs-string">        :param criteria: IoU阈值,用于判断正样本</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># [nboxes,8732],这里的dboxes是ltrb格式</span><br>        ious = calc_iou_tensor(bboxes_in, self.dboxes)<br>        <span class="hljs-comment"># 每个default box对应GTbox的最大值 [8732]</span><br>        best_dbox_ious, best_dbox_idx = ious.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 每个GTbox对应default box的最大值 [nboxes]</span><br>        best_gtbox_ious, best_gtbox_idx = ious.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 匹配策略一:GTbox最匹配的default box为正样本</span><br>        <span class="hljs-comment"># 因此,将对应的default box匹配GTbox的IoU更改为&gt;0.5的值,使后面置之为正样本 [8732]</span><br>        best_dbox_ious.index_fill_(<span class="hljs-number">0</span>, best_gtbox_idx, <span class="hljs-number">2.0</span>)<br>        <span class="hljs-comment"># 更换满足匹配一的default box的索引,使之与GTbox匹配,因为后面要用GTbox的坐标和标签</span><br>        idx = torch.arange(<span class="hljs-number">0</span>, best_gtbox_idx.size(<span class="hljs-number">0</span>), dtype=torch.int64)<br>        best_dbox_idx[best_gtbox_idx[idx]] = idx<br><br>        <span class="hljs-comment"># 匹配策略二:与任意GTbox IoU&gt;0.5的default box即为正样本</span><br>        mask = best_dbox_ious &gt; criteria<br><br>        <span class="hljs-comment"># [8732],默认填充为0 0匹配的是背景</span><br>        labels_out = torch.zeros(self.nboxes, dtype=torch.int64)<br>        <span class="hljs-comment"># 给正样本打上与对应GTbox同样的标签</span><br>        labels_out[mask] = labels_in[best_dbox_idx[mask]]<br><br>        <span class="hljs-comment"># 给正样本赋予对应GTbox同样的坐标</span><br>        bboxes_out = self.dboxes.clone()<br>        bboxes_out[mask, :] = bboxes_in[best_dbox_idx[mask], :]<br><br>        <span class="hljs-comment"># 转换为xywh格式</span><br>        x = <span class="hljs-number">0.5</span> * (bboxes_out[:, <span class="hljs-number">0</span>] + bboxes_out[:, <span class="hljs-number">2</span>])<br>        y = <span class="hljs-number">0.5</span> * (bboxes_out[:, <span class="hljs-number">1</span>] + bboxes_out[:, <span class="hljs-number">3</span>])<br>        w = bboxes_out[:, <span class="hljs-number">2</span>] - bboxes_out[:, <span class="hljs-number">0</span>]<br>        h = bboxes_out[:, <span class="hljs-number">3</span>] - bboxes_out[:, <span class="hljs-number">1</span>]<br>        bboxes_out[:, <span class="hljs-number">0</span>] = x<br>        bboxes_out[:, <span class="hljs-number">1</span>] = y<br>        bboxes_out[:, <span class="hljs-number">2</span>] = w<br>        bboxes_out[:, <span class="hljs-number">3</span>] = h<br>        <span class="hljs-keyword">return</span> bboxes_out, labels_out<br></code></pre></td></tr></table></figure><h4 id="训练"><a class="markdownIt-Anchor" href="#训练"></a> 训练</h4><p>我们完成了上述工作后,便可以开始训练.而训练过程中,我们会通过一些处理工作,获取到<strong>一批</strong>(上面是单张)数据的正负样本,即:<code>location:Tensor[N,4,8732],confidence:Tensor[N,8732]</code>,因此接下来,我们将对这批数据进行loss计算</p><h5 id="loss计算"><a class="markdownIt-Anchor" href="#loss计算"></a> loss计算</h5><p>我们对default box预测的是它相对于中心位置的回归参数,也就是说,是相对于中心位置的偏移值,而在论文中,<strong>偏移值的计算定义</strong>如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><msubsup><mi>g</mi><mi>j</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup><mo>−</mo><msubsup><mi>d</mi><mi>i</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup></mrow><msubsup><mi>d</mi><mi>i</mi><mi>w</mi></msubsup></mfrac><mspace width="1em"/><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><msubsup><mi>g</mi><mi>j</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup><mo>−</mo><msubsup><mi>d</mi><mi>i</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup></mrow><msubsup><mi>d</mi><mi>i</mi><mi>h</mi></msubsup></mfrac><mspace linebreak="newline"></mspace><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mi>w</mi></msubsup><mo>=</mo><mi>log</mi><mo>⁡</mo><mfrac><msubsup><mi>g</mi><mi>j</mi><mi>w</mi></msubsup><msubsup><mi>d</mi><mi>i</mi><mi>w</mi></msubsup></mfrac><mspace width="1em"/><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mi>h</mi></msubsup><mo>=</mo><mi>log</mi><mo>⁡</mo><mfrac><msubsup><mi>g</mi><mi>j</mi><mi>h</mi></msubsup><msubsup><mi>d</mi><mi>i</mi><mi>h</mi></msubsup></mfrac></mrow><annotation encoding="application/x-tex">\hat{g}^{cx}_{j} = \frac{g^{cx}_{j}-d^{cx}_{i}}{d^{w}_{i}} \quad \hat{g}^{cy}_{j} = \frac{g^{cy}_{j}-d^{cy}_{i}}{d^{h}_{i}}\\\hat{g}^{w}_{j} = \log{\frac{g^{w}_{j}}{d^{w}_{i}}} \quad\hat{g}^{h}_{j} = \log{\frac{g^{h}_{j}}{d^{h}_{i}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0975000000000001em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.442076em;vertical-align:-0.9628639999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.479212em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6461920000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.583044em;vertical-align:-0.9977719999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5852720000000002em;"><span style="top:-2.279092em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.830908em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.802972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9977719999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0975000000000001em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4120280000000003em;vertical-align:-0.9628639999999999em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4491640000000001em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6461920000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.631652em;vertical-align:-0.9977719999999999em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.63388em;"><span style="top:-2.279092em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.830908em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9977719999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><p><strong>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个GTbox,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box,上标的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo separator="true">,</mo><mi>c</mi><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">cx,cy,w,h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span></span></span></span>表示计算的对象(中心坐标x等),<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>表示的是GTbox,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>表示的是default box</strong></p><p>我们<strong>通过等式右边的计算便可以得到左侧的偏移值</strong>,而我们的<strong>目标是使得网络学习的偏移值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>,尽量地与真实的偏移值相近,即误差越小越好</strong>,本文中采用的<strong>定位回归loss函数是SmoothL1Loss</strong></p><p>而对于分类损失,本文则采取了交叉熵损失函数,形式如下(拆成了正负样本来写):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi></mrow></msub><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>P</mi><mi>o</mi><mi>s</mi></mrow><mi>N</mi></munderover><mrow><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>p</mi></msubsup><mi>log</mi><mo>⁡</mo><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mi>p</mi></msubsup></mrow><mo>+</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>N</mi><mi>e</mi><mi>g</mi></mrow></munder><mrow><mi>log</mi><mo>⁡</mo><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mn>0</mn></msubsup></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{conf} = - (\sum_{i \in Pos}^{N}{x^{p}_{ij}\log{\hat{c}^{p}_{i}}} + \sum_{i \in Neg}{\log{\hat{c}^{0}_{i}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.150042em;vertical-align:-1.321706em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7822999999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.480449em;vertical-align:-1.430444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">x^{p}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>是一个指示器,它的取值是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>,表示的是匹配第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box和类别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个GTbox,对数函数里面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">\hat{c}^{p}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.059164em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box预测属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>这一类别的概率值,之所以有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>是因为这是经过softmax后的结果</p><p>以下是loss计算的<code>__init__</code>方法,定义了上述所说的损失函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loss</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-built_in">super</span>(Loss, self).__init__()<br>        self.scale_xy = <span class="hljs-number">1.0</span> / dboxes.scale_xy  <span class="hljs-comment"># 10</span><br>        self.scale_wh = <span class="hljs-number">1.0</span> / dboxes.scale_wh  <span class="hljs-comment"># 5</span><br><br>        self.location_loss = nn.SmoothL1Loss(reduction=<span class="hljs-string">&#x27;None&#x27;</span>)<br>        <span class="hljs-comment"># [8732,4] -&gt; [4,8732] -&gt; [1,4,8732] 8732 -&gt; number of anchors</span><br>        self.dboxes = nn.Parameter(dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).unsqueeze(dim=<span class="hljs-number">0</span>),<br>                                   requires_grad=<span class="hljs-literal">False</span>)<br>        self.confidence_loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;None&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们知道,对于定位问题,我们只对正样本计算loss(负样本的loss没有意义),而正样本的位置信息就是GTbox的位置信息(<code>xywh这一类型的</code>),而预测的结果是default box的偏移值,因而需要对传入的正样本信息计算出偏移值,才可以计算定位损失,以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_location_vec</span>(<span class="hljs-params">self, loc</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算gtbox相较于default box的回归参数</span><br><span class="hljs-string">    :param loc: gtbox</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># [batch_size,2,8732]</span><br>    gxy = self.scale_xy * (loc[:, :<span class="hljs-number">2</span>, :] - self.dboxes[:, :<span class="hljs-number">2</span>, :]) / self.dboxes[:, <span class="hljs-number">2</span>:, :]<br>    <span class="hljs-comment"># [batch_size,2,8732]</span><br>    gwh = self.scale_wh * (loc[:, <span class="hljs-number">2</span>:, :] / self.dboxes[:, <span class="hljs-number">2</span>:, :]).log()<br>    <span class="hljs-comment"># [batch_size,4,8732]</span><br>    <span class="hljs-keyword">return</span> torch.cat((gxy, gwh), dim=<span class="hljs-number">1</span>).contiguous()<br></code></pre></td></tr></table></figure><p>将以上的返回值和预测的回归信息交由前面定义的SmoothL1Loss便可以计算出定位损失</p><p>而分类损失则是对正负样本均要计算,但在计算之前,我们需要知道,一张图片,目标可能只有几个,但我们的default box有8k多个,如果正负样本全拿来计算loss,那正样本的loss其实对网络的学习起的作用微乎其微,因为正负样本极不平衡</p><p>因此本文提出了<em>hard negative mininng</em>的思想,即正负样本保持<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1:3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的比例,负样本是根据置信度损失大小降序排序而被挑选出来的(就是挑置信度损失高的,也就是难以区分为背景的)</p><p>以下是Loss类的forward的代码部分,包括了上述说的定位损失以及分类损失的计算,也包括了hard negative mining的处理部分,其中对两种损失的处理是直接相加得到的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, ploc, plabel, gloc, glabel</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param ploc: predicted location [N,4,8732]</span><br><span class="hljs-string">    :param plabel: predicted label [N,num_classes,8732]</span><br><span class="hljs-string">    :param gloc: gt location [N,4,8732]</span><br><span class="hljs-string">    :param glabel: gt label [N,8732]</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获取正样本的mask Tensor [N,8732]</span><br>    mask = torch.gt(glabel, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 计算每一张图片的正样本数目 [N]</span><br>    pos_num = mask.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 计算ground truth的回归参数 [N,4,8732]</span><br>    vec_gd = self._location_vec(gloc)<br><br>    <span class="hljs-comment"># 计算定位损失 [N,4,8732] -&gt; [N,8732]</span><br>    loc_loss = self.location_loss(ploc, vec_gd).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 只计算正样本的loss [N,8732] -&gt; [N] (即每张图片(N的其中一份子)的定位loss组成的)</span><br>    loc_loss = (mask.<span class="hljs-built_in">float</span>() * loc_loss).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 以下是hard negative mining的过程</span><br>    <span class="hljs-comment"># out:[N,8732]</span><br>    conf = self.confidence_loss(plabel, glabel)<br><br>    conf_neg = conf.clone()<br>    <span class="hljs-comment"># 将正样本的分类loss置零,便于后面对置信度loss高的负样本进行获取</span><br>    conf_neg[mask] = <span class="hljs-number">0.0</span><br>    <span class="hljs-comment"># 按置信度loss降序排序,其中获取到的sorted_矩阵表示的是排序后的值,</span><br>    <span class="hljs-comment"># 而conf_idx则是排序后的值对应原conf_neg矩阵对应值的索引矩阵</span><br>    sorted_, conf_idx = conf_neg.sort(dim=<span class="hljs-number">1</span>, descending=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 升序排一次,使得conf_rank矩阵为原conf_neg矩阵的位次阵,即对应元素代表了其大小(0最大)</span><br>    sorted__, conf_rank = conf_idx.sort(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 负样本是正样本的三倍,总数要小于8732 out:[N,1]</span><br>    neg_num = torch.clamp(<span class="hljs-number">3</span> * pos_num, <span class="hljs-built_in">max</span>=mask.size(<span class="hljs-number">1</span>)).unsqueeze(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 保留置信度loss高的负样本</span><br>    neg_mask = torch.lt(conf_rank, neg_num)<br><br>    <span class="hljs-comment"># confidence计算 [N,8732] -&gt; [N] 对每一幅图片的正负样本计算loss,并合在一起(单张图的正负样本的分类loss) [N]</span><br>    conf_loss = (conf * (mask.<span class="hljs-built_in">float</span>() + neg_mask.<span class="hljs-built_in">float</span>())).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 总的loss</span><br>    total_loss = conf_loss + loc_loss<br>    <span class="hljs-comment"># 避免某一些图片的gt为0</span><br>    num_mask = torch.gt(pos_num, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-comment"># 避免gt为0的图片作为分母时无法被除</span><br>    pos_num = pos_num.<span class="hljs-built_in">float</span>().clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">1e-6</span>)<br>    <span class="hljs-comment"># 计算gt非0的图片的loss(每张图片平均gt的loss,再对这一批图片loss取均值)</span><br>    ret = (total_loss * num_mask / pos_num).mean(dim=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h4 id="预测"><a class="markdownIt-Anchor" href="#预测"></a> 预测</h4><h5 id="后处理"><a class="markdownIt-Anchor" href="#后处理"></a> 后处理</h5><p>在验证阶段或者预测阶段,我们需要计算出最终预测框的位置(default box加上偏移值),计算出类别概率,并且对冗余的预测框进行去除,最终用一些metric验证当下模型的性能或者输出预测后的图像</p><p>以下是后处理部分的<code>__init__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostProcess</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-built_in">super</span>(PostProcess, self).__init__()<br>        <span class="hljs-comment"># [8732,4] -&gt; [1,8732,4]</span><br>        self.dboxes_xywh = nn.Parameter(dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).unsqueeze(dim=<span class="hljs-number">0</span>), requires_grad=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 0.1</span><br>        self.scale_xy = dboxes.scale_xy<br>        <span class="hljs-comment"># 0.2</span><br>        self.scale_wh = dboxes.scale_wh<br>        <span class="hljs-comment"># NMS的阈值</span><br>        self.criteria = <span class="hljs-number">.5</span><br>        <span class="hljs-comment"># 一张图片允许的最多框数</span><br>        self.max_output = <span class="hljs-number">100</span><br><br></code></pre></td></tr></table></figure><h6 id="最终预测框"><a class="markdownIt-Anchor" href="#最终预测框"></a> 最终预测框</h6><p>要得到最终预测框,就要将模型预测的回归参数作用到default box上,同时也需要对模型预测的类别进行<code>softmax</code>处理,以转换为概率值,以下是获得最终预测框的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_back_batch</span>(<span class="hljs-params">self, bboxes_in, scores_in</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    传入的bboxes_in和scores_in,是</span><br><span class="hljs-string">    经过预测后的多张图片多个default box的回归参数以及多个类别的置信度</span><br><span class="hljs-string">    本方法目的:</span><br><span class="hljs-string">    ①得到最终预测框;</span><br><span class="hljs-string">    ②对预测框变换坐标格式,便于后期nms;</span><br><span class="hljs-string">    ③对多个类别置信度用softmax获得类别概率</span><br><span class="hljs-string">    :param bboxes_in: [N,4,8732]</span><br><span class="hljs-string">    :param scores_in: [N,num_classes,8732]</span><br><span class="hljs-string">    :return: (bboxes_in,scores_in)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># [N,8732,4]</span><br>    bboxes_in = bboxes_in.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># [N,8732,num_classes]</span><br>    scores_in = scores_in.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># loss为了加速收敛分别对xy和wh除以了0.1和0.2,这里要乘回来,得到预测的回归参数</span><br>    bboxes_in[:, :, :<span class="hljs-number">2</span>] = self.scale_xy * bboxes_in[:, :, :<span class="hljs-number">2</span>]<br>    bboxes_in[:, :, <span class="hljs-number">2</span>:] = self.scale_wh * bboxes_in[:, :, <span class="hljs-number">2</span>:]<br><br>    <span class="hljs-comment"># 最终预测框的位置</span><br>    bboxes_in[:, :, :<span class="hljs-number">2</span>] = bboxes_in[:, :, :<span class="hljs-number">2</span>] * self.dboxes_xywh[:, :, <span class="hljs-number">2</span>:] + self.dboxes_xywh[:, :, :<span class="hljs-number">2</span>]<br>    bboxes_in[:, :, <span class="hljs-number">2</span>:] = bboxes_in[:, :, <span class="hljs-number">2</span>:].exp() * self.dboxes_xywh[:, :, <span class="hljs-number">2</span>:]<br><br>    <span class="hljs-comment"># 转换为ltrb格式,便于之后计算nms</span><br>    l = bboxes_in[:, :, <span class="hljs-number">0</span>] - <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">2</span>]<br>    r = bboxes_in[:, :, <span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">2</span>]<br>    t = bboxes_in[:, :, <span class="hljs-number">1</span>] - <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">3</span>]<br>    b = bboxes_in[:, :, <span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">3</span>]<br><br>    bboxes_in[:, :, <span class="hljs-number">0</span>] = l<br>    bboxes_in[:, :, <span class="hljs-number">1</span>] = t<br>    bboxes_in[:, :, <span class="hljs-number">2</span>] = r<br>    bboxes_in[:, :, <span class="hljs-number">3</span>] = b<br><br>    <span class="hljs-comment"># 对置信度用softmax转换为概率值 [N,8732,num_classes]</span><br>    <span class="hljs-keyword">return</span> bboxes_in, F.softmax(scores_in, dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h6 id="nms"><a class="markdownIt-Anchor" href="#nms"></a> nms</h6><p>当我们得到最终的预测框以及概率值,我们便要进入非极大值抑制(nms),这一步的目的是去除冗余框</p><p>比如人脸检测的时候,在一个人的周围会生成很多框,但是只应留下一个最合适的,很明显即应该留下预测为人的概率值最大的</p><p>若是在一幅图片中有两张人脸需要检测,也依旧如此:①保留概率最大的预测框②与概率最大的预测框进行IoU计算,若大于阈值则认为检测的是同一张人脸,应该删去③若小于等于阈值则认为可能是别的人脸,则此时在剩下的预测框中(原先①中最大的已被剔除,②中大于阈值的也被剔除了)重复以上过程</p><p>最终即可以得到我们所期望的对应的预测框</p><p>以下是nms代码(官方给我们调用的以及自己写的),其中pytorch官方有提供相应函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nms</span>(<span class="hljs-params">boxes, scores, iou_threshold</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    非极大值抑制,去除冗余框</span><br><span class="hljs-string">    :param boxes: tensor[N,4]</span><br><span class="hljs-string">    :param scores: tensor[N]</span><br><span class="hljs-string">    :param iou_threshold: float be used to remove the similarity region boxes</span><br><span class="hljs-string">    :return: tensor,one dimension,refer to the useful boxes indexes</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> torch.ops.torchvision.nms(boxes, scores, iou_threshold)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nms_</span>(<span class="hljs-params">boxes: Tensor, scores: Tensor, iou_threshold: <span class="hljs-built_in">float</span></span>) -&gt; Tensor:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据scores排序,将最大分值的box的索引加入keep,然后用最大分值的box与其他boxes相比(IoU),大于阈值则滤去,</span><br><span class="hljs-string">    然后在剩下的scores又拿最大的进行比较,直至全部比较完毕</span><br><span class="hljs-string">    :param boxes: Tensor[N,4]</span><br><span class="hljs-string">    :param scores: Tensor[N]</span><br><span class="hljs-string">    :param iou_threshold:</span><br><span class="hljs-string">    :return: keep:Tensor</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 最终留下来的boxes的索引用keep存储</span><br>    keep = []<br>    <span class="hljs-comment"># 对scores升序排序,取索引</span><br>    idxs = scores.argsort()<br>    <span class="hljs-comment"># 当idxs还有元素,就继续循环,除非元素都没了(或移除,或留下至keep)</span><br>    <span class="hljs-keyword">while</span> idxs.numel() &gt; <span class="hljs-number">0</span>:<br>        max_score_idx = idxs[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># [1,4]</span><br>        max_score_box = boxes[max_score_idx][<span class="hljs-literal">None</span>, :]<br>        keep.append(max_score_idx)<br>        <span class="hljs-comment"># 表示当前只剩下最后一个元素,且已经加入keep中,直接退出循环即可</span><br>        <span class="hljs-keyword">if</span> idxs.size(<span class="hljs-number">0</span>) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 去除得分最大框</span><br>        idxs = idxs[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># [M,4],其中M表示是idxs的size,指取出还没处理的框</span><br>        other_boxes = boxes[idxs]<br>        <span class="hljs-comment"># [1,M]</span><br>        ious = calc_iou_tensor(max_score_box, other_boxes)<br>        <span class="hljs-comment"># 去除冗余框!</span><br>        idxs = idxs[ious[<span class="hljs-number">0</span>] &lt;= iou_threshold]<br><br>    keep = idxs.new(keep)<br>    <span class="hljs-keyword">return</span> keep<br></code></pre></td></tr></table></figure><p>而从上述代码,我们也不难看出来nms是只对同一类别进行处理,若是多个类别呢?我们当然可以一个类别逐次进行nms,但是这样效率较慢</p><p>我们知道<strong>IoU计算实际上就是计算两个框的重叠性</strong>,那也即是说<strong>IoU本质上也是受到空间距离因素影响</strong>的,我们只要<strong>将不同类别的框的空间距离拉开不同的距离,而同类别框的空间距离拉开相同的距离</strong>,就可以使得nms起作用</p><p>以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">batched_nms</span>(<span class="hljs-params">bboxes, scores, idxs, iou_threshold</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes: 位置信息</span><br><span class="hljs-string">    :param scores: 分类概率</span><br><span class="hljs-string">    :param idxs: 标签</span><br><span class="hljs-string">    :param iou_threshold: IoU阈值</span><br><span class="hljs-string">    :return: keep:Tensor 留下来的框的索引</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> bboxes.numel() == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> torch.empty(<span class="hljs-number">0</span>, dtype=torch.int64, device=bboxes.device)<br><br>    <span class="hljs-comment"># 在所有default box的所有坐标中取最大值,作为一个离散因子,离散化不同类别,因为nms是针对同一类别所做的</span><br>    max_factor = bboxes.<span class="hljs-built_in">max</span>()<br>    <span class="hljs-comment"># 偏移值:按照类别离散化</span><br>    offsets = idxs.to(bboxes) * (max_factor + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 对bboxes加上偏移值</span><br>    bboxes_nms = bboxes + offsets[:, <span class="hljs-literal">None</span>]<br>    <span class="hljs-comment"># nms</span><br>    keep = nms(bboxes_nms, scores, iou_threshold)<br>    <span class="hljs-keyword">return</span> keep<br></code></pre></td></tr></table></figure><p>其实在进行nms之前,我们还需要对一些低概率box,面积过小box进行移除,之后再进入nms,以减少不必要的计算</p><p>以下是包含了上述说的以及nms过程的代码,其中该方法是对单张图片进行处理,需要注意,SSD中预测定位与分类是两个不大相干的任务,即预测定位无需关心它是哪一类别的目标,而在这个方法中,我们采取了Faster RCNN的方法,来将一个预测框与多个类别相关联,以便于后面的nms:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_singe_image</span>(<span class="hljs-params">self, bboxes_in, scores_in, criteria, max_output</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes_in: [8732,4]</span><br><span class="hljs-string">    :param scores_in: [8732,num_classes]</span><br><span class="hljs-string">    :param criteria: nms criteria</span><br><span class="hljs-string">    :param max_output: the maximal number of output boxes</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    device = bboxes_in.device<br>    num_classes = scores_in.shape[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 裁剪边界</span><br>    bboxes_in = bboxes_in.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># default box只关注回归问题 -&gt; default box的回归问题与object类别相关(用于简化nms)</span><br>    <span class="hljs-comment"># [8732,4] -&gt; [8732,21,4]</span><br>    bboxes_in = bboxes_in.repeat(<span class="hljs-number">1</span>, num_classes).reshape(scores_in.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><br>    <span class="hljs-comment"># 创建标签,用以与default box们对应</span><br>    <span class="hljs-comment"># [num_classes]</span><br>    labels = torch.arange(num_classes, device=device)<br>    <span class="hljs-comment"># [num_classes] -&gt; [1,num_classes] -&gt; [8732,num_classes]</span><br>    labels = labels.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).expand_as(scores_in)<br><br>    <span class="hljs-comment"># 移除背景类的信息 num_classes -&gt; num_classes - 1</span><br>    bboxes_in = bboxes_in[:, <span class="hljs-number">1</span>:, :]<br>    scores_in = scores_in[:, <span class="hljs-number">1</span>:]<br>    labels = labels[:, <span class="hljs-number">1</span>:]<br><br>    <span class="hljs-comment"># 合并default box的维度(之前扩了num_classes倍)</span><br>    <span class="hljs-comment"># [8732*20,4] 20是用的voc数据集,有21个类别(含背景)</span><br>    bboxes_in = bboxes_in.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># [8732*20]</span><br>    scores_in = scores_in.reshape(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># [8732*20]</span><br>    labels = labels.reshape(-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 移除低概率目标</span><br>    idxs = torch.where(torch.gt(scores_in, <span class="hljs-number">0.05</span>))[<span class="hljs-number">0</span>]<br>    bboxes_in, scores_in, labels = bboxes_in[idxs, :], scores_in[idxs], labels[idxs]<br><br>    <span class="hljs-comment"># 移除面积很小很小的box</span><br>    widths, heights = (bboxes_in[:, <span class="hljs-number">2</span>] - bboxes_in[:, <span class="hljs-number">0</span>]), (bboxes_in[:, <span class="hljs-number">3</span>] - bboxes_in[:<span class="hljs-number">1</span>])<br>    keep = (widths &gt;= <span class="hljs-number">1</span> / <span class="hljs-number">300</span>) &amp; (heights &gt;= <span class="hljs-number">1</span> / <span class="hljs-number">300</span>)<br>    keep = torch.where(keep)[<span class="hljs-number">0</span>]<br>    bboxes_in, scores_in, labels = bboxes_in[keep, :], scores_in[keep], labels[keep]<br><br>    <span class="hljs-comment"># NMS</span><br>    keep = batched_nms(bboxes_in, scores_in, labels, iou_threshold=criteria)<br><br>    <span class="hljs-comment"># 按iou高的取预测框</span><br>    keep = keep[:max_output]<br>    bboxes_out = bboxes_in[keep, :]<br>    scores_out = scores_in[keep]<br>    labels_out = labels[keep]<br><br>    <span class="hljs-keyword">return</span> bboxes_out, scores_out, labels_out<br></code></pre></td></tr></table></figure><p>以下是<code>PostProcess</code>这个类的forward方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, bboxes_in, scores_in</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes_in: [N,4,8732]</span><br><span class="hljs-string">    :param scores_in: [N,num_classes,8732]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获得最终预测框,并且对置信度做softmax运算获得每个类别的概率</span><br>    <span class="hljs-comment"># [N,8732,4],[N,8732,num_classes]</span><br>    bboxes, probs = self.scale_back_batch(bboxes_in, scores_in)<br><br>    <span class="hljs-comment"># 用于TorchScript的</span><br>    outputs = torch.jit.annotate(<span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Tensor, Tensor, Tensor]], [])<br><br>    <span class="hljs-comment"># 逐张图片做出预测结果</span><br>    <span class="hljs-keyword">for</span> bbox, prob <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(bboxes.split(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (probs.split(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))):<br>        <span class="hljs-comment"># [1,8732,4],[1,8732,num_classes] -&gt; [8732,4],[8732,num_classes]</span><br>        bbox = bbox.squeeze(<span class="hljs-number">0</span>)<br>        prob = prob.squeeze(<span class="hljs-number">0</span>)<br>        outputs.append(self.decode_singe_image(bbox, prob, self.criteria, self.max_output))<br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>至此,本文已经讲完了SSD进行目标检测任务的整体模型搭建过程,而在实际应用中,还需要涉及到如<strong>数据库数据解析</strong>(比如VOC或COCO数据集的解析),<strong>数据预处理</strong>,<strong>优化器选择</strong>,<strong>学习率调整</strong>等部分</p><p>最后给出一张利用SSD进行预测的图像:</p><p><img src="https://s2.loli.net/2023/11/03/qRyNa4DuYB1Tlfo.png" alt="ssd_experiment" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>SSD</tag>
      
      <tag>Object Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some lib of Python</title>
    <link href="/2023/03/14/Some-lib-of-Python/"/>
    <url>/2023/03/14/Some-lib-of-Python/</url>
    
    <content type="html"><![CDATA[<h2 id="tqdm"><a class="markdownIt-Anchor" href="#tqdm"></a> tqdm</h2><p>tqdm是一个可视化的进度条,用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br>range_object = <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)<br>t_bar = tqdm(range_object)<br><span class="hljs-keyword">for</span> i,e <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(t_bar):<br>    time.sleep(<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><p>上述便是tqdm的一个例子,无需print便会在控制台自动输出对应内容的进度条信息</p><p>以下是tqdm这个类可接收的参数信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, iterable=<span class="hljs-literal">None</span>, desc=<span class="hljs-literal">None</span>, total=<span class="hljs-literal">None</span>, leave=<span class="hljs-literal">True</span>, file=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             ncols=<span class="hljs-literal">None</span>, mininterval=<span class="hljs-number">0.1</span>, maxinterval=<span class="hljs-number">10.0</span>, miniters=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-built_in">ascii</span>=<span class="hljs-literal">None</span>, disable=<span class="hljs-literal">False</span>, unit=<span class="hljs-string">&#x27;it&#x27;</span>, unit_scale=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             dynamic_ncols=<span class="hljs-literal">False</span>, smoothing=<span class="hljs-number">0.3</span>, bar_format=<span class="hljs-literal">None</span>, initial=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             position=<span class="hljs-literal">None</span>, postfix=<span class="hljs-literal">None</span>, unit_divisor=<span class="hljs-number">1000</span>, write_bytes=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             lock_args=<span class="hljs-literal">None</span>, nrows=<span class="hljs-literal">None</span>, colour=<span class="hljs-literal">None</span>, delay=<span class="hljs-number">0</span>, gui=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             **kwargs</span>):</span> <br></code></pre></td></tr></table></figure><ul><li>iterable: 接收可迭代对象</li><li>desc: 接收str,用于进度条左侧显示文字</li><li>total: iterable的迭代总次数</li><li>leave: 接收bool值,迭代完成后是否保留进度条,默认True</li><li>file: 输出位置,默认终端</li><li>ncols: 进度条宽度</li><li>unit: 进度条里的单位,默认是<code>it</code>,显示于<code>2.28 it/s</code>,即更改的是<code>it</code>这个单位</li><li>unit_scale:默认False,开启则代表根据国际标准对速度单位进行换算</li><li>postfix: 接收dict,传入信息显示于进度条右侧</li><li>colour: 进度条颜色</li></ul><p>此外,除了在构建进度条时设置的内容,在进度条内部的迭代对象在迭代过程中的元素也可以加入进度条中进行显示,通过如下方式增加:</p><p><code>set_description()</code>: 显示于进度条左侧<br /><code>set_postfix()</code>: 显示于进度条右侧</p><p>例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br><br>iter_object = <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>)<br>tbar = tqdm(iter_object, desc=<span class="hljs-string">&quot;train&quot;</span>, colour=<span class="hljs-string">&quot;green&quot;</span>)<br><span class="hljs-keyword">for</span> i, e <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tbar):<br>    time.sleep(<span class="hljs-number">0.4</span>)<br>    tbar.set_description(<span class="hljs-string">&quot;epoch[&#123;&#125;/&#123;&#125;]&quot;</span>.<span class="hljs-built_in">format</span>(i, <span class="hljs-number">200</span>))<br>    tbar.set_postfix(loss=random.random(), cost_time=random.randrange(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><p>注意:set_postfix传入的参数是<code>**kwargs</code>,即可传入<code>dict</code>(** -&gt; 表示接收可变长参数,以字典形式接收之,同样单星号也是接收可变长参数,不过是以list形式接收之),也可以关键字形式传入</p><h2 id="argparse"><a class="markdownIt-Anchor" href="#argparse"></a> argparse</h2><p>用于编写命令行接口.对我们指定的参数可以通过命令行的长指令写入并在程序中解析.例子如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><span class="hljs-comment"># 1. 定义解析器对象</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;demo of argparse&quot;</span>)<br><span class="hljs-comment"># 2. 添加命令行参数</span><br>parser.add_argument(<span class="hljs-string">&quot;--epoches&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">5</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;epoch of the model&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--lr&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">float</span>, default=<span class="hljs-number">.0001</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;learning rate of the gradient&quot;</span>)<br><span class="hljs-comment"># 3. 解析命令行参数</span><br>args = parser.parse_args()<br><span class="hljs-comment"># 4. 使用命令行参数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoches: &#123;&#125; lr: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(args.epoches, args.lr))<br><br></code></pre></td></tr></table></figure><p>在终端中输入<code>python ./xxx.py --epoches=100 --lr=0.005</code>即可以将对应的参数输入并于程序中解析.同时也可以查看对应的帮助文档<code>python ./xxx.py -h</code></p><h2 id="torchutilstensorboard"><a class="markdownIt-Anchor" href="#torchutilstensorboard"></a> torch.utils.tensorboard</h2><h3 id="summarywriter"><a class="markdownIt-Anchor" href="#summarywriter"></a> SummaryWriter</h3><p>我们知道tensorboard是用于模型训练验证中的可视化,比如记录loss,accurate变化(以曲线图形式表征之)</p><p>而SummaryWriter这一个类则可以向tensorboard中写入对应的数据信息</p><p>SummaryWriter是tensorboard下属的一个类,它会write out event file在我们的项目下,默认存储事件文件的文件夹是runs,可通过如下方式修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">event_writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此当我们run当前的python文件就会在当前项目下产生一个logs文件夹,并且里面存放着刚刚运行后的event file.</p><p>有了event file后便可以查看可视化后的内容,在终端输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tensorboard --logdir=logs<br></code></pre></td></tr></table></figure><p>之后便可以打开终端显示的链接<code>localhost:6006</code>来查看可视化后的内容(端口号可以通过<code>--port=xxx</code>来修改)</p><p>显然,此时你看不到有啥可视化后的内容,因为你还没将需要可视化的数据写入tensorboard中</p><h4 id="add_scalar"><a class="markdownIt-Anchor" href="#add_scalar"></a> add_scalar</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWritter<br><span class="hljs-comment"># ...</span><br>event_writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>event_writer.add_scalar(tag,scalar_value,step)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tag -&gt; 在tensorboard上显示的名字,类似于该图对应的标题</span><br><span class="hljs-string">scalar_value -&gt; 相当于纵坐标对应的值</span><br><span class="hljs-string">step -&gt; 相当于横坐标对应的值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># e.g.:绘制训练模型过程中的loss值随epoch的变化</span><br>event_writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>,train_loss,epoch)<br></code></pre></td></tr></table></figure><h4 id="add_image"><a class="markdownIt-Anchor" href="#add_image"></a> add_image</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">event_writer.add_image(tag,img_tensor,step,dataformats)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tag -&gt; 在tensorboard上显示的名字,类似于该图对应的标题</span><br><span class="hljs-string">img_tensor -&gt; img的数据,允许numpy.ndarray;torch.Tensor;string等</span><br><span class="hljs-string">step -&gt; 好像也是横坐标对应的值</span><br><span class="hljs-string">dataformats -&gt; img的shape对应的是HWC还是CHW</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># e.g.:</span><br>img_path = <span class="hljs-string">&quot;./tulip.jpeg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br>img_ndarray = np.array(img)<br>event_writer.add_image(<span class="hljs-string">&quot;tulip&quot;</span>, img_ndarray, <span class="hljs-number">1</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br></code></pre></td></tr></table></figure><p>最后,使用完后记得关闭之<code>event_writer.close()</code></p><h2 id="torchoptimlr_scheduler"><a class="markdownIt-Anchor" href="#torchoptimlr_scheduler"></a> torch.optim.lr_scheduler</h2><h2 id="fvcorenn"><a class="markdownIt-Anchor" href="#fvcorenn"></a> fvcore.nn</h2><p>fvcore是Facebook开源的轻量核心库,<strong>可以用于计算浮点运算量(FLOPs,计算量),模型参数量</strong>等</p><p>注:</p><ul><li>FLOPS是floating point operations per second,每秒浮点运算次数,即计算速度;</li><li>FLOPs是floating point operations,浮点运算量,即计算量</li></ul><h3 id="flopcountanalysis"><a class="markdownIt-Anchor" href="#flopcountanalysis"></a> FlopCountAnalysis</h3><p>简单使用如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet50<br><span class="hljs-keyword">from</span> fvcore.nn <span class="hljs-keyword">import</span> FlopCountAnalysis,parameter_count_table<br><br>model = resnet50(num_classes=<span class="hljs-number">1000</span>)<br>tensor = torch.rand(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)<br>FLOPs = FlopCountAnalysis(model,tensor)<br><span class="hljs-built_in">print</span>(parameter_count_table(model))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FLOPs: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(FLOPs.total()))<br></code></pre></td></tr></table></figure><h2 id="itertools"><a class="markdownIt-Anchor" href="#itertools"></a> itertools</h2><h3 id="product"><a class="markdownIt-Anchor" href="#product"></a> product</h3><p>用于计算笛卡尔积,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>output = itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele))<br></code></pre></td></tr></table></figure><p>输出结果:</p><p><img src="https://s2.loli.net/2023/11/03/YQ7BwxTmiqESg6U.jpg" alt="itertools-product" /></p><p>它的property有repeat,即是将前面的元素笛卡尔积的结果,作为新元素,重复repeat遍,然后做笛卡尔积,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>output = itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], repeat=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele), end=<span class="hljs-string">&quot;\t&quot;</span>)<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果:</p><p><img src="https://s2.loli.net/2023/11/03/rfB5W76Y8jLidaF.jpg" alt="itertools-product-repeat" /></p><h2 id="python的一些新学到的小知识"><a class="markdownIt-Anchor" href="#python的一些新学到的小知识"></a> Python的一些新学到的小知识</h2><h3 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h3><p>在方法中标注<code>@property</code>这样的注解,可用于将变量私有化(毕竟python提供的伪私有类型是伪的),此时方法便可以像成员变量一样使用.e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, _scale</span>):</span><br>        self._scale = _scale<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._scale<br><br><br>t = Test(<span class="hljs-number">5.0</span>)<br><span class="hljs-built_in">print</span>(t.scale)<br><span class="hljs-comment"># 5.0</span><br><span class="hljs-built_in">print</span>(t.scale())<br><span class="hljs-comment"># TypeError: &#x27;float&#x27; object is not callable</span><br></code></pre></td></tr></table></figure><p>由此可见,加上<code>@property</code>就是把一个function变成了variable,用以保护其内部真正的成员变量名</p><h2 id="torchsummary"><a class="markdownIt-Anchor" href="#torchsummary"></a> torchsummary</h2><p>torchsummary和torchstat、profile这些库一样，可以计算出模型中每层的参数量，总参数量，参数大小等信息，后面的两个库可以计算出flops等信息，这些库需要提前安装一下。</p><p>以下是torchsummary的使用案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet50<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>net = resnet50()<br>net.to(device)<br>summary(net, (<span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br></code></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://s2.loli.net/2023/11/28/JVWoFUtE1fMhNv2.png" alt="torchsummary_resnet18" /></p><h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> copy</h2><p>copy这个库，可以当我们在需要的时候对对象做深浅拷贝</p><p>以下是示例，结合示例进行分析，其中<code>copy.copy()</code>是浅拷贝，<code>copy.deepcopy()</code>是深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>one = <span class="hljs-string">&#x27;def&#x27;</span><br>l1 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], one]<br>l2 = l1<br>l3 = copy.copy(l1)<br>l4 = copy.deepcopy(l1)<br>l1[-<span class="hljs-number">1</span>] = l1[-<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;g&#x27;</span><br>l1[-<span class="hljs-number">2</span>].append(<span class="hljs-string">&#x27;d&#x27;</span>)<br>l1.append(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;one:&quot;</span>, one)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l1:&quot;</span>, l1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l2:&quot;</span>, l2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l3:&quot;</span>, l3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l4:&quot;</span>, l4)<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2023/11/29/Me6VtRXgdKvwOfu.png" alt="copy lib" /></p><p>不难看出在<code>l1</code>中我们增加了作为<code>str</code>对象的<code>one</code>，但是<code>l1</code>并没有跟<code>one</code>一起指向同一块地址（那就是new了一块新的空间给它），因此在后续对该列表值修改的时候，并没有影响到<code>one</code>对象的值；</p><p>对于直接赋值的<code>l2</code>应该跟<code>l1</code>指的是同一块地址；</p><p>对于浅拷贝的<code>l3</code>，只是拷贝了深拷贝的第一层（父对象），对于里面的父对象内部的对象，则是指的同一块地址；</p><p>对于深拷贝的<code>l4</code>，则对全部对象内容进行了拷贝</p>]]></content>
    
    
    
    <tags>
      
      <tag>python lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some knowledge of Pytorch</title>
    <link href="/2023/03/14/Some-knowledge-of-Pytorch/"/>
    <url>/2023/03/14/Some-knowledge-of-Pytorch/</url>
    
    <content type="html"><![CDATA[<h2 id="torch中涉及到的一些函数记录"><a class="markdownIt-Anchor" href="#torch中涉及到的一些函数记录"></a> torch中涉及到的一些函数记录</h2><h2 id="torchnnmodule中的modules和children的区别"><a class="markdownIt-Anchor" href="#torchnnmodule中的modules和children的区别"></a> torch.nn.Module中的modules()和children()的区别</h2><p>首先构建一个全连接网络,看看它的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_dim, hidden_dim1, hidden_dim2, hidden_dim3, out_dim</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.layer1 = nn.Sequential(<br>            nn.Linear(in_dim, hidden_dim1),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        )<br>        self.layer2 = nn.Sequential(<br>            nn.Linear(hidden_dim1, hidden_dim2),<br>            nn.Sigmoid()<br>        )<br>        self.layer3 = nn.Sequential(<br>            nn.Linear(hidden_dim2, hidden_dim3),<br>            nn.Tanh()<br>        )<br>        self.layer4 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.layer1(x)<br>        x = self.layer2(x)<br>        x = self.layer3(x)<br>        x = self.layer4(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># net arch</span><br>    <span class="hljs-built_in">print</span>(net)<br></code></pre></td></tr></table></figure><p>其结构为:</p><p><img src="https://s2.loli.net/2023/11/03/DiRezlK3bdN8BAp.jpg" alt="fcn arch" /></p><p>其结构图大致如下(Sequential以layer的标识号区别之,别的亦同)</p><pre class="mermaid">graphTestNet-->Sequential1 & Sequential2 & Sequential3 & ReLUSequential1 --> Linear1 & ReLU1Sequential2 --> Linear2 & SigmoidSequential3 --> Linear3 & Tanh%% layer4 --> ReLU4</pre><p>而当我们利用<code>net.children()</code>打印时,发现其是generator类型,也即是iterator类型,因此可以通过循环将其输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># children arch</span><br>    <span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(net.children()):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele))<br></code></pre></td></tr></table></figure><p>其输出结果如下:</p><p><img src="https://s2.loli.net/2023/11/03/57SYoj3rz4Lmftv.jpg" alt="fcn-children-arch" /></p><p>可见<strong>通过children()获得的结构仅包含最外一层</strong>,也即可以通过如下方式获得其最外层:<code>print(list(net.children())[0])</code>,即可以获得第0个Sequential:</p><p><img src="https://s2.loli.net/2023/11/03/DFwYUoTCq4em1uP.jpg" alt="fcn-children-arch-0" /></p><p>而通过modules()获得的也是generator类型,因此也用循环将其输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># modules arch</span><br>    <span class="hljs-keyword">for</span> i,ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(net.modules()):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i,ele))<br></code></pre></td></tr></table></figure><p>其输出结果为:</p><p><img src="https://s2.loli.net/2023/11/03/dG2D8SmkpXiHUAJ.png" alt="fcn-modules-arch" /></p><p>可见,其结果类似于深搜,直接把整个结构DFS了一遍</p><p>因此可得<code>children()</code>和<code>modules()</code>的区别如下:</p><ul><li>通过<code>children()</code>获取网络层级结构,只会取最外层,即根节点下的一层</li><li>通过<code>modules()</code>获取网络层级结构,则类似对网络结构进行DFS,依次输出</li></ul><div class="note note-info">            <p>关于<code>named_children()</code>和<code>named_modules()</code>就不再赘述,因为是在<code>children()</code>和<code>modules()</code>的基础上加了个名字,同样的,它们也是generator类型,可以通过循环遍历,不过对应的是<code>name</code>和<code>module</code>(就是上面代码中的<code>ele</code>),可以通过列表推导式查看相应的结果:</p><p><code>net_named_children = [x for x in net.named_children()]</code></p><p><code>net_named_modules = [x for x in net.named_modules()]</code></p><p>而<code>net.parameters()</code>和<code>net.named_parameters()</code>打印的是模型每层的参数,而多了个<code>named</code>的方法则是把对应的层/子模块的名称也带上了.可以通过列表推导式来查看相应的结果.通过它们的类型也是generator.</p><p><code>net_parameters = [x for x in net.parameters()]</code></p><p><code>net_named_parameters =[x for x in net.named_parameters()]</code></p>          </div><h2 id="pytorch中的模型容器"><a class="markdownIt-Anchor" href="#pytorch中的模型容器"></a> pytorch中的模型容器</h2><p>利用模型容器,可以<strong>自动的将module注册到网络上</strong>,以及<strong>将module的parameters添加到网络上</strong></p><h3 id="nnsequential"><a class="markdownIt-Anchor" href="#nnsequential"></a> nn.Sequential</h3><p>将如<code>Conv2d</code>,<code>BatchNorm2d</code>,<code>ReLU</code>等的module放入<code>nn.Sequential</code>容器中,将会<strong>按照放置的顺序执行</strong>,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br>layer1 = nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br>    nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>    nn.ReLU(),<br>    nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br>    nn.BatchNorm2d(<span class="hljs-number">512</span>),<br>    nn.ReLU()<br>)<br><span class="hljs-built_in">print</span>(layer1)<br></code></pre></td></tr></table></figure><p>其网络层级结构如下所示</p><p><img src="https://s2.loli.net/2023/11/03/iw6r3x1fDpNsymY.png" alt="sequential-arch" /></p><p>其还可以用<code>OrderedDict</code>去为每个module命名,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> collections<br><br>layer1 = nn.Sequential(collections.OrderedDict([<br>    (<span class="hljs-string">&quot;conv1&quot;</span>, nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>    (<span class="hljs-string">&quot;bn1&quot;</span>, nn.BatchNorm2d(<span class="hljs-number">256</span>)),<br>    (<span class="hljs-string">&quot;relu1&quot;</span>, nn.ReLU()),<br>    (<span class="hljs-string">&quot;conv2&quot;</span>, nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>    (<span class="hljs-string">&quot;bn2&quot;</span>, nn.BatchNorm2d(<span class="hljs-number">512</span>)),<br>    (<span class="hljs-string">&quot;relu2&quot;</span>, nn.ReLU())<br>]))<br><span class="hljs-built_in">print</span>(layer1)<br></code></pre></td></tr></table></figure><p>网络层级结构如下示</p><p><img src="https://s2.loli.net/2023/11/03/n8zqxsmtRYagSuG.png" alt="sequential-arch-orderedDict" /></p><h3 id="nnmodulelist"><a class="markdownIt-Anchor" href="#nnmodulelist"></a> nn.ModuleList</h3><p>该模型容器类似于list,较之<code>nn.Sequential</code>可以更灵活的使用,充当了存放module的容器,执行的顺序在<code>forward</code>中自行定义,较之原生的list,则是可以注册module于网络以及对其参数添加进<code>nn.Parameters()</code>中.e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        self.bn1 = nn.BatchNorm2d(<span class="hljs-number">256</span>)<br>        self.relu1 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.layer1 = [nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">100</span>), nn.Linear(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>)]<br>        self.layer2_ = [nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">200</span>), nn.Linear(<span class="hljs-number">200</span>, <span class="hljs-number">10</span>)]<br>        self.layer2 = nn.ModuleList(self.layer2_)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.conv1(x)<br>        x = self.bn1(x)<br>        x = self.relu1(x)<br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.layer1:<br>            x = l(x)<br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.layer2:<br>            x = l(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>其执行结果表示,用list充当容器,并不能将所需的module注册,而ModuleList则可以,结果如下图示</p><p><img src="https://s2.loli.net/2023/11/03/mZ2ADBWYPflF31V.png" alt="modulelist-arch" /></p><h2 id="datasetsamplerdataloader三者关系"><a class="markdownIt-Anchor" href="#datasetsamplerdataloader三者关系"></a> Dataset,Sampler,DataLoader三者关系</h2><p>当我们需要对数据文件进行解析获得数据或者自己创建的数据集<code>ImageFolder</code>不能够满足我们的要求,我们则需要自定义一个<code>Dataset</code>类</p><p>而定义好一个<code>Dataset</code>类后,我们可以通过循环或索引得到对应的一条数据,形如<code>data,target</code>,而<code>Sampler</code>则是对这些一条条的数据进行采样的工具,Pytorch提供的主要有<code>SequentialSampler</code>和<code>RandomSampler</code>,这些采样器采样得到的都是这些数据的索引</p><p>显然我们一条条读取数据并不能满足我们的需求,我们更期望的是以batch为单位的读取数据,因而有<code>BatchSampler</code>这么一个批采样器,它会对我们Sampler,如<code>SequentialSampler</code>采样得到的一个个索引整理成一个<code>batch_size</code>大小的索引序列</p><p>在DataLoader里面,我们便是对<code>BatchSampler</code>这个批采样器采样得到的索引序列进行处理,通过传入的<code>dataset</code>参数读取一条条数据,整理成一个<code>List[Tuple[Tensor,Tensor]]</code>这么一个<code>batch_list</code>的形式,交由<code>collate_fn</code>对这一个<code>batch_size</code>大小的数据进行整理,而后得到我们在循环里对<code>DataLoader</code>遍历的数据</p><p>以下展现的是工作进程(num_worker)为0的<code>DataLoader</code>处理方式(跟我上面说的流程一样):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dataloader.py:</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataLoader</span>(<span class="hljs-params"><span class="hljs-type">Generic</span>[T_co]</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_iterator</span>(<span class="hljs-params">self</span>) -&gt; &#x27;_BaseDataLoaderIter&#x27;:</span><br>        <span class="hljs-keyword">if</span> self.num_workers == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> _SingleProcessDataLoaderIter(self)<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SingleProcessDataLoaderIter</span>(<span class="hljs-params">_BaseDataLoaderIter</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_next_data</span>(<span class="hljs-params">self</span>):</span><br>        index = self._next_index()  <span class="hljs-comment"># may raise StopIteration</span><br>        data = self._dataset_fetcher.fetch(index)  <span class="hljs-comment"># may raise StopIteration</span><br>        <span class="hljs-keyword">if</span> self._pin_memory:<br>            data = _utils.pin_memory.pin_memory(data)<br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># fetch.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MapDatasetFetcher</span>(<span class="hljs-params">_BaseDatasetFetcher</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">self, possibly_batched_index</span>):</span><br>        <span class="hljs-keyword">if</span> self.auto_collation:<br>            data = [self.dataset[idx] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> possibly_batched_index]<br>        <span class="hljs-keyword">else</span>:<br>            data = self.dataset[possibly_batched_index]<br>        <span class="hljs-keyword">return</span> self.collate_fn(data)<br></code></pre></td></tr></table></figure><p>自定义一个<code>Dataset</code>类需要的工作:</p><ul><li>继承<code>torch.utils.data.Dataset</code></li><li>在<code>__init__</code>中传入需要处理的数据(可能是数据的目录啥的),对数据的预处理方法</li><li>在**<code>__getitem__</code>**中完成对数据的解析,预处理,然后返回对应的数据,如<code>return data,target</code></li><li>在<code>__len__</code>中反应需要处理的数据集的大小</li></ul><p>自定义一个Sampler类需要的工作:</p><ul><li>继承<code>torch.utils.data.Sampler</code></li><li>在<code>__iter__</code>方法中返回一个iterator</li></ul><h2 id="torchutilsdatadataloader中的collate_fn"><a class="markdownIt-Anchor" href="#torchutilsdatadataloader中的collate_fn"></a> torch.utils.data.DataLoader中的collate_fn</h2><p>在涉及到数据集处理的时候,我们需要考虑到<code>torch.utils.data.Dataset</code>类,以及<code>torch.utils.data.DataLoader</code>类</p><p>其中前者是我们对数据集的处理,比如解析数据集数据,然后<strong>重写<code>__len__()</code>以及<code>__getitem__()</code>方法</strong>,而后在其中对数据进行<strong>预处理</strong>操作,然后才会得到**<code>data,target</code><strong>这样的数据,其中<code>data</code>可以是图像之类的,而<code>target</code>则可能是标签,GTbox的位置等信息,这时我们通过<code>__getitem__</code>方法</strong>只是获取到一条<code>data,target</code>数据**,处理批量数据的任务则由<code>DataLoader</code>承担</p><p>我们在不考虑这一部分将要提及的<code>collate_fn</code>方法前,看一看<code>DataLoader</code>是怎么样将一条数据变成一个<code>batch_size</code>的数据的</p><p>以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br>data = torch.tensor([<br>    [<span class="hljs-number">0.4698</span>, <span class="hljs-number">0.6971</span>, <span class="hljs-number">0.9499</span>, <span class="hljs-number">0.3641</span>],<br>    [<span class="hljs-number">0.0896</span>, <span class="hljs-number">0.5345</span>, <span class="hljs-number">0.5603</span>, <span class="hljs-number">0.5409</span>],<br>    [<span class="hljs-number">0.4988</span>, <span class="hljs-number">0.2155</span>, <span class="hljs-number">0.1244</span>, <span class="hljs-number">0.3456</span>],<br>    [<span class="hljs-number">0.4812</span>, <span class="hljs-number">0.0108</span>, <span class="hljs-number">0.1885</span>, <span class="hljs-number">0.8593</span>],<br>    [<span class="hljs-number">0.6564</span>, <span class="hljs-number">0.3428</span>, <span class="hljs-number">0.8815</span>, <span class="hljs-number">0.3558</span>]])<br>target = torch.tensor([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])<br>dataset = Data.TensorDataset(data, target)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dataset:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br>batch_size = <span class="hljs-number">2</span><br>dataloader = Data.DataLoader(batch_size=batch_size, dataset=dataset)<br><br><span class="hljs-keyword">for</span> d, t <span class="hljs-keyword">in</span> dataloader:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;data:<span class="hljs-subst">&#123;d&#125;</span>\ntarget:<span class="hljs-subst">&#123;t&#125;</span>\n&quot;</span>)<br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">(tensor([0.4698, 0.6971, 0.9499, 0.3641]), tensor(4))</span><br><span class="hljs-string">(tensor([0.0896, 0.5345, 0.5603, 0.5409]), tensor(4))</span><br><span class="hljs-string">(tensor([0.4988, 0.2155, 0.1244, 0.3456]), tensor(1))</span><br><span class="hljs-string">(tensor([0.4812, 0.0108, 0.1885, 0.8593]), tensor(3))</span><br><span class="hljs-string">(tensor([0.6564, 0.3428, 0.8815, 0.3558]), tensor(1))</span><br><span class="hljs-string">data:tensor([[0.4698, 0.6971, 0.9499, 0.3641],</span><br><span class="hljs-string">        [0.0896, 0.5345, 0.5603, 0.5409]])</span><br><span class="hljs-string">target:tensor([4, 4])</span><br><span class="hljs-string"></span><br><span class="hljs-string">data:tensor([[0.4988, 0.2155, 0.1244, 0.3456],</span><br><span class="hljs-string">        [0.4812, 0.0108, 0.1885, 0.8593]])</span><br><span class="hljs-string">target:tensor([1, 3])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>可见,<code>dataset</code>的结构应是一个<code>Sequential[Tuple[Tensor,Tensor]]</code>,而其中一条数据中的tuple里面则包含了<code>data</code>以及<code>target</code>,也即是说通过<code>Dataset</code>我们逐条获取数据得到的是形如<code>(data,target)</code>这样的数据</p><p>而显然我们更加希望<code>data</code>归为<code>data</code>,而<code>target</code>归为<code>target</code>,就如用普通的<code>DataLoader</code>得到的结果一样,输出的结果是一个batch的data和一个batch的target</p><p>显然<code>DataLoader</code>在其内部即帮我们完成了①按batch_size划分数据;②<code>data</code>为<code>data</code>,<code>target</code>为<code>target</code></p><p>以下,我们采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的形式于<code>collate_fn</code>看下输出的结果是什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">loader = Data.DataLoader(batch_size=batch_size, dataset=dataset, collate_fn=<span class="hljs-keyword">lambda</span> x: x)<br>it = <span class="hljs-built_in">iter</span>(loader)<br>batch_data = <span class="hljs-built_in">next</span>(it)<br><span class="hljs-built_in">print</span>(batch_data)<br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># [(tensor([0.4698, 0.6971, 0.9499, 0.3641]), tensor(4)), (tensor([0.0896, 0.5345, 0.5603, 0.5409]), tensor(4))]</span><br></code></pre></td></tr></table></figure><p>根据输出结果不难看出: 在进入<code>collate_fn</code>之前,数据已经按<code>batch_size</code>划分好了,其结构为:<code>List[Tuple(Tensor,Tensor)]</code>,其中List的大小是batch_size的大小,但是数据格式依旧是<code>dataset</code>的结构,因而<code>collate_fn</code>这个方法是用来<strong>调整数据格式</strong>的,在我们不调用自定义的<code>collate_fn</code>时,会用系统默认的函数,将输出调整为batch_size大小的data和target这两个部分</p><p>以下是等价于系统默认的<code>collate_fn</code>(能将输出划分为data和target两部分):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># input x: List[Tuple[Tensor,Tensor],...]</span><br>collate_func = <span class="hljs-keyword">lambda</span> x:(<br>torch.cat(<br>        <span class="hljs-comment"># data: [4] -&gt; [1,4] -&gt; [N,4]</span><br>        <span class="hljs-comment"># target: [1] -&gt; [1,1] -&gt; [N,1]</span><br>        [x[i][j].unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))],<span class="hljs-number">0</span><br>    ) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x[<span class="hljs-number">0</span>]))<br>)<br></code></pre></td></tr></table></figure><p>以上是分别对data,target数据进行取出,然后扩充维度,而后对扩充的维度进行拼接,便得到了期望的结果</p><p>一般来说,不会用到它,但<mark>我在网上以及个人思考后</mark>(pytorch这方面源码没看懂😂),应该是通过<code>torch.stack()</code>进行的维度堆叠,因而如果图片的尺寸或者target中如标签的数目不等,则需要自定义</p><p>比如说一个batch_size是2,那两张图片分别是有两个和三个目标,即对应的target为<code>[2,5]/[3,5]</code>无法用<code>stack()</code>对它们简单的拼接,因而需要自己定义一个<code>collate_fn</code>去处理这个问题,自己去定义一个batch出来的数据的格式</p><h2 id="torch数据并行"><a class="markdownIt-Anchor" href="#torch数据并行"></a> torch数据并行</h2><p>以下内容参考文章:</p><p><a href="https://zhuanlan.zhihu.com/p/648596428">分布式训练</a></p><p><a href="https://zhuanlan.zhihu.com/p/467103734">快速上手</a></p><h3 id="torchnndataparallel"><a class="markdownIt-Anchor" href="#torchnndataparallel"></a> torch.nn.DataParallel</h3><h3 id="torchnndistributeddataparallel"><a class="markdownIt-Anchor" href="#torchnndistributeddataparallel"></a> torch.nn.DistributedDataParallel</h3><h3 id="torchdistributed"><a class="markdownIt-Anchor" href="#torchdistributed"></a> torch.distributed</h3><h2 id="计算图"><a class="markdownIt-Anchor" href="#计算图"></a> 计算图</h2><p>计算图可以表示模型中的<strong>数据</strong>经过<strong>运算</strong>后的流向，是一个有向无环图（DAG），<strong>有利于用链式法则计算梯度</strong>。它是由node和edge构成，node表示的是数据，如Tensor等，edge则表示的是计算，如加减乘除、卷积、非线性函数变换等</p><p><img src="https://s2.loli.net/2023/11/03/lFW9cqwrdLek2xS.jpg" alt="ComputationGraphExample" /></p><p>以上的计算图中，利用代码表示并计算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（即偏导/梯度的分量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>w = torch.tensor([<span class="hljs-number">1.</span>],requires_grad = <span class="hljs-literal">True</span>)<br>x = torch.tensor([<span class="hljs-number">2.</span>],requires_grad = <span class="hljs-literal">True</span>)<br><br>a = torch.add(w,x)<br>b = torch.add(w,<span class="hljs-number">1</span>)<br>y = torch.mul(a,b)<br><br>y.backward()<br><br><span class="hljs-built_in">print</span>(w.grad)<br><br><span class="hljs-comment"># 运行结果如下，其中grad属性是取w的梯度</span><br><span class="hljs-comment"># tensor([5.])</span><br></code></pre></td></tr></table></figure><p>根据链式法则，我们知道，要求</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow></mfrac><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w} = \frac{\partial y}{\partial a}\frac{\partial a }{\partial w} + \frac{\partial y}{\partial b}\frac{\partial b}{\partial w} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>即是对y到w上涉及到的路径进行求和，而路径则是依次求偏导相乘得到的。从图及上式可知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w} = a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，所求得的结果与代码计算的无异</p><p>此外，我们知道原函数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>w</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a = w+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，它们的不同会影响到求导过程中的计算（乘法和加法求导时的区别），因此<code>Tensor</code>中提供了<code>grad_fn</code>属性，便于获取不同运算方式时的求导规则。</p><p>以下是在上面代码补了几行<code>print</code>，打印出<code>grad_fn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.grad_fn)<br><span class="hljs-built_in">print</span>(b.grad_fn)<br><span class="hljs-built_in">print</span>(y.grad_fn)<br><span class="hljs-comment"># 运行结果如下</span><br><span class="hljs-comment"># &lt;AddBackward0 object at 0x000002AA99CA6208&gt;</span><br><span class="hljs-comment"># &lt;AddBackward0 object at 0x000002AA99CA6208&gt;</span><br><span class="hljs-comment"># &lt;MulBackward0 object at 0x000002AA99CA6208&gt;</span><br></code></pre></td></tr></table></figure><p>上图给出的例子中，<code>x</code>和<code>w</code>均是输入值，是作为图中的叶子节点存在的，如果没有特别标明，在反向传播求完梯度后，非叶子节点的梯度是会被释放的，只保留叶子节点的梯度，如需保留非叶子节点的梯度，可以利用<code>retain_grad</code>属性标明</p><p>以下是演示代码及结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>w = torch.tensor([<span class="hljs-number">1.</span>],requires_grad = <span class="hljs-literal">True</span>)<br>x = torch.tensor([<span class="hljs-number">2.</span>],requires_grad = <span class="hljs-literal">True</span>)<br><br>a = torch.add(w,x)<br>b = torch.add(w,<span class="hljs-number">1</span>)<br>y = torch.mul(a,b)<br><br>a.retain_grad()<br>b.retain_grad()<br><br>y.backward()<br><br><span class="hljs-built_in">print</span>(w.grad)<br><span class="hljs-built_in">print</span>(a.grad_fn)<br><span class="hljs-built_in">print</span>(b.grad_fn)<br><span class="hljs-built_in">print</span>(y.grad_fn)<br><br><span class="hljs-built_in">print</span>(a.is_leaf,b.is_leaf,y.is_leaf)<br><span class="hljs-built_in">print</span>(x.is_leaf,w.is_leaf)<br><br><span class="hljs-built_in">print</span>(a.grad,b.grad,y.grad)<br><span class="hljs-comment"># 运行结果如下</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tensor([5.])</span><br><span class="hljs-string">&lt;AddBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">&lt;AddBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">&lt;MulBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">False False False</span><br><span class="hljs-string">True True</span><br><span class="hljs-string">tensor([2.]) tensor([3.]) None</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>详细区别可见：<a href="http://cs231n.stanford.edu/slides/2018/cs231n_2018_lecture08.pdf">cs231n-lecture08-pdf</a></p><h3 id="pytorch和tensorflow计算图比较"><a class="markdownIt-Anchor" href="#pytorch和tensorflow计算图比较"></a> PyTorch和Tensorflow计算图比较</h3><p>PyTorch中的计算图是动态生成的，即类似于解释型语言，它是在运行过程中动态生成的；</p><p>Tensorflow的计算图则是静态生成的，即类似于编译型语言，是先生成计算图，而后进行运算。</p><p>显然动态生成的更灵活，利于定位错误，进行debug；静态生成的则可以进行优化，更高效些。</p><p>PyTorch和Tensorflow现也各自都有动态和静态的计算图于各自的子库中</p><p><img src="https://s2.loli.net/2023/11/03/nvNOErxZqjhtWbk.png" alt="Computation Graph Difference" /></p><h2 id="逐层遍历模型子模块"><a class="markdownIt-Anchor" href="#逐层遍历模型子模块"></a> 逐层遍历模型子模块</h2><p>当我们从<code>torchvision.models</code>中去导入一个模型的时候，比如resnet18</p><p><code>from torchvision.models import resnet18</code></p><p>我们通过<code>print(model) # resnet18</code>会打印出模型详细的层信息，这些个层信息是经由<code>OrderedDict</code>包装过的，即是通过该结构对层信息进行重命名</p><p>我们可以通过<code>model.__dict__</code>来查看模型的内部信息，为了便于查看，我们遍历着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model = resnet18().to(device)<br><span class="hljs-built_in">print</span>(model)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> model.__dict__.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, v)<br></code></pre></td></tr></table></figure><p>以下是模型内部信息打印结果(没截全)：</p><p><img src="https://s2.loli.net/2023/12/04/DNfQgtswnzu9UPe.png" alt="model-dict" /></p><p>不难看出，模型内部信息包含了丰富的内容，其中我们这里关注<code>_modules</code>属性，通过它我们可以很方便地对模型的层信息（子模块）逐层遍历</p><p>我们通过<code>model.__dict__[_modules]</code>获取模型的层信息，其中获取到的层信息是用<code>OrderedDict</code>包装过的，因此进行如下遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">m_dict = model.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br><span class="hljs-keyword">for</span> name, sub_module <span class="hljs-keyword">in</span> m_dict.items():<br>    sub_module_class = sub_module.__class__<br>    sub_module_name = sub_module.__class__.__name__<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_class:&quot;</span>, sub_module_class)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_name:&quot;</span>, sub_module_name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span> % name)<br></code></pre></td></tr></table></figure><p>以下是部分遍历结果：</p><p><img src="https://s2.loli.net/2023/12/04/FvhKZHnsbom3SeG.jpg" alt="model_sub_module_iteration" /></p><p>通过递归可以对子模块进行完整的遍历，因为有些子模块是通过模型容器封装的，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursively_iter_sub_module</span>(<span class="hljs-params">module_dict, module_forward_dict</span>):</span><br>    <span class="hljs-keyword">for</span> name, sub_module <span class="hljs-keyword">in</span> module_dict.items():<br>        <span class="hljs-keyword">if</span> sub_module <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(sub_module, torch.nn.Module) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>            <span class="hljs-keyword">break</span><br>        sub_module_class = sub_module.__class__<br>        sub_module_name = sub_module.__class__.__name__<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_class:%s\nsub_module_name:%s\nname:%s&quot;</span> %<br>              (sub_module_class, sub_module_name, name))<br>        sub_sub_modules = sub_module.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sub_sub_modules) == <span class="hljs-number">0</span>:<br>            module_forward_dict.update(&#123;sub_module: sub_module.forward&#125;)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(sub_sub_modules) &gt; <span class="hljs-number">0</span>:<br>            recursively_iter_sub_module(sub_sub_modules, module_forward_dict)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>    model = resnet18().to(device)<br>    sub_modules = model.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br>    sub_module_forward_dict = &#123;&#125;<br>    recursively_iter_sub_module(sub_modules, sub_module_forward_dict)<br>    <span class="hljs-keyword">for</span> module, forward <span class="hljs-keyword">in</span> sub_module_forward_dict.items():<br>        <span class="hljs-built_in">print</span>(module, <span class="hljs-string">&quot;:&quot;</span>, forward)<br><br></code></pre></td></tr></table></figure><p>这里通过<code>&#123;module:forward&#125;</code>把所有的子模块按顺序封装了是为了后续便于对<code>forward</code>重封装</p><p>以下是部分运行结果图：</p><p><img src="https://s2.loli.net/2023/12/05/Bpr61KqoZsGUI5m.png" alt="recursively_iter_sub_module" /></p><h2 id="pytorch的hook"><a class="markdownIt-Anchor" href="#pytorch的hook"></a> PyTorch的hook</h2><p>pytorch的hook有针对Tensor的,也有针对module的,涉及到的函数如下:</p><pre><code class="mermaid" >graph LRhook --> Tensor & ModuleTensor --> register_hookModule --> register_forward_hook & register_forward_pre_hook & register_full_backward_hook & register_full_backward_pre_hook  </code></pre><h3 id="hook-for-tensor"><a class="markdownIt-Anchor" href="#hook-for-tensor"></a> hook for Tensor</h3><p><code>register_hook(hook)</code>当对应<code>tensor</code>的梯度计算完的时候,这个钩子函数(即里面的hook)会被调用,<strong>该钩子函数可以用来打印中间节点的梯度信息,甚至修改计算完的梯度(虽然pytorch不建议你这么做)</strong>,这个<code>register_hook()</code>返回值是一个<code>handle</code>(<code>RemovableHandle</code>类的),这个<code>handle</code>可以调用<code>remove()</code>方法移除对应<code>tensor</code>的钩子函数</p><p>钩子函数的声明需要遵循如下规则:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(grad) -&gt; Tensor <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>输入是这个tensor对应的梯度,返回值是一个Tensor或一个None值</strong></p><p>用例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    c = a * b<br>    <span class="hljs-built_in">print</span>(c)<br>    c_hook = <span class="hljs-keyword">lambda</span> grad: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cc:&quot;</span>, grad)<br>    c.register_hook(c_hook)<br>    d = torch.tensor(<span class="hljs-number">4.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    d.register_hook(<span class="hljs-keyword">lambda</span> grad: grad * <span class="hljs-number">2</span>)<br>    e = c * d<br>    e.backward()<br>    <span class="hljs-built_in">print</span>(a.grad, b.grad, d.grad)<br><br><span class="hljs-comment"># 输出结果:</span><br>tensor(<span class="hljs-number">6.</span>, grad_fn=&lt;MulBackward0&gt;)<br>cc: tensor(<span class="hljs-number">4.</span>)<br>tensor(<span class="hljs-number">12.</span>) tensor(<span class="hljs-number">8.</span>) tensor(<span class="hljs-number">12.</span>)<br></code></pre></td></tr></table></figure><p>上述<code>a,b,d</code>均为计算图中的叶子节点,<code>c,e</code>为中间节点,因此当我们完成反向传递后,计算图会释放中间节点的梯度,我们可以通过上面说的<code>retain_grad()</code>的方式去保留某些<code>tensor</code>的梯度,也可以像上述通过钩子函数,在该张量算完梯度后,把其梯度值钩出来(因为没有retain,反向传播完后还是会释放)</p><p>此外,上述也通过lambda表达式对<code>d</code>的梯度值进行了修改,变成了原来的2倍,原本应该是6的,现在<code>d</code>的梯度是12</p><h3 id="hook-for-module"><a class="markdownIt-Anchor" href="#hook-for-module"></a> hook for Module</h3><p>用于<code>Module</code>的钩子函数在注册的时候返回值也是一个<code>handle</code>,也可以通过<code>handle.remove()</code>移除对应<code>Module</code>的钩子函数,以下对它们各自的钩子函数的声明进行介绍,并且展示一个统一的用例</p><p>其中,钩子函数可以用于<code>Module(nn.Module)</code>的子类,如一些基础的算子<code>Conv2d</code>,<code>BatchNorm2d</code>,可以提取它们<code>activation</code>等,也可以将中间层的结果可视化处理</p><ul><li><code>register_forward_hook(hook)</code>注册的钩子函数是在<code>forward</code>完成后被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, args, output) -&gt; <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> modified output<br></code></pre></td></tr></table></figure><ul><li><code>register_forward_pre_hook(hook)</code>注册的钩子函数是在<code>forward</code>执行前被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, args) -&gt; <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> modified <span class="hljs-built_in">input</span><br></code></pre></td></tr></table></figure><ul><li><code>register_full_backward_hook(hook)</code>注册的钩子函数在<code>backward</code>完成后被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, grad_input, grad_output) -&gt; <span class="hljs-built_in">tuple</span>(Tensor) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ul><li><code>register_full_backward_pre_hook(hook)</code>注册的钩子函数在<code>backward</code>执行前被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, grad_output) -&gt; <span class="hljs-built_in">tuple</span>[Tensor] <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>总用例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels=<span class="hljs-number">1</span>, out_channels=<span class="hljs-number">2</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>)<br>        self.maxpool = nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>)<br>        self._initial_weights()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_initial_weights</span>(<span class="hljs-params">self</span>):</span><br>        self.conv1.weight[<span class="hljs-number">0</span>].data.fill_(<span class="hljs-number">1</span>)<br>        self.conv1.weight[<span class="hljs-number">1</span>].data.fill_(<span class="hljs-number">2</span>)<br>        self.conv1.bias.data.zero_()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-comment"># x -&gt; [1,1,4,4]</span><br>        x = self.conv1(x)<br>        <span class="hljs-comment"># x -&gt; [1,2,2,2]</span><br>        x = self.maxpool(x)<br>        <span class="hljs-comment"># x -&gt; [1,2,1,1]</span><br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward_hook</span>(<span class="hljs-params">module_name=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_forward_hook</span>(<span class="hljs-params">module, <span class="hljs-built_in">input</span>, output</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>, <span class="hljs-string">&quot;forward pass&quot;</span>, <span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Module Name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(module_name))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>[<span class="hljs-number">0</span>].shape))  <span class="hljs-comment"># 变成了Tuple,取[0],才是输入的tensor</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(output.shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(output))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">104</span>)<br>    <span class="hljs-keyword">return</span> _forward_hook<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward_hook</span>(<span class="hljs-params">module_name</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_backward_hook</span>(<span class="hljs-params">module, grad_input, grad_output</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>, <span class="hljs-string">&quot;backward pass&quot;</span>, <span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Module Name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(module_name))<br>        <span class="hljs-keyword">if</span> grad_input[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Input Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_input[<span class="hljs-number">0</span>].shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Input: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_input))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Output Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_output[<span class="hljs-number">0</span>].shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Output: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_output))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">105</span>)<br>    <span class="hljs-keyword">return</span> _backward_hook<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    model = TestNet()<br>    loss_function = nn.MSELoss()<br>    optimizer = optim.SGD(model.parameters(), lr=<span class="hljs-number">.0001</span>)<br><br>    forward_hooks_dict = &#123;&#125;<br>    backward_hooks_dict = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> name, module <span class="hljs-keyword">in</span> model.named_modules():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module, nn.Module) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:  <span class="hljs-comment"># 确保取到的模块可以注册hook</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(module._modules) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 确保取到的模块是子模块,而非中间的模块,如nn.Sequential之类的</span><br>            f_handle = module.register_forward_hook(forward_hook(name))<br>            forward_hooks_dict[name] = f_handle  <span class="hljs-comment"># 存入对应dict,便于之后remove对应name的hook</span><br>            b_handle = module.register_full_backward_hook(backward_hook(name))<br>            backward_hooks_dict[name] = b_handle<br><br>    fake_data = torch.ones([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br>    fake_label = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=torch.<span class="hljs-built_in">float</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fake label shape: &#123;&#125;\nfake label:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(fake_label.shape, fake_label))<br>    y_logit = model(fake_data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_logit shape:&#123;&#125;\ny_logit&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_logit.shape, y_logit))<br>    loss = loss_function(y_logit, fake_label)<br>    optimizer.zero_grad()<br>    loss.backward()<br>    optimizer.step()<br></code></pre></td></tr></table></figure><p>运行结果如下图:</p><p><img src="https://s2.loli.net/2023/12/10/vFOdzJ5gT4Pt2eY.png" alt="forward_backward_hook_example" /></p><p>具体使用可以参考:<a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.register_forward_hook">pytorch-hook使用指南</a></p><h2 id="dataloader中的num_worker和torch中的set_num_threads"><a class="markdownIt-Anchor" href="#dataloader中的num_worker和torch中的set_num_threads"></a> DataLoader中的num_worker和torch中的set_num_threads</h2><h3 id="先说说一些cpu的概念"><a class="markdownIt-Anchor" href="#先说说一些cpu的概念"></a> 先说说一些CPU的概念</h3><p>通过以下指令查看<strong>物理CPU数目</strong>:</p><p><code>cat /proc/cpuinfo | grep 'physical id'| sort | uniq | wc -l </code></p><p>通过以下指令查看<strong>每个CPU的核心数</strong>:</p><p><code>cat /proc/cpuinfo | grep 'core id' | sort | uniq | wc -l</code></p><p>以上,我们就可以计算出<strong>CPU的总核心数</strong></p><p><code>总核心数=物理CPU数目*每个CPU的核心数</code></p><p>而一般来说,一个核心就对应一个物理线程,而有个叫<strong>超线程</strong>的技术,可以把一个核心当作两个线程来用,也就相当于像两个核心一样.而总逻辑CPU数就是在总核心数的基础上乘上超线程的倍数</p><p><code>总逻辑CPU数目=物理CPU数目*每个CPU的核心数*超线程系数</code></p><p>可以通过以下指令查看<strong>总逻辑CPU数目</strong></p><p><code>cat /proc/cpuinfo | grep 'processor' |sort | uniq | wc -l </code></p><p>关于逻辑CPU的体现,比如<code>top</code>指令中的<code>%CPU</code>表示的是占用的逻辑CPU数目</p><h3 id="关于torchset_num_threads"><a class="markdownIt-Anchor" href="#关于torchset_num_threads"></a> 关于torch.set_num_threads()</h3><p>这个<strong>线程数默认是CPU核心总数</strong>,可以通过<code>torch.get_num_threads()</code>获得,且<strong>一般默认的运算效率是最高的</strong></p><p>需要设置这个的场景是当<strong>多人共享CPU资源进行模型运算</strong>时用的,<strong>以避免一个进程抢占过多的CPU核心</strong></p><p>除了通过<code>torch.set_num_threads()</code>设置,还可以通过环境变量设置,如:<code>MKL_NUM_THREADS和OMP_NUM_THREADS</code>来设置,它们的优先级如下:<code>torch.set_num_threads() &gt; MKL_NUM_THREADS &gt; OMP_NUM_THREADS</code></p><p>其中<strong>一般要运用到这个设置是利用CPU进行大量张量操作</strong>,若是大部分的张量操作都是在GPU上,那设置这个也没啥用,且设置的时候由于PyTorch文档没有说哪些运算会从这个设置上受益,因此建议一边看着CPU利用率一边调整线程数,以最大化CPU利用率</p><p>这些设置的线程应该是用于<strong>算子内并行</strong>(intra-op parallelism)的</p><h3 id="关于dataloader中的参数num_worker"><a class="markdownIt-Anchor" href="#关于dataloader中的参数num_worker"></a> 关于DataLoader中的参数num_worker</h3><p>DataLoader中的num_worker是用于指定加载数据和执行变换的并行worker的数目.如果你在加载很大的图片或者有着复杂的变换操作时,即是此时你的GPU处理数据很快,但是你的DataLoader喂数据给GPU很慢而导致不能连续feed GPU,这种情况下就可以设置较多的worker来解决问题</p><p>一般对num_worker的设置是直到epoch中的一个step是足够快的(也就是数据可以及时喂给GPU)</p><p>注意:num_worker用到的也是计算机的CPU核心数</p><p>本部分内容大多学习自:<a href="https://blog.csdn.net/a_piece_of_ppx/article/details/123714865">ddp中的核心数和线程数</a>、<a href="https://www.zhihu.com/question/394952301/answer/1225338415">pytorch模型在multiprocessing下前馈速度明显降低的原因是什么？</a></p><p><mark>疑惑点:如果我是CPU+GPU计算,那么设置num_worker加速数据读取就好,那如果我是纯CPU计算,我默认我set_num_threads用的是CPU所有核心数,那我num_worker会抢占资源嘛,还是用的是超线程的(如果有)</mark></p><h2 id="trainevalno_grad三者区别"><a class="markdownIt-Anchor" href="#trainevalno_grad三者区别"></a> train(),eval(),no_grad()三者区别</h2>]]></content>
    
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>image-classification的一些常用模型</title>
    <link href="/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="cnn"><a class="markdownIt-Anchor" href="#cnn"></a> CNN</h2><p><strong>CNN</strong>,即<strong>卷积神经网络</strong>,我们所<strong>设计</strong>的<strong>filter</strong>(kernel/neuron),让它去跟图片做卷积,就可以<strong>学习我们想要学习的特征</strong>.比如我们所设计的filter可以识别出图片的边界情况,则输出的那一个通道的特征图就可以反映图片的边界情况.</p><p>但是当我们输入一张猫的图片时,想要学习到猫的特征就需要很多很多个filter.因为一个filter可能学习的是猫的耳朵,一个学的是猫的尾巴,<strong>因此需要多个filter,才可以将学习到的局部特征逐渐堆叠称为全局特征.从而完成图像识别的功能</strong>.<strong>需注意filter的通道数需与输入的特征图的通道数相等</strong>.</p><p><strong>以上便是卷积层conv所作的事情,即学习图像的特征</strong></p><p>而后学习到的图像会有相应尺寸的变化,即原先是一张3*224*224的图片,通过4个3*3*3的filter以1步距的方式卷积后,所得的尺寸变为:4*222*222.很明显<strong>图片变小</strong>了,此外<strong>原图像的边界相较于内部,计算的次数更少</strong>,<strong>因此可以通过填充空白区域的方式即padding来使得边界像素点和内部像素点获得相同的计算次数.且有padding填充,卷积后的图片大小不变.</strong></p><p>而<strong>图片中的像素点,并非全部有用</strong>.因此卷积后得到的特征图需要经由<strong>池化层pooling来减少参数数量,也可以防止模型过拟合,提取图像的更主要的特征</strong>.一般来说,我们卷积的操作就是对应元素相乘后求和,因此如果是需要学习的特征,则经卷积层计算后其对应的输出位置的值会比较大.由此,我们的池化层可以对一个小区域内,即利用2*2的filter(步距为2),对区域内的比较大的值进行保留.即为我们的<strong>maxPooling</strong>.同时也有一种中庸的方法,即对区域内的值取平均,此为<strong>averagePooling</strong>.</p><p><strong>以上便是池化层pooling所做的事情,即提取主要特征并减少参数数量,防止过拟合</strong></p><p>最后,我们通过层层的局部特征学习,主要特征提取如此反复的过程,终于得到了一个像样的可以反映输入图片特征的总体特征图,则可以进行分类了.而在分类之前,我们得到的特征图,是一个多维的矩阵,我们期望的输出结果是一个值,因此需要通过<strong>全连接层Fully Connected</strong>来进行处理.在进入全连接层处理前,我们需要对多维的矩阵进行展平处理,即对应的维度相乘(如1024(C)*7(H)*7(W)),然后通过全连接层(即最基础的神经网络计算方式)将神经元数目变为如100个,然后再经过一个全连接层,将神经元数目变为可分类的种数,如10,再经由softmax处理后,即可取概率值最大的为图像分类的输出值.</p><p>需注意,我们的卷积层和全连接层后面都需要跟着激活函数,即对其输出进行非线性化处理.</p><p>输入输出尺寸变换计算公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>o</mi><mi>u</mi><msub><mi>t</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><msub><mi>n</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>−</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>+</mo><mn>2</mn><mi>P</mi><mo stretchy="false">)</mo></mrow><mi>S</mi></mfrac><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">out_{size}=\frac{(in_{size}-F_{size}+2P)}{S}+1 \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span></span></span></span></p><p>其中P是Padding，S是Stride</p><h2 id="alexnet"><a class="markdownIt-Anchor" href="#alexnet"></a> AlexNet</h2><h3 id="亮点"><a class="markdownIt-Anchor" href="#亮点"></a> 亮点</h3><ul><li>利用双GPU对网络加速训练</li><li>采用ReLU激活函数</li><li>全连接层采用Dropout随机失活神经元,以避免过拟合</li></ul><center><img src="https://s2.loli.net/2023/11/03/bSRlK1FQsU4TrwO.png" alt="dropout" style="zoom:67%;" /></center><ul><li>采用LRN(后经证实无用)</li></ul><h3 id="网络结构图"><a class="markdownIt-Anchor" href="#网络结构图"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/eOdMbmTFIVr2Ely.png" alt="alexnet-arch" style="zoom:60%;" /></center><h2 id="vgg"><a class="markdownIt-Anchor" href="#vgg"></a> VGG</h2><h3 id="亮点-2"><a class="markdownIt-Anchor" href="#亮点-2"></a> 亮点</h3><p><strong>通过堆叠多个3*3的卷积核来代替大尺度的卷积核</strong> ，比如AlexNet里的11*11，7*7这样子的卷积核</p><p>如：可以<strong>通过堆叠两个3*3的卷积核来替代5*5的卷积核，或者三个3*3的卷积核来替代7*7的卷积核</strong>。感受野相同的同时，还减少了计算量。常用的是VGG-16和VGG-19</p><p><strong>理论依据：它们拥有相同的感受野</strong></p><h3 id="感受野receptive-filed"><a class="markdownIt-Anchor" href="#感受野receptive-filed"></a> 感受野(receptive filed)</h3><p><strong>在CNN中，某一层输出结果中的一个单元所对应于输入层的区域大小，即为感受野</strong>.也就是说在输出的特征矩阵的某一个元素，它对应于输入层上的区域大小<br />感受野计算公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>+</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F(i) = (F(i+1) -1) * Stride + filter_{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>层的感受野，Stride是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>层的步距，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">filter_{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是卷积核或者池化核尺寸</p><h3 id="网络结构图-2"><a class="markdownIt-Anchor" href="#网络结构图-2"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/05/GLsyjINliPQfO97.png" alt="vgg-arch" style="zoom:60%;" /></center><h2 id="googlenet"><a class="markdownIt-Anchor" href="#googlenet"></a> GoogLeNet</h2><h3 id="亮点-3"><a class="markdownIt-Anchor" href="#亮点-3"></a> 亮点</h3><ul><li>引入了inception结构，融合不同尺度的特征信息</li><li>使用1*1的卷积核进行降维以及映射处理</li><li>添加两个辅助分类器帮助训练</li><li>丢弃全连接层，使用平均池化层，减少模型参数</li><li>VGG等只有一个输出层，GoogLeNet有三个输出层（有两个是辅助分类层）</li></ul><p><strong>其中最重要的便是前两个创新点，通过借鉴NiN(Network in Network)的思想，利用1*1的卷积核进行降维，此外还增加了网络的非线性（最后用平均池化层替换FC也是出自NiN的思想）；而inception结构，所导致的融合多尺度特征信息是指利用横向排列的多个不同尺度的卷积核来获取图像中的信息，即从横向，而非纵向（深度）来进行创新</strong></p><h3 id="inception结构块"><a class="markdownIt-Anchor" href="#inception结构块"></a> inception结构块</h3><center><img src="https://s2.loli.net/2023/11/03/qGU3IA8l6xF4SuE.png" alt="inception-arch" style="zoom:60%;" /></center><p>先看图a，我们的输入层会经过1*1，3*3，5*5这几个不同尺度的卷积核来提取特征以及3*3的最大池化层提取特征。再提取特征通过对padding进行调整使得最终得到的输出的特征矩阵的大小一致，然后在深度上进行堆叠。因此inception结构快可以看作是在水平方向上加深网络；</p><p>之所以采取多尺度的卷积核，是因为我们的物体在图片里可大可小，因此若是卷积核选取的不恰当，那么则需要通过加深网络去学习对应的特征，但是随之而来的梯度消失问题也会导致最终的分类效果差强人意。而多尺度的卷积核则规避了卷积核尺寸选取的问题。</p><p>而图b是在图a的基础上，增加了1*1的卷积核去降维、聚合以及增加非线性；这可以降低我们的计算量</p><p>其实inception结构块可以看作<strong>既保持网络的稀疏性（局部连接[相对的是全连接]），又利用了密集矩阵高计算性能</strong></p><h3 id="辅助分类器"><a class="markdownIt-Anchor" href="#辅助分类器"></a> 辅助分类器</h3><p>其实在最后inference的时候，并没有利用到辅助分类器，因为作者认为，中间层产生的特征具有较强的识别力，因此它们对参数修正很重要，所以主要是利用它们的loss来反向更新参数的（除了正常网络的loss外，它们的loss也会乘以一定权重后加到主网络的loss中）。</p><h3 id="网络结构图-3"><a class="markdownIt-Anchor" href="#网络结构图-3"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/wv5SdZY7RLVeuFq.png" alt="googlenet-arch" style="zoom:67%;" /></center><h2 id="resnet"><a class="markdownIt-Anchor" href="#resnet"></a> ResNet</h2><h3 id="亮点-4"><a class="markdownIt-Anchor" href="#亮点-4"></a> 亮点</h3><ul><li>提出了残差结构块</li><li>利用Batch Normalization加速训练，丢弃了dropout</li></ul><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><p>在介绍接下来的残差结构块和批归一化的操作前。ResNet与先前的VGG或是GoogLeNet的一大差别在与它的layer很多。</p><p>而VGG这些先前的网络若是加大layer的话，会面临层数多的反而比层数少的top1error更大，也即分类的结果更加不准确了。</p><p>从逻辑上来说，应该不会造成此结果，即我们加多的层若是对原来的特征矩阵只做恒等变换，那么应该不会导致结果更差。</p><p>而之所以加多层数出现更糟糕的结果的原因在于：</p><ul><li>梯度消失/梯度爆炸</li><li>网络退化问题</li></ul><p>梯度消失和梯度爆炸都发生在反向传播的过程中，若系数&lt;1或&gt;1则向前传播误差的时候，则会导致梯度消失或是梯度爆炸的问题，导致结果难以收敛。而层数加深则导致了这个结果。可以通过归一化操作和标准初始化这些操作来处理，本文提出了BN层，用于卷积后对数据的分布进行归一化处理；</p><p>而网络退化问题是：当我们适当增加网络层数，训练集loss逐渐下降并趋于饱和，而此时若再增加网络层数，则会出现loss增大的情况（过拟合是loss一直减小）。此时若之前以达到最优，则新加上的层若只是进行恒等映射，那么结果应该依旧是最优的，但是实际结果并非如此，则可以猜测：恒等映射并不容易被神经网络去拟合（实际上并不是恒等映射，而是一些非线性层，是利用非线性层去近似恒等映射，但是很难做到）。而残差结构则解决了这一问题。</p><h3 id="残差结构块"><a class="markdownIt-Anchor" href="#残差结构块"></a> 残差结构块</h3><center><img src="https://s2.loli.net/2023/11/03/2cLFywINGXOQSvr.png" alt="residual-block" style="zoom:67%;" /></center><p>在残差结构中，右边的分支则是恒等映射，而主分支则是残差映射，得到的结果是二者相加（而非堆叠）。当我们的网络最优时，残差映射则会为0，它比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F(x)=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>易于学习！</p><p>从信息论的角度来说的话，可以理解为越到深层次的特征图，所含有的信息越来越少了，而通过残差结构则可以使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层的信息比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层多</p><p>在ResNet中，像ResNet-18和ResNet-34这种较低层次的网络残差结构块如下图左图所示，而像ResNet-50、ResNet-101以及ResNet-152这种深层的网络残差结构块则如下图右图所示：</p><center><img src="https://s2.loli.net/2023/11/03/pqbZ9Hy4Fc5CXYf.png" alt="different-deeper-residual-block" style="zoom:67%;" /></center><p>可见shortcut connection(就是右边的分支，执行的是identity mapping)和主分支它们输出的特征矩阵的shape需要一样才可以相加。而右侧的则考虑了计算量的因素，利用了1*1的卷积核去做降维以及升维的操作。</p><p>而在论文中ResNet-34的结构图中，如下示：</p><center><img src="https://s2.loli.net/2023/11/03/oitGubIhfULBCNz.png" alt="ResNet-34-arch" style="zoom:80%;" /></center><p>可以看到，有一些shortcut的线是实线，即我们上面的残差结构块；而有一些是虚线，则是因为没有池化层，需要对步距进行调整来使得shortcut connection和主分支（也要对步距进行调整）的输出符合论文中给出的网络结构的shape。其残差结构图如下所示：</p><center><img src="https://s2.loli.net/2023/11/03/vJsnQ57IxA4u3io.png" alt="dotted-residual-block" style="zoom:67%;" /></center><center><img src="https://s2.loli.net/2023/11/03/iSO18I3bW4Aqc2o.png" alt="dotted-residual-block-deeper" style="zoom:67%;" /></center><p>而对于较深层次的网络（如ResNet-50），conv2_x的第一层即conv2_1，可以看见其输入为[56,56,64]，而最终的输出为[56,56,256]，显然此时就需要在两个分支上都对深度进行变换。</p><h3 id="batch-normalization"><a class="markdownIt-Anchor" href="#batch-normalization"></a> Batch Normalization</h3><p>Batch Normalization是由Google团队在15年提出的（<strong>Batch Normalization:Accelerating Deep Network Training by Reducing Internal Covariate Shift</strong>），<strong>通过使用BN层，可以加速网络收敛以及提升准确率</strong>。</p><p>一般来说我们会在预处理阶段对图片进行标准化处理，目的是加速网络收敛。所谓标准化，就是使得我们的特征矩阵满足某一分布规律，又或者说，就是将一些不太标准的数据通过一定的计算方法将数据统一到指定的格式。</p><p>而我们在预处理阶段对图片的标准化处理，只会影响输入层的数据，但是对于中间隐藏层，却没有做到标准化操作。而利用BN层，则可以。</p><p><strong>Batch Normalization即批标准化，它的操作对象是batch内的同一layer下同一channel的特征矩阵，对它们进行标准化，使得<u>标准化后的数据满足均值为0，方差为1</u>的分布规律</strong>。</p><p>大致操作就是：计算出batch内的一layer下的一channel的均值和方差，然后通过对应变换使得生成的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>1</mn><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0,1^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的分布</p><p>显然，batch size应该越大越好，因为希望能代表的是整个训练集的分布规律。而我们在前向传递的过程中统计到的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(\mu,\sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的值，然后反向传递会得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的值，这两个分别是对统计到的分布规律作scale和shift操作。</p><p>此外BN层是放在conv层和激活层间的，而且conv层不要用bias，因为用了结果也一样</p><h4 id="后期补充"><a class="markdownIt-Anchor" href="#后期补充"></a> 后期补充</h4><p>batch normalization计算公式如下:</p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/bn_formula.png" alt="bn_formula" style="zoom:67%;" /><p>一共涉及到四个参数,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>代表的是训练阶段forward pass时统计得到的两个数值,用于对同一batch内的<strong>同维</strong>数据做标准化,将同一个batch内的数据分布标准化为正态分布;而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>则是训练阶段backward pass时的两个learnable parameter,用于将标准化后的数据做一个仿射变换;</p><div class="note note-info">            <p><strong>同维</strong></p><ul><li>对于四维的卷积<code>[N,C,H,W]</code>指的是同一个channel,而另外的三个维度则拼成一个维度<code>[C,N*H*W]</code>,逐channel来计算均值和方差,同样的这时的四个参数的维度都是C维,即有C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li>对于二维的线性层<code>[N,n]</code>,指的是同一列,即同一个特征,这是四个参数的维度都是n维</li></ul><p>个人理解:因为我们是对同一个batch的数据来做normalization(与单纯的standardize不同,还有仿射变换拉回原来的分布特征),那么期望得到的是一个batch内的均值方差,对于图片来说,是规律化的信息,而channel的信息需要单独处理,如果混合处理,会破坏原有的信息</p>          </div><p>对于训练阶段,会对每个batch都计算各自的均值和方差,并应用该阶段的均值和方差(即<code>batch_mean</code>和<code>batch_var</code>),同时会将该阶段的均值和方差利用滑动平均的技巧与之前那些batch的均值方差进行统计(以得到<code>moving_mean</code>和<code>moving_var</code>),以用作推理阶段;</p><p>对于推理阶段,会对每个sample采用训练阶段训练好的滑动均值和滑动方差(<code>moving_mean</code>和<code>moving_var</code>),而另外两个参数则是训练时学到的</p><p>具体的计算公式如下:</p><img src="https://s2.loli.net/2024/06/06/wHiZQaXj1AxPLre.png" alt="bn_detail_formula" style="zoom:67%;" /><p>其中这个滑动平均的思想在训练过程中的做法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">moving_mean = moving_mean * momentum + batch_mean * (<span class="hljs-number">1</span>-momentum)<br>moving_var = moving_var * momentum + batch_var * (<span class="hljs-number">1</span>-momentum)<br></code></pre></td></tr></table></figure><p>momentum是动量参数,在Tensorflow中是0.99,在PyTorch中是0.9,初始的<code>moving_mean=0</code>,<code>moving_var=1</code>即为标准正态分布</p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/93643523">【基础算法】六问透彻理解BN(Batch Normalization）</a></li><li><a href="https://zhuanlan.zhihu.com/p/522525435">吃透bn</a></li><li><a href="https://zhuanlan.zhihu.com/p/521535855">超细节的bn,ln知识点</a></li></ul><h3 id="迁移学习"><a class="markdownIt-Anchor" href="#迁移学习"></a> 迁移学习</h3><p>迁移学习即是使用别人预训练好的模型参数（需要注意别人的预处理方式），能快速训练出较理想结果，且在数据集较小的情况下也能如此。</p><p>为何能进行迁移学习呢，就拿卷积来说，我们一开始学习到的是低级特征，比如一些角点信息、纹理信息，其实是通用的，而后学习到的是五官这一类的高级抽象信息，而后再由全连接层对这些信息进行组合输出对应类别的概率。显然前面的低级信息应是通用的。</p><p>迁移学习的方式</p><ul><li>载入权重训练所有参数</li><li>载入权重后只训练最后几层的参数，如全连接层</li><li>载入权重后在原net上加多一个fc，只训练最后一个fc</li></ul><h3 id="网络结构图-4"><a class="markdownIt-Anchor" href="#网络结构图-4"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/jdz5WgZEM2StRCk.png" alt="resnet-arch" style="zoom:67%;" /></center><h2 id="resnext"><a class="markdownIt-Anchor" href="#resnext"></a> ResNeXt</h2><h3 id="亮点-5"><a class="markdownIt-Anchor" href="#亮点-5"></a> 亮点</h3><p><strong>利用分组卷积对原来ResNet的主分支变为多个分支进行多路卷积。在参数量相同计算速度相差不大的情况下，提升了准确率</strong>，又或者说是融合了Inception结构（split-transform-merge,输入分配到多路，每一路进行变换，最后多路进行结果融合）和ResNet残差结构。</p><h3 id="分组卷积"><a class="markdownIt-Anchor" href="#分组卷积"></a> 分组卷积</h3><p>如下图示，对输入图片的维度记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对输出图片的维度记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，对卷积核的大小记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">k*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.对于传统的卷积来说，则每一个卷积核的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k*k*c_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后需要有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个卷积核，参数量则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k*k*c_{in}*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>对于分组卷积而言，我们假设分组的数目是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，则每一组卷积核的大小应为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><mfrac><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">k*k*\frac{c_{in}}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1925999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而多组卷积核最后得出的结果需要拼接使得输出的channel为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，则意味着我们每一组需要有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个卷积核。则其参数量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>∗</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">k*k*c_{in}*n*\frac{1}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.可见参数量变为原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>倍。</p><center><img src="https://s2.loli.net/2023/11/03/DqwHk1ucSGFJ6zM.png" alt="group-conv" style="zoom:50%;" /></center><h3 id="resnext残差结构"><a class="markdownIt-Anchor" href="#resnext残差结构"></a> ResNeXt残差结构</h3><p>在下图的右边便是ResNeXt的残差结构，可见，它增加了分组的部分，图中的path又或者论文中所提到的cardinality其实指的都是分组的数目。通过Inception结构的split-transform-merge来进行变换。</p><center><img src="https://s2.loli.net/2023/11/03/gaOzPJvTboqWLpc.png" alt="resnext-residual-block" style="zoom:67%;" /></center><p>下图的block模块在数学上是等价的，图C可以看出与原先的ResNet模型的降维卷积升维的操作是一样的，但是在卷积的过程中则利用了分组卷积的思想去减少参数量。</p><center><img src="https://s2.loli.net/2023/11/03/BtUqd95VmpNbKoH.png" alt="resnext-equivalent" style="zoom:67%;" /></center><p>而图B是由图C转换而来的：一个分支对应于一个组，我们的一共有32个分支，也即是有32个分组，因此对输入进行降维的操作，可以将卷积核个数128分配到每一个分支上，即每一个分支的卷积核大小都一样且均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>128</mn><mn>32</mn></mfrac><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\frac{128}{32}=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个（注意，此操作不是分组卷积）。而后经由分组卷积操作，然后对结果进行深度方向的拼接再经由升维的1*1的卷积操作，而后便是主分支和shortcut分支相加。</p><p>图A则是对图B进行变换而来的：其本质是对卷积核原先内部的相加操作（就是1*1的卷积核原先是对某一坐标下的128个元素分别对应channel相乘而后将各channel的乘值相加，现在依旧是对应channel相乘，但是只有4个channel，而后各对4个channel的乘值相加后变得出特征矩阵，则最后的相加操作，是原先对应坐标下的元素的相加）进行切分</p><p>需要注意：ResNeXt的残差结构需要用在ResNet残差结构里有三层以上的才有意义，即需要用在ResNet-50/101/152这些模型身上才有意义。</p><h3 id="网络结构图-5"><a class="markdownIt-Anchor" href="#网络结构图-5"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/rTMqnO91mta2Vfw.png" alt="resnext-arch" style="zoom:67%;" /></center><p>从以上的网络结构图可以看出ResNeXt-50与ResNet-50结构基本相同，除了多了个分组卷积之外，其中ResNeXt-50右边有个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>×</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">32×4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span>，其中32指代的是分组的数目，4d指代的是每一个组内的卷积核的个数。之所以选择<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>×</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">32×4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span>是因在同等计算量下，它的准确度最高。见下图：</p><center><img src="https://s2.loli.net/2023/11/03/sUQl4DMunECm7gi.png" alt="resnext-cardinality-effection" style="zoom:67%;" /></center><h2 id="mobilenet"><a class="markdownIt-Anchor" href="#mobilenet"></a> MobileNet</h2><p>前面所提及的模型，它们的权重文件都很大（几百兆），而且对算力也有一定要求，不便于在移动设备上使用。这一部分提及的MobileNet则可以，它是一种轻量级的卷积网络。在准确率小幅下降的情况下，模型参数和运算量大大减少。</p><center><img src="https://s2.loli.net/2023/11/03/LaBjtmelCPb74rk.png" alt="mobilenetv1-effect" style="zoom:67%;" /></center><h3 id="mobilenetv1"><a class="markdownIt-Anchor" href="#mobilenetv1"></a> MobileNetV1</h3><h4 id="亮点-6"><a class="markdownIt-Anchor" href="#亮点-6"></a> 亮点</h4><ul><li>深度可分离卷积</li><li>控制卷积核个数倍率的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和控制图像大小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li></ul><h4 id="深度可分离卷积"><a class="markdownIt-Anchor" href="#深度可分离卷积"></a> 深度可分离卷积</h4><center><img src="https://s2.loli.net/2023/11/03/fiIk21aKgoWzC6b.png" alt="depthwise-separable-convolution" style="zoom:67%;" /></center><p>上图便是深度可分离卷积(DSC)和传统卷积的对比图。</p><p>深度可分离卷积分为两个过程:<strong>逐深度卷积(DW(depthwise)卷积)和逐点卷积(PW(pointwise)卷积)</strong> ，其中逐点卷积和普通卷积没啥区别，就是1*1的卷积核卷积。</p><p>DW卷积则是逐通道卷积，即卷积核大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_K*D_K*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.若输入特征图的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>则其卷积核的个数亦为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，其输出特征图的深度亦为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>PW卷积，则对DW卷积输出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">D_F*D_F*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的特征图进行卷积，卷积核大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1*1*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，卷积核个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>,最终输出的特征图大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC相较于传统卷积的好处在于输入输出特征图的大小相同，而计算量和参数量的则大大减少</p><p>传统卷积计算量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M*D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC计算量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*D_F*D_F*M+M*D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>计算量之比: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>D</mi><mi>S</mi><mi>C</mi><mtext>计算量</mtext></mrow><mtext>传统卷积计算量</mtext></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><msup><msub><mi>D</mi><mi>K</mi></msub><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{DSC计算量}{传统卷积计算量}=\frac{1}{N}+\frac{1}{ {D_K}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">统</span><span class="mord cjk_fallback mtight">卷</span><span class="mord cjk_fallback mtight">积</span><span class="mord cjk_fallback mtight">计</span><span class="mord cjk_fallback mtight">算</span><span class="mord cjk_fallback mtight">量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">计</span><span class="mord cjk_fallback mtight">算</span><span class="mord cjk_fallback mtight">量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.308964em;vertical-align:-0.46385600000000005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6364490000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7907871428571429em;"><span style="top:-2.830472857142857em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.46385600000000005em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>传统卷积参数量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC参数量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M+M*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>参数量之比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>D</mi><mi>S</mi><mi>C</mi><mtext>参数量</mtext></mrow><mtext>传统卷积参数量</mtext></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><msup><msub><mi>D</mi><mi>K</mi></msub><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{DSC参数量}{传统卷积参数量}=\frac{1}{N}+\frac{1}{ {D_K}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">统</span><span class="mord cjk_fallback mtight">卷</span><span class="mord cjk_fallback mtight">积</span><span class="mord cjk_fallback mtight">参</span><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">参</span><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.308964em;vertical-align:-0.46385600000000005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6364490000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7907871428571429em;"><span style="top:-2.830472857142857em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.46385600000000005em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br />而卷积核一般是3*3的，因此能给参数量和计算量降至原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mn>1</mn><mn>9</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{1}{9},\frac{1}{8}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span><br />在传统的卷积层中，我们常用的是Conv+BN+ReLU这一套作为卷积层。而在DSC中，我们的设置如下图示：</p><center><img src="https://s2.loli.net/2023/11/03/lLpHyMTSendUbmc.png" alt="mobilenetv1-conv-arch" style="zoom:67%;" /></center><p>另外，在MobileNetV1中，采用的是ReLU6激活函数，相较于ReLU函数，它有一个上界，其表达式为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLU6 = min(max(0,x),6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。在低精度浮点数计算时，如8/16位浮点数计算，表达不了那么的大的数，因此用ReLU6在低精度浮点数表示下可以取得比较好的性能。增强鲁棒性。</p><h4 id="超参数alpha和beta"><a class="markdownIt-Anchor" href="#超参数alpha和beta"></a> 超参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>在原论文中称为width multiplier，即宽度乘数，是用它来控制我们每一层的卷积核的个数，它的取值范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，常用的取值是0.25,0.5,0.75,1。根据个人任务需求来自行在精度和速度（计算量以及内存所占的参数量）取得一个平衡。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的各取值效果如下：</p><center><img src="https://s2.loli.net/2023/11/03/ynIupeLdbg2PKJv.jpg" alt="mobilenetv1-width multiplier" style="zoom:67%;" /></center><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>在原论文中称为resolution multiplier，即分辨率乘数，隐式的设置，用来控制我们的输入的分辨率。β的取值范围是(0,1]，常用的输入分辨率为224,192,160,128。用于在精度和速度（计算量）上取得一个平衡。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的各取值效果如下：</p><center><img src="https://s2.loli.net/2023/11/03/uFcEhUvwgd1PDoA.png" alt="mobilenetv1-resolution multiplier" style="zoom:67%;" /></center><h4 id="网络结构图-6"><a class="markdownIt-Anchor" href="#网络结构图-6"></a> 网络结构图</h4><p>在下图所示的网络结构图中，conv dw即代表DW卷积，在其后面的示PW卷积。可见其即是将通用的卷积层全部替换为DSC。(实际上的网络结构跟VGG差不多)</p><center><img src="https://s2.loli.net/2023/11/03/4KwMeD81Ih9ZGYv.png" alt="mobilenetv1-arch" style="zoom:67%;" /></center><h3 id="mobilenetv2"><a class="markdownIt-Anchor" href="#mobilenetv2"></a> MobileNetV2</h3><h4 id="亮点-7"><a class="markdownIt-Anchor" href="#亮点-7"></a> 亮点</h4><ul><li>倒残差结构</li><li>线性的bottleneck</li></ul><h4 id="问题提出"><a class="markdownIt-Anchor" href="#问题提出"></a> 问题提出</h4><p>在MobileNetV1,存在部分DW卷积核训练出来为0的情况,其产生的原因可以归咎于以下几点：</p><ul><li>DW卷积所用的卷积核个数太少了，因而权重数量太少</li><li>ReLU激活函数，导致一些负数在前向传播置为零，而反向传播其梯度亦为0，使之无法更新</li><li>低精度，导致小于某一值后，并不能取得值，则归为0</li></ul><p>在原文的附录中，其实有对DW为0的情况进行数学分析，可以这么认为，即是ReLU激活函数导致的<strong>低维度的信息丢失</strong>。下图是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover><mo>=</mo><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>T</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{x} = T^{-1}ReLU(Tx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，对T的维度进行变换以查看ReLU函数对不同维度信息的丢失程度。可以看出高维的信息经ReLU后丢失较少，而低维信息则丢失较多。</p><p><img src="https://s2.loli.net/2023/11/03/TEtU7BSGfXp3NuL.png" alt="mobilenetv2-relu transformation" /></p><p>在原先的DSC结构中，我们的DW卷积包含以下过程：DW卷积-&gt;BN-&gt;ReLU，而一开始的channel的个数其实很少，这即是所谓的低维度，然后经过ReLU处理，很多信息即丢失了，也即意味着:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>B</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=ReLU(Bx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，在这个等式中，我们并不可逆，因而导致了信息丢失。其中x即输入的维度，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{m * n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则代表对应的权重矩阵，经ReLU操作后，我们的信息会丢失。从数学角度来说，即无法找到唯一解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。那么我们现在期望的是尽可能使这个方程能找到唯一解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，即意味着可逆（无信息丢失）。</p><p>论文中找出了其可逆的条件：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\bold{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span></span>中至少<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\bold{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">n</span></span></span></span></span>个激活为正且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\bold{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span>中对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\bold{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">n</span></span></span></span></span>个向量应线性无关</strong></p><p>第二个条件易于满足，而第一个条件在论文中，作者说到：当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≫</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \gg n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>即使之升维，则较大概率保持可逆。因而需要对输入进行升维处理，使之在DW卷积后经ReLU变换，其信息尽量不丢失；对应的在低维度的情况下，我们则不应该采用ReLU变换。并且通过shortcut连接，将DW卷积过程中可能存在的信息丢失予以弥补。</p><p>因而提出了inverted residual block（相较于ResNet的先降维后升维而言是inverted）和linear bottleneck（bottleneck是指两个低channel的tensor，这里与ResNet中的bottleneck恰好相反，linear则是代表最后一个低channel的tensor是采用线性激活函数）</p><h4 id="倒残差结构"><a class="markdownIt-Anchor" href="#倒残差结构"></a> 倒残差结构</h4><p>在ResNet中，残差结构是先降维然后进行卷积最后升维以及Add操作，而在MobileNetV2中，则是先升维然后DW卷积而后降维以及Add操作，因而称之为倒残差结构(使得低维信息和非线性变换二者解耦)。</p><p>可以对倒残差结构利用压缩文件的思想进行理解：</p><p>压缩包（低维度的输入） -&gt; 解压（升维）-&gt; 处理（DW卷积） -&gt; 压缩（降维）</p><center><img src="https://s2.loli.net/2023/11/03/4BLuhCpSvGFemPc.png" alt="mobilenetv2-inverted residual block" style="zoom:80%;" /></center><p>以下是一个倒残差结构的过程图表：</p><center><img src="https://s2.loli.net/2023/11/03/yhqYpdAxa3VnMOD.png" alt="mobilenetv2-inverted residual block table" style="zoom:67%;" /></center><h4 id="线性的bottleneck"><a class="markdownIt-Anchor" href="#线性的bottleneck"></a> 线性的bottleneck</h4><p>在ResNet中，bottleneck结构是指代残差结构中的卷积过程，而在MobileNetV2中，bottleneck则是指代在DW卷积前后的输入输出两端的低channel的tensor。而线性的bottleneck则是指倒残差结构最后降维处采用了线性激活函数而后输出低维的特征矩阵。</p><h4 id="网络结构图-7"><a class="markdownIt-Anchor" href="#网络结构图-7"></a> 网络结构图</h4><p>bottleneck则是我们上面的倒残差结构，t则代表了扩展因子，即channel经升维扩充为原来的t倍，c则是降维后的channel个数，n则是指该倒残差结构重复的次数，s则是指dw卷积的步距（该block第一个bottleneck的步距,而后的都是1）。</p><p>需要注意，我们可以使得主分支和shortcut分支相加的条件是s=1且两个低维的tensor的shape要相等。</p><center><img src="https://s2.loli.net/2023/11/03/MA1jzymQpGP5vCx.png" alt="mobilenetv2-arch" style="zoom:50%;" /></center><h3 id="mobilenetv3"><a class="markdownIt-Anchor" href="#mobilenetv3"></a> <mark>MobileNetV3</mark></h3><h4 id="亮点-8"><a class="markdownIt-Anchor" href="#亮点-8"></a> 亮点</h4><h4 id="网络结构图-8"><a class="markdownIt-Anchor" href="#网络结构图-8"></a> 网络结构图</h4><h2 id="shufflenet"><a class="markdownIt-Anchor" href="#shufflenet"></a> <mark>ShuffleNet</mark></h2><h2 id="efficientnet"><a class="markdownIt-Anchor" href="#efficientnet"></a> <mark>EfficientNet</mark></h2><h2 id="transformer"><a class="markdownIt-Anchor" href="#transformer"></a> transformer</h2><p>见blog</p><h2 id="vit"><a class="markdownIt-Anchor" href="#vit"></a> ViT</h2><p>见blog</p><h2 id="mobilevit"><a class="markdownIt-Anchor" href="#mobilevit"></a> <mark>MobileViT</mark></h2><h2 id="一些tricks"><a class="markdownIt-Anchor" href="#一些tricks"></a> <mark>一些tricks</mark></h2>]]></content>
    
    
    
    <tags>
      
      <tag>CNN</tag>
      
      <tag>ResNet</tag>
      
      <tag>MobileNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAN的基础理解及代码解析</title>
    <link href="/2022/10/24/GAN%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/24/GAN%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>在先前的图像方法增强合集(<mark>这个还没写</mark>)里,了解到GAN可以用于生成图像,且是无监督学习,即意味着我们无需人为对样本打标签,就可以学习到样本数据里的相关图像信息</p><p>论文原文:<a href="https://proceedings.neurips.cc/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf">Generative Adversarial Nets</a></p><div class="note note-info">            <p>注:PO在上面的是作者后面经修改的版本,在arXiv上的是14年的初稿,related work部分比较空荡荡</p>          </div><h2 id="模型介绍"><a class="markdownIt-Anchor" href="#模型介绍"></a> 模型介绍</h2><p><strong>GAN</strong>(Generative Adversarial Nets)<strong>生成对抗网络</strong>,它是由两个部分组成,一个部分是<strong>生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></strong>(Generator),用于<strong>生成图像</strong>;一个部分是<strong>判别器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></strong>(Discriminator),用于判别图像的真假,即图像来源是我们的样本数据集,还是生成的图像</p><p>我们通过名字以及引言部分的介绍,可以知道GAN是用来生成图像的网络,那么对抗指的是什么?</p><p>在原论文中,作者是以一个制造假币的团伙和警察来介绍对抗的概念:制造假币的罪犯(这个就是生成模型)希望自己制造的假币能像真币一样流通在市场上,即假币假得跟真币一样;而警察(这个是判别模型)则是负责抓造假币的罪犯.二者是一个对立、对抗的关系.那么通过警察识别并查获假币,造假币的罪犯为了使假币流通不断提升技术以期假币能以假乱真,在二者的对抗关系下,发展到最后,警察将无法试别假币与真币.</p><p>上述即解释了整个模型的思想,<strong>生成模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>期望能生成足够类似样本数据集的图片以欺骗判别模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,而判别模型则期望能够最大限度的区分输入的图片是来自样本数据集的还是生成模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的</strong>.</p><h2 id="原理解释"><a class="markdownIt-Anchor" href="#原理解释"></a> 原理解释</h2><p>上述对GAN的模型解释,从原文中抽象一点的角度来说,即生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>是用于学习样本数据的数据分布情况,当我们学习到合适的分布情况下,则通过高斯分布或是均匀分布生成的噪音变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>用于生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的输入,可以映射到对应的分布中去,生成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>,则此刻判别模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>无法判别输入的图片是来自数据集中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>还是生成的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>,则此刻判别概率达到最优,为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>因此我们为了使生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>能学习到在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>上的分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">p_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,定义了输入噪音变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_z(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>作为先验,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的多层感知机的参数为(论文中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>都是这个模型,便于利用反向传播更新参数)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\theta_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,利用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\theta_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>共同表示由G到数据分布空间的映射函数:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">;</mo><msub><mi>θ</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(z;\theta_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>;而我们的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>的映射函数则用:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>θ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x,\theta_d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示<br />根据本节开头所述,我们所期望的是:<br />1.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>尽可能的区分开真实样本和生成样本;<br />2.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>尽可能的骗过D,让它无法分辨真是样本和生成样本;<br />于是就有以下价值函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G,D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>成立</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>G</mi></munder><munder><mo><mi>max</mi><mo>⁡</mo></mo><mi>D</mi></munder><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="double-struck">E</mi><mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo fence="true">[</mo><mi>log</mi><mo>⁡</mo><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo fence="true">]</mo></mrow><mo>+</mo><msub><mi mathvariant="double-struck">E</mi><mrow><mi>z</mi><mo>∼</mo><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo fence="true">[</mo><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\min_{G}\max_{D}V(D,G) = \mathbb{E}_ {x \sim p_{data}(x)}\left[\log{D(x)} \right] +\mathbb{E}_ {z \sim p_z(z)}\left[\log{(1-D(G(z)))} \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.494331em;vertical-align:-0.7443310000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.355669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.744331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999983em;"><span style="top:-2.355669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7443310000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p><p>我们知道对于映射<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>来说,其输出是一个介于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0,1 \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>的概率值,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{2}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>对应的是单调递增函数,则欲使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>取得max,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>趋于1,即分辨出来自样本数据集中的图片,让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>趋于0,即分辨出来自<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中生成的图片,则可以使得整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(D,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>max;此刻则满足期望的第1点;<br />而欲使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>取得min,则是使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>为1,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>将其误认为是样本数据集中的数据,则此刻整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>取值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>,为最小(当然D(G(z))也取不到1,只是趋向1),则此刻满足期望的第二点</p><p>以下是论文中的算法部分:</p><p><img src="https://s2.loli.net/2023/11/03/jIwGiqoT74WkR23.png" alt="GAN-Algorithm" /></p><p>从上图可以看出,我们先是对判别模型通过循环进行了优化,对于它而言,它的优化是对其参数加上所求得的梯度值以更新模型(即增强其区分能力);<br />而后出了判别模型优化的循环后再对我们的生成模型做部分的改变,于它而言对参数的更新则是减去梯度值,以更新模型,增强图形的生成能力.</p><p>我们肯定注意得到,它先是对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>优化,再对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>做小部分的优化.从前面那个造假币的例子中其逻辑可以想清,此处不赘述</p><p>当然,这一部分算法最大的问题,应该(<mark>我觉得</mark>)是出在超参数难以调控,难以达到收敛情况,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>的判断变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h2 id="代码讲解"><a class="markdownIt-Anchor" href="#代码讲解"></a> 代码讲解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">block</span>(<span class="hljs-params">in_feat, out_feat, normalize=<span class="hljs-literal">True</span></span>):</span><br>            layers = [nn.Linear(in_feat, out_feat)]<br>            <span class="hljs-keyword">if</span> normalize:<br>                layers.append(nn.BatchNorm1d(out_feat, <span class="hljs-number">0.8</span>))<br>            layers.append(nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>))<br>            <span class="hljs-keyword">return</span> layers<br><br>        self.model = nn.Sequential(<br>            *block(opt.latent_dim, <span class="hljs-number">128</span>, normalize=<span class="hljs-literal">False</span>), <br>*block(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>),<br>            *block(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>), <br>*block(<span class="hljs-number">512</span>, <span class="hljs-number">1024</span>),<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-built_in">int</span>(np.prod(img_shape))), <br>nn.Tanh())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, z</span>):</span><br>        img = self.model(z)  <span class="hljs-comment"># [64,784]</span><br>        img = img.view(img.size(<span class="hljs-number">0</span>), *img_shape)  <span class="hljs-comment"># [64,1,28,28]</span><br>        <span class="hljs-keyword">return</span> img<br></code></pre></td></tr></table></figure><p>上面这个是Generator的代码,通过一个<code>nn.Sequential</code>的序列容器严格规定网络中layer的执行顺序,前一层输出作为后一层输入,严格遵守,否则报<code>RuntimeError</code><br />初始进去的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>的维度是[64,100],64是batch_size,100是它的初始维度,维度通过全连接层变成了1024后变为img_shape:[1,28,28]的所有元素的乘积即784,然后通过view将维度转换为[64,1,28,28]<br />此即完成了由一个高斯分布生成的噪声变为灰度图片的过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Discriminator</span>(<span class="hljs-params">nn.Module</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self.model = nn.Sequential(nn.Linear(<span class="hljs-built_in">int</span>(np.prod(img_shape)), <span class="hljs-number">512</span>),<br>                                   nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>),<br>                                   nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">256</span>),<br>                                   nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>),<br>                                   nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>), <br>   nn.Sigmoid())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, img</span>):</span><br>        <span class="hljs-comment"># img: [64,1,28,28]</span><br>        img_flat = img.view(img.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)  <span class="hljs-comment"># img_flat: [64,784]</span><br>        validity = self.model(img_flat)  <span class="hljs-comment"># validity: [64,1]</span><br>        <span class="hljs-keyword">return</span> validity<br></code></pre></td></tr></table></figure><p>上面这个是Discriminator的代码,其实就是Generator的反过程,将输入的MNIST数据集中的手写图片转为[64,784]后由model训练,根据sigmoid做分类,其中LeakyReLU激活函数就是在ReLU的负半轴开启了衰弱的梯度衰减(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>e</mi><mi>a</mi><mi>k</mi><mi>y</mi><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>a</mi><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LeakyReLU= \max(0,x) + leak * \min(0,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>),返回的分类结果是[64,1]的向量,里面的值是图片来自generator或是数据集的概率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">adversarial_loss = torch.nn.BCELoss()<br></code></pre></td></tr></table></figure><p>采用的损失函数是二分类交叉熵,我们的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(D,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>价值函数可以从该损失函数公式推得<mark>具体没细看</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer_g = torch.optim.Adam(generator.parameters(),<br>                               lr=opt.lr,<br>                               betas=(opt.b1, opt.b2))<br>optimizer_d = torch.optim.Adam(discriminator.parameters(),<br>                               lr=opt.lr,<br>                               betas=(opt.b1, opt.b2))<br></code></pre></td></tr></table></figure><p>对生成器和判别器都采用了Adam优化器,之后就是对优化器使用的三部曲:</p><ol><li>梯度清零</li><li>backward</li><li>更新梯度</li></ol><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(opt.n_epochs):<br>    <span class="hljs-keyword">for</span> i, (imgs, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        <span class="hljs-comment"># imgs: [64,1,28,28]</span><br>        <br>valid = Variable(<br>            Tensor(imgs.size(<span class="hljs-number">0</span>), <span class="hljs-number">1</span>).fill_(<span class="hljs-number">1.0</span>),  <span class="hljs-comment"># [64,1]值为1的向量</span><br>            requires_grad=<span class="hljs-literal">False</span>)<br>        fake = Variable(<br>            Tensor(imgs.size(<span class="hljs-number">0</span>), <span class="hljs-number">1</span>).fill_(<span class="hljs-number">0.0</span>),  <span class="hljs-comment"># [64,1]值为0的向量</span><br>requires_grad=<span class="hljs-literal">False</span>)<br>        <br><span class="hljs-comment"># 配置输入</span><br>        real_imgs = Variable(imgs.<span class="hljs-built_in">type</span>(Tensor))  <span class="hljs-comment"># 转换type类型为torch.cuda.FloatTensor, [64,1,28,28]</span><br>        <br><span class="hljs-comment"># 训练G</span><br>        optimizer_g.zero_grad()  <span class="hljs-comment"># 梯度置0/梯度清零</span><br><br>        <span class="hljs-comment"># 噪声作为输入</span><br>        z = Variable(Tensor(np.random.normal( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,  <span class="hljs-comment"># normal-&gt;符合高斯分布的概率密度随机数</span><br>                    (imgs.shape[<span class="hljs-number">0</span>], opt.latent_dim))))  <span class="hljs-comment"># [64,100]</span><br><br>        <span class="hljs-comment"># 生成批量images</span><br>        gen_imgs = generator(z)<br><br>        <span class="hljs-comment"># generator&#x27;s loss 尽可能欺骗D</span><br>        g_loss = adversarial_loss(discriminator(gen_imgs), valid)<br><br>        g_loss.backward()  <span class="hljs-comment"># backward</span><br>        optimizer_g.step()  <span class="hljs-comment"># 更新梯度</span><br><br>        <span class="hljs-comment"># 训练D</span><br>        optimizer_d.zero_grad()<br><br>        <span class="hljs-comment"># discriminator&#x27;s loss 尽可能试别数据集图片和生成器生成的图片</span><br>        real_loss = adversarial_loss(discriminator(real_imgs), valid)<br>        fake_loss = adversarial_loss(discriminator(gen_imgs.detach()), fake)<br>d_loss = (real_loss + fake_loss) / <span class="hljs-number">2</span><br><br>d_loss.backward() <span class="hljs-comment"># backward</span><br>        optimizer_d.step() <span class="hljs-comment"># 更新梯度</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>代码参考源于这个大佬:<a href="https://github.com/eriklindernoren/PyTorch-GAN">GitHub跳转</a></p>          </div><h2 id="实验展示"><a class="markdownIt-Anchor" href="#实验展示"></a> 实验展示</h2><p>所用数据集是MNIST<br />以下是100个epoch出来的结果</p><p><img src="https://s2.loli.net/2023/11/03/1kdphc5VC4mFG6R.png" alt="GAN-EX-0" /></p><p><img src="https://s2.loli.net/2023/11/03/m6MuJrNWAsgf27j.png" alt="GAN-EX-1" /></p><p><img src="https://s2.loli.net/2023/11/03/NbrQc9XMhB1qiPE.png" alt="GAN-EX-2" /></p><p>可以看出GAN的生成器学到了一些东西,但其实效果不是那么好,因为超参数很难控制好,置其收敛</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>总的来说,GAN是一个开创性的想法,随它之后可以看到与之相关的论文呈井喷式增加,GAN的他引次数也达50k加次,确实很厉害<br />它的效果虽然不尽人意,但是开创性的思维带来了一个领域的突破,后期会更新1~2个改良后的GAN.</p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BST,AVL树,B树,B+树,红黑树</title>
    <link href="/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>算法课老师讲到了二叉搜索树(BST),因为大四背面经接触过下面几种类型,因此想简单mark一下</p><p><mark>注:本篇文章对树的操作并无图,可自行绘制理解</mark><br /><mark>另:里面的操作部分的文字描述是我看了较多文章自己综合口述的,有可能有错</mark></p><h2 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h2><p>BST(Binary Search Tree)二叉搜索树,也叫二叉查找树<br />它是由<strong>二分法+二叉树</strong>构成,即以树结构呈现的二分法.左子树的节点值均小于根节点,右子树的节点值均大于根节点</p><p><img src="https://s2.loli.net/2023/11/03/jncKkUFz6fuepSx.png" alt="BST" /></p><p>对于查找,插入,删除,平均时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,而其最坏状况,若是依有序数据构建树,则会退化成链表,则对应的时间复杂度都是最坏的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>对于其查找,插入,都跟二分法类似,不赘述;而对于删除问题,因删除后需保持BST的二分特性,因此需要对删除后的树进行一些修改,分三种情况讨论:</p><ol><li>删除的是叶子节点: 直接删除,无影响</li><li>删除的是中间节点,且只有一个子树: 直接把子树根节点对中间节点进行顶替</li><li>删除的是中间节点,且有两个子树: 若删除的节点位于根节点的左子树,则用删除节点的左子树顶替之,并将删除节点的右子树移到其原兄弟节点的右子树下即可;另一侧是对称操作,不赘述.</li><li>删除的是非空根节点:与左子树中最大值交换后删除即可或与右子树中最小值交换后删除即可</li></ol><h2 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h2><p>AVL树叫做<strong>平衡二叉树</strong>,是对BST的一种改进,引进了<strong>平衡机制</strong>,后面要谈的红黑树也是一种balance tree,但是AVL树的平衡更是一种<strong>强平衡</strong><br />平衡机制:<strong>任意节点的左右子树高度差不超过1</strong>,我们管这个1叫做平衡因子(Balance factor),即bf=1<br />通过平衡机制的强硬限制,规避了退化成链表的可能</p><p><img src="https://s2.loli.net/2023/11/03/pgPmINA3vBsoS9i.png" alt="AVL树" /></p><p>AVL树在查找,插入,删除的平均及最差的时间复杂度均为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>对于其查找,与二分法类似,不赘述.之于插入删除问题,由于会影响树的高度,需为维持平衡机制,因此存在<strong>左旋,右旋</strong>的概念,示意图如下:</p><p><img src="https://s2.loli.net/2023/11/03/xBVQnWizqAfYU42.png" alt="AVL-ROTATE" /></p><p>右旋:<code>rotateRight(Q)</code>,将节点Q作为其左孩子的右孩子<br />左旋:<code>rotateLeft(P)</code>,将节点P作为其右孩子的左孩子</p><p>针对插入情况的讨论(假设原始状态均满足平衡机制):</p><table><thead><tr><th style="text-align:center">插入位置</th><th style="text-align:center">状态</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><strong>在节点T的left child的left tree上插入元素</strong></td><td style="text-align:center">LL</td><td style="text-align:center">右旋</td></tr><tr><td style="text-align:center"><strong>在节点T的right child的right tree上插入元素</strong></td><td style="text-align:center">RR</td><td style="text-align:center">左旋</td></tr><tr><td style="text-align:center"><strong>在节点T的left child的right tree上插入元素</strong></td><td style="text-align:center">LR</td><td style="text-align:center">先左旋,再右旋</td></tr><tr><td style="text-align:center"><strong>在节点T的right child的left tree上插入元素</strong></td><td style="text-align:center">RL</td><td style="text-align:center">先右旋,再左旋</td></tr></tbody></table><p>以下以一个插入导致的LL情况作为示例,图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/xwBtuDjr1alMizo.png" alt="AVL-LL" /></p><div class="note note-info">            <p>注:图示的例子是给原树插了两个元素,其实这里一个或是两个元素数量都一样,因为都是挂载在同一棵树上,主要目的是导致了有的节点左右子树高度差超过了1</p>          </div><div class="note note-warning">            <p>特别注意:AVL树插入位置的条件与后面介绍的红黑树的插入位置的条件并不等价!其不等价的原因与各自平衡机制相关</p>          </div><p>以下是插入元素后的旋转情况概览图:</p><p><img src="https://s2.loli.net/2023/11/03/OiU9uRWroFMnIsQ.png" alt="AVL-ALL-ROTATE" /></p><p>删除的情况太多了,大致其实都是删了之后进行1~2次的旋转即可.此处不讨论</p><h2 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> B-树</h2><p>B-树就是B树(Balance Tree),中间的一杠是连字符.它是MongoDB的WiredTiger引擎中索引采用的数据结构.而数据库持久化的数据都是放在硬盘上的,索引也是.而对于硬盘的一次访问即是一次I/O操作,它的时间消耗是毫秒级别的.因此,我们需要减少I/O操作的次数以提高访问速度(毕竟存储结构没办法改变)</p><p>而之所以采用树形结构对索引进行存储,是因其于等值查询和区间查询都具备一定优势,而这些正是我们数据库中绝大多数涉及到的操作.</p><p>那么为什么用B-树呢?</p><p>因为B-树跟上面的树相比更加<strong>矮胖</strong>.B树允许一个节点有多个子节点,且节点内部可以存储多个元素.这就使得我们树的高度可控,不会太高,即树会变得矮胖.而之所以期望树可以更矮胖是因为我们从硬盘中读数据是以磁盘块为单位的,磁盘块有固定大小(一般4096B,4K大小),读出来的数据就等价于我们数据库中的页的概念,<strong>页和磁盘块是一样大小的</strong>,因此我们<strong>树的一个节点对应的是一个磁盘块大小的数据</strong>,那么<strong>减少I/O操作</strong>即转换成<strong>减少访问树的节点个数</strong>.<strong>B树是多路查找树,也是平衡树,它的bf=0</strong>.因此<strong>树的宽度(节点大小)决定了一次I/O操作获取到的数据量,树的高度决定了访问的I/O次数</strong></p><p>一颗m阶B树有如下特点:(这里将节点分为:[根节点,内部节点,叶子节点])</p><ul><li>根节点或是叶子节点,或是拥有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个孩子节点的非叶子节点;</li><li>所有内部节点都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个孩子节点,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo stretchy="false">⌉</mo><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil \le k \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li>所有叶子节点都包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo stretchy="false">⌉</mo><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil \le k \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li>所有叶子节点位于同一层(bf=0的体现)</li><li>每个节点中的key值是升序排列的,节点中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值可以划分出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个孩子节点</li></ul><p>一颗普通的B树如下图示:</p><p><img src="https://s2.loli.net/2023/11/03/sBtZgD4XKPezi5E.png" alt="B-Tree" /></p><div class="note note-info">            <p>注:上图的P1,P2这些是指针,我们的树与子树的关系基本都是通过指针维系的,别的也是,没画出来而已,这里如磁盘块2,它只画了索引值,其实还有个叫卫星数据(不知道为啥叫这个)的东西,它所指代的是索引元素指代的数据记录,那就比如是某张表的某一行数据</p>          </div><p>看完上面对B树的特点定义会好奇<strong>为何根节点要么是叶子节点,要么至少有两个子节点</strong>,<strong>它的插入删除咋执行的</strong>,其实这些问题都源于以下两句话:</p><ul><li><strong>插入key值至超出阈值(上面所说的节点内key值的上界),会致使节点产生分裂,分裂伴随着该节点中值的上溢(上移),甚至有的情况节点上溢会递归导致一个新的根节点的产生</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/RWnkedmxQgXzGM8.png" alt="插入致使上溢,有新节点产生" /></p><p><img src="https://s2.loli.net/2023/11/03/4azrdDiW7AsbCHU.png" alt="插入致使上溢,无新节点产生" /></p><div class="note note-info">            <p>注:可以很清晰地看出来,B-树以及下面要将的B+树,跟以往的树的构造不一样,它们是由下至上构建的,而先前学的二叉树啥的都是自顶向下构建的</p>          </div><ul><li><strong>删除叶子节点的key值至超出阈值(上面所说的节点内key值的下界),会致使其向兄弟节点借一个key值,如果它的兄弟节点key值也不够,那就要三合一(删了key值的节点,它的兄弟节点,它们间的父节点的key值即使其下溢(下移)),甚至可能导致父节点的key值也刚好不够,则递归下溢直至所有节点满足要求</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/pgaXild1emSo4kJ.png" alt="叶子节点删除key,向兄弟借key" /></p><p><img src="https://s2.loli.net/2023/11/03/kwKOUiA6LZbnyBc.png" alt="叶子节点删除key,做合并" /></p><ul><li><strong>删除内部节点(中间节点)的key值至超出阈值,向有足够key值的子节点借一个key值,如果不够,就只可以合并,这个合并也是三合一(跟上面的一样)</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/fIWJdQPM28Ygzui.png" alt="内部节点删除key,向子节点借key" /></p><p><img src="https://s2.loli.net/2023/11/03/m8ISEgL3NYc4i6U.png" alt="内部节点删除key,做合并" /></p><h2 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h2><p>我们知道B+树是MySQL的InnoDB引擎中索引采用的数据结构,而B+树是B树的升级版,它增加了如下的特点:(树的节点于此处分为:[根节点,内部节点,叶子节点])</p><ol><li>非叶子节点内含有k个子节点,亦含有k个key值,每个key值对应一个子节点;</li><li>非叶子节点内不含数据,只有key值用于索引;key值及数据全存放于叶子节点,叶子节点间的key值依升序链接,叶子节点间通过链表链接;</li><li>非叶子节点的key值都存在于子节点中,且是子节点中key值的最大或最小的</li></ol><p>1,3制造冗余边界数据,便于插入和删除的方式改进,将对树的变形控制在单一分支(<mark>其实如插入也存在上溢的情况,也要比较猛烈的变形,但对删除有了很大改变</mark>),避免了复杂的树变形;<br />2.则扩增了每个节点的key值数目,进而使得树更加<strong>矮胖</strong>,有利于减少I/O操作次数;而数据全放在叶子节点,树更稳定(查询都要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>),也利于MySQL常用的区间查询</p><p>以下是B+树的一个普通示例图:</p><p><img src="https://s2.loli.net/2023/11/03/4YXZ8RCWmz7phH2.png" alt="B+Tree" /></p><div class="note note-info">            <p>MongoDB是文档型的数据库,是NoSQL中的一种,用JSON格式存数据(这是一种聚合型的方式,与MySQL的表结构的设计思路很不同,MySQL的表间关系通过外键进行链接,而JSON对有关系的可以直接编到一个map里),于MongoDB而言更多进行的是单一数据查询,不涉及遍历查询,那么我们此刻B+树的优点于它而言就没啥意义,而B-树的值也存在于非叶子节点中,它的时间复杂度处于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>的状态,相较于B+树的稳定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,B-树更适用于MongoDB数据库;<br />MySQL则是我们都熟悉的关系型数据库,很显然,它涉及到较多遍历操作和区间查询,因此更适用于B+树,B-树的遍历和区间查询(需找边缘值后中序遍历)会产生更多的IO操作,不值得</p>          </div><div class="note note-danger">            <p>勘误:经过看MongoDB官方文档,底层用的也是B+树,网上各类博客害人不浅<br />援引如下:</p><blockquote><p>WiredTiger maintains a table’s data in memory using a data structure called a B-Tree ( B+ Tree to be specific), referring to the nodes of a B-Tree as pages. Internal pages carry only keys. The leaf pages store both keys and values.</p></blockquote>          </div><h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2><p>前面说过,AVL树是一种强平衡的树,而红黑树则是弱平衡的BST.它较之于AVL树而言,正由于它的弱平衡性,导致我们在插入删除时不必要进行那么多的旋转操作!</p><p>红黑树的平衡性体现在:<strong>从根到叶子的最长路径不会比最短路径长超过两倍</strong></p><p>之所以说它是弱平衡的,是因为它没有将bf强制约束于某个值,而是通过如下5条性质来维持弱平衡性:</p><ul><li><strong>节点是红色或黑色的</strong></li><li><strong>根节点是黑色的</strong></li><li><strong>叶子节点都是黑色的,它们都是空节点,data为null</strong></li><li><strong>不能出现连续的两个红色节点(即一个红色节点的父节点及其子节点一定都是黑色的)</strong></li><li><strong>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</strong></li></ul><p>针对最后一点性质,红黑树有一个<strong>黑高度(黑高)<strong>的概念:从某个节点出发至一叶子节点,所经历的黑色节点的个数(不包括起始节点,即使它是黑的)称为该节点的黑高bh.因此</strong>某一个节点的bh值应是唯一的</strong>,若不唯一则违背了最后一条性质</p><p>以下是红黑树的一张示意图:</p><p><img src="https://s2.loli.net/2023/11/03/8h6p2cQwK5afSFm.png" alt="RBT" /></p><div class="note note-info">            <p>红黑树的查找,插入,删除的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,跟AVL树的一样,但其实AVL树在处理插入和删除问题时,为了保持bf=1,会涉及到复杂的旋转问题.而具有强平衡性的AVL树的查询能力显然更强.因此在设计底层数据结构的时候可以根据侧重进行选择</p>          </div><p>而在之后介绍如插入等的相关操作时,一般会<strong>忽略掉最后的叶子节点</strong>,就是data为null的节点</p><p>一颗红黑树,通过<strong>将红色节点上移至父节点同一高度组成B树节点后</strong>,即<strong>等价于一颗4阶B树</strong>,其变形如下所示:</p><p><img src="https://s2.loli.net/2023/11/03/tUPQXa4YhdIvrox.png" alt="RBT2BTree" /></p><p>由上图可以看出来,红黑树变形为4阶B树后有如下性质:</p><ul><li>红黑树与4阶B树具有等价性</li><li>黑色节点和其红色子节点融合形成一个B树节点</li><li>在一个融合形成的B树节点里,根节点是黑色的,子节点是红的</li><li>红黑树的非叶子节点的黑色节点个数与4阶B树的节点总数相等</li></ul><p>我们先来探讨一下转换为4阶B树的红黑树,对应的节点内部情况.4阶B树节点内部最多允许有3个元素,依据上述的性质3,即存在以下情况:<strong>红黑红,黑红,红黑,黑</strong>,且其中黑色的一定是原红黑树的子树/树本身的根节点,图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/e62NIFW8owYr3XS.png" alt="RBT2BTree-node-classfication" /></p><p><strong>对红黑树的插入删除情况的讨论也转换为对4阶B树的插入删除情况的讨论,但需要满足红黑树的性质</strong></p><p>插入情况讨论:</p><p>首先给出插入情况的红黑树的图:</p><p><img src="https://s2.loli.net/2023/11/03/muwN2zvGIPep7XD.png" alt="RBT2BTree-Insertion" /></p><p>对于B树的插入,是自底向上的.因此对插入情况可分为如下两大类及对应的细分:</p><ul><li>插入导致上溢</li><li>插入不导致上溢<ul><li>父节点是黑色的</li><li>父节点是红色的</li></ul></li></ul><p>而根据红黑树的性质:<strong>某一结点至叶子节点的任意路径的黑色节点个数相等</strong>可知,若插入节点的颜色是黑的,一定会破坏这条规则,且需要花较大功夫来维持这条规则;若插入节点是红的,则可能破坏了<strong>不允许有两个连续的红色节点</strong>这一规则,但对这一规则的维护可以通过旋转及变色来操作,较容易处理.因此<strong>插入节点一定都是红色节点</strong></p><p>根据给出的示意图,可以分析得出如下的插入情况,分别是:</p><ul><li>满足红黑树性质,无需修复</li><li>不满足红黑树性质,需要修复</li></ul><p>对应的图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/i9cyfeSUzraZWnH.png" alt="RBT2BTree-Insertion-without-repair" /></p><p><img src="https://s2.loli.net/2023/11/03/adcunTZI6XSpNO3.jpg" alt="RBT2BTree-Insertion-need-repair" /></p><p>针对上图的<strong>不需上溢</strong>的情况,其实就是做<strong>旋转以及变色</strong>,旋转后变色需遵循上述的<strong>新B树节点内的根节点是黑色的两侧节点是红色的</strong>.之所以<strong>不需上溢</strong>可以通过旋转加变色处理,是因4阶B树允许节点内部最多三个元素,且当是三个元素的时候,是红黑红(根节点黑,俩子节点红)的情况</p><p>以下仅介绍不需上溢的其中一种情况,即LL.LL意味着插入元素位于父节点的左侧(L),而父节点也是位于grand节点的左侧,之于这种情况可通过右旋更新父节点,而后染色成<strong>红黑红</strong>的B树节点即可,过程见下图示:</p><p><img src="https://s2.loli.net/2023/11/03/Lp6GvV5XMJSBgaP.png" alt="RBT2BTree-Insertion-LL-RR" /></p><p>而后面的[LR,RL]这俩情况则是需要双旋,旋转成[LL,RR]后再转一次和进行染色就ok了</p><p>这四种情况[LL,LR,RL,RR]的流程如下表所示:</p><table><thead><tr><th style="text-align:center">插入位置</th><th style="text-align:center">状态</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><strong>插入元素位于其parent节点的left,而其parent位于其grand的left</strong></td><td style="text-align:center">LL</td><td style="text-align:center">右旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的right,而其parent位于其grand的right</strong></td><td style="text-align:center">RR</td><td style="text-align:center">左旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的right,而其parent位于其grand的left</strong></td><td style="text-align:center">LR</td><td style="text-align:center">先左旋,再右旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的left,而其parent位于其grand的right</strong></td><td style="text-align:center">RL</td><td style="text-align:center">先右旋,再左旋</td></tr></tbody></table><p>而针对于<strong>需要上溢</strong>的情况其实更简单,因为我们首要解决的是上溢的问题,即节点分裂,上移,那么此刻就会分裂出两个新的子节点,而这俩子节点是原先父节点的子节点,现在做了独立的B树节点的根节点,即对二者变色即可,则此刻新插入的节点的情况等价于往黑色的根节点插入新节点,即满足红黑树性质,无需修复.这个整体过程可以概括为:<strong>上溢,变色</strong>,无需旋转</p><p>示例图如下:</p><p><img src="https://s2.loli.net/2023/11/03/IRKqyOMLvV6jpYt.png" alt="RBT2BTree-Insertion-upflow" /></p><p>然后对[25&lt;-38&lt;-55]这一个B树节点(LL情况)右旋然后变色即可</p><p>关于删除的部分情况较多,之后有时间再补上:)</p>]]></content>
    
    
    
    <tags>
      
      <tag>tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVM理解</title>
    <link href="/2022/10/10/SVM%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/10/SVM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="svm概念"><a class="markdownIt-Anchor" href="#svm概念"></a> SVM概念</h2><p>SVM(Support Vector Machine)支持向量机,它是一个二分类模型.也存在变体的SVM模型,可用于处理多分类问题</p><p><mark>SVM擅长于处理样本数少于特征维度数的情况,应该也适用于小样本学习</mark></p><p>从二维空间举例来说,我们存在两个点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,它们是线性可分的,即可以通过一条直线将其进行完全划分.这是二维空间的情况.推广至n维空间,即存在一个<strong>超平面hyperplane</strong>可以对该特征空间下的点集进行划分</p><p>那么很明显,这样的超平面存在无数多个,于二维空间而言,我们可以找多无数多条直线来对点集进行划分.SVM所期望的超平面是<strong>最大间隔超平面</strong></p><p><strong>最大间隔超平面</strong>,即<strong>距离超平面最近的点的距离最大化</strong>.这些离超平面最近的点被称作<strong>支持向量</strong></p><p>之所以以最大间隔作为期望条件,是因其:<strong>间隔越大,两个需要区分的类别差异性更大,更容易做区分</strong></p><h2 id="间隔的表达式"><a class="markdownIt-Anchor" href="#间隔的表达式"></a> 间隔的表达式</h2><p>以二维空间为例,假设我们已经找到了可以将两个点集进行划分的<strong>分割线</strong>,这条分割线的超平面方程式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,根据上面的概念,我们可以通过将该直线上下分别移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>以<strong>恰好</strong>经过一些最近的样本点(即支持向量),来找到对应的间隔上下边界,二者的式子可表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=\pm{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>我们可以对间隔边界的式子进行变形以取得下式:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=\pm{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord"><span class="mord">1</span></span></span></span></span>,我们将这三个式子如下称呼:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>正超平面</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>决策超平面</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><mn>1</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>负超平面</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\begin{aligned}w_1x_1+w_2x_2&amp;=1 \quad &amp;\text{正超平面} \\w_1x_1+w_2x_2&amp;=0 \quad &amp;\text{决策超平面} \\w_1x_1+w_2x_2&amp;=-1 \quad &amp;\text{负超平面} \end{aligned}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.0000000000000004em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000013em;"><span style="top:-4.5em;"><span class="pstrut" style="height:4.5em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">正超平面</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">决策超平面</span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">负超平面</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0000000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>若点代入式子,有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,则其为正类;<br />若点代入式子,有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2\le-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>,则其为负类</p><p>我们可以根据向量投影来求得间隔<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>的值,也可以通过线线距离来求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>的值</p><p><img src="https://s2.loli.net/2023/11/03/CxGoRhzj5YQk1aP.png" alt="margin-of-SVM" /></p><p>根据上图将m,n两点代入正负超平面,做差,而后投影,可得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mfrac><mn>2</mn><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">L=\frac{2}{\Vert \vec{w} \Vert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,我们欲求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\max L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span></span></span></span>,可以转换成求其倒数的最小值,而由于对向量求范式含根号,故对其平方以去根号,因此我们的优化目标转为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\min f(w) = \frac{1}{2}\Vert \vec{w^2} \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3681079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span></p><h2 id="拉格朗日乘数法"><a class="markdownIt-Anchor" href="#拉格朗日乘数法"></a> 拉格朗日乘数法</h2><p>面对存在<strong>一个或多个约束条件</strong>下,我们想求得<strong>目标函数的极值</strong>,可以使用拉格朗日乘数法<br />而在此题中,我们欲求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>的最小值,则可以通过拉格朗日乘数法来求解<br />首先明确,我们的约束条件是:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>1</mn><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_i(w,b) = y_i * (\vec{w}\vec{x_i} + b) \ge 1 \quad\quad (i=1,2,\cdots,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表的是分类值,为1则为正类,为-1则为负类,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\vec{w}\vec{x}+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79733em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>则是超平面的表达式(其所处的维度空间由向量维度确定),<strong>约束条件表明正负类点集都应分布在正负超平面两侧(亦可恰好分布在正负超平面上)</strong></p><p>对于拉格朗日乘数法,它所处理的是等式约束条件,而我们这里是不等式约束条件,可通过增加<strong>松弛变量</strong>来使得其转化为等式的约束条件,可变换成如下形式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>=</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_i(w,b,p_i) = y_i * (\vec{w}\vec{x_i} + b) -1 = {p_i}^2 \quad\quad (i=1,2,\cdots,s) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p><p>此时可以通过构造拉格朗日函数来处理极值问题,构造的函数如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>λ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>−</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mo stretchy="false">)</mo><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}L(w,b,\lambda_i,p_i) &amp;= f(w) - \sum_{i=1}^{s}\lambda_ig_i(w,b,p_i) \\&amp;= \frac{\Vert \vec{w^2} \Vert}{2} - \sum_{i=1}^{s}\lambda_i * (y_i * (\vec{w}\vec{x_i} + b) -1 - {p_i}^2) \quad\quad (i=1,2,\cdots,s)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.506843000000001em;vertical-align:-3.0034215em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.503421500000001em;"><span style="top:-5.552132500000001em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.2743555000000004em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0034215em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.503421500000001em;"><span style="top:-5.552132500000001em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.2743555000000004em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.700108em;"><span style="top:-2.3371079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.2531079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7001079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0034215em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>此时我们可以知道,若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值为负数,则无法起到罚值作用(相关意义可以见后面软间隔部分),因此其取值应为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>需注意,根据拉格朗日乘数法,我们需要对<strong>目标函数</strong>,<strong>拉格朗日算子</strong>以及<strong>松弛变量</strong>求偏导,且零其值为0,因此,得下式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>−</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\Vert \vec{w} \Vert - \sum_{i=1}^{s}\lambda_i * y_i * \vec{x_i} = 0 \\ - \sum_{i=1}^{s}\lambda_i * y_i = 0 \\y_i * (\vec{w}\vec{x_i} + b) - 1 - {p_i}^2 = 0 \\2\lambda_ip_i = 0\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>联立后两个式子(消去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{p_i}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>),我们会发现有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_ig_i(w,b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>这一公式,其只有以下两种情况:</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i=0,g_i(w,b)\neq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,此刻约束条件非零,则意味着点并非落在正负超平面上,非极值,此刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>必须为0;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i\neq0,g_i(w,b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,此刻点落在正负超平面上,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以不为零</li></ol><p>因此,对公式重整,我们有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\Vert \vec{w} \Vert - \sum_{i=1}^{s}\lambda_i * y_i * \vec{x_i} = 0 \\- \sum_{i=1}^{s}\lambda_i * y_i = 0 \\g_i(w,b) \ge 0 \\\lambda_i * g_i(w,b) = 0 \\\lambda_i \ge 0 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.2000399999999996em;vertical-align:-3.3500199999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.85002em;"><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-0.6949900000000002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.9899900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.2849900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.5799900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8749900000000006em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1699900000000008em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.180010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.475010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.770010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.80501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-6.10002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8500000000000005em;"><span style="top:-5.850000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-4.410000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.9700000000000006em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-0.08999999999999997em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>观察可知,此式现已满足KKT条件,即可对其进行求解</p><h2 id="强对偶"><a class="markdownIt-Anchor" href="#强对偶"></a> 强对偶</h2><p>为了效率及后续操作中使用kernel trick,我们可以利用强对偶性对其进行处理<br /><mark>暂时没看懂,后面再补</mark></p><h2 id="软间隔"><a class="markdownIt-Anchor" href="#软间隔"></a> 软间隔</h2><p>我们知道并不是所有点都可以满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g_i(w,b) \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,有些点会出现在我们的margin里面,那么这时候我们要么缩短margin以满足所有点都在margin两侧(hard margin),要么根据误差做罚值<br />根据margin的定义,margin越大越说明二者差异,越易分类.因此,不可轻易缩短margin,我们要容许部分点落在margin内,因此是对二者做的一个平衡</p><p>我们可以将罚值公式记作如下:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon_i = 1 - y_i * (\vec{w} + \vec{x_i} + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p><p>因此,我们所求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\min \frac{\Vert \vec{w^2} \Vert}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.55052em;vertical-align:-0.345em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20552em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0293142857142856em;"><span style="top:-2.746314285714286em;"><span class="pstrut" style="height:2.746314285714286em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.061628571428572em;"><span class="pstrut" style="height:2.746314285714286em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>需要与不同点的罚值寻找一个平衡,构建出以下公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>min</mi><mo>⁡</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>ϵ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\min \frac{\Vert \vec{w^2} \Vert}{2} + \sum_{i=1}^{s}\epsilon_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.386108em;vertical-align:-0.686em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.700108em;"><span style="top:-2.3371079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.2531079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7001079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>使用以上公式,以达总体最优,再根据之前的构造出拉格朗日乘数法进行计算即可</p><h2 id="核技巧中的核函数"><a class="markdownIt-Anchor" href="#核技巧中的核函数"></a> 核技巧中的核函数</h2><p>我们在低维空间可能无法对点集进行线性划分,则我们可以通过将其映射到高维来处理,但映射到高维存在计算量过大的问题,而我们在通过强队偶计算的过程中发现,可以利用其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_ix_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的性质来利用核函数.即:<br />以下是两个核函数公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>多项式核函数</mtext><msub><mi>K</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><mi>d</mi></msup><mspace linebreak="newline"></mspace><mtext>高斯核函数</mtext><mi>K</mi><mo stretchy="false">(</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>γ</mi><msup><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">\text{多项式核函数}  K_d(\vec{x_i},\vec{x_j}) = {(c + \vec{x_i} * \vec{x_j})}^d \\\text{高斯核函数} K(\vec{x_i},\vec{x_j}) = e^{-\gamma {\Vert \vec{x_i}-\vec{x_j} \Vert}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord cjk_fallback">多项式核函数</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275116em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord cjk_fallback">高斯核函数</span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05556em;">γ</span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.7139999999999995em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span><span class="mord mtight">∥</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>]]></content>
    
    
    
    <tags>
      
      <tag>SVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像增强方法合集</title>
    <link href="/2022/10/06/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <url>/2022/10/06/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="mixup"><a class="markdownIt-Anchor" href="#mixup"></a> mixup</h2><h2 id="cutout"><a class="markdownIt-Anchor" href="#cutout"></a> cutout</h2><h2 id="cutmix"><a class="markdownIt-Anchor" href="#cutmix"></a> cutmix</h2>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViT理解及实验</title>
    <link href="/2022/10/04/ViT%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/10/04/ViT%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>ViT(Vision Transformer),是ICLR 2021上的一篇<strong>AN IMAGE IS WORTH 16x16 WORDS:TRANSFORMER FOR IMAGE RECOGNITION AT SCALE</strong>论文里提及的模型,将<strong>transformer应用于image classification</strong>上,并在Google的JFT-300M数据集进行预训练后,在ImageNet-1k上做分类达到当时的SOTA!</p><p><img src="https://s2.loli.net/2023/11/05/2owmLrEzqihCtcd.png" alt="ViT-Paper-Result" /></p><p>因此,本文将通过结构结合代码进行介绍,并于文末将采用与预训练好的模型应用于花分类数据集上进行实验.</p><div class="note note-info">            <p>注:本文采用的是ViT-B/16模型进行解析,B-&gt;Base 16-&gt;patch size:16*16,输入图片的shape是(224,224,3)</p>          </div><p><img src="https://s2.loli.net/2023/11/03/FKTfWnXRGQMPYol.png" alt="Details of ViT variants" /></p><p>原论文链接:<a href="https://arxiv.org/pdf/2010.11929.pdf">AN IMAGE IS WORTH 16x16 WORDS:TRANSFORMER IMAGE RECOGNITION AT SCALE</a><br /><a href="https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz">花分类数据集下载</a></p><h2 id="vit整体结构"><a class="markdownIt-Anchor" href="#vit整体结构"></a> ViT整体结构</h2><p>首先看下ViT的整体结构图:</p><p><img src="https://s2.loli.net/2023/11/05/5HgIBdYF8btX7OG.png" alt="ViT-overview" /></p><p>整个ViT由以下三部分组成:</p><ul><li>Linear Projection of Flattened Patches -&gt; 转换为transformer接受的输入</li><li>Transformer Encoder -&gt; 进入Encoder学习图片的相关性,对应特征</li><li>MLP Head -&gt; 做分类,其实就是全连接层</li></ul><h3 id="linear-projection-of-flattened-patches"><a class="markdownIt-Anchor" href="#linear-projection-of-flattened-patches"></a> Linear Projection of Flattened Patches</h3><h4 id="patch-embedding"><a class="markdownIt-Anchor" href="#patch-embedding"></a> patch embedding</h4><p>根据先前介绍的transformer的知识,我们输入的应该是token sequence,如由词向量组成的矩阵,row的个数表示词的个数,column宽度表示词的dimension.<br />因此输入图片是不符合要求的,我们需要将图片处理成<strong>对应的序列</strong>才行.将图片切割成一小块一小块的patch,再将patches延展成一维的(获得patch_num),再将每个patch通过线性变换映射到对应的维度(patch_dim),即完成了patch embedding的过程.最终得到的参数为:[patch_num,patch_dim]<br />其实上述过程,用卷积的思想解释就是<strong>kernel=16x16,stride=16,采用768个卷积核进行卷积计算,即可以将[224,224,3]-&gt;[14,14,768]</strong>,然后再通过torch的flatten处理就可以得到[196,768]</p><div class="note note-info">            <p>注:这里的<strong>768</strong>并非通过如16*16*3计算出来的,而是作者规定的dimension,如ViT-H/16,其patch_dim是1280.</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatchEmbed</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    2D Image to Patch Embedding</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, img_size=<span class="hljs-number">224</span>, patch_size=<span class="hljs-number">16</span>, in_c=<span class="hljs-number">3</span>, embed_dim=<span class="hljs-number">768</span>, norm_layer=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        img_size = (img_size, img_size)<br>        patch_size = (patch_size, patch_size)<br>        self.img_size = img_size<br>        self.patch_size = patch_size<br>        self.grid_size = (img_size[<span class="hljs-number">0</span>] // patch_size[<span class="hljs-number">0</span>], img_size[<span class="hljs-number">1</span>] // patch_size[<span class="hljs-number">1</span>])<br>        self.num_patches = self.grid_size[<span class="hljs-number">0</span>] * self.grid_size[<span class="hljs-number">1</span>]<br><br>        self.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="hljs-comment"># 这里所复现的代码用的是卷积的形式,原文的代码不是卷积</span><br>        self.norm = norm_layer(embed_dim) <span class="hljs-keyword">if</span> norm_layer <span class="hljs-keyword">else</span> nn.Identity() <span class="hljs-comment"># 这里的Identity指的是不对输入做任何修改直接输出的意思</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        B, C, H, W = x.shape <span class="hljs-comment"># x.shape = [batch_size,channel,height,width]</span><br>        <span class="hljs-keyword">assert</span> H == self.img_size[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> W == self.img_size[<span class="hljs-number">1</span>], \<br>            <span class="hljs-string">f&quot;Input image size (<span class="hljs-subst">&#123;H&#125;</span>*<span class="hljs-subst">&#123;W&#125;</span>) doesn&#x27;t match model (<span class="hljs-subst">&#123;self.img_size[<span class="hljs-number">0</span>]&#125;</span>*<span class="hljs-subst">&#123;self.img_size[<span class="hljs-number">1</span>]&#125;</span>).&quot;</span><br><br>        <span class="hljs-comment"># flatten: [B, C, H, W] -&gt; [B, C, HW] </span><br>        <span class="hljs-comment"># transpose: [B, C, HW] -&gt; [B, HW, C] 即[B,196,768]</span><br>        x = self.proj(x).flatten(<span class="hljs-number">2</span>).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        x = self.norm(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 代码中的类继承了nn.Module,这里面重写了魔法方法__call__,该方法里面调用了forward方法,因此子类重载forward可使得该方法通过<strong>类实例化对象如普通方法般调用</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">patchEmbed = PatchEmbed(para1,para2,...)<br>x = torch.rand(B,C,H,W)<br>patchEmbed(x) <span class="hljs-comment"># 于此会调用__call__方法,因而调用自己重载后的forward方法</span><br></code></pre></td></tr></table></figure>          </div><h4 id="cls-token"><a class="markdownIt-Anchor" href="#cls-token"></a> CLS token</h4><p>ViT中的分类采用的是Bert中的CLS的思想来进行的,因此我们的patchEmbedding需要变换成**[196+1,768]**,即多出一行用于分类,这个参数由网络学习得到.其与patchEmbedding是concat的关系</p><h4 id="positional-embedding"><a class="markdownIt-Anchor" href="#positional-embedding"></a> positional embedding</h4><p>在transformer里讲过,我们输入的序列缺乏位置信息,因此需要增加positional embedding来使得其位置信息得以保持.在代码中,我们的位置信息是通过模型训练获得的(nn.Parameter()),其与patch embedding是直接add的</p><h3 id="encoder-block"><a class="markdownIt-Anchor" href="#encoder-block"></a> encoder block</h3><p>流程如下图所示:</p><p><img src="https://s2.loli.net/2023/11/05/UVtJnMqul2fjCEO.png" alt="ViT encoder block" /></p><p>关于Multi-Head Attention层相关的部分跟transformer的一样,这里不赘述.以下是Multi-Head Attention的代码解析部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Attention</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 dim,   <span class="hljs-comment"># 输入token的dim(768)</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 num_heads=<span class="hljs-number">8</span>, <span class="hljs-comment"># 有几个头(multi的head)</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 qkv_bias=<span class="hljs-literal">False</span>, <span class="hljs-comment"># 偏移量</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 qk_scale=<span class="hljs-literal">None</span>, <span class="hljs-comment"># 放缩量</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 attn_drop_ratio=<span class="hljs-number">0.</span>, <span class="hljs-comment"># attention公式执行完后的dropout比例</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 proj_drop_ratio=<span class="hljs-number">0.</span></span>):</span> <span class="hljs-comment"># 一个encoder block执行完后的drop比例 </span><br>        <span class="hljs-built_in">super</span>(Attention, self).__init__()<br>        self.num_heads = num_heads<br>        head_dim = dim // num_heads <span class="hljs-comment"># 每个头对应的维度</span><br>        self.scale = qk_scale <span class="hljs-keyword">or</span> head_dim ** -<span class="hljs-number">0.5</span><br>        self.qkv = nn.Linear(dim, dim * <span class="hljs-number">3</span>, bias=qkv_bias) <span class="hljs-comment"># 将QKV三个一次性一起生成</span><br>        self.attn_drop = nn.Dropout(attn_drop_ratio)<br>        self.proj = nn.Linear(dim, dim)<br>        self.proj_drop = nn.Dropout(proj_drop_ratio)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-comment"># [batch_size, num_patches + 1, total_embed_dim]</span><br>        B, N, C = x.shape<br><br>        <span class="hljs-comment"># qkv(): -&gt; [batch_size, num_patches + 1, 3 * total_embed_dim] QKV三个矩阵一起的(相当于沿列方向concat,[B,196,768*3])</span><br>        <span class="hljs-comment"># reshape: -&gt; [batch_size, num_patches + 1, 3, num_heads, embed_dim_per_head] </span><br>        <span class="hljs-comment"># permute: -&gt; [3, batch_size, num_heads, num_patches + 1, embed_dim_per_head] Q,K,V三个矩阵分出来,并且将其各分成num_heads个小矩阵</span><br>        qkv = self.qkv(x).reshape(B, N, <span class="hljs-number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>        <span class="hljs-comment"># [batch_size, num_heads, num_patches + 1, embed_dim_per_head]</span><br>        q, k, v = qkv[<span class="hljs-number">0</span>], qkv[<span class="hljs-number">1</span>], qkv[<span class="hljs-number">2</span>]  <span class="hljs-comment"># make torchscript happy (cannot use tensor as tuple)</span><br><br>        <span class="hljs-comment"># transpose: -&gt; [batch_size, num_heads, embed_dim_per_head, num_patches + 1]</span><br>        <span class="hljs-comment"># @: multiply -&gt; [batch_size, num_heads, num_patches + 1, num_patches + 1] 集体做矩阵乘</span><br>        attn = (q @ k.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) * self.scale<br>        attn = attn.softmax(dim=-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对行向量做softmax</span><br>        attn = self.attn_drop(attn)<br><br>        <span class="hljs-comment"># @: multiply -&gt; [batch_size, num_heads, num_patches + 1, embed_dim_per_head] </span><br>        <span class="hljs-comment"># transpose: -&gt; [batch_size, num_patches + 1, num_heads, embed_dim_per_head]</span><br>        <span class="hljs-comment"># reshape: -&gt; [batch_size, num_patches + 1, total_embed_dim]</span><br>        x = (attn @ v).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).reshape(B, N, C)<br>        x = self.proj(x) <span class="hljs-comment"># 相当于拼接好后的Z矩阵与W^O矩阵相乘</span><br>        x = self.proj_drop(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>nn.Linear()就是全连接(如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><msup><mi>A</mi><mi>T</mi></msup><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = xA^T + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>是输入参数,可以是多维的,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>是权重矩阵,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>是偏置向量),对x.shape的最后一个维度最连接操作,也可以将其理解为矩阵乘,其参数由训练迭代更新(源码中将其加入了nn.Parameter()中)<br />nn.Droupout()防止过拟合,参数表示不被激活的神经元的占比<br />@-&gt;矩阵乘 *-&gt;矩阵点乘(又或者说逐向量内积)</p>          </div><h4 id="mlp-block"><a class="markdownIt-Anchor" href="#mlp-block"></a> MLP block</h4><p>从上方ViT Encoder Block的图中可以看出,MLP是由两层全连接层和GELU激活函数构成,第一层将其维度变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>768</mn><mi>x</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">768x4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord mathnormal">x</span><span class="mord">4</span></span></span></span>,第二层将其维度变回768(<mark>没搞明白为啥这样变</mark>).代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mlp</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_features, hidden_features=<span class="hljs-literal">None</span>, out_features=<span class="hljs-literal">None</span>, act_layer=nn.GELU, drop=<span class="hljs-number">0.</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        out_features = out_features <span class="hljs-keyword">or</span> in_features<br>        hidden_features = hidden_features <span class="hljs-keyword">or</span> in_features<br>        self.fc1 = nn.Linear(in_features, hidden_features) <span class="hljs-comment"># hidden_features == 4*in_features</span><br>        self.act = act_layer()<br>        self.fc2 = nn.Linear(hidden_features, out_features) <span class="hljs-comment"># out_features == in_features</span><br>        self.drop = nn.Dropout(drop)<br><br><span class="hljs-comment"># 按照上述流程图的顺序执行的</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.fc1(x)<br>        x = self.act(x)<br>        x = self.drop(x)<br>        x = self.fc2(x)<br>        x = self.drop(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h3 id="mlp-head"><a class="markdownIt-Anchor" href="#mlp-head"></a> MLP HEAD</h3><p>切片,取第0行的向量(CLS),然后做全连接,流程如下图所示</p><p><img src="https://s2.loli.net/2023/11/03/M4T2mAFqiBhE7JZ.png" alt="MLP-HEAD" /></p><p>关于上面的Pre-Logits,在ImageNet-1K无需用到,直接设置为None;在ImageNet-21K里用到了,就是一个全连接层+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">tanh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">h</span></span></span></span>激活函数</p><h2 id="vit执行流程"><a class="markdownIt-Anchor" href="#vit执行流程"></a> ViT执行流程</h2><p>详见下图,图片源于B站UP主:霹雳吧啦Wz</p><p><img src="https://s2.loli.net/2023/11/05/QJbGUKgoFZw3kuN.png" alt="ViT Execution Process" /></p><h2 id="vit实验"><a class="markdownIt-Anchor" href="#vit实验"></a> ViT实验</h2><p>拿的别人的模型跑的,但是好像用CUDA的地方出了点问题,在调BUG,跑好了会摆上来</p><h2 id="vit与传统cnn的差异"><a class="markdownIt-Anchor" href="#vit与传统cnn的差异"></a> ViT与传统CNN的差异</h2><p>关于二者的差异在<strong>Do Vision Transformers See Like Convolutional Neural Networks</strong>这篇论文中进行了详细的比对.下面将对其结果和主要使用分析工具进行介绍</p><p>原论文连接:<a href="https://arxiv.org/pdf/2108.08810.pdf">Do Vision Transformers See Like Convolutional Neural Networks?</a><br /><mark>非常粗粒度的看了这篇论文</mark></p><h3 id="主要分析工具"><a class="markdownIt-Anchor" href="#主要分析工具"></a> 主要分析工具</h3><p>CKA(Centered Kernel Alignment),可用于<strong>计算神经网络表征(neural network representation)的相似度</strong>.可以用于计算<strong>同一模型不同层间的表征相似度</strong>,或者是<strong>不同模型间的层的表征相似度</strong>,具体计算公式不细说(<mark>主要是我没弄明白</mark>),知其定义即可理解该论文对ViT和ResNet间的差异性分析.</p><h3 id="vit和resnet的比较"><a class="markdownIt-Anchor" href="#vit和resnet的比较"></a> ViT和ResNet的比较</h3><h4 id="同一模型间的不同层级的表征相似性比较"><a class="markdownIt-Anchor" href="#同一模型间的不同层级的表征相似性比较"></a> 同一模型间的不同层级的表征相似性比较</h4><p><img src="https://s2.loli.net/2023/11/03/jJPaSAEu3WD5Gb8.png" alt="representation structure of ViTs and CNN" /></p><p>从上面这个图可以很清晰的看出来:<strong>ViT模型整体具有高度的表征相似性,而ResNet只是局部具有较高的表征相似性,如低层和高层,且lower layers和higher layers相似性很小</strong></p><h4 id="不同模型间的对应层级的表征相似性比较"><a class="markdownIt-Anchor" href="#不同模型间的对应层级的表征相似性比较"></a> 不同模型间的对应层级的表征相似性比较</h4><p><img src="https://s2.loli.net/2023/11/03/7yHbhG1k2YTDWxM.png" alt="representation structure between ViTs and CNN" /></p><p>从上面这个heatmap图可以看出来:ResNet中较多的较低层与ViT中较少的较低层具有相似性,但是在高层间(最高的那一片区域)二者相似性很低</p><p>以上对模型自身及模型间的层与层的表征相似性的说明了:</p><ul><li><strong>ViT最高层对于ResNet来说,具有相当不同的表示</strong></li><li><strong>ViT在较低层和较高层间的传播表示更为强烈</strong></li><li><strong>ViT计算较低层表征的方式与ResNet较低层的不同</strong></li></ul><h4 id="层表征中的局部和全局信息"><a class="markdownIt-Anchor" href="#层表征中的局部和全局信息"></a> 层表征中的局部和全局信息</h4><p>这个标题主要的意思就是,不同模型中<strong>低层和高层中学习到了的是什么样的信息,局部的或是全局的或是二者皆有</strong><br />因此这里的层表征主要指代的就是<strong>低层</strong>和<strong>高层</strong>的,于ViT而言就是最开始的encoder block和最后一次的encoder block<br />之于CNN而言,我们知道,它卷积其实受限于相邻的区域,即使stride有所调整,也是局部的(于低层而言,<mark>我觉得高层也是,某一块kernel对应的是一只猫的耳朵或是尾巴,其实也是局部信息</mark>)<br />以下是ViT的低层和高层部分的学习到的信息的图(注意,这里的Mean Distance是一种用单个头的注意力权重,就是之前说的Z<sub>i</sub>(i∈[0,15])来加权pixel distance(<mark>我觉得是对应patch的dimension</mark>),然后做平均得到的结果.大距离说明是全局信息,小距离说明是局部信息)</p><p><img src="https://s2.loli.net/2023/11/03/bD5HhY2R1NnCeVE.png" alt="Local and Global information that ViT learned" /></p><p>显而易见,<strong>encoder block在低层时,学到的既有局部信息也有全局信息,而高层的encoder block学习到的都是全局信息</strong>(<mark>个人认为就是自注意力机制脱离了邻域关注的问题,使得低层次也可以学习到全局的信息</mark>)</p><p>当然,这只是说明ViT跟CNN学习方式不同,并非说局部信息不好的意思.论文里作者也用了没有pretrain的ViT,其效果很烂之余,也发现其压根没学到啥局部信息,反而印证了前期学习中局部信息的重要性,效果图如下:</p><p><img src="https://s2.loli.net/2023/11/03/FfwCltvQgaTmysd.png" alt="Local and Global information which no pretrained ViT learned" /></p><p>那么全局信息有啥用呢,作者通过对encoder block 1和2里面各自的16个head划分成多个子集,子集范围对应着[多数含局部信息的heads,多数含全局信息的heads],用这些子集和低层的ResNet计算CKA,得出下图:</p><p><img src="https://s2.loli.net/2023/11/03/2Cmqso1lvcZnSMw.png" alt="Local and Global ViTs Representations compared to ResNets" /></p><p>结果显而易见,随着全局信息增多(即平均距离增大),基本上二者CKA单调递减<br /><mark>作者其实没明确给出ViT中encoder block低层且head较小时学到的全局信息有啥用,但我觉得这个局部信息(基于Mean Distance这种度量方式)可能正是源于我们多头机制想要规避开的<strong>对于自身所在词的过度关注</strong>,而随着后面cocat成一个完整的Z与W<sup>O</sup>做乘积时,其局部性被削弱(这也跟Multi-Head Attention这个机制有关)</mark><br /><mark>而此刻输出值作为下一个encoder block的输入,其包含了较多的全局信息,这使得<strong>我们较低层与较高层构建出一定的相似性</strong>,当然这也与skip connection有关(其实这里说的就是skip connection)</mark></p><p>接着作者还对<strong>有效感受野(ERF)<strong>进行了分析,如下图示:<br /><img src="http://qny.ayyha.store/ViT%20and%20ResNet%20ERF.png" alt="ViT and ResNet ERF" /><br />我们知道,卷积的有效感受野受</strong>kernel大小</strong>以及<strong>下采样层</strong>影响,因此一开始很小;而自注意力机制使得ViT的有效感受野不受局部信息局限,还多了全局信息,因此有效感受野比较大;<br />而之后ResNet的ERF以局部扩增的方式增大(<strong>高度局部化</strong>),而ViT的ERF则是从局部转向全局,且高度依赖于中心的patch,这与skip connection有强烈关系!下图是pre-residual的感受野:</p><p><img src="https://s2.loli.net/2023/11/03/XNuAwY1DVLZMOC9.png" alt="Pre-residual receptive fields of all ViT-B/32 sublayers" /></p><p>可以看出上图(比较Attention12),可以看出残差连接制约着感受野对于中心patch的依赖性</p><h4 id="skip-connection在vit中发挥的作用"><a class="markdownIt-Anchor" href="#skip-connection在vit中发挥的作用"></a> skip connection在ViT中发挥的作用</h4><p>根据先前的ViT不同层级做CKA进行相似性比较的图,我们知道了它的表征具有<strong>高度一致性</strong>,这是由我们这里要讨论的skip connection 发挥的作用<br />我们通过范数比:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∥</mi><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">∥</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Vert z_i \Vert}{\Vert f(z_i)\Vert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>来进行探讨,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\Vert z_i \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span>是来自于skip connection的第i个层的hidden representation,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\Vert f(z_i) \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∥</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>经过long branch后的值,这里的long branch指的是MLP或是self-attention</p><p>至此,我们知道了,<strong>若是范数比比值大则意味着skip connection起主要作用,若是范数比比值小则意味着long branch起主要作用</strong></p><p>以下是根据范数比所作的heatmap,需注意CLS token和别的spatial token是分开来讨论的:</p><p><img src="https://s2.loli.net/2023/11/03/6XgPrMaVNExsBq7.png" alt="ratio of norms" /></p><p>根据左图,显而易见,CLS token(token[0])和别的spatial token的受影响方式恰好相反<br /><strong>CLS token是网络前期(Block index小的部分)范数比大,即受skip connection影响大,而网络后期则是受long branch影响大,spatial token则相反</strong></p><p>根据右图,除了彰显了上述结论,也可以看出<strong>ViT较ResNet受skip connection影响更大</strong></p><p>作者又做了个干预性实验来证明skip connection对ViT表征结构高度一致性的影响,即移除中间某一个block的skip connection,图示如下:</p><p><img src="https://s2.loli.net/2023/11/05/4FnBmsAk3qGCdiZ.png" alt="ViT remove a block's skip connection" /></p><p>可见,若是移除了某一个block的skip connection,那在该block前后的层的表征相似性则非常低.由此<strong>佐证了skip connection对ViT层间表征相似性的作用</strong>!</p><h4 id="vit在higher-layers的空间位置信息是否仍然保留"><a class="markdownIt-Anchor" href="#vit在higher-layers的空间位置信息是否仍然保留"></a> ViT在higher layers的空间位置信息是否仍然保留</h4><p>知道了前面ViT与ResNet的一些差别后,还想知道它的空间信息在较高的层是否仍然保留,这对transformer是否可以干除了图像分类之外的事很重要,如目标检测</p><p>我们通过对最后一个block的token与最开始输入的patch token进行比较(计算不同位置的CKA值),然后做heatmap,可以看出它们的相似性,即空间位置信息是否被high layers保留.图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/BK32qcVsveSCfu8.png" alt="spatial location of ViT &amp; ResNet" /></p><p>显然,ViT的空间位置信息被保留下来了,而且所选的单个token与最开始的对应的patch相似性最强,而边缘部分的token也是如此,但其与其他边缘位置相似性也很高.可以看出ViT对空间位置信息有保留!相较之下,ResNet则体现不出来,按作者的说法就是significantly weaker的位置信息</p><p>然后作者还对ResNet为啥会位置信息保留得如此薄弱进行了实验,认为是分类所采用的方法导致的,ViT采用的是一个单独的token-&gt;CLS token,对原位置信息本就不影响,而ResNet在训练时分类用的是全局平均池化(GAP),把信息都杂糅在一起了,哪里还有原来规整的位置信息</p><p>因此,就把ViT里面的CLS token去掉,通过GAP来做分类,结果说明了确实是GAP的原因,图示如下:</p><p><img src="https://s2.loli.net/2023/11/05/yIZtpWrUkqmFhPn.png" alt="ViT use GAP to classification" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transformer理解</title>
    <link href="/2022/10/02/transformer%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/02/transformer%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是attention注意力机制"><a class="markdownIt-Anchor" href="#什么是attention注意力机制"></a> 什么是Attention(注意力机制)</h2><p>在提起Attention之前,因其涉及到encoder-decoder的设计思想,因此先从RNN-&gt;Seq2Seq做一个简单介绍,以理解Attention为何如此设计</p><h3 id="rnn的一个例子"><a class="markdownIt-Anchor" href="#rnn的一个例子"></a> RNN的一个例子</h3><p>我们知道,RNN(循环神经网络),是可以帮助我们处理序列数据,如文本,语音</p><p>例如,我们需要订票,那么&quot;我去A地&quot;和&quot;我离开A地&quot;,这两个A地分别指代的是不同的信息,一个是目的地,一个是始发地.若是用传统的神经网络难以处理此类问题,而RNN则可以很好的进行分类</p><p>因为RNN对于处理文本信息时,每一个输入的词是<strong>自带了时序信息</strong>在里面的,而当前时刻的词,通过hidden layer,可以与前一时刻的词相关联(类似hidden markov model)</p><p>对输入的词进行编码,构建RNN,因为&quot;去&quot;和&quot;离开&quot;二词的编码信息不同,则最后计算出来的&quot;A地&quot;的得分也不同,因此便可以进行区分</p><p>这是一个<strong>N对N</strong>的例子,即<strong>输入序列的长度==输出序列的长度</strong><br />RNN亦可以实现<strong>1对N</strong> 或是 <strong>N对1</strong></p><p>那如果我们是做文本翻译或是QA系统,那么就会有<strong>N对M</strong>的情况,则需要用到Seq2Seq</p><h3 id="seq2seq的一个例子"><a class="markdownIt-Anchor" href="#seq2seq的一个例子"></a> Seq2Seq的一个例子</h3><p>上面说了,Seq2Seq可以处理<strong>N对M</strong>的情形,其结构又称为<strong>encoder-decoder</strong>模型</p><p>其本质就是利用了<strong>两个RNN</strong>(encoder和decoder都是)来做处理,decoder利用encoder生成的语义编码来做解码,有两种(我所知)使用形式:</p><ul><li>可以将语义编码作为decoder的初始状态</li><li><strong>可以将语义编码作为decoder每一个token的输入</strong></li></ul><p>很明显,若是将语义编码作为decoder每一个token输入的话(较前一个方法好),那么存在一个问题:所有待预测的token它们使用的都是一个语义编码,即没有针对性,没有做到focus each one</p><p>因此就有attention注意力机制的出现</p><h3 id="attention"><a class="markdownIt-Anchor" href="#attention"></a> Attention</h3><p>由上述可知,我们在对不同的词做翻译的时候,如&quot;机器学习&quot;-&gt;“machine learning”,并不是说&quot;机器&quot;,&quot;学习&quot;这两个词语对machine的翻译具有相同的贡献,因此不同贡献可以通过如权重的概念来进行体现</p><p>那么这个&quot;贡献&quot;要怎么获得,即不同词语的权重影响要怎么实现?</p><p>先将这个问题放一边(假设我们有能力做到这一点),那么我们<strong>不同的贡献就可以对应不同语义模型</strong>,那么&quot;注意力&quot;的思想即得到了体现</p><p>回到&quot;贡献&quot;获得的问题,attention中的&quot;贡献&quot;:是输入的时候通过计算encoder和decoder对应token的余弦相似度来获得,然后每一个词有不同的值,通过softmax进行归一化,那么这就是一个语义模型.流程见下图:</p><p><img src="https://s2.loli.net/2023/11/03/Y4GCVzv6H98lARM.png" alt="attention-multi-semantic-model" /></p><h2 id="什么是transformer"><a class="markdownIt-Anchor" href="#什么是transformer"></a> 什么是transformer</h2><p>transformer是一个NLP任务的一个里程碑模型(刷新了多项任务的SOTA),而后被人运用到CV,如DETR(Detection Transformer),ViT(Vision Transformer,做分类的)</p><p>其中ViT在数据量足够大的情况下,可以达到甚至超过当时的SOTA(ViT基本是直接将transformer直接搬到CV上用的,没咋改,除了切图片以使其序列化)</p><p>因此可以看出transformer在CV领域也是大有作为.下面将先以NLP的transformer的释义进行模型解释.</p><p>此外,transformer在NLP机器翻译中的一大特点是它可以并行处理(<mark>存疑:我认为只局限于training阶段</mark>),即对单词的翻译不必由一个去预测下一个</p><p>原论文链接:<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a></p><h3 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h3><p><img src="https://s2.loli.net/2023/11/03/c6zkRCEOosmIr3q.png" alt="transformerarch" /></p><p>由上图可见,我们的transformer整体也是分为encoder-decoder结构的</p><p>图中所示为encoder,即表明其内部由多个encoder block组成(原论文是6个),decoder也同理<br />(也是6个)</p><h3 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h3><p>在transformer中因其采用了注意力机制,因此导致了<strong>位置信息的缺失</strong>,而在机器翻译中,如一个not放置的位置若是不同,语句的意义也可能截然相反.因此我们需要对输入进行编码,以保持位置信息</p><p>我们要对输入进行<strong>词编码</strong>和<strong>位置编码</strong>,以获取输入语句的一个<strong>词的表示向量x</strong>,而后这些词的表示向量堆叠可以获得<strong>词的表示矩阵X</strong>,X∈R<sup>(nxd~model~)</sup></p><p>对于<strong>词编码</strong>,可以通过如Word2Vec等的方式获取<br />对于<strong>位置编码</strong>,transformer采用了正余弦函数来获取(位置编码:偶数位置用正弦,奇数位置用余弦)</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><mi>d</mi></mfrac></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PE_{(pos,2i)} = \sin(\frac{pos}{10000^{\frac{2i}{d}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94467em;vertical-align:-0.8371099999999999em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.16289em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9471099999999999em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8371099999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><mi>d</mi></mfrac></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PE_{(pos,2i+1)} = \cos(\frac{pos}{10000^{\frac{2i}{d}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94467em;vertical-align:-0.8371099999999999em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.16289em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9471099999999999em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8371099999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><div class="note note-info">            <p>pos:表示的是词在句子中的位置;<br />d:表示的是词编码后的维度,即词编码后的表示向量的列数;<br />2i:表示的是偶数维度;<br />2i+1:表示的是奇数维度</p>          </div><p>词编码和位置编码均完毕后,我们将其对应相加,即可以得到X的表示矩阵,过程图如下图示:</p><p><img src="https://s2.loli.net/2023/11/03/W9cUZEDxPKHF78f.png" alt="transformer-input-embedding" /></p><h3 id="self-attention"><a class="markdownIt-Anchor" href="#self-attention"></a> self-attention</h3><p>self-attention是attention中的一个特例<br />我们知道attention是找两个句子间的词间关系,而<strong>self-attention找的是一个句子间的词间关系</strong>(也可以理解为两个相同的句子)</p><p>从transformer_arch的图可以看出<strong>Multi-Head Attention</strong>在整个过程中起了极大作用,是核心模型,图中的Multi-Head Attention,其实里面就是由多个self-attention组成(论文里是8个)</p><p>因此我们需要关注self-attention的工作机制</p><p>self-attention的工作过程如下图所示:</p><p><img src="https://s2.loli.net/2023/11/03/hPi9aRNoU7M8evF.png" alt="self-attention-process" /></p><p>可以看出,它有三个输入Q,K,V,分别代表的是Query,Key,Value,然后需要经过MatMul(矩阵相乘),Scale(数值放缩),Mask(掩码,Output时需要),Softmax(归一化)这些个过程.</p><h4 id="获取qkv"><a class="markdownIt-Anchor" href="#获取qkv"></a> 获取Q,K,V</h4><p>首先,输入到encoder里的是我们上面获得的<strong>表示矩阵X</strong></p><p>X通过与对应权重(一开始是随机生成的,后面梯度下降更新的)的矩阵:W<sub>Q</sub>,W<sub>K</sub>,W<sub>V</sub>相乘,获取到对应的Q,K,V三个矩阵,其中它们的维度为:n*d<sub>Q</sub>,n*d<sub>K</sub>,n*d<sub>V</sub>,<strong>n代表着一个句子中词的数目</strong>,<strong>每一个行向量,代表的是某一个词的Q或K或V的维度</strong></p><p>计算的示例图如下图所示:</p><p><img src="https://s2.loli.net/2023/11/03/eh7TqgkBXxdRFrt.png" alt="QKV-compute" /></p><h4 id="self-attention计算公式"><a class="markdownIt-Anchor" href="#self-attention计算公式"></a> self-attention计算公式</h4><p>根据上面的方法获取了Q,K,V三者的矩阵后,可以对其进行self-attention-process图示的计算,公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>Q与K<sup>T</sup>相乘,得到的是n*n的矩阵(d<sub>K</sub>==d<sub>Q</sub>),那么这个矩阵的<strong>每一行代表的是该词语与别的词语的关注强度(相关性)</strong>,然后为了防止内积过大(不利于梯度更新),则进行放缩,而后通过softmax以使得<strong>词语与词语间的关注强度更为明显</strong>,而后再乘于V,则得到最终的输出Z(n*d<sub>V</sub>)</p><p>从逻辑上思考,Q与K<sup>T</sup>乘积后得到的矩阵,存在着一个问题,即<strong>模型会过度关注自身的位置</strong>,则整体模型的效果会大打折扣,因此作者提出了<strong>Multi-Head Attention</strong>机制来应对这个问题</p><div class="note note-info">            <p>我认为Q,K,V三者的关系可以这么理解(知乎看的):<br />我们要在一个dict上查单词,那么单词肯定是K对应V,若是在dict中刚好有Q==K,则可以立刻找到对应的V;但是现在的情况是,我们的词变成了词向量,则要通过其Q和K相关洗漱,再与V做内积,来找到最有可能的V</p>          </div><h4 id="multi-head-attention"><a class="markdownIt-Anchor" href="#multi-head-attention"></a> Multi-Head Attention</h4><p>self-attention机制存在一个问题,<strong>模型在对当前位置信息进行编码时,会过度的将注意力集中于自身的位置</strong>,那么这样出来的模型就会忽略了其他位置的作用.因此作者提出了Multi-Head Attention机制.<br />在原论文中作者运用了8个头,即h=8.用其去对Q,K,V三者的维度进行划分,即</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>K</mi></msub><mo>=</mo><msub><mi>d</mi><mi>V</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">d_K = d_V = \frac{d_{model}}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由上述公式可以看出,我们的d<sub>K</sub>是经过划分的,若不划分,那么即是在h=1的情况下,d<sub>K</sub>= d<sub>V</sub> = d<sub>model</sub>,则经过Scaled Dot-Production Attention后的Z,其主对角线的值总是最大的(就是过于关注自身的问题),因此,通过多头机制,对Q,K,V的列的维度进行划分,以减弱这种影响!公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub><mo stretchy="false">)</mo><msup><mi>W</mi><mi>O</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mspace width="1em"/><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo separator="true">,</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><mo separator="true">,</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}MultiHead(Q,K,V) &amp;= Concat(head_1,\cdots,head_h)W^O \\where \quad head_i &amp;= Attention(QW_i^Q,KW_i^K,VW_i^V)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.17057em;vertical-align:-1.335285em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.835285em;"><span style="top:-3.943954em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span><span style="top:-2.3247150000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.335285em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.835285em;"><span style="top:-3.943954em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3247150000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9592389999999998em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.335285em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>我们划分将Q,K,V划分成八个(8个h),对它们可以并行做计算,然后最后会得到八个Z<sub>i</sub>(i∈[0,7]),对它们进行concat(合并后的维度与X一致),然后与W<sup>O</sup>矩阵进行相乘即得出对应输出,输出矩阵维度与表示矩阵维度X一致</p><p>具体过程见下图:</p><p><img src="https://s2.loli.net/2023/11/03/CNwkVviS9M3f54b.png" alt="multi-head attention" /></p><p><img src="https://s2.loli.net/2023/11/03/Hg5qPCadnrZtk3x.png" alt="output of multi-head attention" /></p><p>至此,多头注意力机制介绍完毕</p><h3 id="encoder-block"><a class="markdownIt-Anchor" href="#encoder-block"></a> encoder block</h3><p>我们知道,一个encoder block里面,经过了Multi-Head Attention的洗礼后,要经过一个<strong>Add &amp; Norm</strong>的东东,而后再将输出经过Feed Forward NN,便完成了一个encoder的工作</p><h4 id="add-norm"><a class="markdownIt-Anchor" href="#add-norm"></a> Add &amp; Norm</h4><p>其实Add就是ResNet的<strong>shortcut connection</strong>,以防止gradient vanish或者说network degradation;</p><p>然后Norm其实指的就是Layer Normalization,一个归一化的东东(<mark>这是用于RNN里的,与BN不同,是针对每个样本进行的</mark>),用于加快收敛(总之就是加快训练速度)</p><h4 id="feed-forward"><a class="markdownIt-Anchor" href="#feed-forward"></a> Feed Forward</h4><p>是一个两层的全连接层,公式如下(<mark>这个没细看</mark>):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>X</mi><msub><mi>W</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>W</mi><mn>2</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">max(0,XW_1 + b_1)W_2 + b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>最后输出的维度与X表示矩阵的一致</p><h3 id="encoder"><a class="markdownIt-Anchor" href="#encoder"></a> Encoder</h3><p>Encoder就是将多个encoder block线性连接了起来,前者的输出作为后者的输入,重复六次,则得出最终的输出<strong>编码信息矩阵</strong>,其维度与X的一致<br />过程见图所示:</p><p><img src="https://s2.loli.net/2023/11/03/eLsR5rCEuwxdX9a.png" alt="encoders-process" /></p><h3 id="decoder-block"><a class="markdownIt-Anchor" href="#decoder-block"></a> decoder block</h3><p>decoder block相较于encoder block,它有如下差别:</p><ul><li>首个Multi-Head Attention有Masked掩码操作;</li><li>第二个多头注意力机制,K,V源于encoder的输出的编码信息矩阵,Q则是源于上一个含掩码的输出;</li></ul><h4 id="关于masked-multi-head-attention"><a class="markdownIt-Anchor" href="#关于masked-multi-head-attention"></a> 关于Masked Multi-Head Attention</h4><p>所谓的Masked指的是:翻译的时候是顺推的,即翻译出了第i个单词后,才会进行第i+1个单词的翻译,那么在翻译第i个单词的时候,就需要将第i+1个单词及之后的信息进行遮掩</p><p>需注意:</p><ul><li>在training阶段时,我们采用的是teacher force的策略,就是在每一轮(i)的预测的时候,不采用上一轮(i-1)的输出,而是直接采用正确答案,因为是训练,所以有答案,所以可以做并行;</li><li>在predict阶段,没有答案,需要类似Seq2Seq的方法,即i轮预测需要i-1轮的输出,无法并行.循环往复,直至预测完毕</li></ul><p><strong>Mask操作,是在self-attention里的softmax前执行的</strong></p><h4 id="关于第二个multi-head-attention"><a class="markdownIt-Anchor" href="#关于第二个multi-head-attention"></a> 关于第二个Multi-Head Attention</h4><p>这个其实和普通的差不多,就是K,V来自于encoder的编码信息矩阵</p><h4 id="softmax预测"><a class="markdownIt-Anchor" href="#softmax预测"></a> softmax预测</h4><p>根据最后输出的结果,我们的矩阵是含有掩码的,那么就是说:第0行的输出,只包含词0的信息,第二行,则包括词0,词1的信息.<br />因此softmax是根据输出矩阵的每一行预测下一个单词.</p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>transformer</tag>
      
      <tag>attention</tag>
      
      <tag>nlp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NUMA</title>
    <link href="/2022/09/29/NUMA/"/>
    <url>/2022/09/29/NUMA/</url>
    
    <content type="html"><![CDATA[<h2 id="smp和amp对比"><a class="markdownIt-Anchor" href="#smp和amp对比"></a> SMP和AMP对比</h2><p>SMP(Symmetric MultiProcessing):对称多处理器架构<br />AMP(Asymmetric MultiProcessing):非对称处理其架构</p><p>二者区别:</p><ul><li>SMP里的多处理器是<strong>同构</strong>的,使用的是相同架构的CPU;AMP的多个处理器可能是<strong>异构</strong>的;</li><li>SMP多个处理器<strong>共享同一内存地址空间</strong>;AMP则每个处理器有各自<strong>独立的地址空间</strong>;</li><li>SMP多处理器可以通过<strong>共享内存</strong>来<strong>协同通信</strong>;AMP则需要提供一种处理器间通信机制</li></ul><p><strong>现今主流X86架构的多处理器的电脑都是SMP架构,然后AMP架构多是应用于嵌入式系统</strong></p><h2 id="numa和uma对比"><a class="markdownIt-Anchor" href="#numa和uma对比"></a> NUMA和UMA对比</h2><p>NUMA(Non-Uniform Memory Access):非统一内存访问<br />UMA(Uniform Memory Access):统一内存访问</p><p>NUMA和UMA所指代的<strong>统一</strong>是<strong>处理器访问内存的访问时间是否依赖于二者相对位置</strong></p><p><strong>NUMA和UMA是SMP架构的一种设计和实现的不同选择</strong></p><div class="note note-info">            <p>摘自Wiki:<br />NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures.</p>          </div><p>先说一下UMA架构,就是CPU对内存的访问不依赖于其二者的相对位置关系,因为CPU访存是通过内存控制器(Memory Controller)来的,内存控制器被北桥芯片集成,因此是以<strong>多个CPU-北桥芯片-内存</strong>这样的方式链接的.</p><p>各个CPU是通过FSB(Front Side Bus)前端总线与北桥相连.</p><p><img src="https://s2.loli.net/2023/11/03/Slw8MEfXQqrstT1.png" alt="CPU-North Bridge-Memory" /></p><p>由上图可以看出来,总线模型保证了CPU对所有内存的访问都是一致的,不必考虑相对位置带来时间差异</p><p>这种架构适合用于如服务器(网站,数据库)一类的机子上,因为这类工作都是外部请求访问时,服务器创建线程, 随机访存,然后线程处理的时间很短.</p><p>但随着业务的扩展,会遇到需要很大运算量的应用,那么此刻若是有一个更接近于CPU的本地内存,可以提升速度,而且这样大运算量的应用,或者说线程,不止一个(则需要多个CPU,或者多个核心),那么UMA就不适应于这样的工作,而且FSB会成为其bottleneck(加核心没用),因此有了NUMA的出现</p><p>在NUMA架构中,其将<strong>多个核心作为一个节点(Node)(如一颗多核的CPU)</strong>,<strong>内存控制器芯片(MCH)集成在Node内</strong>,<strong>每一个Node独立连接一部分内存</strong>,此直连的内存称为**“本地内存”**,Node间通过QPI(Quick Path Interconnect)总线连接.因此可以访问&quot;远程内存&quot;.</p><p>由此可以见到内存访问存在本地和远程的区别!</p><p><img src="https://s2.loli.net/2023/11/03/exDGdRYnWiLMpF8.png" alt="NUMA" /></p><p>在Linux机器下,可以通过numactl指令进行查看</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memory Access</tag>
      
      <tag>CPU</tag>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux namespace</title>
    <link href="/2022/09/22/namespace/"/>
    <url>/2022/09/22/namespace/</url>
    
    <content type="html"><![CDATA[<h2 id="namespace常用类型"><a class="markdownIt-Anchor" href="#namespace常用类型"></a> Namespace常用类型</h2><h3 id="pid-namespace"><a class="markdownIt-Anchor" href="#pid-namespace"></a> pid namespace</h3><p>Linux内核维护着一个进程树，Linux中的进程关系通过此树来反映。而在pid namespace引入后，可以认为Linux内依旧是维护着一个进程树，但是其节点既可以是进程也可以是进程树，即此时进程树允许树的嵌套关系。而不同的进程树则使得其内部的进程组互相隔离，它们并不清楚彼此的存在。见下图</p><p><img src="https://s2.loli.net/2023/11/03/eYXaIt2dvu9WMG1.png" alt="nested-process-tree" /></p><p>在不考虑新的pid namespace的情况下，我们所有进程都属于同一个命名空间init_pid_ns，整个进程树都是由作为根的1号进程派生而来的。而当我们创建新的pid namespace时，则会创立出一个新的独立的进程空间。它是我们在创建子进程时可以设置的一个选项，使得新创建出来的子进程在新的pid namespace中，并且成为该命名空间的1号进程。</p><p>显然，利用pid namespace做隔离，子命名空间里的进程认为自己是一棵独立的进程树，完全不知到是父命名空间的存在。但是父命名空间（即init_pid_ns）却拥有着整个进程树的真正完整的视图，因为在引入pid namespace的概念后，pid的含义也变得复杂了，加入了层级level的概念，高层级的进程可以被低层级看见，即init_pid_ns这个进程空间的层级是最低的，为0，而新的进程命名空间随着嵌套情况逐次增加层级。就像图一所示，6号进程的子进程是8号进程（需要被level0的看见），但是由于其派生时设置标志位CLONE_NEWPID，使得8号进程与原先的进程树分离，自己作为新进程命名空间里的1号进程，此时该进程便拥有两个pid，一个是level1的1号进程，而另一个则为level0的8号进程。因此此时的pid结构也发生了相应的变化，见下图</p><p><img src="https://s2.loli.net/2023/11/03/eVCkPrU9KhXzRJ8.png" alt="structure-of-upid-pid" /></p><p>通过引入pid namespace，一个进程现在可以有多个与之关联的pid，每个pid通过level即层级来进行划分，然后利用变长数组numbers可以检索到对应的upid，而upid里的nr即为此命名空间里的pid的值。</p><p>上文中说过，要创建一个新的pid namespace，除了需要利用特殊的标志位注明外，对于pid namespace而言，只能通过clone()这一系统调用进行新的进程命名空间的创建。示例程序如<code>create-new-pidns</code>所示，其输出结果如<code>pid-of-new-pidns</code>所示：</p><p><img src="https://s2.loli.net/2023/11/03/l8ixOqpUKwy5mET.png" alt="create-new-pidns" /></p><p><img src="https://s2.loli.net/2023/11/03/geJ1md4GkvD5W6n.png" alt="pid-of-new-pidns" /></p><p>通过图3图4的示例程序及相应的输出结果，不难看出在clone()后的子进程在新的进程命名空间里，它认为自己是1号进程，打印出其父进程，则为0，即意味着该进程本身是这个进程树的init进程。</p><p>在此时，我们的进程只是隔离了进程空间，即在不同的进程空间下我们所打印出来的进程表都是不同的，但实质上如端口号这一类的资源还是会产生冲突。</p><h3 id="network-namespace"><a class="markdownIt-Anchor" href="#network-namespace"></a> network namespace</h3><p>网络命名空间的作用是隔离网络协议栈，即解决了上述所说的端口号资源冲突问题。除了对端口资源进行隔离外，也对网络设备、ARP表、路由表、iptables以及套接字等资源进行隔离，即构建出一套独立的网络协议栈供新的网络命名空间所用。</p><p>在这一部分就简单的对网络设备的隔离进行讲解，后续一部分会专门对network namespace进行详细的分析。</p><p>若是我们在clone()时增添标志位CLONE_NEWNET，则会使得我们的子进程处于一个新的网络命名空间中，与原命名空间相比，二者的网络设备完全不同，即原来主机上的以太网卡和环回设备在新的命名空间中消失了，取而代之的是一个与原来不同的新的环回设备。也即说明网络命名空间对网络设备一级也做了隔离。示例程序见<code>create-new-netns</code>，其输出结果见<code>difference-of-netns-device</code>：</p><p><img src="https://s2.loli.net/2023/11/03/DL8ZAJS93Xr5dg6.png" alt="create-new-netns" /></p><p><img src="https://s2.loli.net/2023/11/03/SD4eO79lZNojUry.png" alt="difference-of-netns-device" /></p><p>可以看出此主机上的的以太网卡eth0和其环回设备与新的network namespace的并不相同（环回设备状态不同）。因此在网络设备级别做了隔离。</p><p>此时，不同的网络命名空间就相互隔离开来，若是想让多个不同的网络命名空间进行通信，则可以通过虚拟网卡、虚拟网桥来实现，甚至还可以通过主机的以太网卡接受外界的数据包而后通过路由进程路由到对应的子网络命名空间（这里的子对应的是初始的网络命名空间）。见下图：</p><p><img src="https://s2.loli.net/2023/11/03/XKnbAzC7DkGY8US.png" alt="netns-usage" /></p><h3 id="uts-namespace"><a class="markdownIt-Anchor" href="#uts-namespace"></a> uts namespace</h3><p>uts namespace隔离的是utsname这个结构体的domainname和nodename，前者指待的是域名，后者在单服务器上等价于主机名。之所以取名为uts（UNIX Time-Sharing System），是与早期的UNIX分时系统有关，但在现在的namespace中，它只负责隔离主机名和域名。通过标识主机名，有利于我们在一些IP地址动态变化的情况下的操作，即只需要知道IP和这个主机名关联关系即可，无需关心IP的变化。因此uts namespace对于大型容器化的环境非常有帮助。以下是关于uts namespace更改主机名的实验，示例代码如下图<code>modify-new-utsns-hostname</code>所示，结果输出如图<code>hostname-of-diffrent-utsns</code>所示：</p><p><img src="https://s2.loli.net/2023/11/03/LzJpK5UcX6GHNvn.png" alt="modify-new-utsns-hostname" /></p><p><img src="https://s2.loli.net/2023/11/03/LRoMPpmQw9OhxGJ.png" alt="hostname-of-diffrent-utsns" /></p><p>通过上述结果，可以看出uts namespace对主机名的隔离作用，在新的uts namespace中对主机名的修改并不影响另一uts命名空间的主机名。</p><h3 id="mount-namespace"><a class="markdownIt-Anchor" href="#mount-namespace"></a> mount namespace</h3><p>mount namespace用于隔离挂载点，以使得不同的命名空间中的进程不能查看到彼此的文件。</p><p>创建单独的mount namespace效果类似于chroot(改变程序执行时的参考的根目录)，但chroot并不能提供完全的隔离。chroot变更文件的根挂载点示例如下图所示</p><p><img src="https://s2.loli.net/2023/11/03/caMFWXDB6CjKvTP.png" alt="chroot-modify-root-mount-point" /></p><p>在一个新的mount namespace中，子进程会看到和原来的父进程完全相同的挂载点，但此时我们可以在新的挂载命名空间中利用mount或umount来进行挂载或卸下对应的挂载点，这并不会对原来的父进程的挂载点有任何改变，只是对这个命名空间里的挂载点有变化。</p><h3 id="ipc-namespace"><a class="markdownIt-Anchor" href="#ipc-namespace"></a> ipc namespace</h3><p>ipc namespace可以对命名空间内的进程间通信资源进行隔离，这里隔离的是每个命名空间所属的消息队列、信号量以及共享内存，并没有对所有的通信方式都进行隔离。</p><p>以共享内存进行通信为例，我们的同一ipc namespace里的进程组可以通过共享内存来快速知道一些共享的公共参数的变化，而此时若不进行隔离，则会产生安全性问题。</p><h3 id="user-namespace"><a class="markdownIt-Anchor" href="#user-namespace"></a> user namespace</h3><p>user namespace主要是用来隔离用户权限的。它是namespace中最核心也最复杂的，Linux内核对其进行了最长时间的开发。其涉及到权限和安全问题。其包括uid/gid以及capabilities的两大部分的内容。user namespace通过对权限以及uid/gid的控制，使得即使在新的user namespace里是root的用户，当它试图去篡改原来的user namespace里的如主机名一类的别的namespace，它是否具备权限是看它原来在该user namespace是否有相应的修改权限，这也正是为什么每一个非user namespace的命名空间，在它们结构体定义里，都需要指向一个用户命名空间的意义所在。通过user namespace这个命名空间的利用，可以很好的避免了一些越权的行为发生。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>namespace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析与设计</title>
    <link href="/2022/08/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/08/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="调度问题"><a class="markdownIt-Anchor" href="#调度问题"></a> 调度问题</h2><p>问题:有n项任务,每项任务加工时间已知.从0时刻开始陆续安排到一台机器上加工.每个任务的完成时间是从0时刻到任务加工截止的时间.<br />求:总完成时间最短的方案</p><p>问题建模:</p><ul><li>输入:任务集:S={1,2,…,n} 第j项任务加工时间:tj∈Z+,j=1,2,…,n.</li></ul><p>  贪心算法:<br />设计策略:<strong>加工时间短的先做</strong><br />算法:根据加工时间从小到大排序,依次加工<br />算法正确性:对所有输入实例都得到最优解</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN</title>
    <link href="/2022/08/24/CNN/"/>
    <url>/2022/08/24/CNN/</url>
    
    <content type="html"><![CDATA[<h2 id="cnn模型的理解"><a class="markdownIt-Anchor" href="#cnn模型的理解"></a> CNN模型的理解</h2><p>  CNN全名为Convolutional Neural Network卷积神经网络.它有以下几个部分组成:</p><ul><li><strong>卷积层</strong></li><li><strong>激活函数</strong></li><li><strong>池化层</strong></li><li><strong>全连接</strong></li></ul><h3 id="卷积层"><a class="markdownIt-Anchor" href="#卷积层"></a> 卷积层</h3><p>卷积层是用来识别图像的特征,它是通过卷积核(kernel,filter,neuron)来寻找图像的特征.<br />图片输入进来的时候,机器会将其的分辨率及其通道转换为数组,如32*32*3,然后根据训练好的多个卷积核如5*5*3(Height,Width,Depth)对其进行特征寻找.需要注意的是kernel的depth需要与输入的depth一致.然后便输出一张激活图(此例卷积步长为1,激活图大小为28*28*n(kernel数量)).激活图(activation map/feature map)之后会作为下一层的输入</p><h3 id="激活函数"><a class="markdownIt-Anchor" href="#激活函数"></a> 激活函数</h3><p>激活函数(activation function)是用于<strong>完成数据的非线性变换</strong>,解决线性模型的表达、分类能力不足的问题.根据网上所说,若是在net中全是线性变换,则可以通过矩阵变换将所谓的多层网络转换成一层网络.因此需要通过激活函数使得网络的多层有意义,故需要对数据进行非线性变换<br />常用的激活函数有:</p><ul><li>ReLU</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo separator="true">,</mo><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">y=\begin{cases}0,\quad &amp;x\lt0 \\ x,\quad &amp;x\ge0 \end{cases} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>Sigmoid</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{ 1 }{ 1+e^{ -x } } </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>tanh</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{e^x - e^{-x}}{e^x+ e^{-x}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>根据AlexNet的文章我们可以知道,ReLU相较于传统的激活函数可以提高训练速度,减缓梯度衰减的趋势,同时省去了归一化的开销.</p><h3 id="池化层"><a class="markdownIt-Anchor" href="#池化层"></a> 池化层</h3><p>池化层降低了输入的激活图的维度,对其进行了稀疏处理,减少了数据运算量,也缓解了卷积层对位置的过渡敏感性.池化层也是通过kernel来进行维度处理.<br />池化通常有两种方式:</p><ul><li>最大池化</li><li>平均池化<br />根据名字可以看出,一个是取kernel里最大的值作为输出的激活图的新位置的值,一个是取平均.一般的池化都是stride==kernel的尺寸</li></ul><h3 id="全连接层"><a class="markdownIt-Anchor" href="#全连接层"></a> 全连接层</h3><p>如图像分类,我们最后期望的结果是可能是识别类别的总数的概率,即输出一个N维向量,里面的值代表每一个识别类别的概率,然后进行输出.(此例采用的是softmax此激活函数)</p><h3 id="针对过拟合问题"><a class="markdownIt-Anchor" href="#针对过拟合问题"></a> 针对<strong>过拟合</strong>问题:</h3><p>在网络中,我们若是模型参数多,但是样本又少,那么训练出来的模型就会存在过拟合的问题,即在train的时候模型精确率还可以,但是test和inference就惨不忍睹,那就是因为模型中的参数权重等被量身定做了.<br />对于过拟合问题,可以采用Dropout以使得过拟合问题得到一定解决.<br />Dropout的主要原理就是根据Bernoulli原理生成概率向量[1,0,…,1],然后与输入序列相乘,之后进行forward propagation,backpropagation,这样就相当于集成算法中的Bagging一样,生成了多个子网络,那么多个子网络的平均表达结果就可以规避掉过度耦合的关系.<br />Dropout有两种版本:</p><ul><li>Vanilla Dropout</li><li>Inverted Dropout<br />两者的区别在于<strong>放缩</strong>的顺序,一个是在inference的时候进行放缩,一个是在train的时候放缩.后者相较于前者的优势在于不必在predict的时候频繁调整结果(要放缩).<br />Inverted版本需要在输入序列与概率序列相乘后进行放缩,设p为丢弃概率,则需对相乘后的序列乘上 $ \frac{1}{1-p} $ ,而这个放缩后的序列也会体现在反向传播的梯度中.<br />之所以要进行放缩,是因为此刻我丢弃了p%的数据,那么整体的规模缩小了(1-p)%,则需要放大 $ \frac{1}{1-p} $ 倍.</li></ul><h3 id="一些名词解释"><a class="markdownIt-Anchor" href="#一些名词解释"></a> 一些名词解释</h3><ul><li>SGD stochastic gradient descent 随机梯度下降:GD的话需要计算所有向量以计算梯度值,随机取的话可以减少计算量,但存在陷入局部最优的可能</li><li>top1 error rate:top1错误率,即分类问题中<strong>正确标签</strong>不是<strong>最佳概率</strong>的总数/样本总数</li><li>top5 error rate:top5错误率,即分类问题中<strong>正确标签</strong>不是<strong>前五个较大概率的可能结果</strong>的总数/样本总数</li></ul><p><mark>以下论文还没看完</mark></p><h2 id="pose-guided-feature-disentangling-for-occluded-person-re-identification-based-on-transformer"><a class="markdownIt-Anchor" href="#pose-guided-feature-disentangling-for-occluded-person-re-identification-based-on-transformer"></a> Pose-guided Feature Disentangling for Occluded Person Re-identification Based on Transformer</h2><p>  本文名词解释:</p><ul><li>ViT(Vision Transformer 用于抽取小片特征的视觉Transformer)</li><li>PFD(Pose-guided Feature Disentangling 姿态引导的特征分离)</li><li>Re-ID(Re-identification 再识别)</li><li>PFA(Pose-guided Feature Aggregation 姿态引导的特征聚合[含匹配和分配机制])</li><li>PVM(Pose-View Matching 姿态视图匹配 匹配身体的可见部分,把遮挡的部分分离)</li><li>Post-guided Push Loss 特征值,用于强调身体的可见部分</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringDataJPA学习</title>
    <link href="/2022/03/01/SpringDataJPA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/01/SpringDataJPA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>JPA</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM的理解</title>
    <link href="/2022/02/28/ORM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/02/28/ORM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>  ORM -&gt; Object Relational Mapping 对象关系映射。这个技术的出现主要是为了解决：面向对象模型和数据库的关系模型的不匹配问题。<br />  ORM是通过使用描述对象和数据库之间映射的元数据（XML或注解），来将对象持久化到数据库的操作，或是将数据库中某张表的某行数据映射成为我们的一个对象。<strong>本质是数据形式的转化</strong>。<br />  常见的ORM技术的实现有：hibernate、mybatis、JPA</p>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PO、VO、DTO等对象的理解</title>
    <link href="/2022/02/26/PO%E3%80%81VO%E3%80%81DTO%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/02/26/PO%E3%80%81VO%E3%80%81DTO%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="po"><a class="markdownIt-Anchor" href="#po"></a> PO</h2><p>  PO -&gt; Persistence Object 持久化对象，即一个持久化对象可以理解为数据库一张表中的记录，即它所包含的<strong>属性对应表中字段</strong></p><h2 id="vo"><a class="markdownIt-Anchor" href="#vo"></a> VO</h2><p>  VO -&gt; Value Object 值对象，一般指一些不会变化的值作为属性来存储；<br />  VO -&gt; View Object 表现层/UI层的对象，即它里面所对应的属性的数据是用于界面展示的数据</p><h2 id="dto"><a class="markdownIt-Anchor" href="#dto"></a> DTO</h2><p>  DTO -&gt; Data Transfer Object 数据传输对象，将客户端请求的数据通过网络传输给它，它相较于PO的区别在于：我们存到数据库的数据的字段可能有20个，但我们客户端需要的只是5个，我们只需要将这5个对象传输给客户端即可，即<strong>不会暴露我们的表结构</strong>，也可以<strong>提高传输效率</strong>。将与客户端进行数据交互的功能交由DTO处理。<br />  当然DTO对象到客户端后，若是用于界面展示，则它转化为VO。</p><h2 id="pojo"><a class="markdownIt-Anchor" href="#pojo"></a> POJO</h2><p>  POJO -&gt; Plain Ordinary Java Object 简单的Java对象，可以根据具体的使用场景转化为PO、VO、DTO</p><h2 id="dao"><a class="markdownIt-Anchor" href="#dao"></a> DAO</h2><p>  DAO -&gt; Data Access Object 数据访问对象。封装了对于数据库的CRUD操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础知识</title>
    <link href="/2022/02/24/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/02/24/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="resource和autowired"><a class="markdownIt-Anchor" href="#resource和autowired"></a> @Resource和@Autowired</h2><p>  二者都是提供从IOC容器中获取对应的实例进行注入。@Resource是由jdk提供，@Autowired是由Spring提供。其实二者都是通过byName或byType来进行匹配查询的。（@Autowired采用byType策略，@Resource采用byName策略）<br />  @Autowired在匹配到单一实现类时，则会将单一实现类进行注入；当匹配到多个实现类时，无法甄别，则需要用bean的名字进行甄别，就是变量名是否匹配某个实现类的小驼峰，若是符合则将该实现类进行注入，否则抛出错误。<br />  因此，若是在单一实现类时，直接使用@Autowired注入即可；若是有多个实现类时，可结合@Qualifier(“beanName”)注解来搭配使用，即@Qualifier注明某个实现类的小驼峰写法，则可以将对应的实例进行注入。<br />  @Resource则默认靠beanName来进行匹配，当然，若是变量名没匹配到实现类的小驼峰写法，若是只有单一实现类，则可以成功注入，否则会报错；@Resource也可以通过@Resource(name=“beanName”)来指定beanName实现注入，这个注解也可以通过指定type属性来实现注入。<br />  (参考博客)[<a href="https://blog.csdn.net/kevinxxw/article/details/105145397">https://blog.csdn.net/kevinxxw/article/details/105145397</a>]</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea使用遇到的小bug处理及指南</title>
    <link href="/2022/01/29/idea%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8Fbug%E5%A4%84%E7%90%86/"/>
    <url>/2022/01/29/idea%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8Fbug%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="模块创建缺少iml文件"><a class="markdownIt-Anchor" href="#模块创建缺少iml文件"></a> 模块创建缺少iml文件</h2><p>  iml全称为information of module，即模块信息文件。模块必有iml文件，若是没有，可以在terminal下移动到<strong>模块所在的路径</strong>下执行<code>mvn idea:module</code>指令以生成模块对应的iml文件。</p><h2 id="maven使用父模块pom进行依赖管理"><a class="markdownIt-Anchor" href="#maven使用父模块pom进行依赖管理"></a> maven使用父模块pom进行依赖管理</h2><p>  我们先利用Spring Initializer构建一个Spring Boot项目用作父模块来进行<strong>依赖管理</strong>，其中内部不写功能代码。<br />  子模块的pom通过使用以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  来将父模块pom中所含的依赖加入其中（但不包含dependencyManagement其内的内容），而父模块pom需要标明自己的打包方式为pom，且通过modules来管理子模块（如进行clear、package时可以通过父模块完成，而不是一个模块一个模块的去处理）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标明打包方式，默认jar包 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 标明所含子模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  上面说的dependencyManagement就是<strong>按需继承</strong>的意思，父模块pom内通过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependcyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  如上方式来添加依赖，并进行<strong>版本管理</strong>，之后子模块只需要自行通过如下方式<strong>按需添加</strong>就行，<strong>不必写版本号</strong>，版本号统一由父模块的pom进行管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  其实上面所说的是parent和modules分别属于maven继承和聚合的特性，更具体的解释可以网上搜索查看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础内容</title>
    <link href="/2022/01/04/JavaScript%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2022/01/04/JavaScript%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="js用途"><a class="markdownIt-Anchor" href="#js用途"></a> JS用途</h2><p>  之前了解的JS，只知道可以实现一些交互和动效，从服务器拿下数据等的作用，但基本上只能局限在浏览器内，除非自己搭个JS引擎在电脑上跑，不然也只能靠浏览器来跑。<br />  但在了解了一些关于Node.js的基础知识后发现，它提供了一个JS的运行环境，使得它可以在本地上跑，不局限于浏览器，可以像Java、python一样，写起后端来。（本文写的只是一些之前忘记了的JS知识，不涉及Node.js部分！！）</p><h2 id="js语法"><a class="markdownIt-Anchor" href="#js语法"></a> JS语法</h2><p>  其实JS大多数语法跟Java很像，语法逻辑上基本上是一样的，以下只对不同的部分进行阐述。</p><h3 id="js数据类型"><a class="markdownIt-Anchor" href="#js数据类型"></a> JS数据类型</h3><p>  JS的数据类型分为：<strong>基本数据类型 + 引用类型</strong><br />  基本数据类型:</p><ul><li>Number<br />就是把整型和浮点数放一起了，还有NaN和Infinity这些特殊值</li><li>String<br />字符串</li><li>Boolean<br />就true|false</li><li>Null<br />指向空指针</li><li>Undefined<br />JS是弱类型语言，就一个var定义所有的变量（ES6可以用let和const定义局部变量），初值都是undefined</li><li>Symbol<br />ES6新加的，用了symbol方法的变量后是此类型，意味unique独一无二</li></ul><p>  引用类型：</p><ul><li>Object<br />就是对象，可以new Object(),一个个加，也可以{}直接写（就是JSON格式里的object）</li><li>Array<br />数组，可以new Array(),里面可以写array‘s length，也可以写数组的内容，当然也可以如[‘a’,123,1.23]这样写，毕竟JSON就是JS的标记法。它这个数组内容是支持任意类型。</li><li>Function<br />函数/方法。通过<code>function funcName(param1,...)&#123;...&#125;</code>这样定义，也可以是匿名函数，然后将函数指针交予一个变量，如<code>var f = function(param1,...)&#123;&#125;;</code>。</li></ul><h3 id="js事件处理"><a class="markdownIt-Anchor" href="#js事件处理"></a> JS事件处理</h3><p>  事件指的是<strong>用户和网页进行某一种交互</strong>，事件处理就是事件发生时该执行的操作。<br />  我们可以使用事件监听器用来处理事件，事件监听器主要的作用就是：<strong>监听事件，当事件发生做出操作。</strong><br />  JS有提供很多的事件，如鼠标、键盘、窗口事件等，我们可以通过JS来将具体的事件（HTML元素属性）和事件发生后的操作（就是自己写函数）进行绑定，从而形成事件监听器。</p><ul><li>在HTML元素里指明attribute<br />如<code>&lt;button id=&quot;myBtn&quot; onclick=&quot;btn()&quot;&gt;&lt;/button&gt;</code>，这里的事件的attribute即使onclick绑定了JS里写的方法btn();</li><li>在JS里绑定<br />如</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascipt">function btn()&#123;<br>alert(&quot;event of click&quot;);<br>&#125;<br>document.getElementById(&quot;myBtn&quot;).onclick=btn;<br></code></pre></td></tr></table></figure><h3 id="js一些别的知识"><a class="markdownIt-Anchor" href="#js一些别的知识"></a> JS一些别的知识</h3><p>  DOM(Document Object Model)文档对象模型，浏览器加载的时候会构建一个DOM，这个东西是树结构。<br />  DOM树的节点分为：</p><ul><li>元素/标签节点（即每一个标签均为一个标签节点/元素节点，是最主要的应用。type为1）；</li><li>属性节点（是<strong>元素节点的内容</strong>，可通过<code>getAttributeNode()</code>获得，也可以在JS自己<code>setAttributeNode()</code>进去，type为2）；</li><li>文本节点（就是不含于标签的文本，type为3）；</li><li>文档节点（是后面所述的document，根节点，type为9）；<br />  在DOM树中，<strong>Document是根节点</strong>（document对象），其余的节点是<strong>标签节点</strong>和<strong>文本节点（不含于标签内）</strong>，这些个节点被称为<strong>Element</strong>对象，可以通过document对象的getElementById()等方法获得（这里及下面谈论的都是元素/标签节点）。<br />  而Element对象可以帮助我们set/get标签的<strong>属性（attributes）<strong>或是</strong>内容(innerHTML/innerText)</strong>;</li></ul><div class="note note-info">            <p>  Element对象带有nodeName、nodeValue、nodeType等属性，可以让我们区分是哪一种类型的节点。<br />  如上述所说的文本节点，一般都是通过Element对象的<code>childNodes()</code>获得。</p>          </div><p>  BOM(Browser Object Model)浏览器对象模型，使得JS和浏览器具有交互能力。BOM核心对象是window，表示当前浏览器的窗口，我们所有的全局对象都是window的属性，document对象也是。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="redis安装"><a class="markdownIt-Anchor" href="#redis安装"></a> redis安装</h2><ol><li>wget URL</li><li>tar xzf packageName</li><li>在有makefile文件下make(可以通过make install prefix=/usr/local/redis自定义安装的位置)</li></ol><h2 id="redis文件含义"><a class="markdownIt-Anchor" href="#redis文件含义"></a> redis文件含义</h2><p>安装完redis后，它会产生一系列文件，对应的文件解释如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">./redis-benchmark //用于进行redis性能测试的工具<br>./redis-check-dump //用于修复出问题的dump.rdb文件<br>./redis-cli //redis的客户端<br>./redis-server //redis的服务端<br>./redis-check-aof //用于修复出问题的AOF文件<br>./redis-sentinel //用于集群管理<br></code></pre></td></tr></table></figure><h2 id="redis服务端"><a class="markdownIt-Anchor" href="#redis服务端"></a> redis服务端</h2><p>redis-server即为redis服务端，可以直接通过./redis-server启动，但这是前台启动。</p><p>后台启动则通过将守护进程daemonize设为yes，然后利用配置文件启动服务端即可。（./redis-server ./redis.conf）</p><p>更多的关于redis.conf的配置可以看：<a href="https://www.runoob.com/redis/redis-conf.html">redis.conf配置</a></p><p>redis服务端<strong>默认端口为6379</strong></p><h2 id="redis客户端"><a class="markdownIt-Anchor" href="#redis客户端"></a> redis客户端</h2><h3 id="redis数据结构"><a class="markdownIt-Anchor" href="#redis数据结构"></a> redis数据结构</h3><p>  redis是key:value存储系统，所谓的redis数据结构其实指的是value的数据结构</p><h4 id="strings-字符串"><a class="markdownIt-Anchor" href="#strings-字符串"></a> strings 字符串</h4><ul><li>set key value</li><li>get key</li></ul><h4 id="lists-字符串列表"><a class="markdownIt-Anchor" href="#lists-字符串列表"></a> lists 字符串列表</h4><p>  redis的list底层实现是链表</p><ul><li>lpush key value</li><li>rpush key value</li><li>lrange key start stop</li></ul><h4 id="sets-字符串集合"><a class="markdownIt-Anchor" href="#sets-字符串集合"></a> sets 字符串集合</h4><p>  redis的set是无序集合，可以做集合能做的事情，如交并差等</p><ul><li>sadd key value</li><li>smembers key</li><li>sismember key value</li><li>sunion key1 key2 […keyn]</li></ul><h4 id="sorted-sets-字符串有序集合"><a class="markdownIt-Anchor" href="#sorted-sets-字符串有序集合"></a> sorted sets 字符串有序集合</h4><p>  redis中的有序集合是通过加入score这一字段来实现有序性的，且因为其命令以z开头，因此redis的有序集合称为zsets</p><ul><li>zadd key score value</li><li>zrange key start stop [rev]</li></ul><h4 id="hashes-哈希"><a class="markdownIt-Anchor" href="#hashes-哈希"></a> hashes 哈希</h4><p>  类似于bean，可以用一个key存储一系列的键值对信息</p><ul><li>hset key filed value […field value]</li><li>hgetall key</li><li>hget key field</li></ul><h2 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> redis持久化</h2><p>   <strong>redis的持久化有两种方式，分别是RDB（redis database）和AOF(append only file)</strong></p><p>  二者可同时使用，若redis重启，则优先采用AOF来进行数据恢复</p><h3 id="持久化之rdb"><a class="markdownIt-Anchor" href="#持久化之rdb"></a> 持久化之RDB</h3><p>  RDB是指在不同时间点将redis存储的数据通过生成快照的方式存储在磁盘上；</p><p>  RDB如何持久化：单独fork一个子进程来完成持久化这项工作，主进程不进行任何IO操作；子进程会先将数据写入到一个临时文件中，待持久化结束，会将这个临时文件替换上次持久化好的文件。</p><p>  若是对数据完整性并不敏感，则可以用RDB来恢复数据。（因为RDB持久化是隔一段时间进行一次的，所以会丢失部分的数据）</p><h3 id="持久化之aof"><a class="markdownIt-Anchor" href="#持久化之aof"></a> 持久化之AOF</h3><p>  AOF（Append Only File 只许追加不许改写）是将redis执行过的所有写指令记录下来</p><p>  利用AOF来恢复数据的话，它会从前往后的将指令执行一遍</p><p>  如何配置：redis.conf里有个appendonly将其改为yes即打开了AOF功能，若有写操作，则会被追加到AOF文件的末尾</p><p>  <strong>插入内容（方便下文理解）：</strong></p><p>Linux的同步IO（sync、fsync、fdatasync）</p><p>  之所以会出现以上那些个同步IO是因为：传统的unix系统的磁盘IO是通过<strong>缓冲</strong>来进行的，是通过在内核中设有对应的<strong>缓冲区高速缓存</strong>或<strong>页高速缓存</strong>来实现的。</p><p>  <strong>当我们将数据写入文件时，内核将数据复制到缓冲区中，只有当缓冲区写满或内核需要重用缓冲区时，才会将里面的数据冲去输出队列，至队首才进行真正的IO，此即为延迟写</u></strong></p><p>  延迟写会带来：数据更新慢以至更新的数据丢失等的情况，因此有上面的同步方法的出现，用于：<strong><u>保证磁盘上的文件与缓冲区高速缓存中内容的一致性</u></strong></p><ul><li>sync</li></ul><p>将缓冲区中的内容冲到输出队列即返回，并不等待实际的写磁盘结束。</p><ul><li>fsync</li></ul><p>将指定的文件描述符中处于缓冲区的内容冲到输出队列，且等待实际的写磁盘结束后才返回。</p><p>既影响文件的数据部分，又影响文件的属性部分(metadata(size、access_time、modify_time…))</p><p>两次IO（数据部分与属性部分置于不同磁盘块）</p><ul><li>fdatasync</li></ul><p>与fsync类似，但只影响文件的数据部分，不影响属性部分</p><p>一次IO</p><p>  <strong>插入完毕</strong></p><p>  <strong>默认的AOF持久化策略为每秒fsync一次</strong>。此时可以让redis保持良好的性能，在丢失数据时，最多也是最近1秒的数据</p><p>  如果遇到一些特殊情况：追加时遇到磁盘满、inode满、断电等情况，<strong>可以通过redis-check-aof工具来进行日志修复</strong></p><p>  <strong><u>因为AOF采用追加方式，所以在不额外做处理的情况下，文件会越来越大，因此，redis提供了AOF文件重写(rewrite)机制</u></strong>，所谓的AOF重写机制指的是：<strong>AOF文件的大小超过阈值，redis会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集（如INCR 100次，不如INCRBY KEY 100）</strong></p><p>  <strong>如何重写呢：</strong></p><pre><code>1. redis fork 重写子进程，读取现有 AOF文件，将其指令进行分析压缩后写入到一个临时文件中；2. 主进程则将新接收的写指令放入缓冲区中，也写入到原AOF文件中（避免重写遇断电，无法恢复）；3. 重写子进程重写完毕后，会给父进程发信号，父进程收到后会将缓冲区的写指令追加到新AOF文件中；4. 追加完毕后，redis用新AOF文件替代旧的AOF文件。</code></pre><h3 id="rdb和aof对比"><a class="markdownIt-Anchor" href="#rdb和aof对比"></a> RDB和AOF对比</h3><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>数据敏感性</td><td>较差</td><td>较好</td></tr><tr><td>数据恢复速度</td><td>较快</td><td>较慢</td></tr><tr><td>文件体积</td><td>较小</td><td>较大</td></tr></tbody></table><h2 id="redis主从"><a class="markdownIt-Anchor" href="#redis主从"></a> redis主从</h2><p>  redis支持主从同步，也有一主多从、多级从结构</p><p>  redis的主从同步是异步进行的</p><ul><li><p><strong>如何进行主从同步的呢：</strong></p><ol><li><p>从服务器发出SYNC给主服务器，主服务器接收后，调用BGSAVE来创建子进程进行数据持久化工作（即将数据写入RDB文件中）；</p></li><li><p>在持久化工作完成前，主服务器的写指令缓存在内存中；</p></li><li><p>BGSAVE完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器会将其存到磁盘上，然后读到内存中。之后主服务器会将期间缓存的写指令以redis协议的格式发给从服务器。</p></li></ol></li><li><p><strong>如果有多个从服务器发送SYNC指令呢？</strong></p><p>那也只会执行一次BGSAVE，只需把持久化好的RDB文件发给多个下游就好</p></li><li><p><strong>主从同步分为：</strong></p><ul><li><p>全量同步（即上面所介绍的“如何进行主从同步的呢”，初次连接都是全量同步）</p><p><img src="https://s2.loli.net/2021/12/21/Ab7wOClYSaFx6ji.png" alt="Redis_主从同步_全量同步.jpg" /></p></li><li><p>增量同步（Redis 2.8 之后有）</p><p>增量同步指的是：主服务器每执行一个写指令时会向从服务器发送相同的写指令，从服务器接收并执行对应的写指令。</p><p><strong>增量同步如何进行？</strong></p><p>  <mark>未写待续…</mark></p></li></ul></li><li><p><strong>Redis主从同步策略</strong></p><p>主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。</p><p>当然，如果有需要，slave 在任何时候都可以发起全量同步。</p><p>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p></li></ul><h2 id="redis事务处理"><a class="markdownIt-Anchor" href="#redis事务处理"></a> redis事务处理</h2><p>  <strong>在redis中，与事务处理相关的指令有以下四个：</strong></p><ul><li><p>multi</p><p>  用于组装事务</p></li><li><p>exec</p><p>  用于执行事务</p></li><li><p>discard</p><p>  用于取消事务</p></li><li><p>watch</p><p>  <strong>用于监视key（可多个），当被监视的key在<u>multi</u>之前有改变时，无论事务的内容是否关于该key，都会返回nil；若是被监视的key没有改变，则正常执行</strong></p></li></ul><p>  <strong>在使用事务时可能遇到的错误：</strong></p><ul><li><p>执行前的错误</p><p>  即语法错误或内存错误导致，在编写事务的某一条指令后会报错(exec前)，之后调用exec指令时，会拒绝执行该事务（2.6.5版本之后）</p></li><li><p>执行后的错误</p><p>  即应用层的错误，如sadd myset “a”;lpush myset “b”;可看出，myset于这两条指令中被使用了不同数据结构的指令。redis在执行此条事务时不会理睬这些错误，而是继续向下执行其他指令（不会影响其他指令的执行，也不会影响该条指令入列），事务最终可以被执行</p></li></ul><h2 id="redis配置"><a class="markdownIt-Anchor" href="#redis配置"></a> redis配置</h2><p>  redis的配置文件为：redis.conf(Linux下)，其支持在主配置文件中引入外部的配置文件，如：</p><p><code>include /home/ayy/...</code></p><p>  redis配置文件被划分为如下几部分：</p><ol><li><p>general</p></li><li><p>snapshotting</p></li><li><p>replication</p></li><li><p>security</p></li><li><p>limits</p></li><li><p>append only mode</p></li><li><p>lua scripting</p></li><li><p>slow log</p></li><li><p>event notification</p></li><li><p>gopher server</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用高级命令</title>
    <link href="/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h2><p>  功能：用于<strong>查找文件</strong><br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find 查找路径 查找条件<br></code></pre></td></tr></table></figure><p>  查找条件：</p><ul><li>-name<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;a.txt&quot;<br>查找当前目录下（含子目录）名称为“a.txt”的文件<br></code></pre></td></tr></table></figure><ul><li>-type<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f <br>查找当前目录下（含子目录）的普通文件<br></code></pre></td></tr></table></figure><p>  linux下文件类型主要有以下几种：</p><table><thead><tr><th style="text-align:center">字母</th><th style="text-align:center">文件类型</th></tr></thead><tbody><tr><td style="text-align:center">f(file)</td><td style="text-align:center">普通文件</td></tr><tr><td style="text-align:center">d(directory)</td><td style="text-align:center">目录</td></tr><tr><td style="text-align:center">b(block)</td><td style="text-align:center">块设备</td></tr><tr><td style="text-align:center">s(socket)</td><td style="text-align:center">套接字</td></tr><tr><td style="text-align:center">c(char)</td><td style="text-align:center">字符设备</td></tr><tr><td style="text-align:center">l(link含硬链接和软链接)</td><td style="text-align:center">链接</td></tr><tr><td style="text-align:center">p(pipe)</td><td style="text-align:center">管道</td></tr></tbody></table><ul><li>-user<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -user &quot;ayyHA&quot;<br>查找当前目录下（含子目录）user为ayyHA的文件<br></code></pre></td></tr></table></figure><ul><li>-group<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -group &quot;test&quot;<br>查找当前目录下（含子目录）group为test的文件<br></code></pre></td></tr></table></figure><ul><li>-not<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -not -type f<br>查找当前目录下（含子目录）文件类型为非普通文件的文件<br></code></pre></td></tr></table></figure><p>  -not也可以用!来替换，二者等价</p><ul><li>-a -o<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -a -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -o -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件或以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>  注：默认情况是-a，即查找条件是合取的关系。</p><ul><li>-maxdepth -mindepth<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -maxdepth 2 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最大深度为2且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mindepth 1 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最小深度为1且以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>  注：当前目录下即为深度为1，往下的每一个子目录深度便加1。</p><ul><li>-size<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -size 10k<br>查找当前目录下（含子目录）大小为10K的文件<br></code></pre></td></tr></table></figure><p>  注：+10K表示比10K大的文件；-10K表示比10K小的文件。</p><ul><li>-perm<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -perm 644<br>查找当前目录下（含子目录）文件权限为644的文件（此为精确匹配）<br></code></pre></td></tr></table></figure><p>  注：权限值若是写成-404则表明只要user权限为r且other权限为r即可，只要满足了这两个条件的文件就都会被筛选出来；权限值若是写成了/404则表明只要user权限为r或other权限为r即可，只要满足了两个条件的其中一个就会被筛选出来。</p><ul><li>-atime -ctime -mtime<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mtime -7 <br>查找当前目录下（含子目录）的文件在7天内有进行过修改的<br></code></pre></td></tr></table></figure><p>  注：其余两个类似，不赘述。（对数字前添加‘+’/‘-’表示‘大于’/‘小于’）</p><ul><li>-exec 命令 {} ;<br />  此查找条件意思为：对<strong>查找到的文件执行(execute)命令</strong>，其中**{}代表的是查找到的文件**。<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;<span class="hljs-emphasis">*md&quot; -exec cat &#123;&#125; \;</span><br><span class="hljs-emphasis">对查找到的以md结尾的文件执行cat命令。</span><br></code></pre></td></tr></table></figure><p>  注：有个<code>-ok 命令 &#123;&#125; \;</code>与该命令相似，但它会询问查找到的文件是否执行该命令(y/n)。</p><h2 id="wc"><a class="markdownIt-Anchor" href="#wc"></a> wc</h2><p>  功能：用于统计行数(line)、单词数(word)、字节数(char,内存占1byte)<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc 统计条件 文件名<br></code></pre></td></tr></table></figure><p>  统计条件：</p><ul><li>-l<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -l ./text.txt<br>用于统计text.txt文件的行数<br></code></pre></td></tr></table></figure><ul><li>-w<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -w ./text.txt<br>用于统计text.txt文件的单词数<br></code></pre></td></tr></table></figure><ul><li>-c<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -c ./text.txt<br>用于统计text.txt文件的字节数<br></code></pre></td></tr></table></figure><ul><li>-m<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -m ./text.txt<br>用于统计text.txt文件的字符数（一个汉字在utf8编码里是3个字节，利用-c不方便统计字符数）<br></code></pre></td></tr></table></figure><ul><li>-L<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -L ./text.txt<br>用于统计text.txt文件最长行的长度<br></code></pre></td></tr></table></figure><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h2><p>  功能：依据条件进行过滤，找到满足条件的行<br />  基本格式；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">grep [option] pattern file<br></code></pre></td></tr></table></figure><p>  option：<br />以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/22/1HB2myCgfSLURvZ.png" alt="grep option test file.png" /></p><ul><li>-E<br />  作用：pattern匹配转为扩展正则表达式，等价于egrep命令。</li><li>-i<br />  作用：忽略大小写，ignore。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/MNxbnQC4cFoI3yt.png" alt="grep -i.png" /></p><ul><li>-v<br />  作用：反向查询，类似取反，invert。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/xgBqR1JAsXLakEF.png" alt="grep -v.png" /></p><ul><li>-n<br />  作用：输出行号，number。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/4fEnBglMyROKLIa.png" alt="grep -n.png" /></p><ul><li>-w<br />  作用：匹配整个单词，字符串内出现的不匹配，word。<br />  在原来的文本上补加了一些内容用以演示，演示文本如下图所示：</li></ul><p><img src="https://s2.loli.net/2021/12/22/z8CVugykKlm3jDW.png" alt="grep option test file2.png" /></p><p>  演示如下：</p><p><img src="https://s2.loli.net/2021/12/22/MVeg9XinhKbmp8H.png" alt="grep -w.png" /></p><ul><li>-c<br />  作用：统计匹配到的行数，count。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/BivsRuxHTD4Fc75.png" alt="grep -c.png" /></p><ul><li>-o<br />  作用：只显示匹配到的字符串，不显示其所在行的内容。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/2G1ietD6KTlsEfw.png" alt="grep -o.png" /></p><ul><li>-Ax<br />  作用：输出匹配到内容所在行的后x行的内容，after x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/aP2fjGeyrdRHVt7.png" alt="grep -Ax.png" /></p><ul><li>-Bx<br />  作用：输出匹配到内容所在行的前x行的内容，before x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/3SR7Fq9IuaXrt81.png" alt="grep -Bx.png" /></p><ul><li>-Cx<br />  作用：输出匹配到内容所在行的前后x行的内容，context x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/VQLbpYTBtfgrXw7.png" alt="grep -Cx.png" /></p><ul><li>-e<br />  作用：实现多个匹配，相当于or。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/2QNHo4A6UgLjZdP.png" alt="grep -e.png" /></p><ul><li>-q<br />  作用：安静模式，只关心结果，即有没有匹配到。匹配到为0，匹配不到为1，文件有误为2，quiet。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/bF7aTqXPDpZiU45.png" alt="grep -q.png" /></p><div class="note note-info">            <p>  注：如果在使用grep匹配关键字时，匹配到的关键字没高亮，可以通过在命令<code>grep --color=auto &quot;word&quot; file</code>中添加<code>--color=auto</code>来开启；也可以通过alias命令重申一下grep命令<code>alias &quot;grep=grep --color=auto&quot;</code>来达到效果。</p>          </div><h3 id="pattern均为扩展正则表达式"><a class="markdownIt-Anchor" href="#pattern均为扩展正则表达式"></a> pattern（均为扩展正则表达式）:</h3><p>以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/23/xZlKf47MLJDVo2j.png" alt="re test file.png" /></p><h4 id="单个字符匹配相关"><a class="markdownIt-Anchor" href="#单个字符匹配相关"></a> 单个字符匹配相关</h4><ul><li>.<br />  作用：匹配<strong>任意</strong>的单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/NMRckIXrfUnspwl.jpg" alt="re ..jpg" /></p><ul><li>[  ]<br />  作用：匹配<strong>指定范围内</strong>的任意单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/dMiYpb48Q9DtzCX.jpg" alt="re   .jpg" /></p><ul><li>[^  ]<br />  作用：匹配<strong>指定范围外</strong>的任意单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/fKPtF1Y7C4VH6AJ.jpg" alt="re ^ .jpg" /></p><ul><li>[0-9] / [[:digit:]]<br />  作用：[0-9]和[[:digit:]]功能一样，匹配[0,9]间任意的单个数字<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/q24p6arlHcwPbVZ.jpg" alt="re 0-9.jpg" /></p><ul><li>[a-zA-z] / [[:alpha:]]<br />  作用：[a-zA-z]和[[:alpha:]]功能一样，匹配单个任意的大小写字母<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/8R3hXU5GMNJqVel.jpg" alt="re a-z.jpg" /></p><ul><li>[^0-9] / [^[:digit:]]<br />  作用：[^0-9]和[^[:digit:]]功能一样，匹配单个非数字字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/oi6j8pNmBXruqVz.png" alt="re  ^0-9.png" /></p><h4 id="次数匹配相关"><a class="markdownIt-Anchor" href="#次数匹配相关"></a> 次数匹配相关</h4><ul><li>?<br />  作用：<strong>匹配其前面的字符0次或1次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/XoTC6RLYDwqcHh1.jpg" alt="re ?.jpg" /></p><ul><li><ul><li></li></ul></li></ul><p>  作用：<strong>匹配其前面的字符至少1次</strong><br />  演示如下：</p><p><img src="https://s2.loli.net/2021/12/23/XWNkxrpv6AGcqE8.png" alt="re +.png" /></p><ul><li>*<br />  作用：<strong>匹配其前面的字符至少0次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/wVLJ8mpWM1v7RFP.jpg" alt="re .jpg" /></p><ul><li>{n}<br />  作用：<strong>匹配其前面的字符n次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/oxlNqW4nOITgGcw.png" alt="re {n}.png" /></p><ul><li>{n,}<br />  作用：<strong>匹配其前面的字符至少n次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/Tz6QYKoABqPRLkh.png" alt="re {n,}.png" /></p><ul><li>{,m}<br />在原来的文本上新增一行内容以体现演示效果，文本内容如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/gMywnzfhaqULSPD.png" alt="re test file2.png" /></p><p>  作用：<strong>匹配其前面的字符至多m次，最少可以是0次</strong><br />  演示如下：</p><p><img src="https://s2.loli.net/2021/12/24/mcgXYvMiGquxR2o.png" alt="re {,m}.png" /></p><ul><li>{n,m}<br />  作用：<strong>匹配其前面的字符至少n次，至多m次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/4bJSjCD9xcA3BsN.png" alt="re {n,m}.png" /></p><h4 id="位置匹配相关"><a class="markdownIt-Anchor" href="#位置匹配相关"></a> 位置匹配相关</h4><ul><li>^<br />  作用：其后跟着的内容需位于<strong>行首</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/YnKjS8vP1mMouyU.png" alt="re ^.png" /></p><ul><li>$<br />  作用：其前跟着的内容需位于<strong>行尾</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/pcQOKedIY2b8JgR.png" alt="re $.png" /></p><ul><li>\&lt; / \b<br />  作用：其后跟着的内容需位于<strong>词首</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/GJUe9Cb4Qz5EOvj.png" alt="re .png" /></p><ul><li>\&gt; / \b<br />  作用：其前跟着的内容需位于<strong>词尾</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/QgniJvzjoVLt6Ou.png" alt="re .png" /></p><p>  若是将<code>\&lt;</code>和<code>\&gt;</code>同时作用于一单词上，表明它既是词首又是词尾，那其实它就是个独立的单词，示例如下；</p><p><img src="https://s2.loli.net/2021/12/24/QTtz8hOxbeNp6Pj.png" alt="re   .png" /></p><ul><li>\B<br />  作用：匹配非词首或非词尾的内容（具体看它放在单词前还是后）<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/uPWpweh5NlyCQ7D.png" alt="re .png" /></p><h4 id="分组和后向引用"><a class="markdownIt-Anchor" href="#分组和后向引用"></a> 分组和后向引用</h4><p>  修改了演示文件以便于展示效果，新的演示文件如下：</p><p><img src="https://s2.loli.net/2021/12/24/o35kyPu19tXMnxf.png" alt="re test file3.png" /></p><ul><li>()<br />  作用：分组内部的内容为一个<strong>整体</strong>，<strong>可嵌套</strong>使用<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/gZmKzu1A87Jw2NG.png" alt="re ().png" /></p><ul><li>\x<br />  作用：后向引用分组，<strong>匹配分组x相同的内容</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/g7usQXN2tjC1c4W.png" alt="re .png" /></p><h4 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h4><ul><li>\<br />  作用：转义符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/4viCzfdm3DpGEwQ.png" alt="re png" /></p><div class="note note-info">            <p>  注:对需要转义的字符进行转义时，加上<code>\</code>即可，但若是对<code>\</code>本身进行转义，则需要使用<code>''</code>单引号而非双引号。</p>          </div><ul><li>|<br />  作用：表示<strong>或</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/JEubgS23M96yzod.png" alt="re |.png" /></p><ul><li>.*<br />  作用：类似<strong>通配符</strong>，可<strong>匹配任意字符的任意内容</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/w4pKLBOCUhEs2zk.png" alt="re ..png" /></p><ul><li>^$<br />  作用：<strong>表示空行</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/dgZPsM1vzIaRp28.png" alt="re ^$.png" /></p><h2 id="du"><a class="markdownIt-Anchor" href="#du"></a> du</h2><p>  功能：查询磁盘目录下文件的大小 disk usage<br />  常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -h<br>查询当前目录下（递归查询）文件的大小，最后输出目录总大小，会以K，M，G的格式写明文件大小。<br>human readable<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -s<br>查询当前目录下文件的总计大小，只输出总文件大小。 summarize<br></code></pre></td></tr></table></figure><h2 id="df"><a class="markdownIt-Anchor" href="#df"></a> df</h2><p>  功能：查询文件系统的使用情况 disk file system<br />  常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">df -h<br>查询当前盘符的使用情况，以人类可读的方式输出。human readable<br></code></pre></td></tr></table></figure><h2 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h2><p>  功能：排序（一行一行排，默认按字典序排）<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sort [option] file<br>默认升序<br></code></pre></td></tr></table></figure><p>  option：<br />以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/24/O1rGviUWcuIhCzT.png" alt="sort test file.png" /></p><ul><li>-r<br />  作用：逆序输出 reverse<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/bWrDHNRcu4SG8zv.png" alt="sort -r.png" /></p><ul><li>-t组合-k<br />  作用：-t后跟着分隔符，用以将内容划分成列；-k后跟着数字，用以指明第几列<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/nWiAF65eNqTg7yb.png" alt="sort -t -k.png" /></p><p>  我们用空格作为分隔符，将其划分成三列，且取第二列作为排序的依据，当结果看起来好像排错了，其实没错，因为sort默认按照<strong>字典序</strong>排序，10&lt;4是因为利用ASCII码比较完首个字符后，就认为4&gt;10。可以通过后面的-n选项来用<strong>数值</strong>比较。<br />-t(field separator) -k(key)</p><ul><li>-n<br />  作用：按数值大小排序，默认是字典序，会出现10&lt;2的情况 numeric sort<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/WPR2SwnajvdDu6y.png" alt="sort -n.png" /></p><p>  我们可以看到，此可第二列是按照正常的升序进行的排序。</p><ul><li>-u<br />  作用：去除重复的行（不要求重复行相邻） unique<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/lCtq8doRTQE9k1r.png" alt="sort -u.png" /></p><h2 id="uniq"><a class="markdownIt-Anchor" href="#uniq"></a> uniq</h2><p>  功能：去重（去掉<strong>连续</strong>的<strong>重复行</strong>），重复行需要相邻。<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">uniq [option]<br></code></pre></td></tr></table></figure><p>  此处的演示文本依旧使用sort的文本。</p><p>  option:</p><ul><li>不带option时<br />  作用：去除重复的行（需要借助sort来将重复文本弄成相邻的行）<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/7EVMi3va9GbDkpc.png" alt="uniq default.png" /></p><ul><li>-c<br />  作用：统计行数，置于行首 count<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/El2Jq9pPCvB8V76.png" alt="uniq -c.png" /></p><ul><li>-u<br />  作用：不打印重复的行 unique(only print unique lines)<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/Mk6S9rJUYcqFl53.png" alt="uniq -u.png" /></p><h2 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> cut</h2><p>  功能：打印列<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">cut option file<br></code></pre></td></tr></table></figure><p>  此处的演示文本依旧使用sort的文本。</p><p>  option:</p><ul><li>-d -f<br />  作用：-d(delimiter)后跟着分隔符，-f后跟着数字用以选择是哪个域(field)<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/DjTCRkboBSQJty1.png" alt="cut -d -f.png" /></p><h2 id="perl"><a class="markdownIt-Anchor" href="#perl"></a> perl</h2><h2 id="lsmod"><a class="markdownIt-Anchor" href="#lsmod"></a> lsmod</h2><p>查看已加载在内核中的LKM（loadable kernel module）</p><h2 id="lshw"><a class="markdownIt-Anchor" href="#lshw"></a> lshw</h2><h2 id="lspci"><a class="markdownIt-Anchor" href="#lspci"></a> lspci</h2>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim的基础使用</title>
    <link href="/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vim的几种模式"><a class="markdownIt-Anchor" href="#vim的几种模式"></a> Vim的几种模式</h2><ul><li><strong>normal模式</strong><br />  默认模式，此模式下你可以输入命令，如利用<code>/ + 单词</code>来进行搜索，又或者利用yp进行cv操作；</li><li><strong>编辑模式</strong><br />  通过输入i(insert)/a(append)/o(open a line)进入编辑模式，可以进行文本的编辑操作；</li><li><strong>命令模式</strong><br />  就是在normal模式下输命令，比如分屏：<code>:vs</code>竖分屏； <code>:sp</code>横分屏</li><li><strong>可视化模式</strong><br />  所谓的可视化模式用于选择文本，在normal模式下使用<code>v</code>可以进入visual模式，可选择的最小单位是每一个字符；使用<code>V</code>可以进入visual line模式，顾名思义，可选择的最小单位是每一行；使用<code>ctrl + v</code>可以进入visual block模式，可以以矩阵的方式进行文本选择。</li></ul><h2 id="编辑模式下的小技巧"><a class="markdownIt-Anchor" href="#编辑模式下的小技巧"></a> 编辑模式下的小技巧</h2><ul><li><code>ctrl + h</code> 删除上一个编辑的字符</li><li><code>ctrl + w</code> 删除上一个编辑的单词</li><li><code>ctrl + u</code> 删除当前行<br />上述的快捷键也可以用于终端；</li><li><code>ctrl + [</code> insert模式切换到normal模式</li><li><code>gi</code>快速跳转到最后一次编辑的地方并进入插入模式</li></ul><h2 id="vim移动"><a class="markdownIt-Anchor" href="#vim移动"></a> Vim移动</h2><ul><li><code>hjkl</code>即是vim normal模式下的左下上右键；</li><li>w/W移到下一个单词开头</li><li>e/E移到下一个单词结尾</li><li>b/B移到上一个单词开头 back word</li></ul><div class="note note-info">            <p>  上面移动的小写和大写的区别在于：<br />小写指的是以非空白符分割的单词；<br />大写指的是以空白符分割的单词；</p>          </div><ul><li><code>f + &lt;char&gt;</code>可以移动到<strong>行内</strong>第一个符合的字符上，若不符合，可以通过<code>;</code>或<code>,</code>进行搜索下一个或上一个；大写的F则表示反向搜索，而非正向搜索；</li></ul><div class="note note-info">            <p>  上面的f可以理解为find,使用<code>f + &lt;char&gt;</code>可以到达寻找的字符；<br />  而若是用<code>t + &lt;char&gt;</code>则可以寻找到要找的字符前一位，此处的t可以理解为to；</p>          </div><ul><li><code>0</code>可以移动到当前行的行首；</li><li><code>$</code>可以移动到当前行的行尾；</li><li><code>^</code>可以移动到当前行的首个非空字符；</li><li><code>g_</code>可以移动到当前行的最后一个非空字符；</li><li><code>gg/G</code>移动到文件开头或结尾；</li><li><code>H/M/L</code>可以跳转到屏幕的开头(Head)/中间(Middle)/结尾(Lower)；</li><li><code>ctrl + f/ctrl + u</code>向下分页(forward)/向上分页(upward)</li><li><code>zz</code>把屏幕设置为中间</li></ul><h2 id="vim增删改查"><a class="markdownIt-Anchor" href="#vim增删改查"></a> Vim增删改查</h2><h3 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h3><ul><li>i(insert): 在字符前插入</li><li>a(append): 在字符后插入</li><li>o(open a new line): 下启一行插入</li><li>I: 在行首插入</li><li>A: 在行末插入</li><li>O: 上启一行插入</li></ul><h3 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h3><ul><li>x: 删除单个字符</li><li>d(delete): 此为删除命令，可结合文本对象具体使用，如diw(delete inner word)</li></ul><div class="note note-info">            <p>  d和x可以搭配数字使用，以达到同一命令重复执行多次的效果。</p>          </div><h3 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h3><ul><li>r(replace): <code>r &lt;char&gt;</code>用以替换当前光标所在处的字符；</li><li>c(change):  可以搭配文本对象具体使用，如<code>&quot;just try try&quot;</code>中使用<code>ci&quot;</code>则会删除掉引号内的内容(引号不会去掉，若是<code>ca&quot;</code>则会)，并且进入到编辑模式</li><li>s(substitute): 删除并进入编辑模式</li></ul><div class="note note-info">            <p>  <code>s</code>可以搭配数字使用；<br />  上述的三个命令若是大写（即R/C/S）会有不同的作用：</p><ul><li>R进入replace模式，从当前字符起可以一直替换，直到退出该模式；</li><li>C/S二者差不多，删掉整行进入编辑模式；</li></ul>          </div><h3 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h3><ul><li><code>/ + &lt;word&gt;</code>: 前向搜索</li><li><code>? + &lt;word&gt;</code>: 反向搜索</li><li><code>n/N</code>: 跳到下一匹配项/跳到上一匹配项</li><li><code>*/#</code>: 当前光标处单词的下一项/上一项匹配</li></ul><h2 id="vim搜索替换"><a class="markdownIt-Anchor" href="#vim搜索替换"></a> Vim搜索替换</h2><p>  格式: <code>:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]</code><br />  range表示范围(不写则默认当前行)：</p><ul><li><code>%</code>表示全选；</li><li><code>m,n</code>表示第m-第n行；</li><li><code>n,$</code>表示第n行到末尾；</li></ul><p>  s表示替换<br />  pattern表示替换前的单词，可以用正则<br />  string表示替换后的单词<br />  flags表示替换方式(不写则默认替换第一个(当前行/范围内的行)出现的pattern)：</p><ul><li>g(global): 全局执行（即所有出现的，不局限在第一个）</li><li>n(number): 报告匹配的次数而不替换</li></ul><h2 id="个人小结"><a class="markdownIt-Anchor" href="#个人小结"></a> 个人小结</h2><p>  对于可以结合文本对象进行操作的命令：如y(yank)/d(delete)/c(change)等，可以结合以下的范围词来使用：a(around,含该字符)/f(find,含该字符)/i(inner,不含该字符)/t(to,不含该字符)来结合特定的字符使用。<br />  如：<code>yf;</code>表示由当前字符开始复制至<code>;</code>处，且含<code>;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础应用</title>
    <link href="/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <url>/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="git是什么"><a class="markdownIt-Anchor" href="#git是什么"></a> Git是什么</h2><p>  Git是分布式版本管理系统<br />  它可以帮助你：</p><ul><li><strong>构造本地仓库</strong></li><li><strong>管理本地仓库内的文件版本（可以回滚，可以往前）</strong></li><li><strong>与远程仓库建立连接（通过SSH）</strong></li><li><strong>远程仓库存储副本</strong></li><li><strong>多人协作开发</strong></li><li>…</li></ul><h2 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> Git安装</h2><ul><li>windows系统<br />下个Git Bash</li><li>Linux系统<br /><code>yum install git -y</code></li></ul><p>  安装完成后我们需要在Git Bash内或是Linux的终端中(下文统一称为<strong>terminal</strong>)设置全局属性name和email。用以标识用户。<br />  <code>git config --global user.name &quot;ayyHA&quot;</code><br />  <code>git config --global user.email &quot;email@qq.com&quot;</code><br />  还可以启用Git的一些额外颜色<br />  <code>git config --global color.ui true</code></p><h2 id="git本地仓库的操作"><a class="markdownIt-Anchor" href="#git本地仓库的操作"></a> Git本地仓库的操作</h2><p>  我们可以新建一个目录，用以作为被Git管理的本地仓库，<strong>放置于其内的任意文件都会被Git进行版本管理</strong>。</p><h3 id="本地仓库初始化"><a class="markdownIt-Anchor" href="#本地仓库初始化"></a> 本地仓库初始化</h3><p>  通过<code>git init</code>命令即可以将该目录设置为<strong>本地仓库</strong>，且该目录内会多出一个**.git**文件夹，其内是Git用于版本管理的东西，<strong>没事别乱动！！</strong></p><h3 id="提交文件"><a class="markdownIt-Anchor" href="#提交文件"></a> 提交文件</h3><p>  之后你可以往这个文件夹里建文件，写东西。但是这并没有使用到我们Git的版本管理。如何使用到呢？<br />  我们可以打开terminal输入<code>git status</code>这条命令进行查看。<br />  你会发现上面写着Untracked files,即意味着你的文件只是放在这个目录下，还没有被Git进行跟踪管理。</p><p>  我们可以通过<code>git add &lt;file&gt;</code>来将文件放置到一个叫<strong>暂存区</strong>的地方（即index或stage，存放于.git下）</p><p>  我们可以一次性将许多文件放在暂存区内，然后提交到<strong>本地仓库:</strong><code>git commit -m &quot;这里写此次提交的注释&quot;</code></p><p>  之后当你修改这些被跟踪的文件时，都可以通过<code>git status</code>来查看有谁被modified，有谁需要committed。</p>  <div class="note note-info">            <p>  你可能会想到一种情况：<br />  我在本地仓库里新建了a文件，修改了其内容，然后通过<code>git add a.txt</code>将其提交到暂存区，之后忽然发现有个地方写错了，然后直接先去修改a文件了，此时Git会将你放入暂存区的文件和再次修改的文件分隔来看，即放入暂存区的文件可以通过<code>git commit</code>将内容上交，而新加的内容则是被认为是modified，需要重新<code>git add</code>。</p>          </div><h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3><p>  当我们对文件一股脑的进行修改后发现，修改的部分极大可能出错了，且修改的地方比较多，若是一点一点回去改，会很耗时。而Git给我们提供了一剂后悔药<code>git checkout -- &lt;file&gt;</code>即可以将修改撤销，变回修改前的模样。</p>  <div class="note note-info">            <p>  ①若是未将文件<code>git add</code>到暂存区，则文件会回滚文修改前的版本；<br />  ②若是将文件放到了暂存区，又进行了修改，则checkout后得到的是暂存区的版本；（现在Git）</p>          </div><p>  除了上面所说的<code>git checkout -- &lt;file&gt;</code>来对文件进行撤销修改外，Git也提供了<code>git restore &lt;file&gt;</code>来撤销修改（因为<code>git checkout</code>也与后面的分支切换有关）,还提供了<code>git restore --staged &lt;file&gt;</code>来<strong>撤销放置于暂存区的文件</strong></p><h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3><p>  撤销修改中的①其实就是回退到最新的版本，也可以通过版本回退来实现:<code>git reset --hard HEAD^</code>此即为回退到上一个版本，若是想回退到上上一个版本，加多个<sup>即可。但若是我们需要回退的版本很前很前，写那么多个</sup>并不现实，可以通过：<code>git --reset HEAD~100</code>即可以回退到前100个版本去；<br />  那我们如果想回退到某一个版本，我们不知道它跟我们现在的版本差距为多少，我们可以通过<strong>版本号</strong>来进行回退。版本号可以通过<code>git log</code>来得到（commit后面那一串就是版本号）,如果版本太多，可以通过<code>git log --pretty=oneline</code>来较为清晰地输出版本信息。<br />  回退的时候我们不需要把版本号全部写上去，写前几个字母就好了，如：<code>git reset --hard 95a9b</code>。<br />  那当我们知道了版本号，其实不只可以进行版本回退，也可以将版本向前移动。若是不知道版本号，我们可以通过<code>git reflog</code>来进行查询。</p><div class="note note-info">            <p>  上面指令中的<strong>HEAD其实就是指向当前分支（如master）</strong>, 而<strong>当前的分支才是指向提交</strong>的，也即是说我们<strong>commit到本地仓库的内容是提交在当前分支上</strong>的，这个在后面的分支管理部分可以更好的理解。</p>          </div><h2 id="git远程仓库的操作"><a class="markdownIt-Anchor" href="#git远程仓库的操作"></a> Git远程仓库的操作</h2><h3 id="github设置及远程推送"><a class="markdownIt-Anchor" href="#github设置及远程推送"></a> Github设置及远程推送</h3><p>  要知道，我们GitHub和Git的数据传输是通过SSH加密的，需要进行如下的设置：</p><ol><li>在terminal中通过<code>ssh-keygen -t rsa -C &quot;email&quot; </code>来生成，它利用RSA加密算法生成一个公钥和密钥，放在你当前用户的HOME目录下（windows在C:/User/UserName/.ssh下，Linux在~/.ssh下）;</li><li>将在.ssh目录下的id_rsa放置到你的Github的Settings下的SSH and GPG keys中（通过点击New SSH key放置其中）；其中id_rsa是公钥，带pub后缀的是密钥;<br />至此，你的电脑利用Git去远程访问你的Github下的信息已经可以进行权限认证了（就是可以分辨出有没资格去拿信息）。</li><li>我们需要在Github上建一个仓库，并将本地仓库和远程仓库通过<code>git remote add origin git@github.com:github_name/repo_name.git </code>关联起来(注意github_name需替换成你的GitHub账号,repo_name需替换成你的仓库名);<br />  以上，你便将你的本地仓库和远程仓库建立了连接。我们可以将<strong>本地文件push到repo</strong>了。<code>git push -u origin master</code>首次push需要加-u，以使得你的本地分支master和远程仓库分支master相关联。之后就<code>git push origin master</code>就行。<br />  我们也可以<strong>拉取到该repo的文件</strong><code>git pull origin master</code>。</li></ol><h3 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h3><p>  通过上面的描述我们知道，我们的本地仓库在创建之时给我们自带了一个master分支，我们也可以自创分支<code>git branch branchName</code>，也可以切换分支<code>git checkout branchName</code>，可以通过<code>git branch来查看当前有多少分支</code>，还可以通过<code>git branch -d branchName</code>来删除分支。<br />  上面的分支切换和分支创建也可以通过如下指令完成<code>git checkout -b branchName</code>。<br />  我们一般都是用一个分支（如dev）进行修改提交（就是dev改了内容之后要add、commit），然后再合并到主分支master上，即是：<code>git merge dev</code>(master合并掉dev,通过fast-forward策略)。</p><div class="note note-info">            <p>  分支就像是一个线程一样，共享仓库里的文件，但是对文件的修改提交只对该分支可见。</p>          </div><p>  我们前面曾说过，我们的分支是面向提交的，那么也就是说如果我有master分支和dev分支，我们即对dev做了修改提交，又对master做了修改提交，那么在合并的时候就会产生<strong>冲突</strong>，我们可以通过查看产生了冲突的文件，上面会有&lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt;的信息来指示这个部分是哪个分支进行的修改，手动解决冲突后，即可合并。</p><div class="note note-info">            <p>  fast forward策略合并分支后，我们若是删除了分支，会丢失掉分支的信息。因此可以通过禁用fast forward的方式来避免丢失信息：<code>git merge -no-ff -m &quot;注释&quot; branchName</code>，之后还可以通过<code>git log</code>来找到它。<br />  若是在遇到某些bug的情况下需要另建分支，解决bug，而此时工作现场又无法commit的话，我们可以通过<code>git stash</code>来隐藏工作现场，后期可以通过<code>git stash list</code>来查看现场，然后可以通过<code>git stash apply</code>和<code>git stash drop</code>来应用和删除现场，也可以通过<code>git stash pop</code>来恢复现场和删除现场。</p>          </div><h3 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h3><p>  在前面push内容到GitHub时，我们用到了<code>git push origin master</code>其实这个origin就是远程仓库默认的名字。我们可以通过<code>git remote</code>和<code>git remote -v</code>来查看远程仓库的信息。而这里的master则是指的本地分支，意为：将本地的master分支push到origin上去。<br />  那么我们若是要push本地的dev分支到origin去的话，我们的远程仓库会自动set up一个叫dev的分支，并与我们本地的dev分支建立关联。<br />  若是我们需要将origin上的dev分支弄到本地来，可以通过<code>git checkout -b dev origin/dev</code>实现；<br />  若是当我们要提交的dev分支产生冲突，我们需要拉取最新的下来，我们需要先指定本地dev分支与远程origin/dev分支的关联关系：<code>git branch --set-upstream dev origin/dev</code>，再pull即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo之方便文创的代码</title>
    <link href="/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="tag插件"><a class="markdownIt-Anchor" href="#tag插件"></a> Tag插件</h2><h3 id="便签"><a class="markdownIt-Anchor" href="#便签"></a> 便签</h3><p>  便签，就是贴在文章中的彩色标签，用于展示作者的一些提示信息。便签是通过便签类型来进行划分的。<br /><a href="https://hexo.fluid-dev.com/docs/guide/">fluid配置指南</a></p><p><strong>用法</strong></p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>这里写便签里的内容<br>&#123;% endnote %&#125;<br>需注意：上面的success是便签类型的指代，此为绿色的便签。<br></code></pre></td></tr></table></figure><p><strong>便签类型和颜色的对应关系</strong></p><table><thead><tr><th style="text-align:center">便签类型</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center">primary</td><td style="text-align:center">紫色</td></tr><tr><td style="text-align:center">secondary</td><td style="text-align:center">灰色</td></tr><tr><td style="text-align:center">success</td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:center">danger</td><td style="text-align:center">红色</td></tr><tr><td style="text-align:center">warning</td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">蓝色</td></tr><tr><td style="text-align:center">light</td><td style="text-align:center">白色</td></tr></tbody></table><p><strong>效果演示</strong></p>  <div class="note note-primary">            <p>我是primary，我是紫色</p>          </div>  <div class="note note-secondary">            <p>我是secondary，我是灰色</p>          </div>  <div class="note note-success">            <p>我是success，我是绿色</p>          </div>  <div class="note note-danger">            <p>我是danger，我是红色</p>          </div>  <div class="note note-warning">            <p>我是warning，我是黄色</p>          </div>  <div class="note note-info">            <p>我是info，我是蓝色</p>          </div>  <div class="note note-light">            <p>我是light，我是白色</p>          </div><h3 id="行内标签"><a class="markdownIt-Anchor" href="#行内标签"></a> 行内标签</h3><p>  行内标签类似于一个按钮（就是不可以按），用于标识信息。</p><p><strong>用法：</strong><br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% label primary @text%&#125;<br></code></pre></td></tr></table></figure><br /><div class="note note-info">            <p>text即为标签的文本，primary这些与便签类似，但多了个default，没有secondary和 light，且text开头不能是@。</p>          </div></p><p><strong>效果演示：</strong><br /><span class="label label-primary">我是primary</span><br /><span class="label label-default">我是default</span><br /><span class="label label-success">我是success</span><br /><span class="label label-warning">我是warning</span><br /><span class="label label-danger">我是danger</span></p><h3 id="按钮"><a class="markdownIt-Anchor" href="#按钮"></a> 按钮</h3><p>  按钮就是加了底色的外链跳转</p><p><strong>用法：</strong><br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% btn url,text,title %&#125;<br></code></pre></td></tr></table></figure></p>  <div class="note note-info">            <p>btn标识其为一个按钮，url是点击后跳转的外链，text是按钮显示的文本，title是鼠标悬停的文字，是个可选项。</p>          </div><p><strong>效果演示：</strong></p>  <a class="btn" href="http://baidu.com"  title="百度" target="_blank">我是一个可以跳到百度的按钮</a><h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2><p>  脚注可以使得我们很方便地标出文章中一些引用部分的出处或是相关的解释。脚注在生成的文章中被放置于文末，类似于参考文献，且带有锚点，我们点击即可到达标注处。</p><p><strong>用法</strong>：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br>这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br>这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup><br><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">第一处的脚注</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">第二处的脚注</span><br>[<span class="hljs-symbol">^3</span>]: <span class="hljs-link">第三处的脚注</span><br></code></pre></td></tr></table></figure><p>把上面代码段的内容贴到MD文档里是以下的<strong>效果</strong>：</p><p>这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br />这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br />这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>第一处的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>第二处的脚注<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>第三处的脚注<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud自学</title>
    <link href="/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>  由于Netfilx提供的服务组件停止维护了，因此选择了Alibaba提供的服务组件，本文会围绕着Nacos,Sentinel等组件来讲解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloudAlibaba</tag>
      
      <tag>Nacos</tag>
      
      <tag>Ribbon</tag>
      
      <tag>Hystrix</tag>
      
      <tag>Feign</tag>
      
      <tag>Zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自学</title>
    <link href="/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot的大时代"><a class="markdownIt-Anchor" href="#springboot的大时代"></a> SpringBoot的大时代</h1><hr /><h2 id="1-微服务"><a class="markdownIt-Anchor" href="#1-微服务"></a> 1. 微服务</h2><ul><li>微服务是一种架构风格</li><li>一个应用拆分为一组小型服务</li><li>每一个服务可以部署在自己的服务器上，运行在自己的进程内，也就是可以独立部署和升级，与单个应用无差</li><li>服务之间的交互使用轻量级的HTTP交互</li><li>服务围绕业务功能进行拆分</li><li>服务可以由全自动部署机制独立部署</li><li>去中心化（每一个服务可以用不同的语言来进行开发，也可以使用不同的存储技术）、服务自治</li></ul><p>而<strong>微服务的出现，将大应用拆分成多个小服务进行独立部署，会导致分布式的产生</strong></p><hr /><h2 id="2-分布式"><a class="markdownIt-Anchor" href="#2-分布式"></a> 2. 分布式</h2><p>问题：</p><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>…</li></ul><p>分布式的解决：SpringBoot + SpringCloud</p><h2 id="3-云原生"><a class="markdownIt-Anchor" href="#3-云原生"></a> 3. 云原生</h2><p>原生应用如何上云：Cloud Native</p><p>上云的困难：</p><ul><li>服务的自愈</li><li>弹性伸缩（拥塞）</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>…</li></ul><h1 id="springboot官方文档架构"><a class="markdownIt-Anchor" href="#springboot官方文档架构"></a> SpringBoot官方文档架构</h1><hr /><p><a href="Spring.io">Spring官方网址</a></p><p>可以通过官方网址的Projects&gt;SpringBoot进行SpringBoot的学习</p><p>其中OVERVIEW部分可以看到发布版本的更新情况以及更新的内容；LEARN则可以选择版本来进行对应的学习</p><p>本次学习所采用的是2.3.4版本的SpringBoot</p><h1 id="springboot2之helloworld"><a class="markdownIt-Anchor" href="#springboot2之helloworld"></a> SpringBoot2之HelloWorld</h1><p>系统要求：</p><ul><li>Java8及以上</li><li>Maven3.3+</li></ul><ol><li>配置Maven</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>HelloWorld</li></ol><p>需求：浏览发送/hello请求，响应Hello,SpringBoot2</p><p>①创建一个普通的Maven项目，编写POM</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ayy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot-01-helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 导入SpringBoot父工程，版本是2.3.4 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SpringBoot web开发启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②编写主程序类，在main&gt;java下创建com.ayy.boot.MainApplication Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类；主配置类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③编写controller类，并运行main方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">//@ResponseBody  //此注解用于表示此类的返回值均是写给浏览器的，而不是跳转某个页面等；</span><br><span class="hljs-comment">//@Controller</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>简化配置</li></ol><p>在resources下创建一个application.properties的配置文件，所有的配置如端口号等，都可以写此处，当运行时，SpringBoot会读取里面的配置,若是无更改的则按照SpringBoot默认的配置行事。</p><p>当不知道什么配置可以写于其中时，可参照官方文档中的Application Properties的内容来进行设置。</p><ol start="4"><li>简化部署</li></ol><p>maven项目默认是打包为jar包</p><p>SpringBoot所打包是一个<strong>可执行的jar包</strong>，通过以下插件配置即可实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过maven自带的lifestyle的clean和package进行打包操作</p><p>对打好的包通过cmd命令行执行 <code>java -jar 包名</code>即可执行之！！</p><p>注意：</p><ul><li>需要取消cmd的快速编辑模式</li></ul><p>最后展示一下此模块的目录结构：</p><p><img src="https://s2.loli.net/2021/12/13/sfYOvp6CVNwumB4.png" alt="目录结构" /></p><hr /><h1 id="springboot依赖管理特性"><a class="markdownIt-Anchor" href="#springboot依赖管理特性"></a> SpringBoot依赖管理特性</h1><ul><li>父项目做依赖管理(<strong>自动版本仲裁机制</strong>)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>//starter-parent里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>在spring-boot-dependencies这一项目里面，几乎声明了所有开发中常用的依赖的版本号,此即为自动版本仲裁机制<br></code></pre></td></tr></table></figure><ul><li>开发导入starter场景启动器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. spring-boot-starter-* : 此即代表某种场景<br>2. 只要引入starter，这个场景的所有常规需要的依赖我们都会自动导入<br>3. SpringBoot所有支持的场景：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter<br>4. 见到的 *-spring-boot-starter : 是第三方为我们提供的简化开发的场景启动器<br>5. 所有场景启动器最底层的依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">引入依赖默认都可以不写版本号，除非引入的依赖是非版本仲裁的jar，则一定要写版本号<br></code></pre></td></tr></table></figure><ul><li>可以修改版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 查看spring-boot-dependencies里面规定的当前依赖的版本所用的关键字<br>2. 在当前项目里面重写配置<br><br>注：利用的时MAVEN提供的特性：就近优先原则<br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.43<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="springboot自动配置特性"><a class="markdownIt-Anchor" href="#springboot自动配置特性"></a> SpringBoot自动配置特性</h1><ul><li><p>自动配置tomcat（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入tomcat依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置tomcat</li></ol></blockquote></li><li><p>自动配置SpringMVC（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入了SpringMVC全套组件</li><li>自动配好SpringMVC常用组件(功能)</li></ol></blockquote></li><li><p>自动配好Web常见功能，如：字符编码问题</p><blockquote><p>SpringBoot帮我们配置好了所有web开发时的常见场景</p></blockquote></li><li><p>默认的包结构</p><blockquote><ul><li>主程序所在的包及其下边的所有的子包都能被扫描（即无需配置包扫描，此为默认的包扫描规则）</li><li><strong>如果想要改变包扫描路径，可以通过在@SpringBootApplication(scanBasePackages=“com.ayy”)来改变</strong></li><li>或者通过一个@ComponentScan来指定扫描的路径，但此时因SpringBootApplication已经使用了其，故暂时不能将其与之写于一起来进行包扫描路径的替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>等同于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.ayy&quot;)</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>各种配置都拥有默认值</strong></p></li></ul><blockquote><p>默认配置最终都是映射到某一个类上的</p><p>配置文件的值会绑定到某一个类上，这个类会在容器中创建对象</p></blockquote><ul><li><strong>按需加载所有自动配置项</strong></li></ul><blockquote><p>引入了哪些场景，这个场景的自动配置才会开启</p><p>SpringBoot的所有自动配置功能都在spring-boot-autoconfigure包里面</p></blockquote><hr /><h1 id="底层注解-configuration组件添加解析"><a class="markdownIt-Anchor" href="#底层注解-configuration组件添加解析"></a> 底层注解-@Configuration(组件添加)解析</h1><hr /><p>在之前，我们对Spring进行一个组件的注册是通过在spring.xml配置文件里增添如下内容实现，在表示配置spring.xml之前，先进行两个类的构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*User类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*Pet类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pet&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过spring.xml对其中的bean进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Pet&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上便是<strong>Spring通过配置文件的方式，来实现组件的注册，经注册的组件可以在容器中找到</strong></p><p>而<strong>在SpringBoot中，可以通过@Configuration这个注解来替代spring.xml配置文件，即用一个含有@Configuration注解的类来进行组件的注册，而在需要注册的组件上，只需要通过@Bean注解来声明即可</strong>，如下类MyConfig所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.config;<br><br><span class="hljs-keyword">import</span> com.ayy.boot.bean.Pet;<br><span class="hljs-keyword">import</span> com.ayy.boot.bean.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 告诉SpringBoot这是一个配置类（配置类就等于配置文件）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 给容器中添加组件，以方法名作为组件的id,返回类型就是组件类型。返回的值就是组件在容器中的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*被@Bean注解所注的方法的返回值即是注册在容器中的组件的实例对象，方法名即为实例对象的id，若是不满方法名作为对象id,可以在@Bean(&quot;myName&quot;)中进行组件id的重写</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>需要特别注意的是：<strong>此时我们所注册在容器中的组件都是单例的</strong>，无论你通过容器如何getBean或多次getBean，甚至直接获取MyConfig组件（<strong>因其也是在配置文件下的类，故其也被注册在容器里</strong>）直接进行方法的调用，也依旧是单例！！</p><p>​这个单例的构成，与**@Configuration注解下的proxyBeanMethods的默认值为true有直接关系**，proxyBeanMethods即意为<strong>代理Bean方法</strong>，在其为true的情况下，我们通过getBean获得的MyConfig类的实例对象其实是<strong>代理对象</strong>，也即通过这个代理对象，我们无论怎么去调用对象里的方法，也只是从容器里面获取对应的组件而已；当<strong>代理Bean方法</strong>值为false时，才会是个普通的对象，通过调用其中方法，获得的实例则不相同。</p><p>​以下部分是体现代理对象调用方法后所得组件为容器中组件且为单例的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>        <span class="hljs-comment">// 查看容器里的组件</span><br>        String[] names = run.getBeanDefinitionNames();<span class="hljs-comment">// 获取容器中组件的实例对象的名字</span><br>        <span class="hljs-keyword">for</span>(String name:names)<br>            System.out.println(<span class="hljs-string">&quot;NANE: &quot;</span>+name);<br>   <span class="hljs-comment">// 从容器中获取组件</span><br>        MyConfig myConfig = run.getBean(MyConfig.class);<br>        Pet jerry = run.getBean(<span class="hljs-string">&quot;jerry&quot;</span>, Pet.class);<br>        System.out.println(jerry==myConfig.tom());<br>        System.out.println(myConfig);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注：当我们打出myconfig的内容时，会发现其打印的内容为：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig$$EnhancerBySpringCGLIB$$8a7037ca@7ea4d397</span><br><span class="hljs-comment">并非一个单纯的类，而在其中还夹杂了EnhancerBySpringCGLIB,即其被SpringCGLIB所提升，而很自然联想到是被提升为代理对象</span><br><span class="hljs-comment">小贴士：在Spring中一般这种事是jdk干的，但在SpringBoot中，这种事交由CGLIB干</span><br><span class="hljs-comment">而当我们修改MyConfig的注解为@Configuration(proxyBeanMethods=false)时，再运行程序，可以发现：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig@62d0ac62</span><br><span class="hljs-comment">此时则为一个普通的容器中的组件</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>proxyBeanMethods:代理bean的方法根据true/false，有以下两种模式：</p><ul><li>Full(proxyBeanMethods=true) 全模式</li><li>Lite(proxyBeanMethods=false) 轻量级模式，因为不像全模式，在<strong>构建</strong>时需要查询容器中是否存在该实例，加快了运行速度，故为轻量级</li></ul><p>在此处举一个单例的实例：比如我们的User里有一个成员变量是Pet，它们两个都是在容器中获得的组件，且此为<strong>User依赖Pet</strong>，那么通过单例，可以很好地体现这么一个<strong>依赖关系</strong>，因为User所占有的Pet，也是容器里面所独有的Pet，不存在这些个Pet相异的情况。</p><p><strong>因此：当没有依赖组件时则用Lite轻量级模式；当需要依赖时，则需要使用Full全模式。</strong></p><p><strong>注：根据后面的学习来看，轻量级模式下的自动类配置，它的参数的获取，有大概率的可能是通过容器中获取。若是自己写的配置类（如笔者自己的MyCofig），使这个代理bean方法失效后，因笔者没有传入参数，故没有进行进一步的测试。<em>因此笔者猜测：SpringBoot在处理配置类的参数时，直接获取的是容器中已有的组件，若是构建当前组件的实例，则对Full会进行单例查询，而对Lite则不查询，直接放入容器中。但随之而来的问题是：自动获取的传入参数如何保证是我们所想要的哪个呢？而框架本身的因为是与配置文件相绑定，所以只要是获取到的实参，都是所需的。</em></strong></p><p>2021.9.7看，不懂上面的注说的啥</p><h1 id="底层注解-import导入组件解析"><a class="markdownIt-Anchor" href="#底层注解-import导入组件解析"></a> 底层注解-@Import(导入组件)解析</h1><hr /><p>除了上面所说的@Configuration加上@Bean可以给容器注册组件外，还有之前的@Component（表示为一个组件）、@Controller（表示为一个控制器）、@Service（表示为一个业务逻辑组件）、@Repository(代表它是一个数据库层组件)都能用。</p><p>@ComponentScan就是通过指定包扫描路径来实现组件导入，因为告知了Spring该去哪里扫描即哪里找可能是组件的类</p><p><strong>@Import是给容器导入组件，可以写在配置类中或组件类中</strong></p><p><strong>它的参数是一个数组，这个数组里面写的是想要导入到容器中的组件的类型，它会<u>调用该类的无参构造器来构造出该类的对象加入到容器中，所默认使用的id，即BeanName是全类名</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先在配置类MyConfig里写下以下内容，以在容器中导入对应的类实例对象</span><br><br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean(&quot;jerry&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-comment">// 之后我们通过MainApplication来打印导入的类，查看其打印情况</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 查看Import注解导入的组件的名字</span><br>        String[] beanNames = run.getBeanNamesForType(User.class);<br>        System.out.println(<span class="hljs-string">&quot;&lt;====================================&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(String bean:beanNames)<br>            System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + bean);<br>        DBHelper dbHelper = run.getBean(DBHelper.class);<br>        System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + dbHelper);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 打印结果如下：</span><br>&lt;====================================&gt;<br>bean:com.ayy.boot.bean.User<br>bean:user01<br>bean:ch.qos.logback.core.db.DBHelper@1d81e101<br>不难看出，我们通过导入进去的默认BeanName即我们在Spring.xml注册的id即为全类名，且其为无参构造得到的。<br><br></code></pre></td></tr></table></figure><h1 id="底层注解-conditional条件装配"><a class="markdownIt-Anchor" href="#底层注解-conditional条件装配"></a> 底层注解-@Conditional条件装配</h1><hr /><p><strong>条件装配：满足Conditional指定的条件，则进行组件注入</strong>！！！</p><img src="https://s2.loli.net/2021/12/13/SG6y5Umhs1oxv3p.png" alt="Conditional相关注解.png" style="zoom:67%;" /><p>Conditional是个根注解，其下的许多注解可以按照名字的意思来进行对应的测试，下面的例子用@ConditionalOnBean来实现，其意为，当某个Bean存在时，则执行下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>通过对<span class="hljs-meta">@Bean</span>注解注释，使之不会注册到容器中，以下为此例的验证<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用注册到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 通过输出结果即证明了没有加上注解@Bean的Javabean不会注册到容器中。则根据这一规则我们可以进行下面的测试</span><br>    <br>    <br><span class="hljs-number">2.</span> 当tom存在时，才注册user01到容器中，否则不注册<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@ConditionalOnBean(name=&#123;&quot;tom&quot;&#125;)</span><span class="hljs-comment">// 当容器中有个名为tom的组件时，才执行user01组件注册到容器中，否则不注册到容器中</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用，注入到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;    <br>   <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">false</span><br><span class="hljs-comment">// 通过结果可以得出，当名为tom的组件在容器中找不到时，user01也不会注册到容器中，此注解也可以放置到类上，以期满足某种条件，才执行类中的组件的注册。</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-importresource导入spring配置文件"><a class="markdownIt-Anchor" href="#底层注解-importresource导入spring配置文件"></a> 底层注解-@ImportResource导入Spring配置文件</h1><hr /><p>@ImportResource用于向SpringBoot中导入Spring的配置文件：spring.xml，即通过此注解可以将无法被SpringBoot所理解的组件注册到容器中。<strong>此注解写于配置类上即可</strong></p><p>以下为一实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>当在配置类MyConfig中没有加上此注解时：<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLUser&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.User&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&quot;</span>&gt;&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;18&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLPet&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.Pet&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&#x27;s pet&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br><span class="hljs-comment">// 上述为spring.xml中的注册组件</span><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>    <span class="hljs-comment">// 对IOC容器进行查询，根据BeanName查询</span><br>        <span class="hljs-keyword">boolean</span> springXMLUser = run.containsBean(<span class="hljs-string">&quot;springXMLUser&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLUser:&quot;</span> + springXMLUser);<br>        <span class="hljs-keyword">boolean</span> springXMLPet = run.containsBean(<span class="hljs-string">&quot;springXMLPet&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLPet:&quot;</span> + springXMLPet);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 输出结果为：</span><br>springXMLUser:<span class="hljs-keyword">false</span><br>springXMLPet:<span class="hljs-keyword">false</span><br>    <br><span class="hljs-comment">// 我们对配置类MyConfig进行@ImportResource(&quot;classpath:spring.xml&quot;)注解标识后，再运行，可得如下输出结果</span><br>springXMLUser:<span class="hljs-keyword">true</span><br>springXMLPet:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 此时即实现了对spring中的组件进行了注册</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-configurationproperties配置绑定"><a class="markdownIt-Anchor" href="#底层注解-configurationproperties配置绑定"></a> 底层注解-@ConfigurationProperties配置绑定</h1><p>在以前，我们对一些常规配置的内容是写在my.properties中然后通过绑定的机制来将之内容写入Javabean中，这个过程较为繁琐，而<strong>在SpringBoot中，我们可以通过将配置信息写在application.properties，然后通过注解@ConfigurationProperties来实现绑定</strong>，且绑定的形式有两种！下图是之前绑定的方法的一个流程显示：</p><p><img src="https://s2.loli.net/2021/12/13/AK9Fbc8GnCDaBLJ.png" alt="ConfigurationProperties.png" /></p><p>法①</p><p>通过在Javabean类Car中进行注解：@Component 和 @ConfigurationProperties(prefix = “mycar”) 来实现配置文件中的内容与该Javabean的绑定，并注册为容器中的一个组件。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*   只有在容器中的组件，才能使用SpringBoot提供的强大功能，因此需要通过@Component注解来将这个组件加入到容器中，</span><br><span class="hljs-comment">*   然后对prefix为mycar的配置内容进行获取</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&#x27;&quot;</span> + price + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String brand, String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 以下内容是application.properties的配置内容：</span><br>server.port=<span class="hljs-number">8888</span><br><br>mycar.brand=TESLA<br>mycar.price=<span class="hljs-number">280000</span><br>    <br><span class="hljs-comment">// 接着我们在HelloController类中通过映射请求来实现这个绑定的体现：</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Car car;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/car&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">myCar</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> car;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 紧接着我们访问 localhost:8888/car 即可获得输出于浏览器上的结果</span><br>&#123;<span class="hljs-string">&quot;brand&quot;</span>:<span class="hljs-string">&quot;TESLA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-string">&quot;280000&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>法②</p><p><strong>删去Car类中的@Component组件并通过在MyConfig这个配置类中增加注解@EnableConfigurationProperties(Car.class)来开启Car类的属性配置功能</strong></p><p>其中@EnableConfigurationProperties的作用有如下两点：</p><blockquote><ol><li><strong>开启Car组件的配置绑定功能</strong></li><li><strong>把Car这个组件自动地注册到容器中</strong></li></ol></blockquote><p><strong>此类用法多用于我们使用第三方的jar包中的类的时候，我们不能轻易地去修改别人的源代码，因此可以通过这样的方式来实现组件的配置绑定及加载到容器中。</strong></p><hr /><h1 id="自动配置-自动包规则原理"><a class="markdownIt-Anchor" href="#自动配置-自动包规则原理"></a> 自动配置-自动包规则原理</h1><hr /><p>自动包配置原理，是在SpringBoot应用下才生效的，即在SpringBoot应用下，可以自动加载配置类，即会自动往容器中导入组件，那么这个实现得从注解@SpringBootApplication先看起；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>&lt;=====&gt;等价于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br>接下来我们对它们逐个解析<br></code></pre></td></tr></table></figure><ol><li>@SpringBootConfiguration</li></ol><p><strong>往此注解内部点去，可以发现其内部的核心是@Configuration，即注明此类是配置类</strong>，也就是说，我们的<strong>MainApplication类也是配置类</strong></p><ol start="2"><li>@ComponentScan</li></ol><p>此即为自动包扫描的配置，配置其下的目录及其子包都会被扫描</p><ol start="3"><li><strong>@EnableAutoConfiguration</strong></li></ol><p>我们通过Ctrl+左键点击进去后发现，@EnableAutoConfiguration注解由如下注解组成：</p><ul><li><p><strong>@AutoConfigurationPackage</strong></p></li><li><p><strong>@Import({AutoConfigurationImportSelector.class})</strong></p></li></ul><p>我们先着重说一下，@AutoConfiguraionPackage这个注解！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们点进去@AutoConfigurationPackage这个注解有以下内容</span><br><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br><span class="hljs-comment">// 我们发现，@AutoConfiguraionPackge里的注解是导入了Registrar组件，那么导入组件则是一个一个导入，我们先继续点进去该类看下</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>        Registrar() &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>            AutoConfigurationPackages.register(registry, (String[])(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//上面是这个类的方法，我们看第一个方法registerBeanDefinitions()，传入的第一个参数metadata是一个注解元数据类型，所获取到的其实质是这个注解所注的类的元数据信息，而这个注解是合成注解，因此所获取到的是MainApplication这个标注了@SpringBootApplication注解的类，再看该方法里面的内容，它通过metadata获取到了我们主类的包名，然后还给它弄成了一个数组，对这个包名下的组件进行了注册！！</span><br></code></pre></td></tr></table></figure><p>由此可见，我们自动包规则原理，便是基于这个<strong>Registrar</strong>这个类，利用这个类，给容器导入一系列的组件。将指定的标注了这个注解（@AutoConfiguraionPackage）或利用之合成的注解(@EnableAutoConfiguraion或@SpringBootApplication)的类<strong>所在的包进行了组件注册</strong>！！</p><h1 id="自动配置-初始加载自动配置类"><a class="markdownIt-Anchor" href="#自动配置-初始加载自动配置类"></a> 自动配置-初始加载自动配置类</h1><hr /><p>上面我们解释了@EnableAutoConfiguraion中的@AutoConfiguraionPackage，紧接着我们讲一下另一个注解@Import({AutoConfigurationImportSelector.class})，我们来详细谈一下这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>在进入AutoConfigurationImportSelector类后，我们看到一个方法：<br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata)&#123;...&#125;，其中该方法有一行代码是：getAutoConfigurationEntry(annotationMetadata);<span class="hljs-comment">// 此方法用于给容器批量导入一批组件</span><br><span class="hljs-number">2.</span>上面所说的那个给容器批量导入一批组件的方法，其内调用了：<br>    List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<span class="hljs-comment">// 通过调用此方法获取到所有需要导入到容器中的配置类</span><br><span class="hljs-number">3.</span>上述的那个方法是怎么知道导入这些需要导入的配置类的呢？往里面点，我们发现：<br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br><span class="hljs-comment">// 它利用工厂加载来加载内容，那么所加载的内容是什么呢？</span><br><span class="hljs-number">4.</span>再往下点击，可以发现其所加载的内容是：<br>    Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)&#123;...&#125;;<span class="hljs-comment">// 即通过一个Map来获取到所有的组件</span><br><span class="hljs-number">5.</span>那么这些组件是从哪里得到并加载的呢？通过以下对loadSpringFactories的debug过程便可略知一二：<br>     Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<span class="hljs-comment">// 不难看出，它是从一个META-INF/spring.factories的位置来加载文件。Spring会默认扫描我们当前系统里面所有的META-INF/spring.factories位置的文件！！</span><br><span class="hljs-number">6.</span>我们可以通过External Libraries来找对应的存在META-INF/spring.factories位置的jar包，查看其中内容。而最核心的包便是spring-boot-autoconfigure这个包。通过对这个包的内容进行查看，看到其下META-INF/spring.factories中有一行注为Auto Configure的内容，其后紧跟着<span class="hljs-number">127</span>个自动配置类！！也就是说，文件里面写死了spring-boot一启动就要加载到容器中的所有配置类。<br><span class="hljs-number">7.</span>我们可以通过getBeanDefinitionCount()来查看的确是有这<span class="hljs-number">127</span>个组件的存在，那么此时又存在另一个问题：它那么大，不应该会导致系统很卡嘛？<br>    虽然我们<span class="hljs-number">127</span>个场景的所有自动配置启动的时候默认全部加载，但最终会按需配置！！！<br>    这个按需配置就是利用了之前所学的条件装配规则！！！（<span class="hljs-meta">@ConditionnalOnClass(使用者所需要导入的类.class)</span>）<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/13/O3bjzpPL7FcgJBf.png" alt="AutoConfigurationImportSelector.png" /></p><center>上图不难看出，默认导入的组件有127个之多。</center><h1 id="自动配置中一些有趣的东西"><a class="markdownIt-Anchor" href="#自动配置中一些有趣的东西"></a> 自动配置中一些有趣的东西</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">            name = &#123;&quot;multipartResolver&quot;&#125;</span><br><span class="hljs-meta">        )</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> resolver;<br>        &#125;<br><span class="hljs-comment">// 上面这就是MultipartResolver文件上传解析器,当容器中有该类并且找不到该类名为multipartResolver的组件时，则通过下面的函数，利用参数由容器中获取，然后将之返回，并将其名字改为函数名即multipartResolver，然后重新放回到容器中！</span><br><span class="hljs-comment">// 此例用于将不规范的文件上传解析器名字进行更改，以规范化！</span><br></code></pre></td></tr></table></figure><p><strong>SpringBoot默认会在底层配好所有的组件，但是如果用户自己配置了的话，则就以用户的优先</strong><br />下面以字符配置(HttpEncodingAutoConfiguration)为例，并先对默认配置进行解释，再展示自我配置的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix=&quot;server.servlet.encoding&quot;,value = &#123;&quot;enabled&quot;&#125;,matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(ServerProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getServlet().getEncoding();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br><span class="hljs-comment">/*...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​从上面的源码中我们可以得知HttpEncodingAutoConfiguration是一个配置类，且其开启了类ServerProperties的配置绑定，并将之加入于容器中，然后我们的是Web项目，且是类型为Servlet的，又因为自动导入了SpringMVC,因此对应的CharacterEncodingFilter类也存在，最后的注解标识是实不实现都可以，因此满足自动配置此类的条件，则可以继续往下执行！<br />​它的构造函数会从刚刚加入到容器中的ServerProperties组件获取，然后把一些内容交予本类的成员properties，之后的characterEncodingFilter()这个函数，则利用该成员进行字符编码的设置！！<strong>由此可见，若想通过DIY方式配置SpringBoot的环境，可以通过修改配置文件（即application.properties）来实现；</strong></p><p>​当然也可以通过接下来的手段实现，<strong>因为在进行组件的注册时，其有条件装配规定的约束，当容器中无该类才执行，即若是使用者自行注册，则不会再次于其中注册</strong>，此即满足了<strong>用户优先原则，且也为我们DIY配置环境提供了一个方法，就是自己定义配置类进行注册</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以下以字符编码CharacterEncodingFilter类为例，先展示无修改任何配置的情况下的正常输出：</span><br><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span> + name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 当我们在浏览器中键入：&#x27;localhost:8888/hello?name=张三&#x27; 则在浏览器中会显示&#x27;Hello,SpringBoot2!张三&#x27;，由此可见SpringBoot默认在底层的确给我们配置好了所有组件！</span><br><br><span class="hljs-comment">// 接下来，通过修改配置文件application.properties来进行乱码操作！</span><br>我们通过查找HttpEncodingAutoConfiguration类发现其prefix为server.servlet.encoding，然后在application.properties中进行修改，将之修改为server.servlet.encoding.charset=ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span><br>则通过浏览器进行输入测试，会发现，已乱码为：Hello,SpringBoot2!??<br>    由此可见，配置文件DIY便利着实有效！<br><br><span class="hljs-comment">// 接下来，通过自定义配置类，然后注册组件实现字符编码DIY</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br><span class="hljs-comment">//上述代码实则在运行的时候会报错，因为该组件在底层其他部分也有重要的应用，但可以通过这种方法注册组件，而不是使用系统默认的组件配置。</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>SpringBoot先加载所有的自动配置类（xxxAutoConfiguration）</p></li><li><p>每个自动配置类按照条件装配进行生效，默认都会“绑定”配置文件指定的值，这个绑定是通过利用参数xxxProperties(这是个类，用于配置属性绑定的)获得的。xxxProperties和它对应的配置文件进行了配置绑定！</p></li><li><p>生效的配置类就会给容器中装配组件</p></li><li><p>只要容器中有这些组件，相当于拥有了这些功能</p></li><li><p>只要用户有自己配置的，就以用户的优先</p></li><li><p>定制化配置（DIY配置）</p><blockquote><p>用户通过自定义配置类再通过@Bean注解来使用自己想配置的组件</p><p>用户通过看底层源码对应的xxxProperties中的prefix来获取前缀，通过application.properties来进行修改（结合tab提示）</p></blockquote></li></ul><p>xxxAutoConfiguration(自动配置类) —&gt; 导入了一大堆组件 —&gt; 通过xxxProperties去获取值 —&gt; 通过application.properties去重设置值</p><hr /><h1 id="springboot编写逻辑"><a class="markdownIt-Anchor" href="#springboot编写逻辑"></a> SpringBoot编写逻辑</h1><ol><li>引入对应的场景依赖<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">spring-boot-starter-xxx</a></li></ul></li><li>查看自动配置了哪些组件<ul><li>自行分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true<strong>开启自动配置报告</strong> Negative(不生效) / Positive(生效)</li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/appendix-application-properties.html#common-application-properties">文档地址</a></li></ul></li><li>自行分析，xxxProperties绑定的配置文件的前缀，然后找到注入的部分</li><li>自定义加入或者替换组件<ul><li>@Bean@Component</li></ul></li><li>自定义器xxxCustomizer(目前IDon’tKnow)</li><li>…</li></ul></li></ol><hr /><h1 id="开发小技巧-lombok"><a class="markdownIt-Anchor" href="#开发小技巧-lombok"></a> 开发小技巧-Lombok</h1><p>Lombok这个东西可用于简化JavaBean的开发</p><p>安装依赖及插件的过程如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">1.依赖安装<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.插件安装，通过Settings&gt;Plugins下搜索lombok进行安装即可！</p><p>lombok的几个重要注解：</p><ul><li>@Getter/@Setter:作用于类上，生成所有成员变量的get/set方法；作用于成员变量上，则只对该变量生成get/set方法。可以设置访问权限（@Getter(value=“AccessLevel.PUBLIC”)）和是否懒加载。</li><li>@ToString:会自动给Javabean的成员变量们构造toString函数，可以通过of/exclude来指定/排除某些成员变量生成于toString方法中。</li><li>@EqualsAndHashCode:生成equals和hashcode方法。</li><li>@NoArgsConstructor:自动给Javabean创造无参构造器</li><li>@AllArgsConstructor:自动给Javabean创造全参构造器</li><li>@RequiredArgsConstructor:生成包含final和@NonNull注解的成员变量构造器</li><li>@Data:@Getter+@Setter+@ToString+@EqualsAndHashCode+@RequiredArgsConstructor</li><li>@Builder:作用于类上，快速地为类实现建造者模式。可以链式赋值（初始化的时候），若是需要修改要么通过set，要么在实体类的@Builder(toBuilder=true)，但它会返回一个全新的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user = User.builder().id(<span class="hljs-number">1</span>).username(<span class="hljs-string">&quot;ayy&quot;</span>).build();<br></code></pre></td></tr></table></figure><ul><li>@Slf4j:给类注入日志类，<a href="http://xn--log-u68dx6aq0u2xfq43ed1nol0brja.info">以后在该类中调用log.info</a>()便可将内容通过日志输出，而不用sout输出于控制台下</li></ul><p>注：若需部分成员构造器，则可以自行编写或利用IDEA的自动编写功能</p><hr /><h1 id="开发小技巧-dev-tools"><a class="markdownIt-Anchor" href="#开发小技巧-dev-tools"></a> 开发小技巧-dev-tools</h1><p>此物需要增加依赖于pom.xml中，用于制造伪热更新（实质通过restart形式实现，而热更新是通过reload形式实现），以下是其依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们修改我们的代码文件后，不需要通过关闭再打开项目来实现刷新，而直接通过Ctrl + F9重新编译项目即可，然后就实现了刷新！</p><p>如果想要使用真正的热更新，可以付费购买插件JRebel。</p><hr /><h1 id="开发小技巧-spring-initializer"><a class="markdownIt-Anchor" href="#开发小技巧-spring-initializer"></a> 开发小技巧-Spring Initializer</h1><p>创建SpringBoot项目通过File&gt;New&gt;Project&gt;Spring Initializer以GUI界面创建SpringBoot，其中要啥starter就自行勾选啥，然后创建的时候要联网，会自动帮你导jar包（就是自动添加依赖啦）。</p><p>不过一开始关于mvn和.gitignore不会用到，删去即可。</p><p>而在src下，我们可以看到src&gt;main&gt;java + resources。在resources目录下，可以看到application.properties + static(包)  + templates(包)</p><p>static包用于存储静态资源，如css 、js；templates包用于存放页面</p><hr /><h1 id="配置文件-yaml用法"><a class="markdownIt-Anchor" href="#配置文件-yaml用法"></a> 配置文件-yaml用法</h1><hr /><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><ul><li>key: value #k，v之间有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li><li>‘’ 与 “” 表示字符串内容，会比如 转义/不转义</li></ul><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li>字面量：单个的、不可再分的值 Date、Boolean、String、number、null</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">k: v<br></code></pre></td></tr></table></figure><ul><li>对象：键值对的集合。 map、hash、set、object</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;<br>或<br>k:<br> k1: v1<br> k2: v2<br> k3: v3<br></code></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: [v1,v2,v3]<br>或<br>k:<br> - v1<br> - v2<br> - v3<br></code></pre></td></tr></table></figure><h1 id="配置文件-自定义类绑定的配置提示"><a class="markdownIt-Anchor" href="#配置文件-自定义类绑定的配置提示"></a> 配置文件-自定义类绑定的配置提示</h1><hr /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加如下依赖:<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>在build&gt;plugins下的spring-boot-maven-plugin插件内添加如下配置，以在打包时舍弃之，减少包的大小<br><span class="hljs-tag">&lt;<span class="hljs-name">configuraion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuraion-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuraion</span>&gt;</span><br></code></pre></td></tr></table></figure><hr /><h1 id="web-静态资源规则与定制化"><a class="markdownIt-Anchor" href="#web-静态资源规则与定制化"></a> Web-静态资源规则与定制化</h1><h2 id="1-静态资源目录"><a class="markdownIt-Anchor" href="#1-静态资源目录"></a> 1. <strong>静态资源目录</strong></h2><p>只要静态资源放在类路径下：</p><p><code>/static</code>(or<code>/public</code>or<code>/resources</code>or<code>/META-INF/resources</code>)</p><p>则可以直接通过：当前项目根路径/ + 静态资源名 <strong>进行访问</strong></p><p><strong>原理：静态映射/**，即拦截所有的请求，而controller也是如此。</strong></p><p><strong>在运行的时候，请求进来，先去找controller看能不能处理，不能处理的所有请求则交给静态资源处理器，若是静态资源处理器也无法处理则报告404</strong></p><p><strong>改变默认的静态资源路径：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">static-locations:</span> [<span class="hljs-string">classpath:/xxx/</span>]<br></code></pre></td></tr></table></figure><h2 id="2-静态资源访问前缀"><a class="markdownIt-Anchor" href="#2-静态资源访问前缀"></a> 2. <strong>静态资源访问前缀</strong></h2><p>默认无前缀。</p><p>之所以要使用这个东西是因为，如果是一个web项目，需要登录后才可以执行某一些操作，若是拦截器拦截/**，则静态资源也会被拦截。为了拦截器可以放行静态资源，因此可以通过静态资源加上访问前缀来过滤掉它们。</p><p>可以通过如下方式在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/res/**</span><br></code></pre></td></tr></table></figure><h2 id="3-支持webjar静态资源访问"><a class="markdownIt-Anchor" href="#3-支持webjar静态资源访问"></a> 3. <strong>支持webjar静态资源访问</strong></h2><p>webjar即是将如css、js等文件通过jar包的形式给出，可通过依赖获得</p><p><a href="https://www.webjars.org/">获取webjar</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以下是一个jQuery的webjar的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>访问形式：localhost:8080/webjars/…(资源详细路径)</p><hr /><h1 id="web-welcome与favicon功能"><a class="markdownIt-Anchor" href="#web-welcome与favicon功能"></a> Web-welcome与favicon功能</h1><h2 id="1-欢迎页支持"><a class="markdownIt-Anchor" href="#1-欢迎页支持"></a> 1. 欢迎页支持</h2><p>用于直接ip:port访问项目，会显示index.html欢迎页</p><ul><li>静态资源路径下放置index.html<ul><li><strong>可以配置静态资源路径</strong></li><li><strong>不可以配置静态资源访问前缀，否则会导致index.html不能默认访问</strong></li></ul></li></ul><h2 id="2-自定义favicon"><a class="markdownIt-Anchor" href="#2-自定义favicon"></a> 2. 自定义Favicon</h2><p>用于更改web项目的小图标，这个在静态资源路径下放置favicon.ico即可，需注意浏览器缓存可能导致的无法显示。同样的也<strong>不可以配置静态资源的访问前缀</strong>，否则会导致其失效</p><hr /><h1 id="静态资源配置原理"><a class="markdownIt-Anchor" href="#静态资源配置原理"></a> 静态资源配置原理</h1><ul><li><p>SpringBoot启动默认加载 xxxAutoConfiguration类(自动配置类)</p></li><li><p>SpringMVC功能的自动配置类 WebMvcAutoConfiguration生效</p><ul><li>那么它给容器中配了些什么呢？</li></ul><p>比如：OrderedHiddenHttpMethodFilter(用来兼容rest风格，表单可以提交PUT、DELETE等)、OrderedFormContentFilter(表单内容过滤器)，然后有一个叫做WebMvcAutoConfigurationAdapter这么一个配置类（那么它肯定也在容器中）。接下来研究一下它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>先看到配置文件，它让WebMvcProperties和ResourceProperties跟对应的配置文件绑定。<strong>spring.mvc==WebMvcProperties 、spring.resources==ResourceProperties</strong></li></ul></li></ul><p>​1. <strong>配置类只有一个有参构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有参构造器所有参数的值都会从容器中确定</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* resourceProperties 获取和spring.resources绑定的所有值的对象</span><br><span class="hljs-comment">* mvcProperties 获取和spring.mvc绑定的所有值的对象</span><br><span class="hljs-comment">* beanFactory Spring的bean工厂</span><br><span class="hljs-comment">* HttpMessageConverters 找到所有的HttpMessageConverters</span><br><span class="hljs-comment">* ResourceHandlerRegistrationCustomizer 找到资源处理器的自定义器</span><br><span class="hljs-comment">* DispatcherServletPath</span><br><span class="hljs-comment">* ServletRegistrationBean 注册servlet、filter...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span><span class="hljs-params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.resourceProperties = resourceProperties;<br>            <span class="hljs-keyword">this</span>.mvcProperties = mvcProperties;<br>            <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>            <span class="hljs-keyword">this</span>.messageConvertersProvider = messageConvertersProvider;<br>            <span class="hljs-keyword">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();<br>            <span class="hljs-keyword">this</span>.dispatcherServletPath = dispatcherServletPath;<br>            <span class="hljs-keyword">this</span>.servletRegistrations = servletRegistrations;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>资源处理的默认规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>       <span class="hljs-comment">// isAddMapping这个玩意是看你要不要使用静态资源的默认规则，可以通过spring.resources.add-mappings来选择使用或关闭，默认使用</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这个是用来设置静态资源的缓存的存活时间，可以通过spring.resources.cache.period设置</span><br>                Duration cachePeriod = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getPeriod();<br>                CacheControl cacheControl = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();<br>                <span class="hljs-comment">// 注册/webjars/**静态资源，且说明其资源路径是META-INF/resources/webjars下，那么之后访问webjars资源则通过访问/webjars/所需访问的资源的层级目录即可！所以这里是webjars的规则（/webjars/**的所有请求，通过类路径下的/META-INF/resources/webjars下拿）</span><br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">&quot;/webjars/**&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br>   <span class="hljs-comment">// 这一段是对静态资源默认路径的配置，先通过mvcProperties获取/**下的所有请求，通过getStaticLocations获取的区域下面拿取静态资源。静态资源都有缓存策略</span><br>                String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();<br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>欢迎页的处理规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HandlerMapping:处理器映射，保存了每一个handler能处理哪些的请求 </span><br><span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title">welcomePageHandlerMapping</span><span class="hljs-params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;<br>            WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="hljs-keyword">new</span> WelcomePageHandlerMapping(<span class="hljs-keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="hljs-keyword">this</span>.getWelcomePage(), <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern());<br>            welcomePageHandlerMapping.setInterceptors(<span class="hljs-keyword">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));<br>            welcomePageHandlerMapping.setCorsConfigurations(<span class="hljs-keyword">this</span>.getCorsConfigurations());<br>            <span class="hljs-keyword">return</span> welcomePageHandlerMapping;<br>        &#125;<br><br><span class="hljs-comment">// 以下是欢迎页处理器映射的构造函数，不难看出，它写死了欢迎页只能在/**下</span><br>WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;<br>    <span class="hljs-comment">// 欢迎页存在且/**等于静态资源路径才可以使用之，否则不行</span><br>        <span class="hljs-keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="hljs-string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;forward:index.html&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page template: index&quot;</span>);<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="请求参数处理"><a class="markdownIt-Anchor" href="#请求参数处理"></a> 请求参数处理</h1><h2 id="请求映射这里说的不是requestmapping而是rest风格的请求映射注解"><a class="markdownIt-Anchor" href="#请求映射这里说的不是requestmapping而是rest风格的请求映射注解"></a> 请求映射(这里说的不是RequestMapping,而是Rest风格的请求映射注解)</h2><ul><li>@xxxMapping</li><li>Rest风格支持*(使用<strong>HTTP请求方式动词</strong>来表示对资源的操作)*<ul><li>以前是通过：/getUser获取用户 /deleteUser删除用户 /editUser修改用户 /saveUser保存用户</li><li>现在是通过： /user （就只这一个访问路径）<ul><li>GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户</li></ul></li><li>核心Filter：HiddenHttpMethodFilter<ul><li><strong>用法： 表单method=post , 隐藏域type=hidden,_method=PUT</strong></li><li><strong>需注意还需要手动开启：spring.mvc.hiddenmethod.filter.enable=true；</strong></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br><br><br>源码部分：<br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span><br>   <span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">       prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span><br><span class="hljs-meta">       name = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">       matchIfMissing = false</span><br><span class="hljs-meta">   )</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> OrderedHiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrderedHiddenHttpMethodFilter();<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>Rest原理(表单提交，且需要使用REST时)</strong></p><ul><li>表单提交会带上_method=PUT</li><li>请求过来的时候会被HiddenHttpMethodFilter拦截<ul><li>请求是否是POST，且是否正常<ul><li>获取到_method的值</li><li>原生request(post)，包装模式requestWrapper重写了getMethod方法，返回的是传入的值(_method=XXX)</li><li>兼容以下请求：<strong>PUT DELETE PATCH等</strong></li><li>过滤链放行的时候使用的是wrapper。以后调用的getMethod方法是调用requestWrapper的。</li></ul></li></ul></li></ul><p><strong>Rest使用客户端工具：</strong></p><ul><li>如postman直接发生put、delete等方式请求，无需filter重新包装</li></ul><p><strong>上述的@RequestMapping(value=“/user”,method=“RequestMethod.POST”)这些注解，可以更改为以下的注解(由上述注解合成而来)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@PutMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>**如何更改默认的_method为我们想要的名字呢？**请看以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>    <span class="hljs-comment">// 组件无依赖故Lite型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span></span>&#123;<br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        hiddenHttpMethodFilter.setMethodParam(<span class="hljs-string">&quot;_m&quot;</span>);<br>        <span class="hljs-keyword">return</span> hiddenHttpMethodFilter;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过使用“用户优先原则”来进行HiddenHttpMethodFilter组件的注册，并设定MethodParam的值，重而实现更改默认的_method！</span><br><br></code></pre></td></tr></table></figure><hr /><h2 id="请求映射原理"><a class="markdownIt-Anchor" href="#请求映射原理"></a> 请求映射原理</h2><hr /><h2 id="普通参数与基本注解"><a class="markdownIt-Anchor" href="#普通参数与基本注解"></a> 普通参数与基本注解</h2><ul><li>注解：</li></ul><p><mark>@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestAttribute、@RequestBody、@MatrixVariable</mark></p><ul><li>Servlet API</li></ul><p><mark>WebRequest、ServletRequest、MultipartRequest、HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、Zoneld</mark></p><ul><li>复杂参数</li></ul><p><mark>Map、Model(<strong>map,model里面的数据会被放在request请求域中</strong>即req.setAttribute(xxx))、Errors/BindingResult、RedirectAttributes(<strong>重定向携带数据</strong>)、ServletResponse(<strong>Response</strong>)、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</mark></p><ul><li>自定义对象参数</li></ul><p><mark>可以自动类型转换和格式化，可以级联封装</mark></p><h3 id="1-注解"><a class="markdownIt-Anchor" href="#1-注解"></a> 1. <strong>注解：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @PathVariable一般接收的是Rest风格的请求，即表单请求，因此使用GetMapping,然后里面的value/path用希望使用者访问的路径和传入的数据，而数据通过&#123;数据名&#125;的形式括起来，在函数的参数部分通过@PathVariable(数据名)来获取数据，并且给到参数；当然也可以通过Map&lt;String,String&gt;的方式来进行直接获取全部的参数，此时在@PathVariable里不需写任何参数。</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;id&quot;</span>,id);<br>       map.put(<span class="hljs-string">&quot;username&quot;</span>,userName);<br>       map.put(<span class="hljs-string">&quot;pv&quot;</span>,pv);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br><span class="hljs-comment">// @RequestHeader获取的是浏览器页面的请求头的kv值，可以通过@RequestHeader(数据名)来获取数据；也可以通过@RequestHeader Map&lt;String,String&gt; rh来获取所有的请求头的内容，此时再@RequestHeader内不需写任何内容。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,<span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;userAgent&quot;</span>,userAgent);<br>       map.put(<span class="hljs-string">&quot;rh&quot;</span>,rh);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br>  <span class="hljs-comment">// @RequestParam获取的请求参数，可以通过@RequestParam(数据名)来获取数据的值；也可以通过@RequestParam Map&lt;String,String&gt;来获取所有的请求参数的信息，这时不需要写数据名，默认全部访问</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;age&quot;</span>,age);<br>       map.put(<span class="hljs-string">&quot;interests&quot;</span>,interests);<br>       map.put(<span class="hljs-string">&quot;rp&quot;</span>,rp);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @CookieValue注解用于获取当前访问内容的cookie值。可通过以下来种方式进行访问：①@CookieValue(cookie的名称) 基本数据类型，则这样获取到的是这个cookie对应的value值；②@CookieValue(cookie的名称) Cookie cookie,则这样获取到的是cookie的对象，里面有其name和value和供我们获得</span><br>   <span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span>Cookie cookie)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;_ga&quot;</span>,_ga);<br>       System.out.println(cookie.getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + cookie.getValue());<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @RequestBody获取请求体，这个只有post请求才有请求体。可以通过这样来获取表单的kv数据。@RequestBody String content</span><br><span class="hljs-meta">@PostMapping(&quot;/save&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String content)</span></span>&#123;<br>       Map map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;内容&quot;</span>,content);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 搭配上述内容使用的HTML文件 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>com.ayy.test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HelloIndexHtml<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;POST-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;car/3/owner/zhangsan?age=18&amp;interest=basketball&amp;interest=tennis&quot;</span>&gt;</span>car/&#123;id&#125;/owner/&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@PathVariable 路径变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestHeader 获取请求头<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestParam 获取请求参数<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@CookieValue 获取Cookie值<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestAttribute 获取request域属性<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestBody 获取请求体<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@MatrixVariable 矩阵变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/save&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Pwd&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;passwd&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Usr&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usrName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/sell;price=300000;brand=BYD,AUTO,TESLA&quot;</span>&gt;</span>MatrixVariable111 /cars/sell;price=300000;brand=BYD,AUTO,TESLA<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/boss;id=666/emp;id=888&quot;</span>&gt;</span>MatrixVariable222 /cars/boss;id=666/emp;id=888<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @RequestAttribute获取request域的属性。request可以通过setAttribute方法来设置属性，而request是在一次请求中生效。这就要说下forward和redirect两个的区别先。</span><br><span class="hljs-comment">// forward是直接转发，它只需要客户端发起一次的请求即可；而redirect(重定向/间接转发)是客户端发起两次请求。服务器端在响应第一次请求的时候，让浏览器再向另一个URL发出请求，从而达到转发的目的。</span><br><span class="hljs-comment">// 因此本次测试，需要采用forward直接转发的方式</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此例子用于显示HttpServletRequest 和 <span class="hljs-doctag">@RequestAttribute</span>注解提取request的域属性，需用forward进行直接请求转发，redirect这个是间接转发要进行</span><br><span class="hljs-comment">     * 两次请求，不符要求</span><br><span class="hljs-comment">     * 在默认情况下，无<span class="hljs-doctag">@ReponseBody</span>默认进行页面跳转</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/goto&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">gotoNextPage</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        request.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        request.setAttribute(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(&quot;user&quot;)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-meta">@RequestAttribute(&quot;status&quot;)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                           HttpServletRequest request)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>        map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MatrixVariable是矩阵变量，需要与PathVariable路径变量结合起来使用。且一般存放的是cookie的kv</span><br><span class="hljs-comment">// 我们通过PathVariable设置访问路径，而MatrixVariable是在路径变量;后的那一大串，当然也可以通过另一个路径变量相隔开。</span><br><span class="hljs-comment">// 矩阵变量的例子： localhost://car/sell;price=200000;brand=BYD,AUTO,TESLA</span><br><span class="hljs-comment">// 其中同一个k的多个v也可以用分号拆开(brand=BYD;brand=AUTO;brand=TESLA)，这里的sell就是PathVariable，后面的;到结尾都是MatrixVariable。</span><br><span class="hljs-comment">// 那么通过路径来显示就是/car/&#123;path;price=xxx;brand=xxx,yyy,zzz&#125; ，这里可以看出MatrixVariable必须依靠PathVariable而存在</span><br><span class="hljs-comment">// 需要跟RequestParam进行区分/car/&#123;path&#125;?price=xxx&amp;brand=xxx，这里可以看出PathVariable和RequestParam是独立的两个个体</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarSell</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;path&quot;)</span> String path,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;price&quot;)</span> Integer price,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;path&quot;</span>,path);<br>        map.put(<span class="hljs-string">&quot;price&quot;</span>,price);<br>        map.put(<span class="hljs-string">&quot;brand&quot;</span>,brand);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 需注意，以下此物默认关闭，需自定义组件UrlPathHelper来开启</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">webMvcConfigurer</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;<br>                UrlPathHelper urlPathHelper=<span class="hljs-keyword">new</span> UrlPathHelper();<br>                <span class="hljs-comment">// 开启不移除分号功能，这样才可以使MatrixVariable生效</span><br>                urlPathHelper.setRemoveSemicolonContent(<span class="hljs-keyword">false</span>);<br>                configurer.setUrlPathHelper(urlPathHelper);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-comment">// 若是存在/car/1;age=20/2;age=30这种情况，则可以利用MatrixVariable的参数pathVar来设定区域，否则若是直接根据k取age会都取到第一个。</span><br><span class="hljs-comment">//    /cars/boss;id=666/emp;id=888</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path1&#125;/&#123;path2&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarDetail</span><span class="hljs-params">(<span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path1&quot;)</span> Integer bid,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path2&quot;)</span> Integer eid)</span></span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;bid&quot;</span>,bid);<br>        map.put(<span class="hljs-string">&quot;eid&quot;</span>,eid);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 小拓展：一般来说我们若是将cookie功能禁掉，是无法访问到session的，因为session-&gt;jsessionId相关联-&gt;而jsessionId是存放在cookie-&gt;cookie在每一次的请求中都会被带上，但若是禁掉，就无法获得jessionId，就无法获得session。但现在可以通过矩阵变量的方式去获得(具体不清晰！！！)</span><br></code></pre></td></tr></table></figure><h3 id="2-servlet-api"><a class="markdownIt-Anchor" href="#2-servlet-api"></a> 2. Servlet API</h3><p>就如上面所说的那么多的Servlet API，是怎么通过Resolver（即参数解析器）来实现对应参数获取的？此外，注解获得的参数，也是通过参数解析器实现参数的获取。</p><p>以下以HttpServletRequest这个ServletAPI来展示如何通过参数解析器来获取之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ServletRequestMethodArgumentResolver</span><br>WebRequest.class.isAssignableFrom(paramType) || <br>ServletRequest.class.isAssignableFrom(paramType) || <br>MultipartRequest.class.isAssignableFrom(paramType) || <br>HttpSession.class.isAssignableFrom(paramType) || <br>pushBuilder != <span class="hljs-keyword">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType) ||<br>Principal.class.isAssignableFrom(paramType) || <br>InputStream.class.isAssignableFrom(paramType) || <br>Reader.class.isAssignableFrom(paramType) || <br>HttpMethod.class == paramType || <br>Locale.class == paramType || <br>TimeZone.class == paramType || <br>ZoneId.class == paramType;<br><span class="hljs-comment">// WebRequest == Request + Response + ...</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">resolveNativeRequest</span><span class="hljs-params">(NativeWebRequest webRequest, Class&lt;T&gt; requiredType)</span> </span>&#123;<br>        T nativeRequest = webRequest.getNativeRequest(requiredType);<br>        <span class="hljs-keyword">if</span> (nativeRequest == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Current request is not of type [&quot;</span> + requiredType.getName() + <span class="hljs-string">&quot;]: &quot;</span> + webRequest);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> nativeRequest;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 此时即返回原生的request。因此这是通过resolver实现ServletAPI参数获取的一个展示。可通过debug逐步寻找</span><br></code></pre></td></tr></table></figure><h3 id="3-复杂参数"><a class="markdownIt-Anchor" href="#3-复杂参数"></a> 3. 复杂参数</h3><p>对于复杂参数：<strong>Model、Map它俩存放的区域是request的请求域(渲染时存放的)，即request attribute那个东西。以下例子通过直接转发来体现之：访问localhost:8080/params -&gt; localhost:8080/success</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/params&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(Map&lt;String,Object&gt; map,</span></span><br><span class="hljs-params"><span class="hljs-function">                        Model model,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletRequest req,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletResponse resp)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,<span class="hljs-string">&quot;map content&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;md&quot;</span>,<span class="hljs-string">&quot;model content&quot;</span>);<br>    req.setAttribute(<span class="hljs-string">&quot;req&quot;</span>,<span class="hljs-string">&quot;request content&quot;</span>);<br><br>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>);<br>    resp.addCookie(cookie);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(value =&quot;user&quot;,required = false)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-meta">@RequestAttribute(value = &quot;status&quot;,required = false)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                       HttpServletRequest request)</span></span>&#123;<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>    map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;map1&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;md&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;md&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;req&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;req&quot;</span>));<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-自定义对象的参数"><a class="markdownIt-Anchor" href="#4-自定义对象的参数"></a> 4. 自定义对象的参数</h3><p>它是通过一个叫“数据绑定”的东西：当页面提交的请求数据(GET、POST)都可以和对象属性进行绑定，包括级联绑定。以下是数据绑定的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/saveUser&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">saveUser</span><span class="hljs-params">(Person person)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> person;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/saveUser&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;birth&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000/1/5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="响应处理"><a class="markdownIt-Anchor" href="#响应处理"></a> 响应处理</h1><hr /><h2 id="响应json"><a class="markdownIt-Anchor" href="#响应json"></a> 响应JSON</h2><h3 id="jacksonjar-responsebody"><a class="markdownIt-Anchor" href="#jacksonjar-responsebody"></a> jackson.jar +  ResponseBody</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>web场景自动引入了Json场景<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以通过jackson.jar包和@ResponseBody注解返回给前端json数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Person person;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/response/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.person;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个返回值是如何变成了json数据的格式呢？</p><p>先前说过ArgumentResolver参数解析器，在确定方法的参数值的时候，会用各种参数解析器来确定；</p><p>而现在有ReturnValueHandler，故可知springmvc对返回值的所有解析也是采取了返回值解析器的方法。</p><hr /><h2 id="returnvaluehandler原理"><a class="markdownIt-Anchor" href="#returnvaluehandler原理"></a> ReturnValueHandler原理</h2><hr /><h2 id="httpmessageconverter原理"><a class="markdownIt-Anchor" href="#httpmessageconverter原理"></a> HTTPMessageConverter原理</h2><hr /><h2 id="内容协商原理"><a class="markdownIt-Anchor" href="#内容协商原理"></a> 内容协商原理</h2><hr /><h2 id="基于请求参数的内容协商原理"><a class="markdownIt-Anchor" href="#基于请求参数的内容协商原理"></a> 基于请求参数的内容协商原理</h2><hr /><h2 id="自定义messageconverter"><a class="markdownIt-Anchor" href="#自定义messageconverter"></a> 自定义MessageConverter</h2><hr /><h2 id="浏览器与postman内容协商完全适配"><a class="markdownIt-Anchor" href="#浏览器与postman内容协商完全适配"></a> 浏览器与PostMan内容协商完全适配</h2><hr /><h1 id="视图解析与模板引擎"><a class="markdownIt-Anchor" href="#视图解析与模板引擎"></a> 视图解析与模板引擎</h1>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
