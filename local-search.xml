<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pnnx基础学习</title>
    <link href="/2024/07/13/pnnx%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/13/pnnx%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是模型部署"><a class="markdownIt-Anchor" href="#什么是模型部署"></a> 什么是模型部署</h2><blockquote><p><strong>本部分参考OpenMMLab在知乎的博文进行编写</strong></p></blockquote><p>模型部署需要明确<strong>部署场景</strong>,<strong>部署方式</strong>(中心服务化还是本地终端部署),模型优化指标,如何提高吞吐和减少延迟</p><h3 id="部署场景"><a class="markdownIt-Anchor" href="#部署场景"></a> 部署场景</h3><ul><li><strong>中心服务器云端部署</strong><ul><li>用户通过API调用接口或网页访问</li></ul></li><li><strong>边缘部署</strong><ul><li>用于<strong>嵌入式设备</strong>,要将模型打包封装到SDK,集成到嵌入式设备,<strong>数据处理和模型推理要在终端设备上执行</strong>(功耗,别耗电;要小,不占地儿)</li></ul></li></ul><h3 id="部署方式"><a class="markdownIt-Anchor" href="#部署方式"></a> 部署方式</h3><table><thead><tr><th></th><th style="text-align:center">SDK部署</th><th style="text-align:center">Service部署</th></tr></thead><tbody><tr><td>部署环境</td><td style="text-align:center">SDK引擎</td><td style="text-align:center">训练框架</td></tr><tr><td>模型语义转换</td><td style="text-align:center">需要进行前后处理和模型算子重实现</td><td style="text-align:center">一般框架内部负责语义转换</td></tr><tr><td>前后处理对齐算子</td><td style="text-align:center">训练和部署对应两套实现,需要进行算子数值对齐</td><td style="text-align:center">共用算子</td></tr><tr><td>计算优化</td><td style="text-align:center">挖掘芯片编译器的深度优化能力</td><td style="text-align:center">利用引擎已有的训练优化能力</td></tr></tbody></table><h3 id="部署核心优化指标"><a class="markdownIt-Anchor" href="#部署核心优化指标"></a> 部署核心优化指标</h3><p>合理把控：成本、功耗、性价比</p><ul><li>成本<ul><li>芯片选型</li><li>算力需求挑芯片（如加个DSP增加定点算力）</li></ul></li><li>功耗<ul><li>电池电池电池！！要用专用的优化的加速器单元如NPU以节省功耗</li></ul></li><li>性价比<ul><li>云端追求多路的吞吐量优化需求</li><li>终端追求单路延迟需要；针对CV和NLP问题对精度的要求不一样，因此有芯片选型的问题：CV INT4/INT8；NLP FP16</li></ul></li></ul><h3 id="部署流程"><a class="markdownIt-Anchor" href="#部署流程"></a> 部署流程</h3><p>这里用的是商汤的SenseParrots来讲解部署流程，且以SDK部署为例</p><h4 id="模型转换"><a class="markdownIt-Anchor" href="#模型转换"></a> 模型转换</h4><p>转换模型以适配不同框架。主流以ONNX或Caffe为模型交换格式。</p><p>主要分为：</p><ul><li><strong>计算图生成</strong></li><li><strong>计算图优化（optional，如算子融合）</strong></li><li><strong>计算图转换</strong></li></ul><h5 id="计算图生成"><a class="markdownIt-Anchor" href="#计算图生成"></a> 计算图生成</h5><p>通过一次推理来记录，将模型翻译成静态的表达（转成静态图）。在模型推理时，框架会记录算子的详细信息，也包括入参出参，以及所属层次</p><h5 id="计算图优化"><a class="markdownIt-Anchor" href="#计算图优化"></a> 计算图优化</h5><p>去除冗余op，算子融合</p><h5 id="计算图转换"><a class="markdownIt-Anchor" href="#计算图转换"></a> 计算图转换</h5><p>分析静态计算图算子，转换到目标格式。支持多后端（啥意思？）</p><h4 id="模型量化压缩"><a class="markdownIt-Anchor" href="#模型量化压缩"></a> 模型量化压缩</h4><p>边缘部署要求<strong>模型小</strong>，<strong>吞吐率高</strong> -&gt; 蒸馏/剪枝/量化</p><p>量化：FP32压缩到INT8/INT4乃至INT1（？），比如压到INT8-&gt;上面说了终端设备芯片选型会弄个定点计算单元，可以低比特指令实现低精度算子</p><p>量化技术栈：</p><ul><li><strong>量化训练（Quantization Aware Training）</strong>:插入伪量化算子（模拟低精度运算），通过梯度下降来做微调，以使得得到精度符合预期的模型</li><li><strong>离线量化（Post Training Quantization）</strong>： 少量校准数据集（原始数据集中挑），获得网络的激活分布，用统计手段或优化浮点定点输出分布来获得量化参数</li></ul><p>平衡吞吐和精度是一个问题；结合推理引擎挖掘芯片的能力；</p><h4 id="模型打包封装sdk"><a class="markdownIt-Anchor" href="#模型打包封装sdk"></a> 模型打包封装SDK</h4><p>要做前后处理，相当于是流水线中的一个流水段，可能是许多模型的一部分</p><p>保护模型还要加密（没想过还有这个，不过也合理）</p><h2 id="pnnx"><a class="markdownIt-Anchor" href="#pnnx"></a> PNNX</h2><p><strong>PNNX: <u>P</u>yTorch <u>N</u>eural <u>N</u>etwork e<u>X</u>change</strong></p><p>模型部署新方式</p><p><mark>介绍补充</mark></p><h2 id="pnnx2ncnn运行resnet-50快速上手vulkan"><a class="markdownIt-Anchor" href="#pnnx2ncnn运行resnet-50快速上手vulkan"></a> pnnx2ncnn运行ResNet-50快速上手(vulkan)</h2><p>开始前请先确定自己的ncnn已编译安装完成</p><h3 id="搭建项目结构"><a class="markdownIt-Anchor" href="#搭建项目结构"></a> 搭建项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>|-- CMakeLists.txt<br>|-- bin<br>|-- build<br>|-- images<br>|   `-- cat.jpg<br>|-- src<br>|   `-- infer.cpp<br>|-- utils<br>|   `-- resnet50.py<br>`-- weight_param<br></code></pre></td></tr></table></figure><p>项目结构如上所示,其中:</p><ul><li><strong>CMakeLists.txt</strong>: 用于构建项目</li><li><strong>bin</strong>: 用于存储最终编译得到的可执行文件</li><li><strong>build</strong>: 用于项目构建,以便清理</li><li><strong>images</strong>: 存放用于进行推理效果检测的图片,图片大小需要为224x224,这里准备了一张小猫的图片</li><li><strong>src</strong>: 用于存放源文件</li><li><strong>utils</strong>: 用于存放python文件</li><li><strong>weight_param</strong>: 用于存放python文件导出的TorchScript文件和pnnx进行转换后的权重和计算图参数文件</li></ul><h3 id="获取pnnx"><a class="markdownIt-Anchor" href="#获取pnnx"></a> 获取pnnx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pnnx<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 此方法方便快捷,当然也可以<code>wget</code>对应的源文件进行编译</p>          </div><h3 id="pytorch-resnet50转换为torchscipt"><a class="markdownIt-Anchor" href="#pytorch-resnet50转换为torchscipt"></a> PyTorch ResNet50转换为TorchScipt</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.models <span class="hljs-keyword">as</span> models<br><br><span class="hljs-comment"># 加载预训练好的ResNet-50</span><br>resnet = models.resnet50(pretrained=<span class="hljs-literal">True</span>)<br>resnet.<span class="hljs-built_in">eval</span>()<br><br><span class="hljs-comment"># 输入参数为[1,3,224,224]</span><br>ipt = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>)<br><br>jit_model = torch.jit.trace(resnet, ipt)<br>jit_model.save(<span class="hljs-string">&#x27;../weight_param/resnet50.pth&#x27;</span>) <br></code></pre></td></tr></table></figure><p>在utils下运行<code>python resnet50.py</code>后,在weight_param文件夹下得到<code>resnet50.pth</code></p><h3 id="pnnx转torchscipt为ncnn"><a class="markdownIt-Anchor" href="#pnnx转torchscipt为ncnn"></a> pnnx转TorchScipt为ncnn</h3><p>在weight_param下运行<code>pnnx resnet50.pth [1,3,224,224]</code></p><div class="note note-info">            <p>注: 在命令行中通过输入<code>pnnx</code>后运行,可以看到一些<code>Sample Usage</code>,里面有举例说明用法</p>          </div><p>运行指令后可以在当前文件夹下得到多个<code>.bin</code>,<code>.param</code>文件</p><p><code>.bin</code>文件内部存储的是模型的权重;</p><p><code>.param</code>文件存储的是计算图的详细信息</p><h3 id="编写推理文件"><a class="markdownIt-Anchor" href="#编写推理文件"></a> 编写推理文件</h3><p>在开始编写推理文件前,需要看一下<strong>pnnx转ncnn</strong>中的<code>resnet50.ncnn.param</code>,我们需要从该文件内获取输入输出对应的blob:</p><p><img src="https://s2.loli.net/2024/07/17/umnT5Uze1aRfql6.png" alt="resnet50.ncnn.param" /></p><p>推理文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(USE_NCNN_SIMPLEOCV)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;simpleocv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">detect_resnet50</span><span class="hljs-params">(<span class="hljs-keyword">const</span> cv::Mat&amp; bgr, std::vector&lt;<span class="hljs-keyword">float</span>&gt;&amp; cls_scores)</span></span><br><span class="hljs-function"></span>&#123;<br>    ncnn::Net resnet50;<br><br>    resnet50.opt.use_vulkan_compute = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 加载模型的计算图参数和权重</span><br>    <span class="hljs-keyword">if</span> (resnet50.<span class="hljs-built_in">load_param</span>(<span class="hljs-string">&quot;weight_param/resnet50.ncnn.param&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (resnet50.<span class="hljs-built_in">load_model</span>(<span class="hljs-string">&quot;weight_param/resnet50.ncnn.bin&quot;</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><span class="hljs-comment">// 图片格式转换 BGR-&gt;RGB</span><br>    ncnn::Mat in = ncnn::Mat::<span class="hljs-built_in">from_pixels_resize</span>(bgr.data, ncnn::Mat::PIXEL_BGR2RGB, bgr.cols, bgr.rows, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>);<br>    <br>    <span class="hljs-comment">// 图像归一化,这里做的是:(x/255 - 0.485) / 0.229 ,上下同时乘255可得</span><br>    <span class="hljs-comment">// (x - 0.485*255) / 0.229*255 ,而在substract_mean_normalize中的标准差是倒数</span><br>    <span class="hljs-comment">// 因此norm_vals的标准差取了倒数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> mean_vals[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0.485f</span>*<span class="hljs-number">255.f</span>, <span class="hljs-number">0.456f</span>*<span class="hljs-number">255.f</span>, <span class="hljs-number">0.406f</span>*<span class="hljs-number">255.f</span>&#125;;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> norm_vals[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>/<span class="hljs-number">0.229f</span>/<span class="hljs-number">255.f</span>, <span class="hljs-number">1</span>/<span class="hljs-number">0.224f</span>/<span class="hljs-number">255.f</span>, <span class="hljs-number">1</span>/<span class="hljs-number">0.225f</span>/<span class="hljs-number">255.f</span>&#125;;<br>    in.<span class="hljs-built_in">substract_mean_normalize</span>(mean_vals, norm_vals);<br><br>    ncnn::Extractor ex = resnet50.<span class="hljs-built_in">create_extractor</span>();<br><br>    ex.<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;in0&quot;</span>, in);<br><br>    ncnn::Mat out;<br>    ex.<span class="hljs-built_in">extract</span>(<span class="hljs-string">&quot;out0&quot;</span>, out);<br><br>    cls_scores.<span class="hljs-built_in">resize</span>(out.w);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; out.w; j++)<br>    &#123;<br>        cls_scores[j] = out[j];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">print_topk</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">float</span>&gt;&amp; cls_scores, <span class="hljs-keyword">int</span> topk)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 前topk的局部排序</span><br>    <span class="hljs-keyword">int</span> size = cls_scores.<span class="hljs-built_in">size</span>();<br>    std::vector&lt;std::pair&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>&gt; &gt; vec;<br>    vec.<span class="hljs-built_in">resize</span>(size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        vec[i] = std::<span class="hljs-built_in">make_pair</span>(cls_scores[i], i);<br>    &#125;<br><br>    std::<span class="hljs-built_in">partial_sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">begin</span>() + topk, vec.<span class="hljs-built_in">end</span>(),<br>                      std::greater&lt;std::pair&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>&gt; &gt;());<br><br>    <span class="hljs-comment">// 打印topk及对应的分数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; topk; i++)<br>    &#123;<br>        <span class="hljs-keyword">float</span> score = vec[i].first;<br>        <span class="hljs-keyword">int</span> index = vec[i].second;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%d = %f\n&quot;</span>, index, score);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Usage: %s [imagepath]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* imagepath = argv[<span class="hljs-number">1</span>];<br><br>    cv::Mat m = cv::<span class="hljs-built_in">imread</span>(imagepath, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;cv::imread %s failed\n&quot;</span>, imagepath);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    std::vector&lt;<span class="hljs-keyword">float</span>&gt; cls_scores;<br>    <span class="hljs-built_in">detect_resnet50</span>(m, cls_scores);<br><br>    <span class="hljs-comment">// 打印得分前三的类别</span><br>    <span class="hljs-built_in">print_topk</span>(cls_scores, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完推理文件后,进行CMakeLists.txt的编写:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(NCNN_DEMO)<br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>.<span class="hljs-number">12</span>)<br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<br><br><br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;CMAKE_PREFIX_PATH&#125;</span> <span class="hljs-string">&quot;/path/to/ncnn/build/install&quot;</span>)<br><span class="hljs-keyword">find_package</span>(ncnn   REQUIRED)<br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><br><br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-keyword">add_executable</span>(resnet50 src/infer.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(resnet50 ncnn <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span>)<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 上面的<code>CMAKE_PREFIX_PATH</code>加上的搜索路径是你编译安装好ncnn后,build文件夹内的install文件夹</p>          </div><h3 id="构建及测试"><a class="markdownIt-Anchor" href="#构建及测试"></a> 构建及测试</h3><p>进入build文件夹下,执行<code>cmake ..</code>构建项目,而后执行<code>make</code>以生成可执行文件</p><p><code>cd ..</code>退到项目根目录下</p><p>运行<code>./bin/resnet50 ./images/cat.jpg</code>以查看推理结果:</p><img src="https://s2.loli.net/2024/07/17/BT85sEXMcSyNCU3.png" alt="pnnx2ncnn_infer" style="zoom:50%;" /><p>这里输出的283,154一类的数字是训练用的标签,因为采用的ResNet-50是在ImageNet数据集上进行预训练的,其中上述标签对应具体类别为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">154: &#x27;Pekinese, Pekingese, Peke&#x27;, // 哈巴狗<br>283: &#x27;Persian cat&#x27;, // 波斯猫<br>284: &#x27;Siamese cat, Siamese&#x27;, // 暹罗猫<br></code></pre></td></tr></table></figure><p>可以看出来,它确实正确预测了是只猫(虽然具体的种类错了)</p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/367042545">AI 框架部署方案之模型部署概述</a></li><li><a href="https://github.com/HuPengsheet/use-ncnn/blob/main/notes/ncnn02-onnx%E8%BD%ACncnn%E6%A8%A1%E5%9E%8B%E8%B7%91resnet18.md">onnx2ncnn</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pnnx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CUDA优化技巧</title>
    <link href="/2024/07/09/CUDA%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/07/09/CUDA%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="向量化访存指令在smem中的机制"><a class="markdownIt-Anchor" href="#向量化访存指令在smem中的机制"></a> 向量化访存指令在SMEM中的机制</h2><blockquote><p>When you store (or load) more than 4 bytes per thread, which is like saying more than 128 bytes per warp, the GPU does not issue a single transaction. The largest transaction size is 128 bytes.</p></blockquote><p>上面这段话是在Nvidia论坛上官方回复的一句话，可以这么理解：<strong>所谓的访存请求是会被拆分为memory transaction来执行的，如果是每个线程取/存4B的元素，则整个warp是处理128B的数据，这正好是单次memory transaction可以处理的最大数据</strong></p><p>如果单次访存请求超过了128B，则不会只发射1条transaction</p><p>GPU会进行拆分，比如你采用LDS.64访存，会被拆成两条memory transaction，[T0-T15],[T16,T31]各自承担1个memory transaction。每一个都是128B的位宽，而后的bank conflict是根据每个memory transaction中涉及到的线程所产生的，而不是所谓的请求/warp/指令。</p><h3 id="lds32"><a class="markdownIt-Anchor" href="#lds32"></a> LDS.32</h3><p>这是最朴素的一种访存机制，因为在warp内的32个线程，每个线程去访问共享内存中的32bit，即4B的一个元素。存在以下情况：</p><ul><li>线程访问到各自对应的共享内存上的元素，即访问到不同bank，无bank conflict;</li><li>某些个线程访问到同一个bank上的同一地址，发起广播机制（这某些个线程里：其中1个线程取数，然后广播给另几个线程），无bank conflict;</li><li>某些个线程访问到同一个bank上的不同地址，产生bank conflict。所谓的某些个线程有n个，则为n way bank conflict，会将访存转换为串行的n条指令进行（应该就是n条memory transaction）</li></ul><h3 id="lds64"><a class="markdownIt-Anchor" href="#lds64"></a> LDS.64</h3><p>采用类似于float2/uint2的向量化访存对shared memory进行访存时，1个warp被拆成了2个half warp，如T0-T15、T16-T31，1个活跃的half warp进行1次memory transaction，活跃即意味着里面有至少一个线程是有访存需求的。</p><p>因此如果1个warp里的2个half warp都是活跃的，则要进行2次memory transaction，是串行执行的。</p><p><strong>当有以下情况发生时，则2次memory transaction可以合并成1次</strong>：</p><ul><li>对于整个warp，活跃的第i号线程，与不活跃的第i^1号线程  || 活跃的第i号线程和活跃的第i^1号线程访问同一块地址;</li><li>对于整个warp，活跃的第i号线程，与不活跃的第i^2号线程  || 活跃的第i号线程和活跃的第i^2号线程访问同一块地址;</li></ul><div class="note note-info">            <p>注：上面的合并memory transaction的情况是<strong>针对整个warp而言的</strong>，如果两个half warp一个满足规则1（就是第一条），一个满足规则2，也是无法合并的</p>          </div><h3 id="lds128"><a class="markdownIt-Anchor" href="#lds128"></a> LDS.128</h3><p>采用类似于float4/uint4的向量化访存对shared memory进行访问，1个half warp被拆分成2个quarter warp，如T0-T7、T8-T15，1个活跃的quarter warp进行1次memory transaction</p><p>可见当4个quarter warp都活跃时需要进行4次串行的memory transaction，它的合并策略和LDS.64的一样，这里重复一次，并注明它的注意事项：</p><ul><li>对整个warp：(活跃的第i号线程与不活跃的第i^1号线程) || (活跃的第i号线程和活跃的第i^1号线程均访问同一地址);</li><li>对整个warp：(活跃的第i号线程与不活跃的第i^2号线程) || (活跃的第i号线程和活跃的第i^2号线程均访问同一地址);</li></ul><div class="note note-info">            <p>注：</p><ul><li>只有T0-T7,T8-T15活跃，并且满足条件1，则合并为1个half warp，1次memory transaction</li><li>只有T8-T15,T16-T23活跃，且满足条件1，由于分属不同half warp，无法合并，2次memory transaction</li><li>T0-T7,T8-15满足条件1，T16-T23,T24-T31满足条件2，无法合并，4次memory transaction</li><li>T0-T7,T8-T15,T16-T23,T24-T31均满足同一合并条件，则合并为两个half warp，2次memory transaction，注意，俩half warp不可再合了，没有这种cascade操作</li></ul>          </div><h3 id="实验部分"><a class="markdownIt-Anchor" href="#实验部分"></a> 实验部分</h3><h4 id="lds64-2"><a class="markdownIt-Anchor" href="#lds64-2"></a> LDS.64</h4><p>源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cuda_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t1</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">if</span>(tid&lt;<span class="hljs-number">16</span>)&#123;<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid]= <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t2</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">if</span>(tid&lt;<span class="hljs-number">15</span> || tid==<span class="hljs-number">16</span>)&#123;<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid==<span class="hljs-number">16</span>?<span class="hljs-number">15</span>:tid];<br>    &#125;<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t3</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[tid/<span class="hljs-number">2</span>];<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t4</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">uint32_t</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span>+tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">uint32_t</span> idx = (tid&gt;&gt;<span class="hljs-number">4</span>)&lt;&lt;<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// printf(&quot;0:[tid:%d]:[idx:%d]\n&quot;,tid,idx);</span><br>    idx = (idx == <span class="hljs-number">0</span>) ? idx+tid&gt;&gt;<span class="hljs-number">1</span> : (idx + (tid&amp;<span class="hljs-number">1</span>) + (((tid&gt;&gt;<span class="hljs-number">2</span>)<span class="hljs-number">-4</span>)&lt;&lt;<span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// printf(&quot;1:[tid:%d]:[idx:%d]\n&quot;,tid,idx);</span><br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[idx];<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-keyword">void</span> <span class="hljs-title">smem_t5</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span>* src)</span></span>&#123;<br>    __shared__ <span class="hljs-keyword">uint32_t</span> smem[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">int</span> tid = threadIdx.x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        smem[i*<span class="hljs-number">32</span> + tid] = tid;<br>    &#125;<br>    __syncwarp();<br>    <span class="hljs-keyword">uint32_t</span> idx = tid&gt;&gt;<span class="hljs-number">4</span>==<span class="hljs-number">0</span> ? tid : tid<span class="hljs-number">-16</span>;<br>    <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(src)[tid] = <span class="hljs-keyword">reinterpret_cast</span>&lt;uint2*&gt;(smem)[idx];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">uint32_t</span>* dA;<br>    <span class="hljs-keyword">size_t</span> sizedA = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">uint32_t</span>) * <span class="hljs-number">128</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        相当于:</span><br><span class="hljs-comment">        bank    0   1  ... 31 </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   - </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   -</span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">                -   -   -   - </span><br><span class="hljs-comment">               | | | | | | | |</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">cudaMalloc</span>(&amp;dA,sizedA);<br>    <span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span></span>;<br><br>    smem_t1&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t2&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t3&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t4&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    smem_t5&lt;&lt;&lt;grid,block&gt;&gt;&gt;(dA);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br><br>    <span class="hljs-built_in">cudaFree</span>(dA);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是对着第三个参考文件里的图LDS.64的图写的，并采用Nsight Compute的shard_op_ld进行bank conflict和memory transaction次数的查看，实验结果如下(其中wavefront代表memory transaction的次数，这里没有产生bank  conflict的例子)：</p><img src="https://s2.loli.net/2024/07/26/aCX3xBLzIPFDiV4.png" alt="lds64_smem_t1" style="zoom:50%;"/><img src="https://s2.loli.net/2024/07/26/Pieh8Jpfb7ad9nM.png" alt="lds64_smem_t2" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/8GczNsDFakHBoJR.png" alt="lds64_smem_t3" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/25PqRkyQHugMYFs.png" alt="lds64_smem_t4" style="zoom:50%;" /><img src="https://s2.loli.net/2024/07/26/iaJXFLNsQfvbk9m.png" alt="lds64_smem_t5" style="zoom:50%;" /><p><strong>参考文件：</strong></p><ul><li><a href="https://forums.developer.nvidia.com/t/how-to-understand-the-bank-conflict-of-shared-mem/260900">how-to-understand-bank-conflict-of-shared-memory</a></li><li><a href="https://forums.developer.nvidia.com/t/unexpected-shared-memory-bank-conflict/77228">LDS.128-how-to-increase-bandwidth</a></li><li><a href="https://code.hitori.moe/post/cuda-shared-memory-access-mechanism-with-vectorized-instructions/">CUDA Shared Memory 在向量化指令下的访存机制</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>OpDev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake简易使用</title>
    <link href="/2024/06/03/CMake%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/03/CMake%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><p><strong>通过编写平台无关的CMakeLists.txt文件来定制整个编译流程,然后执行之,根据目标平台生成所需的Makefile文件</strong>.流程如下:</p><ol><li>编写CMake配置文件CMakeLists.txt;</li><li>执行命令<code>cmake path</code>或选择带交互式界面的<code>ccmake path</code>,<code>path</code>是CMakeLists.txt所在的目录;</li><li>生成Makefile后使用<code>make</code>命令进行编译;</li></ol><p>因此采用CMake进行C++项目工程编译的关键在于编写CMakeLists.txt配置文件</p><p><strong><code>CMakeLists.txt</code>主要由命令,注释,空格组成,其中命令不区分大小写,<code>#</code>后跟着注释</strong><br /><strong>命令由命令名称,小括号,参数组成,参数用空格间隔开</strong></p><h2 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h2><ul><li><p><code>cmake_minimum_required(VERSION X.X)</code>: 运行此配置文件所需的cmake最低版本;</p></li><li><p><code>project(projectName)</code>: 指明项目名称;</p></li><li><p><code>add_executable()</code>: 将源文件(放后面)编译成可执行文件(放前面)</p></li><li><p><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code>: 指定dir,会获取该目录下的所有源文件,将结果存入变量variable中(通过${}调用变量)</p></li><li><p><code>add_subdirectory()</code>: 增加编译子目录,会去编译子目录下的<code>CMakeLists.txt</code>文件</p></li><li><p><code>target_link_libraries()</code>: 参数第一个放可执行文件,后面放链接库的库名,可能是自己的库</p></li><li><p><code>add_library()</code>: 生成链接库,跟add_executable一样,生成的库名放前面,后面放的是源文件</p></li><li><p><code>configure_file(&lt;input&gt; &lt;output&gt;)</code>: 将输入的配置文件,一般是<code>config.h.in</code>,里面编写了一些<code>#cmakedefine ...</code>语句,让<code>CMakeLists.txt</code>中的变量转换为宏定义,转换后的文件为<code>output</code>,里面的宏定义可以在代码中通过<code>#include ...</code>引入</p></li><li><p><code>option(&lt;variable&gt; &quot;&lt;help_text&gt;&quot; [value])</code> 定义一个变量,中间的是描述变量的作用,value可以写ON/OFF,不写则默认OFF,可以跟<code>CMakeLists.txt</code>中的<code>if()...endif()</code>一类的搭配使用,还可以和上面的配置文件搭配使用</p></li><li><p><code>set(&lt;variable&gt; value1 value2 ...)</code> 用来定义变量</p></li><li><p><code>include_directories()</code> 用以增加需要扫描的头文件路径</p></li><li><p><code>find_package(&lt;variable&gt; library_name HINTS &lt;dir&gt;)</code> 查找指定目录下的名为<code>library_name</code>的库,在编译前便会进行查找,而非到链接阶段再去看有没有库</p><div class="note note-info">            <p>注:实质上<code>find_package</code>一般用作寻找系统中安装的第三方库并进行链接,找的是<code>xxxConfig.cmake</code>这种包配置文件,比如找OpenCV的<code>OpenCVConfig.cmake</code>.一般的使用形式是:<code>find_package(OpenCV REQUIRED) # 查找名为opencv的包,找不到就报错,会终止当前的cmake进程不再执行.</code></p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/631259689">find_package</a></li></ul>          </div></li><li><p><code>message()</code>可以在打印<code>CMakeLists</code>中的变量或是提示信息</p></li></ul><h2 id="预定义变量"><a class="markdownIt-Anchor" href="#预定义变量"></a> 预定义变量</h2><p>参见最后一篇的参考文件,预定义变量对我们的项目工程排布有很大作用,需要记住常用的</p><h2 id="通用模板"><a class="markdownIt-Anchor" href="#通用模板"></a> 通用模板</h2><p>目前所采用的项目目录结构如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">.<br>├── bin<br>│   └── main<br>├── build<br>├── CMakeLists.txt<br>├── config.h.in<br>├── include<br>│   ├── config.h<br>│   └── xmath.h<br>├── lib<br>│   └── libxmath.a<br>└── src<br>    └── main.cpp<br></code></pre></td></tr></table></figure><ul><li>bin目录用来存放生成的可执行文件</li><li>build目录用以执行<code>cmake .. &amp;&amp; make</code></li><li>include目录用以放置头文件,故基本上扫描的头文件路径就是它</li><li>lib目录放置的是自己编写的静态/动态库,这是由另外的进行生成,我试着把库生成和main.cpp写在一个项目,但是在执行make的时候总出错,应该是我编写的问题,后续修改这个问题</li><li>src目录用以放置源文件</li><li><code>config.h.in</code>文件装放的是一些对源文件编译有影响的cmake中的变量,在<code>cmake .. </code>的时候会生成config.h,转换为C可用的宏定义</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.8</span>)<br><span class="hljs-keyword">project</span>(final_demo)<br><span class="hljs-keyword">add_compile_options</span>(-Wall -std=c++<span class="hljs-number">11</span>)<br><br><span class="hljs-keyword">option</span>(MYMATH <span class="hljs-string">&quot;USE MY POW FUNCTION&quot;</span> <span class="hljs-keyword">ON</span>)<br><br><span class="hljs-keyword">configure_file</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/config.h.in <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>/config.h)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-keyword">if</span>(MYMATH)<br>    <span class="hljs-comment"># add_subdirectory($&#123;PROJECT_SOURCE_DIR&#125;/src/math)</span><br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_CPP)<br><span class="hljs-keyword">add_executable</span>(main <span class="hljs-variable">$&#123;SRC_CPP&#125;</span>)<br><span class="hljs-keyword">if</span>(MYMATH)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib/libxmath.a)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/534439206">全网最细的CMake教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/664125090">[C++]Cmake使用教程(看这一篇就够了)</a></li><li><a href="https://blog.csdn.net/b1049112625/article/details/136501488">cmake的configure_file的用法</a></li><li><a href="https://www.jianshu.com/p/2946eeec2489">Cmake命令之configure_file介绍</a></li><li><a href="https://blog.csdn.net/weixin_44688770/article/details/128857512">CMake常见的预定义变量</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>C++项目编译工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>armV8架构及指令集知识</title>
    <link href="/2024/04/10/armV8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/10/armV8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="neon-intrinsic入门"><a class="markdownIt-Anchor" href="#neon-intrinsic入门"></a> Neon intrinsic入门</h2><h3 id="两个例子学习自arm的neon-intrinsic教程"><a class="markdownIt-Anchor" href="#两个例子学习自arm的neon-intrinsic教程"></a> 两个例子(学习自ARM的neon intrinsic教程)</h3><p>其实还有个collision detection的例子,但感觉那个例子不如前两个例子好,因此没编程实现</p><ol><li><strong>RGB deinterleaving</strong></li></ol><img src="https://s2.loli.net/2024/04/18/9BJZxrGLgn1Sepm.png" alt="RGB image pixel array" style="zoom:50%;" /><p>我们知道一个像素有三个颜色通道,R,G,B.每个像素点的颜色通道顺序排列,但如果我们想逐通道进行处理,则需要进行像素通道的分离,即从<code>rgb</code>这个数组中,分离三色通道,获得<code>r</code>,<code>g</code>,<code>b</code>三个单独的数组</p><p>用C实现如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_c</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *r,<span class="hljs-keyword">uint8_t</span> *g,<span class="hljs-keyword">uint8_t</span> *b,<span class="hljs-keyword">uint8_t</span> *rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;color_length;i++)&#123;<br>        r[i] = rgb[i*<span class="hljs-number">3</span>];<br>        g[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>];<br>        b[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样逐个元素取出然后放入数组是很容易联想到的一种方法,但是我们arm的通用寄存器是64位,每次处理都是64位的寄存器从内存load一个8位的数,又store回去.寄存器是宝贵的计算机资源,如此使用很浪费.</p><p>因此选择用neon实现,可以用向量寄存器来处理,128位则可以一次性处理16个8位的无符号整数(颜色范围[0,255]),但这样显然有问题,因为一次处理三个通道的数据,需要是3的倍数,因此可以选择用一个<code>uint8x16x3_t</code>的矩阵型数据类型来处理,这样一次采用三个向量寄存器处理即可.</p><p>用neon实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arm_neon.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_neon</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* r,<span class="hljs-keyword">uint8_t</span>* g,<span class="hljs-keyword">uint8_t</span>* b,<span class="hljs-keyword">uint8_t</span>* rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br><span class="hljs-keyword">int</span> num8x16 = color_length/<span class="hljs-number">16</span>;<br><span class="hljs-keyword">uint8x16x3_t</span> intlv_rgb;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num8x16;i++)&#123;<br>intlv_rgb = vld3q_u8(rgb+<span class="hljs-number">3</span>*<span class="hljs-number">16</span>*i);<br>vst1q_u8(r+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">0</span>]);<br>vst1q_u8(g+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">1</span>]);<br>vst1q_u8(b+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">2</span>]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中因为一次是处理了16个像素点(48个通道信息),所以像素长度要除以16(也可以让控制像素长度的步长每次走16步)</p><p><code>vld3q_u8</code>是第一个接触到的neon intrinsic函数,v表示vector操作,ld表示这个函数的基本功能load,3q表示用到3个qword的寄存器,即是3个128位的向量寄存器,u8表示寄存器里的一个通道的数据是u8类型的,即unsigned int 8类型的.</p><p>它的返回值是一个<code>uint8x16x3_t</code> 的数据类型,将该类型的数据逐个取出,通过<code>vst1q_u8</code>的操作写到对应的数组中去</p><ol start="2"><li><strong>matrix multiplication</strong></li></ol><p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=A*B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>来考虑,其中是列主序的存储方式,C的维度是<code>n*m</code>,则普通的C矩阵乘如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_c</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span>* A,<span class="hljs-keyword">float32_t</span>* B,<span class="hljs-keyword">float32_t</span>* C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,p;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            C[i+j*n] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// Inner Product</span><br>            <span class="hljs-keyword">for</span>(p=<span class="hljs-number">0</span>;p&lt;k;p++)&#123;<br>                C[i+j*n] += A[i + p*n] * B[p + j*k]; <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然,这样的矩阵乘是最朴素的,那怎么优化呢?</p><p>不妨先从一个固定大小,然后维度比较小的矩阵来思考,我们的向量寄存器的宽度是128,那就是对于float32_t可以放4个,因此考虑一个<strong>4x4的小矩阵的乘法</strong>先,那么优化的过程如下图示:</p><img src="https://s2.loli.net/2024/04/18/l6nvdY2sVQALmaJ.jpg" alt="ARM-matrix multiply neon 4x4" style="zoom:60%;" /><p>如图,我们想算C阵的一列数据,则按照A逐行与B的某一列做内积,则经过多次内积,可以得出C阵的一列数据;</p><p>但是这样对于A阵会频繁发生cache miss的问题,频繁访存导致latency,因此A阵最好也以列的方式取数据,通过分析我们知道,若要求C0(C阵的第一列),则A0通通要乘于<code>B0[0]</code>(B阵第一列的第一个数据),A1要乘于<code>B0[1]</code>,如此遍历完A阵(逐列)与B0列(逐元素)的数据,则可以计算出C0,大大减少了cache miss,且可以用neon intrinsic实现(减少指令数量,并有利于编译器做循环展开),代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_4x4_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// 先把A,B,C的列都给用float32x4_t表示</span><br>    <span class="hljs-keyword">float32x4_t</span> A0 = vld1q_f32(A);<br>    <span class="hljs-keyword">float32x4_t</span> A1 = vld1q_f32(A+<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A2 = vld1q_f32(A+<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A3 = vld1q_f32(A+<span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br><br>    <span class="hljs-comment">// 给结果的中间值逐列设置初值0(因为要累加嘛)</span><br>    <span class="hljs-keyword">float32x4_t</span> C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C3 = vmovq_n_f32(<span class="hljs-number">0</span>); <br><br>    B0 = vld1q_f32(B);<br>    C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>    C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>    C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>    C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br>    vst1q_f32(C,C0);<br><br>    B1 = vld1q_f32(B+<span class="hljs-number">4</span>);<br>    C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>    C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>    C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>    C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">4</span>,C1);<br><br>    B2 = vld1q_f32(B+<span class="hljs-number">8</span>);<br>    C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>    C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>    C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>    C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">8</span>,C2);<br><br>    B3 = vld1q_f32(B+<span class="hljs-number">12</span>);<br>    C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>    C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>    C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>    C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">12</span>,C3);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码思路与上面画图的思路是一样的,由此便完成了一个4x4的neon intrinsic实现的矩阵乘</p><p>那么对于大的矩阵呢?如何处理?</p><p>其实可以划分为4x4的块,用我们上面优化后的矩阵乘进行计算,当然这样的情况针对的是行列两个维度均是4的倍数的,如果不是4的倍数,比如A的维度是514x515这样的,就可以做padding处理,这样也不用改动4x4的矩阵乘的代码</p><p>以下是一般阵的情况(这里没做padding):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// A,B,C三个阵的逐列数据</span><br>    <span class="hljs-keyword">float32x4_t</span> A0,A1,A2,A3;<br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br>    <span class="hljs-keyword">float32x4_t</span> C0,C1,C2,C3;<br><br>    <span class="hljs-comment">// A,B,C三个阵的地址偏移值</span><br>    <span class="hljs-keyword">int</span> a_offset,b_offset,c_offset;<br>    <br>    <span class="hljs-comment">// 迭代变量</span><br>    <span class="hljs-keyword">int</span> i_idx,j_idx,k_idx;<br>    <br>    <span class="hljs-keyword">for</span>(i_idx=<span class="hljs-number">0</span>;i_idx&lt;n;i_idx+=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">for</span>(j_idx=<span class="hljs-number">0</span>;j_idx&lt;m;j_idx+=<span class="hljs-number">4</span>)&#123;<br>            C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C3 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 得等这一个循环完成了才算做完4x4次内积,因此里面的C的值得累加,出循环再store</span><br>            <span class="hljs-keyword">for</span>(k_idx=<span class="hljs-number">0</span>;k_idx&lt;k;k_idx+=<span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-comment">// 计算偏移值</span><br>                a_offset = i_idx + n*k_idx;<br>                b_offset = k_idx + k*j_idx;<br>                <span class="hljs-comment">// 获取当前基址+偏移值的位置处的列值</span><br>                A0 = vld1q_f32(A+a_offset);<br>                A1 = vld1q_f32(A+a_offset+n);<br>                A2 = vld1q_f32(A+a_offset+<span class="hljs-number">2</span>*n);<br>                A3 = vld1q_f32(A+a_offset+<span class="hljs-number">3</span>*n);<br><br>                B0 = vld1q_f32(B+b_offset);<br>                C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>                C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>                C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>                C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br><br>                B1 = vld1q_f32(B+b_offset+k);<br>                C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>                C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>                C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>                C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);                                <br><br>                B2 = vld1q_f32(B+b_offset+<span class="hljs-number">2</span>*k);<br>                C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>                C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>                C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>                C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br><br>                B3 = vld1q_f32(B+b_offset+<span class="hljs-number">3</span>*k);<br>                C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>                C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>                C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>                C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>            &#125;<br>            <span class="hljs-comment">// 计算偏移值</span><br>            c_offset = i_idx + n*j_idx;<br>            vst1q_f32(C+c_offset,C0);<br>            vst1q_f32(C+c_offset+n,C1);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">2</span>,C2);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">3</span>,C3);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出,n,m,k三个维度的步距都改作了4,注意C阵的值是需要累加完整个k维的循环,才可以得到C的一个小块(4x4)的结果,因此C的摆放位置有了变化,别的基本差不多.</p><h3 id="函数规范"><a class="markdownIt-Anchor" href="#函数规范"></a> 函数规范</h3><p>在说起函数规范前,先学一下<strong>用于neon的数据类型</strong>:</p><ul><li><code>baseW_t</code>: <strong>base表示基本的数据类型</strong>,然后<strong>W表示该类型的位宽</strong>,比如int8,uint8,float32这些,后面跟着的t是表示typedef的意思;</li><li><code>baseWxL_t</code>:这在上面的基础上加上了个L,实际上就是用了向量寄存器,<strong>L表示数据的个数</strong>,比如128位的寄存器,对于float32_t来说,就可以存4个,即float32x4_t(类似一维数组);</li><li><code>baseWxLxN_t</code>: 这个较上面的方法则类似二维数组,<strong>N表示baseWxL的个数</strong>,就比如分离RGB的例子,uint8x16x3_t表示的是有3个uint8x16的一维数组.</li></ul><div class="note note-info">            <p>其实x86中比如avx2的数据类型也差不多,虽然看起来是__m256d,__m256i这样高深莫测的样子,但是内部的结构体也差不多</p>          </div><p>在ARM neon intrinsic入门的教程里,函数规范定义如下:</p><p><strong><code>return_type v[p][q][r]opname[u][n][q][x][_high][_lane | _laneq][_n][_result]_type(args) </code></strong></p><p>非常复杂,从左往右开始说</p><ul><li><p><code>reture_type:</code> 返回类型,就是我们上面说到的neon的数据类型;</p></li><li><p>v: <strong>在所有intrinsic中必有</strong>,表示是一个vector操作</p></li><li><p>p: pair,成对操作</p></li><li><p>q: 饱和操作,就是数值溢出,不是对它做如取余(上溢),加上边界值(下溢)的操作,而是暂停在边界值</p></li><li><p>r: rounding向下取整</p></li><li><p>opname: <strong>具体操作的名字</strong>,比如add,mul,sub之类的</p></li><li><p>u:</p></li><li><p>n: narrow,窄指令,输入操作数的向量是128位的,结果向量是64位的,类型相同,但是宽度减半,例子:</p><ul><li>``</li></ul><div class="note note-info">            <p>我在网上看到还有w(wide,宽指令),l(long,长指令)</p><ul><li>l: long,长指令,输入操作数的向量是64位的,结果向量是128位的,类型相同,但是宽度加倍,例子:</li></ul><p>``</p><ul><li>w: wide,宽指令,输入操作数1个是64位的,1个是128位的,结果向量是128位的,类型相同,宽度上64位的是128位的一半,例子:</li></ul><p><code>uint64x2_t vaddw_u32 (uint64x2_t a, uint32x2_t b) </code></p>          </div></li><li><p>q: <strong>表示用到是128的向量寄存器</strong>,<strong><u>q</u>uad word</strong>,<strong>默认是64位的double word</strong></p></li><li><p>x:</p></li><li><p>_high:</p></li><li><p>_lane | _laneq: 表示<strong>从一个向量的通道中取一个标量操作数</strong>.<strong>有q和无q的区别就是向量寄存器是用128位还是64位</strong>(感觉就默认的向量寄存器(不加q)就是用64位).下面是官网的两个例子:</p><ul><li><img src="https://s2.loli.net/2024/04/19/ZwBocAkCQxyn2jI.png" alt="vfmaq_laneq_f32" style="zoom:50%;" /></li><li><img src="https://s2.loli.net/2024/04/19/DTApiKL1HOl8aUf.png" alt="vfmaq_lane_f32" style="zoom:50%;" /></li></ul></li><li><p>_n: 表示<strong>有一个标量操作数</strong>,是<strong>要从参数中获取</strong></p></li><li><p>_result:</p></li><li><p>_type: 表示<strong>每个通道的具体的数据类型</strong></p></li><li><p>args: 输入参数</p></li></ul><h2 id="neon相关的体系结构"><a class="markdownIt-Anchor" href="#neon相关的体系结构"></a> Neon相关的体系结构</h2><p>下面的内容主要摘自ARM的Neon introducing:</p><hr /><p><strong>Neon技术为指令集体系结构提供了一个专门的扩展</strong>,提供的额外指令能<strong>在多个数据流上并行的执行数学运算(SIMD)</strong></p><p>为什么需要用到这个Neon呢?</p><p>处理大量数据集,主要的性能限制因素是<strong>执行数据处理指令</strong>所花费的大量<strong>CPU时间</strong> -&gt; 这个<strong>CPU时间</strong>取决于<strong>处理整个数据集的指令数量</strong> -&gt; 这个<strong>指令数量</strong>又取决于<strong>每条指令所能处理的数据项</strong></p><blockquote><p>When processing large sets of data, a major performance limiting factor is the amount of CPU time taken to perform data processing instructions. This CPU time depends on the number of instructions it takes to deal with the entire data set. And the number of instructions depends on how many items of data each instruction can process.</p></blockquote><p><strong>如果你现在处理的数值是小于最大位的大小,用SISD的话,额外的潜在的带宽是被浪费掉的</strong></p><blockquote><p>If the values you are dealing with are smaller than the maximum bit size, that extra potential bandwidth is wasted with SISD instructions.</p></blockquote><p>即是我要对8位的数值去做一个ADD操作,那么每个8位的数值会被加载到一个单独的64位的寄存器.这样去处理数据,对硬件资源并没有很好的利用到.</p><p><strong>SIMD指令是对多个数据项同时执行相同的操作.在一个较大的寄存器里,这些数据项会作为单独的通道被打包.</strong>(通道lane是完全隔离的,互相影响不到的)</p><blockquote><p>Single Instruction Multiple Data (SIMD) instructions perform the same operation simultaneously for multiple data items. These data items are packed as separate lanes in a larger register.</p></blockquote><p><strong>Neon寄存器有128位的,也有64位的(就是把128位的高64位给置零,只用低64位</strong>,跟AVX兼容SSE差不多)</p><hr /><p><strong>AArch64:Armv8-A架构的64位的执行状态</strong>.有时候一些GNU/Linux文档会把AArch64叫做ARM64.在AArch64状态下,处理器执行<strong>A64指令集</strong>(包含Neon指令)</p><p><strong>AArch32:就是Armv8-A架构的32位执行状态,和Armv7几乎是一样的</strong>.在AArch32状态下处理器可以执行<strong>A32</strong>(在早期架构版本中是叫ARM)/<strong>T32</strong>(Thumb)<strong>指令集</strong>.这俩指令集向下兼容Armv7也有Neon指令</p><hr /><p>Armv8是64位的架构和用的是64位的寄存器,而我们的Neon用的是128位的寄存器,是因为Neon单元是在一个<strong>单独的128位寄存器的寄存器文件</strong>(硬件,可以参照RISC-V内有一个参考文件提及了处理器设计)上进行的操作</p><p><strong>Neon寄存器包含了相同数据类型的元素的向量,这些相同数据类型的元素在输入输出寄存器中的位置是被称为通道lane</strong>(其实就跟数组一个样,不过更加具象化)</p><p><strong>通道数n</strong>:就是指Neon指令会使得n个操作并行执行,这个n就是通道数,比如我们对一个float32x4_t,做加法操作,那这个4就是通道数,因为做了4个float32的加法操作(不过是一条指令).也就是说操作是针对通道lane的</p><p>显然,Neon向量的通道数就取决于向量大小(64位还是128位)和每个通道的数据类型(<strong>8位-B(byte) | 16位-H(halfword) | 32位-S(word,感觉single precision也可以) | 64位-D(doubleword)</strong>)</p><p>以128位的向量来说有:</p><ul><li><strong>16个8位的元素(汇编中寄存器后缀会呈现为<code>.16B</code>)</strong></li><li><strong>8个16位元素(汇编中寄存器后缀会呈现为<code>.8H</code>)</strong></li><li><strong>4个32位元素(汇编中寄存器后缀会呈现为<code>.4S</code>)</strong></li><li><strong>2个64位元素(汇编中寄存器后缀会呈现为<code>.2D</code>)</strong></li></ul><p>以64位向量来说有:</p><ul><li><strong>8个8位的(<code>.8B</code>)</strong></li><li><strong>4个16位的(<code>.4H</code>)</strong></li><li><strong>2个32位的(<code>.2S</code>)</strong></li></ul><p>下图右侧的<code>V0.4S</code>是在汇编中向量寄存器作为操作码的写法(<strong>0表示V0,有32个向量寄存器</strong>)</p><p><img src="https://s2.loli.net/2024/04/18/uckhg4E7wfvAYVF.jpg" alt="ARM-neon vector (64and128)" /></p><p><strong>在向量中元素是从LSB(最低有效位)开始放置的,就是element0(lane0的数据)会用到寄存器的LSB</strong></p><p>有些指令是向量跟一个向量里面的某一个位置的元素进行操作的,比如<code>mul v0.4s v2.4s v3.s[2]</code>就是V2寄存器里的4个float32_t和V3寄存器的lane2处的元素做乘法.如下图示:</p><img src="https://s2.loli.net/2024/04/18/r2SY7ToR5fzQjan.png" alt="ARM-neon instruction using scalars" style="zoom:80%;" /><h2 id="一些arm的基础知识"><a class="markdownIt-Anchor" href="#一些arm的基础知识"></a> 一些ARM的基础知识</h2><p>ARMv8有31个64位的通用寄存器,有32个128位的向量寄存器</p><h2 id="neon-assembly入门"><a class="markdownIt-Anchor" href="#neon-assembly入门"></a> Neon Assembly入门</h2><h3 id="神奇的指令"><a class="markdownIt-Anchor" href="#神奇的指令"></a> 神奇的指令</h3><ul><li><p>预取指令</p><p><code>prfm pldl1keep,[Rn,#imm]</code>,一般见到的是这样的格式</p></li><li></li></ul><p><strong>具体代码参考可见<a href="https://github.com/ayyHA/OperatorDev">opDev</a>中的数组加权和和<code>box_filter</code>盒子滤波的例子</strong></p><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><p><strong>Neon intrinsic系列</strong>:</p><ul><li><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">intrinsic-set reference</a></li><li><a href="https://developer.arm.com/documentation/102467/0201">Learn the architecture - Optimizing C code with Neon intrinsics</a></li><li><a href="https://developer.arm.com/documentation/102474/0100/">Learn the architecture - Introducing Neon</a></li></ul><p><strong>Neon Assembly系列:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/143328317">neon assembly教程-移动端arm cpu优化学习笔记第4弹–内联汇编入门</a></li><li><a href="https://zhuanlan.zhihu.com/p/451014220">ARM Cortex-A 系列ARMv8-A程序员指南： 第6章 A64指令集</a> <mark>未看完</mark></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>assembly</tag>
      
      <tag>armv8</tag>
      
      <tag>ARM architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V汇编知识</title>
    <link href="/2024/04/10/RISC-V%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/10/RISC-V%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a class="markdownIt-Anchor" href="#写在开头"></a> 写在开头</h2><p>在大致查阅了网上社交媒体的一些关于主流芯片的架构的评价后,<strong>x86</strong>,<strong>arm</strong>,<strong>RISC-V</strong>这三个讨论热度最大.其中x86比较闭塞,且从8086出发,学习成本略高,冗余度也高(有部分内容在后续芯片设计开发中被废弃);arm的话生态最好,但是指令集授权(虽然也不是我该关心的事😂)比较hard,有些厂商没有v9的架构,只能用v8一套的生态,但是ARM架构的芯片有应用于PC的(MAC),也有应用移动设备上的,总体前景和生态是优于x86的;RISC-V的话开源,简单,且UC Berkeley在cs61c的课程中教授的就是这个芯片架构及指令集,国内浙大也跟着开授了相关的课程;</p><p>因此决定先从RISC-V学习起一些基础的汇编知识,然后再转到ARMv8上,主体的学习成本依旧放在ARMv8上,<strong>RISC-V只是作为汇编初入门的一个过渡阶段,以及对体系结构知识的温习</strong>;</p><p>关于之前学习的x86下的intrinsic编程,其实在arm中的neon intrinsic也是有类似的知识,知识总是具有相通性,因此也不能说之前如SSE,AVX的编程知识就废弃了,从某种意义上说,思想本质是一样的.借用浮点寄存器/向量寄存器去做SIMD,不过相关的命名规范,指令名称一类的换个样子适配到arm架构上去罢了.也算是一种知识迁移吧~</p><h2 id="与别的isa不同之处"><a class="markdownIt-Anchor" href="#与别的isa不同之处"></a> 与别的ISA不同之处</h2><p>RISC-V与别的指令集架构不同之处在于，它被设计为<strong>模块化ISA</strong>，而如x86是<strong>增量ISA</strong></p><p>增量ISA：在支持原有的指令集的基础上增加新的指令和功能，就是向下兼容的意思（那感觉操作码的位置空间都被占的差不多了…）</p><p><strong>模块化ISA：由1个基本的整数指令集（如RV32I/RV64I）+可选的扩展指令集</strong></p><p><img src="https://s2.loli.net/2024/04/11/LzxNYwOvQ3Kmsoa.png" alt="RISC-V IS basic" /></p><p><img src="https://s2.loli.net/2024/04/11/KpsvP2FqOofh8mr.png" alt="RISC-V IS extension" /></p><div class="note note-info">            <p><strong>注意：在下文的讨论中，我们所采用的基础指令集是RV32I，关于扩展指令集，本文不涉及</strong></p><p>如果想要使用<code>mul</code>,<code>div</code>,<code>rem</code>表示乘，除，取余操作，这些需要加上扩展指令集M才可以用，即RV32IM</p>          </div><h2 id="单位度量"><a class="markdownIt-Anchor" href="#单位度量"></a> 单位度量</h2><p>在RISC-V中,一个字节是8位,16位的被称作半字,32位则称作字(word),64位则是双字</p><div class="note note-info">            <p>注意：在8086的学习中，关于堆栈段里涉及到的字（word）这个的大小是2个字节，所以不同的处理器架构乃至说不同的生态，在一些没有统一定论的数据格式的规范上，是很混乱的，所以这些东西遇到了要查一查文档。</p>          </div><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p>采用32位寄存器（RV32I）,有<strong>32个</strong>,常用别名(一般用别名,有特殊含义)见下表:</p><p><img src="https://s2.loli.net/2024/04/11/lMyUdCmc15LovRQ.png" alt="RISC-V register info" /></p><p>一般在进行数据传输的时候,若是把一个字节的数搬到寄存器中去的话,需要做<strong>符号位扩展</strong>,<strong>即需要将8位的数扩展为32位,且不改变数值本身的大小</strong>.在计算机中是以补码存储,比如<code>(-2)=(10000010)b</code>的补码形式为<code>(11111110)b</code>将其扩展为32为则是用符号位补足剩余的位数<code>(11111111 11111111 11111111 11111110)b </code>,则成功扩展,对补码取补码即得原码,可见依旧是-2</p><h2 id="操作码"><a class="markdownIt-Anchor" href="#操作码"></a> 操作码</h2><p>先给出RV32I的指令集指令表,方便后续查看(其实指令条数不多)</p><p><img src="https://s2.loli.net/2024/04/13/FvdrPtTm5gUQBY3.png" alt="RV32I instruction table" /></p><div class="note note-info">            <p>注释中说的zero-extends指的是零扩展,msb-extends指的是最高有效位扩展(符号位扩展)</p>          </div><h3 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h3><p>在RISC-V中，一般涉及到多个寄存器的操作时，<strong>第一个寄存器一般都是目标寄存器</strong></p><p>RISC-V的<strong>指令</strong>集很清晰，它都是一些<strong>明确语义的英文单词的首字母拼接而成</strong>，如分支指令的<code>bne</code>，表示<u>b</u>ranch <u>n</u>ot <u>e</u>qual</p><p>RISC-V指令集针对不足32位的数的写入会做符号位扩展，而如<code>lw</code>(<u>l</u>oad <u>w</u>ord)一类的则不扩展，因为一个word就是32位，可以满足寄存器的要求，如<code>lb</code>(<u>l</u>oad <u>b</u>yte)则需要做符号位扩展</p><h4 id="基本指令"><a class="markdownIt-Anchor" href="#基本指令"></a> 基本指令</h4><p><code>op rd rs1 rs2</code> (rd: register destination; rs: register source)</p><p>比如一些基础的算术，逻辑运算，如：</p><p><code>add t0 t1 t2 # 将t1,t2寄存器的值相加，放置到t0寄存器中</code></p><p><code>sll t0 t0 t2 #将t0寄存器的值逻辑左移t2值位，放置到t0寄存器中</code></p><h4 id="立即数指令immediate-instruction"><a class="markdownIt-Anchor" href="#立即数指令immediate-instruction"></a> 立即数指令(immediate instruction)</h4><p><code>opi rd rs imm</code></p><p>比如<code>addi t0 x0 2</code> t0的值被置位2，<strong>x0这个寄存器的值永远是0</strong></p><p>立即数指令基本上都是在相应的操作码后面加个<strong>i</strong>（immediate）</p><h4 id="分支指令branch-instruction有条件的跳转"><a class="markdownIt-Anchor" href="#分支指令branch-instruction有条件的跳转"></a> 分支指令(branch instruction)[有条件的跳转]</h4><p><code>bop rs1 rs2 label</code></p><p>分支指令是<code>rs1 bop rs2</code>时，则会跳转到label的位置（条件跳转），当然后面的label也可以换做是数字，比如是个100，那就表示条件满足则令pc=pc+2*100</p><div class="note note-info">            <p>注意：pc是程序计数器，指示的是下一条指令的位置，修改pc即是指示程序下一条指令应该取哪的。我们的指令都是4字节的，合理来说应该*4才对，但好像是为了兼容16位的，所以*2</p><p>而作为一个标签,比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x1c |beq rs1 rs2 loop # 前面那|是用来分隔下地址和指令<br># ...<br># ...<br>0x38 |loop: ...<br></code></pre></td></tr></table></figure><p>这里我们当<code>rs1==rs2</code>会跳转到loop这个标签**,loop实际上指代的就是<code>loop:...</code>这条指令的地址**,实际在运行的时候它会被转换成一个偏移值,即分支指令的标签会被替换为:<strong>下一条指令地址相较于loop所指代指令地址的值</strong>,这个值是以字节为单位的,比如上面那里的值是0x38-0x20(0x1c + 0x4) = 0x18 = 24(10)字节,而按照上面说的会对数字*2处理,因此实际这个偏移量会是12(以2字节,也即是半字为偏移量的系数)</p><p><mark>但实际上我在模拟器上试的时候显示的是6,即是以字为偏移量系数</mark></p><img src="https://s2.loli.net/2024/04/15/qrVfZ6ARzBLdwsC.png" alt="RISC-V strange label offset" style="zoom:65%;" />          </div><p>分支指令可以用来做for,while一类的循环</p><p>示例for(while差不多)：</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs as"><span class="hljs-comment">/* C码:</span><br><span class="hljs-comment">// t0 -&gt; i,t1 -&gt; 10</span><br><span class="hljs-comment">for(int i=0;i&lt;10;i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br># RISC-V assemble<br>addi t0 x0 <span class="hljs-number">0</span><br>addi t1 x0 <span class="hljs-number">10</span><br>loop: bge t0 t1 end<br>...<br>addi t0 t0 <span class="hljs-number">1</span><br>beq x0 x0 loop # 也可以这么写jal x0 loop <br>end:<br># 跳出循环了<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注意：因为我们的分支指令是有条件的跳转，满足条件则跳到指定标签，即跳出循环；而对于循环而言是符合条件就在循环里面，因此<strong>写分支指令的时候，条件反着写更好</strong>，比如i&lt;10则在循环内，那我们可以写作i≥10再跳到标签（跳出循环），然后需要注意<strong>循环条件的变化</strong>以及<strong>重新跳回循环的判断处</strong>（循环开始的标签）</p>          </div><h4 id="数据传输指令内存和寄存器的交流"><a class="markdownIt-Anchor" href="#数据传输指令内存和寄存器的交流"></a> 数据传输指令[内存和寄存器的交流]</h4><p>现在CISC和RISC指令集其实都很纷繁复杂，一种比较明显的区别是CISC中的访存操作存在隐式的，而RISC中则是显式的进行访存操作（通过访存取值如load，将值从寄存器写回内存的store）</p><ul><li><code>lw rd imm(rs)</code>rs里的值作为基址，imm作为偏移,从(rs+imm)表示的内存地址开始，依次取1个<u>w</u>ord的数据放到rd中去</li><li><code>sw rd imm(rs) </code>跟上面一样，不过是把rd里的32位的值，放置到以(rs+imm)表示的内存地址所指向的空间，一个地址指向的空间可以存放的是一个字节的数据，这里要放4个字节的数据，即(rs+imm)~(rs+imm+3)的空间内放的都是rd的值（具体放的顺序看大小端）</li><li><code>lb rd imm(rs)</code> 跟lw差不多，不过这里取的是一个字节，要做符号位扩展，放到rd中去（如果是lbu这种，就是无符号扩展，前面填0补够位数就好了）</li><li><code>sb rd imm(rs)</code>跟sw差不多，不过因为是一个字节，直接塞到(rs+imm)指向的空间里面去就好</li></ul><h4 id="跳转指令无条件的跳转"><a class="markdownIt-Anchor" href="#跳转指令无条件的跳转"></a> 跳转指令[无条件的跳转]</h4><p><code>jal rd label</code> jump and link,一般这个rd是ra(return address)这个寄存器。在调用这条指令的时候会先把pc的值+4再存入ra，然后无条件跳转到label处，当然这个label可以是我们的函数名，也可以是100这样的东西，就相当于pc= pc + 2*100，将pc换成这个值，然后执行下一条指令的时候就会去取这个pc，就会跳到我们期望的位置了，label实际上也是这样，就是改变pc，让它跳到我们的函数区域。</p><h3 id="伪指令"><a class="markdownIt-Anchor" href="#伪指令"></a> 伪指令</h3><p><strong>伪指令易于记忆和使用</strong>,会被<strong>汇编器翻译成一条或多条对应的汇编指令</strong>,本身并不具备扩展指令集的功能,类似于我们在C中喜欢用<code>typedef / #define</code></p><ul><li><code>mv rd rs</code>，这个是让rd寄存器获取rs寄存器的值（register copy）</li><li><code>li rd imm</code> li表示load immediate，往rd里放立即数的值</li><li><code>la rd symbol</code>la表示load address,对应<code>auipc rd,symbol[31:12]</code>和<code>addi rd,rd,symbol[11:0]</code>这两条指令,看起来就是把symbol的所有位数与PC相加然后放到了rd里面.之所以这样做,是因为我们的I型指令的立即数位数只有12位,U型指令的立即数位数有20位,通过这样操作,才可以让pc加上完整的symbol,然后放置到rd中去(这个symbol应该是偏移量,这样pc+symbol就是期望的地址)</li><li><code>ret</code>即pc从当前位置返回到ra所指向的指令位置，实际是通过<code>jalr x0 ra 0</code>即pc=ra+0，这是一条I型指令即<code>jalr rd rs imm</code>表示rd=pc+4,pc=rs+imm</li></ul><img src="https://s2.loli.net/2024/04/12/SWBmroywzQViFpM.png" alt="RISC-V pseudo instruction" style="zoom:67%;" /><h3 id="伪操作"><a class="markdownIt-Anchor" href="#伪操作"></a> 伪操作</h3><p><strong>伪操作用于指导汇编器去理解汇编程序的行为</strong>.<strong>以<code>.</code>作为伪操作的开头</strong></p><ul><li>声明当前属于哪个段<ul><li><code>.data</code> 已初始化的全局变量静态变量</li><li><code>.text</code> 代码段</li><li><code>.bss</code>未初始化的全局变量静态变量</li></ul></li><li>声明字串<ul><li><code>str1: .string &quot;哈哈哈哈哈2\n&quot;</code></li></ul></li><li>定义符号<ul><li><code>.set tmp,100</code></li></ul></li><li>定义字节/半字/字数组<ul><li><code>byte_list: .byte 1,2,3</code></li><li><code>word_list:.word 0x12345678,0x111 </code></li></ul></li><li>做地址对齐<ul><li><code>.align 3</code></li><li><code>.balign 4</code></li></ul></li></ul><div class="note note-info">            <p><strong>标签和符号实际上都是代表内存地址</strong>(如<code>str1:</code>代表这里的(数据)地址和<code>loop:</code>代表这里的(指令)地址,本质上是一样的,只不过内存被分了段),然后易于记忆和使用,但是标签应该更多的是指用于流程控制(比如<code>bne x0,x0,loop</code>),而符号则是如变量这些(比如<code> li t0,tmp</code>,其中tmp在数据段被定义<code>.set tmp,100</code>)</p><p>二者之后都会被弄到<strong>符号表</strong>去</p>          </div><h3 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h3><p><strong>宏实际上是由伪操作组成的</strong></p><p>用<code>.macro macro_name,para1,para2,...</code>定义宏,用<code>.endm</code>结束宏,通过利用宏定义,我们可以弄出一些属于自己的频繁使用的伪指令,调用时直接宏名作为指令名,然后传入需要的参数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># 采用宏声明一个乘加操作,以实现a+b*c,将结果存在t1寄存器中<br>.macro mul_add, a,b,c<br>mul t0,b,c<br>add t1,a,t0<br>.endm<br><br>.text<br>mul_add a0,a1,a2<br></code></pre></td></tr></table></figure><p>汇编器处理宏时,会进行宏替换,把宏体里的形参用实参替换,生成的指令插入到对应的位置</p><h2 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h2><p>从jal这一条指令来看，函数调用即是我们在调用前把需要传入的参数放入a0~a7这些参数寄存器中，然后通过jal把下一条指令的地址放到ra中去，以便return,然后就跳转到jal中标定的label，即是我们的函数名，执行完毕后可以把要返回的值放入a0，然后ret。</p><p>实际中我们的函数调用涉及到栈帧概念.</p><h3 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h3><h2 id="关于嵌套的函数"><a class="markdownIt-Anchor" href="#关于嵌套的函数"></a> 关于嵌套的函数</h2><p>函数P调用函数Q，P称为调用者(caller)，Q称为被调用者（callee），它们两个各自有需要保存的寄存器，只需要压栈保护自己要保存的东西即可，然后可以用另一方的寄存器。</p><h2 id="指令格式"><a class="markdownIt-Anchor" href="#指令格式"></a> 指令格式</h2><p>在RISC-V中，每一条指令都是<strong>4字节</strong>，这跟那种指令不定长的指令集不同，每条指令均为4个字节的设计，PC自动增4，以跳到下一跳指令的内存位置，同时也方便我们的硬件解析指令的设计，因为32位的指令中，哪个位置是放寄存器的，哪个位置是放操作码的是固定的。</p><p>以下是RV32I的指令集格式，共有六种类型的指令。其中<strong>opcode</strong>代表的是<strong>操作码</strong>，<strong>rd</strong>(register destination)代表的是<strong>目标寄存器</strong>,<strong>rs</strong>(register source)代表的是<strong>源操作器</strong>，funct3代表的是3位的用来指示该操作码具体指令的功能，funct7同理，<strong>imm</strong>代表的是<strong>立即数</strong>，有的imm是分为高低位被拆开的，imm有12位的，也有20位的，具体是针对不同的指令类型而言。</p><ul><li><p>R-type代表的是三种寄存器的指令类型;</p></li><li><p>I-type代表的是load指令和有立即数的指令.而这里的立即数只取低12位,因此取值范围是[-2048,2047];</p></li><li><p>S-type代表的是store类型的指令;</p></li><li><p>SB-type代表的是分支指令;</p></li><li><p>U-type代表的是upper immediate，有LUI(load upper immediate)和AUIPC(add upper immediate PC)这两条指令，前者表示<code>lui rd imm # rd = imm &lt;&lt; 12</code>,后者为<code>auipc rd imm # rd = pc + imm &lt;&lt; 12</code>.为什么需要这一个类型的指令呢?上面讲<code>la</code>伪指令讲了.因此如果想要将一个高于12位的立即数放入到寄存器中可以通过移位的指令达成,也可以通过LUI达成,如想要将<code>0x00009000</code>这个值放入寄存器中,通过<code>lui t0 0x00009</code>即可.如果想获得如<code>0x12345abc</code>,则</p><p><code>lui  t0 0x12345</code> <code>addi t0 t0 0xabc</code>即可.</p></li><li><p>UJ-type代表的是无条件跳转指令</p></li></ul><p><img src="https://s2.loli.net/2024/04/11/O2UbnNtp8XPx1Ki.png" alt="RISC-V instruction format" /></p><div class="note note-info">            <ul><li>有的版本会把SB类型写成B类型,把UJ写成J类型</li><li><strong>立即数之所以被拆开来(比如S型指令)</strong>,是因为整体的体系结构在设计的时候尽量让所有位置少变动,比如opcode一直在[0,6]位,<strong>保持尽可能相似的指令格式以降低硬件的设计复杂性</strong></li><li>SB型指令的立即数写作<code>imm[12|10:5]</code>表示的是,指令格式的第31位存储的是立即数的第12位,指令格式的[25,30]位存储的是立即数的[5,10]位,之所以这么设计,我猜测跟硬件电路设计有关系</li><li>我们所有指令都是4字节的,需要做<strong>偶数对齐</strong>,即指令跳转的时候令PC+奇数肯定是错误的,因此PC+上的一定是偶数,因此SB型指令的第0位恒定是0(其实<code>PC+= imm*2</code>,为啥乘2而不是4,感觉不是前面说的兼容16位,没找到有16位的RV16I这种东东,或许是从加上的是偶数这个地方出发,从而*2)</li></ul>          </div><h2 id="内存布局"><a class="markdownIt-Anchor" href="#内存布局"></a> 内存布局</h2><p>我们整个程序都是存在内存中的，无论是指令还是数据（函数本质上也是指令和数据的复合体），因此将内存划分成了几个区域来存储我们的程序</p><p>有一部分数据是运行的时候不会变的，比如字符串，比如代码，这些就放在ROM区，而函数的调用涉及到的栈帧开销，对象创建涉及到的新内存开辟，统一成员信息的静态变量，全局可见的全局变量，则放在RAM区。</p><p>为此对于代码段给它起个名字叫text，对字符串这种只读的常量放置在rodata(<mark>这个在RISCV中还没有,用伪操作别用它,直接用data</mark>)处，它俩都是ROM区的；</p><p>对已初始化的全局变量，静态变量则放置在data处；对未初始化的全局变量静态变量则放在bss(block started by symbol segment)处；再往上就是heap，堆区，用于存放malloc等方式分配出来的变量；再往上就是stack区，用来存放函数。整体的内存布局如下图所示：</p><img src="https://s2.loli.net/2024/04/11/vOx8CgkTUuWeHsb.png" alt="memory allocation" style="zoom:50%;" /><img src="https://s2.loli.net/2024/04/11/bUkD25KZzONXPRt.png" alt="RISC-V-memory allocation" style="zoom:67%;" /><p>而在RISC-V内存分配图的右边则是一个栈帧的图,可以看到它的fp用作ebp的功能，sp用作esp的功能（这里的ebp和esp是x86系列里关于栈帧的俩指针）</p><h2 id="关于代码编写"><a class="markdownIt-Anchor" href="#关于代码编写"></a> 关于代码编写</h2><p>若想在以RISC-V架构的处理器上进行编程,需要一套对应的编程工具链(编译器,汇编器,链接器,加载器)</p><p>而目前大多数的处理器是x86架构或是ARM架构,因此需要先用QEMU模拟器,模拟对应的处理器,然后搭建对应的编译环境,相关信息请参阅参考文件中关于环境搭建的文章进行执行</p><p>本文考虑到学习成本,先不予搭建(其实有云服务器的话会好很多,不然太麻烦了)</p><p>后期有时间再搭建,玩一玩~</p><hr /><p>谷歌的colab有用于RISC-V的汇编学习的教程，在此编程~</p><p>主要是编程完后用clang和lld生成可执行文件，再提交可执行文件给<strong>RISC-V-ALE</strong>（RISC-V-assemble language environment）解析及运行</p><h2 id="risc-v的特权架构"><a class="markdownIt-Anchor" href="#risc-v的特权架构"></a> RISC-V的特权架构</h2><p>RISC-V有三级特权架构，<strong>U-User S-Supervisor M-Machine</strong>，越往后的则权限等级越高</p><p>之所以会学到特权架构，是因为在使用colab的helloworld程序时，看到了一个叫做ecall的指令，这个指令很奇怪，就光秃秃一个操作符，没有操作数</p><p>ecall叫做environment call,是一个环境调用指令，调用它的时候，我们会从U模式切换到更高级的模式，在更高级的模式有一类称为CSR(control state register，控制状态寄存器)的寄存器，这是在S和M模式才有的寄存器，在进行模式切换的时候，会对我们的PC进行保存，保存在sepc/mepc，这个e实际上是exception，即是<strong>异常</strong>的意思，跟x86一样，<strong>RISC-V也存在中断和异常的处理</strong>。程序会在stvec/mtvec找到中断的基址，然后在scause/mcasue中找到这次异常对应的号码（见下图）,然后发现是环境调用异常事件（发生地址跳转），就会去寄存器a7（参数寄存器那个a7）里看你想要处理的是什么系统调用（我们在a7存放的值被称为<strong>系统调用号</strong>，见再下一个图），然后a0~a6传入的是参数，处理好后会把返回值放到a0寄存器里面去。</p><img src="https://s2.loli.net/2024/04/12/UD4uEVdS1fjKJbX.png" alt="[m,s]cause code" style="zoom:67%;" /><img src="https://s2.loli.net/2024/04/15/RLWbIwSiBEvkDCj.png" alt="RISC-V syscall number" style="zoom:67%;" /><p>详细了解中断可以从这篇文章去看<a href="https://blog.csdn.net/weixin_42031299/article/details/134033246?spm=1001.2014.3001.5502">RISC-V中断处理和中断控制器</a></p><h2 id="关于x86中的intel规范和att规范"><a class="markdownIt-Anchor" href="#关于x86中的intel规范和att规范"></a> 关于X86中的Intel规范和AT&amp;T规范</h2><img src="https://s2.loli.net/2024/04/15/EiXF1kgNthYS8Uu.png" alt="at&t and intel assembly style" style="zoom:65%;" /><p><a href="https://www.cnblogs.com/wanghuizhao/p/16388198.html">at&amp;t和Intel汇编风格</a></p><h2 id="关于clang和lld"><a class="markdownIt-Anchor" href="#关于clang和lld"></a> 关于clang和lld</h2><p>在colab提供的clang和lld中，大致说一下它二者的作用：</p><ul><li>clang</li><li>lld 用作链接器</li></ul><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://www.zhihu.com/column/c_1747638745254453248">UCB CS61C课程笔记</a></li><li><a href="https://blog.csdn.net/m0_62730135/article/details/126799687">一文学懂RISC-V汇编操作</a></li><li><a href="https://zhuanlan.zhihu.com/p/337147166">RISC-V 汇编语言程序设计基础简析</a></li><li><a href="https://www.zhihu.com/column/c_1215698269139152896">一起学习RISC-V编程</a></li><li><a href="https://zhuanlan.zhihu.com/p/259305354">RISC-V编译环境的搭建</a></li><li><s><a href="https://riscv-programming.org/">RISC-V汇编学习环境</a></s></li><li><a href="https://creatorsim.github.io/creator/">在线RISC-V汇编学习环境(有样例,以及优秀的调试面板,但是系统调用号啥的好像不一样)</a></li><li><s><a href="https://antoniocgj.github.io/RISC-V-ALE/">RISC-ALE</a></s></li><li><a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf">RISC-V card</a></li><li><a href="https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf">RISC-V card2(有扩展指令集，伪指令等的解析，更全面)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些奇奇怪怪的hpc技术栈</title>
    <link href="/2024/04/09/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84hpc%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2024/04/09/%E4%B8%80%E4%BA%9B%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84hpc%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>因为大多数知识都是通过网络了解,有一些奇怪且必须了解且有前景的技术或是与HPC相关的技术栈会被记录在此</p><h2 id="模型压缩"><a class="markdownIt-Anchor" href="#模型压缩"></a> 模型压缩</h2><ul><li>量化</li><li>蒸馏</li><li>剪枝</li><li>二值化</li></ul><h2 id="模型转换"><a class="markdownIt-Anchor" href="#模型转换"></a> 模型转换</h2><ul><li>onnx</li></ul><h2 id="模型推理"><a class="markdownIt-Anchor" href="#模型推理"></a> 模型推理</h2><ul><li><strong>tensorRT</strong></li><li><strong>TVM</strong></li></ul><h2 id="推理优化"><a class="markdownIt-Anchor" href="#推理优化"></a> 推理优化</h2><h2 id="算子开发"><a class="markdownIt-Anchor" href="#算子开发"></a> 算子开发</h2><ul><li><strong>JIT:</strong> just in time,一款编译器</li><li><strong>xbyak</strong>: 类汇编的C</li><li><strong>RISC-V</strong>: 一个初学的精简指令集</li><li><strong>ARMv8</strong>: 之后主体采用armv8的汇编指令进行算子ILP</li><li><strong>cutlass</strong>: 主要对运用TensorCore对密集计算进行优化.编写算子本质上是密集计算的性能问题,要写一个极致优化的算子is hard,cutlass可以提供一个模板库来实现高性能的密集计算算子<ul><li>参考资料: <a href="https://zhuanlan.zhihu.com/p/677616101">cutlass相关教程系列</a></li></ul></li></ul><p><strong>AscendC</strong>是华为公司开发的一款编程语言</p>]]></content>
    
    
    
    <tags>
      
      <tag>hpc</tag>
      
      <tag>cutlass</tag>
      
      <tag>tvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OperatorDev常见优化方案</title>
    <link href="/2024/04/05/OperatorDev%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <url>/2024/04/05/OperatorDev%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h2><p>减少函数调用带来的栈帧开销,适用于那些简单的函数</p><h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2><p>对于GPU来说,没有分支预测功能,循环展开可以帮助它少做判断,少走分支,规避掉warp divergence.</p><p>比如<code>for(int i=0;i&lt;tid;i++)&#123;...&#125; // 其中tid代表block内的线程号</code>可以看出对于[0,31]这一个warp内的线程来说,有很严重的线程束分化.通过循环展开的话,可以减少条件判断的次数;</p><h2 id="分块打包"><a class="markdownIt-Anchor" href="#分块打包"></a> 分块打包</h2><p>分块的意义在于充分的利用其多层缓存机制,数据放在正确的位置,可以在存取的时候减少延迟,同时可以使得数据被复用;</p><p>打包又叫数据重排,把数据放在连续的内存地址,既有利于预取,还有利于少占用TLB条目的数量</p><h2 id="指令级并行ilp"><a class="markdownIt-Anchor" href="#指令级并行ilp"></a> 指令级并行(ILP)</h2><p>指令执行是在不同CPU部件上的,单一的串行执行不能很好发挥各部件的性能,为了使得各部件一直处于繁忙状态,由此出现了流水线技术.经典的五级流水线结构是:<strong>取指(Instruction Fetch),译码(Instruction Decode),执行(EXE),访存(MEM),写回(Write Back)</strong>.各部分的详细功能如下:</p><ul><li>取指: 从L1-ICache中取出指令;</li><li>译码: 将取出的指令按照相应架构的指定读取方式进行翻译,读出操作数,操作类型等;</li><li>执行: 交由具体的功能单元如ALU来执行相应操作;</li><li>访存: 从内存中取数据到寄存器(load)或将数据写入内存中(store),这里是L1-DCache;</li><li>写回: 将指令执行结果写回RegisterFile中去</li></ul><hr /><p>CPI(Cycle Per Instruction):每个指令的时钟周期数</p><p>IPC(Instruction Per Cycle):每个时钟周期能流出的指令数</p><ul><li><p><strong>时钟周期</strong></p><p>最小的时间单位,也叫振荡周期,也叫节拍,以主频10GHZ为例,表示1s内能振荡10<sup>10</sup>次,也就是说一个时钟周期即是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow></mfrac><mi>s</mi></mrow><annotation encoding="application/x-tex">\frac{1}{10^{10}}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight"><span class="mord mtight">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">s</span></span></span></span>,即是0.1ns</p></li><li><p><strong>机器周期</strong></p><p>由多个时钟周期组成,<strong>用来表示流水线阶段的基本单位</strong>,所包含时钟周期个数叫做机器周期的<strong>时间宽度</strong>.如果每个机器周期时间宽度相等则为<strong>定长机器周期</strong>,反之为<strong>变长机器周期</strong></p></li><li><p><strong>指令周期</strong></p><p>由多个机器周期组成</p></li></ul><p>流水线级数增加对指令执行时间的影响在于增加了很多小的流水段,这些流水段把任务更加细分,实际上是<strong>追求机器周期尽可能等于时钟周期</strong>*(即是期望CPI-&gt;1),从单个指令的完整执行上看,时间是被拉长了的,因为中间的结果你可以要用一些锁存器一类的进行存储,但是指令的吞吐量增大了</p><p>比如一个操作4级流水线,每个流水段假设80ns,变成11级流水线,每个流水段30us,整体的执行时间是多了10us,但在无流水线的情况下该指令执行完成需要280us.通过流水线可以看出来明显的增加了吞吐量:<code>280/80≈3.5</code>可以看出来四级流水线相较于无流水线的情况增加了3.5倍的吞吐,若是11级流水线则是<code>280/30≈9.3</code>9.3倍的吞吐量的增加!</p><p>因此流水线处理的好处在于指令的吞吐增大了非常多,因为我们指令不需要完整等待上一个指令完成才进入.但是单一流水线无论如何优化,它的界限就是<code>IPC=1</code></p><hr /><p>指令级并行意味着一个时间周期内可以同时并行执行超过1条指令的能力</p><p>为了支持指令级并行,有多发射技术,如下图示:</p><img src="https://s2.loli.net/2024/05/10/OuTSmIepjndhwD9.png" alt="Multi Issue" style="zoom:67%;" /><p>多发射并不意味着会有多套重复的流水线部件,但它具备同时并行执行多条指令,也即是执行部件会增多,执行部件被称作FU(functional unit),比如ALU,AGU(address generation unit),BRU(branch unit),FPU等,都是FU中的一种(SIMD的部件也是)</p><p>而取指则通过增强取指部件,一次取多条指令,译码器则通过增加部件进行译码,如此来实现多流水线,从而达到<code>IPC&gt;1</code>的效果</p><p>从这张图来说,多发射包括静态多发射和动态多发射:</p><p>静态多发射即是指的超长指令字(VLIW)一类的方式,一次性将多个指令给它弄成一个指令包,然后在取指译译码的时候都是针对这一个大大指令包,它是静态的在于它是通过编译器来实现多发射,是软件层面的实现而非硬件层面的实现;</p><p>动态多发射是指超标量,它通过一次读取多条指令,通过多个译码器进行译码,后续根据执行的时候是乱序的还是顺序再进行细分</p><p>以下给出一张A76的微架构图,它的多发射采用的是超标量乱序执行的方式:</p><p><img src="https://s2.loli.net/2024/07/13/IvPHtFbCN1GTKR9.png" alt="A76-micro-architecture" /></p><p><strong>乱序执行</strong></p><p>想要同时执行指令,则前后的指令不应有相关性,相关性类型有以下三种:</p><ul><li><strong>WAR 读后写</strong></li><li><strong>WAW 写后写</strong></li><li><strong>RAW 写后读</strong></li></ul><p>前面两种可以通过Rename,即重命名寄存器的方式解决,而后面的一种则是真正的依赖,因为不按这个顺序处理你会脏读,它是通过<strong>旁路</strong>来处理的</p><p>还有一种相关性是<strong>控制相关性</strong>,即分支指令引起的,这是<strong>分支预测</strong>负责的任务</p><p>主要参见参考文件2,没整理好</p><div class="note note-info">            <p>在理解的时候忽然想到了超线程,即一个核心内,同时有两套寄存器和缓存以保留两份工作现场,这样可以丝滑切换线程.而如果是一个核心内,普通情况下(即只有一套寄存器,缓存)进行多线程,则需要涉及到工作现场的切换,这种多线程(单核心)是不丝滑的</p>          </div><h2 id="指令重排"><a class="markdownIt-Anchor" href="#指令重排"></a> 指令重排</h2><p>一般来说指令重排是发生在<strong>编译时期(静态)<strong>和</strong>运行时期(动态)</strong></p><ul><li><p>编译时期的指令重排:当前后指令存在相关性时,顺序执行则会发生阻塞,可以把后续一些无相关性的指令提前执行,以减少阻塞等待的时间.如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a++;<br>b = a + <span class="hljs-number">2</span>;<br>c--;<br></code></pre></td></tr></table></figure><p>则b对于a是有数据依赖(RAW)的,必须等<code>a++</code>执行完才才能执行b的语句,若是顺序执行,则在五级流水线中,当第二条语句处于exe的流水段时,第一条语句是处于mem流水段,并没有到wb到相应的寄存器文件中去,所以此时会发生流水线停顿.而通过指令重排,则可以规避掉这个停顿</p><div class="note note-info">            <p>注:实际上,上面的这个例子并不太好,因为处理器设计的时候考虑到了这个问题,有一个叫做forwarding的前递设计,会把执行后的结果传递给有依赖的指令</p><p>但并不是说指令重排就不重要了,事实上比如<code>a=b+c</code>,以汇编的形式写出就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm__ volatile(<br>ldr w0,[%b]// IF   ID   EXE  MEM   WB<br>ldr w1,[%c]//     IF   ID   EXE   MEM    WB<br>add w2,w0,w1//        IF   ID    EXE(×) EXE WB<br>str w2,[%a]<br>: [a] &quot;+r&quot;(a)<br>: [b] &quot;+r&quot;(b),<br>  [c] &quot;+r&quot;(c)<br>: &quot;cc&quot;,&quot;memory&quot;,&quot;w0&quot;,&quot;w1&quot;,&quot;w2&quot;<br>);<br></code></pre></td></tr></table></figure><p>从上面的内联汇编中可以看出,这样会导致流水线停顿,因此可以把后面不相关的指令提前(则重排了指令)以规避停顿的问题</p>          </div></li><li><p>运行时期的指令重排即是上面所说的乱序执行,是动态的,由硬件控制的</p></li></ul><p>从单线程的角度出发,指令重排并不会对最终的结果产生什么影响,它的结果和顺序执行是一样的,目的只是为了优化流水线并行,提升程序的执行效率</p><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><ul><li><a href="https://www.cnblogs.com/openix/p/4085666.html">发射Issue</a></li><li><a href="https://zhuanlan.zhihu.com/p/195008675">超标量处理器流水线</a></li><li><a href="https://www.zhihu.com/column/c_1534317687497138176">超标量处理器设计</a></li><li><a href="https://blog.csdn.net/zongza/article/details/82874937">指令级并行</a></li><li><a href="https://zhuanlan.zhihu.com/p/676396222">CPU微架构</a></li><li><a href="https://blog.csdn.net/qq_39815222/article/details/111471063">计算机并行性的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/461519409">时钟周期、机器周期与指令周期</a></li><li><a href="https://www.cnblogs.com/myseries/p/14458367.html">CPU流水线</a></li><li><a href="https://blog.51cto.com/u_16213606/9632493">A76-A77-A78微架构对比</a></li><li><a href="https://blog.csdn.net/qq_29768741/article/details/105224252">体系结构小白笔记</a></li><li><a href="http://www.360doc.com/content/14/1104/15/13336430_422441127.shtml">SandyBridge MicroArchitecture</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GEMM</tag>
      
      <tag>Conv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>review-CS-basic-knowledge</title>
    <link href="/2024/04/03/review-CS-basic-knowledge/"/>
    <url>/2024/04/03/review-CS-basic-knowledge/</url>
    
    <content type="html"><![CDATA[<h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2><p>参考资料：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp">ms智能指针</a></li><li><a href="https://blog.csdn.net/qq_45445740/article/details/134520594">C++智能指针</a></li></ul><h2 id="总线相关"><a class="markdownIt-Anchor" href="#总线相关"></a> 总线相关</h2><p>CPU内部和cache是通过<strong>本地总线</strong>(<strong>local bus</strong>,又叫<strong>后端总线</strong>)连接的,而访存是通过接口连上<strong>系统总线</strong>,系统总线又连上<strong>IO桥接器</strong>(<strong>北桥芯片</strong>),桥接器一端是IO总线,一端是内存总线(又叫<strong>前端总线</strong>)</p><img src="https://s2.loli.net/2024/05/16/Ih2SJvQTrjWnf65.png" alt="bus-arch-rough" style="zoom:67%;" /><ul><li><strong>北桥芯片主要控制CPU内存显卡等高速设备</strong></li><li><strong>后南桥芯片被加入,是用来负责IO总线之间的通信</strong></li></ul><img src="https://s2.loli.net/2024/05/16/27JjqrCkyudGpXb.png" alt="bus-arch-rough-south" style="zoom:67%;" /><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/675605402">揭秘计算机内部通信：探秘数据、地址与控制信号的奥秘</a></li></ul><h2 id="cpu的三级缓存"><a class="markdownIt-Anchor" href="#cpu的三级缓存"></a> CPU的三级缓存</h2><p>CPU的三级缓存:<strong>L1Cache,L2Cache,L3Cache</strong></p><p>其中L1,L2是核心(core)内的缓存,而L3则是多核心共用的缓存,也在片内</p><img src="https://s2.loli.net/2024/05/16/YhIQ6XFWfeu9OaZ.png" alt="3level-cache-arch" style="zoom:80%;" /><p>L1Cache是分离缓存,分为L1 D-Cache和L1 I-Cache可以避免访存冲突(总不可能流水线处理的时候IF和MEM这俩个流水段打起来吧)</p><p>L2Cache则变为统一缓存,毕竟分离缓存的size不好掌握,cache资源又宝贵,如果分离的话,又cache没用满就吃亏了</p><img src="https://s2.loli.net/2024/05/16/v8coAk6V4GFzudN.png" alt="cache-arch" style="zoom:80%;" /><p>从<strong>单核的缓存一致性</strong>来讲,有**写直达(Write through)和写回(Write back)**两种策略来确保缓存一致性</p><ul><li><strong>Write through</strong>无论你这个更新的数据在不在cache内都得写回内存;</li></ul><img src="https://s2.loli.net/2024/05/16/Dpk2J5VFNM6AHwv.png" alt="cache-write-through" style="zoom:80%;" /><ul><li><strong>Write back</strong>则是多了个dirty标志位,标识cache line中的数据和内存中的是否一致,不过这会使得读cache line进去,且cache已满,且交换出去的cache块是dirty的,就要执行一次写操作</li></ul><img src="https://s2.loli.net/2024/05/16/sfurLUeI3XVTElW.png" alt="cache-write-back" style="zoom:80%;" /><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/669258217">一文吃透CPU三级缓存</a> 只讲了单个核心的缓存一致性问题，对于多个核心的缓存一致性问题没有描述</li><li><a href="https://zhuanlan.zhihu.com/p/584128599">我把 CPU 三级缓存的秘密，藏在这 8 张图里</a></li></ul><h2 id="内存对齐"><a class="markdownIt-Anchor" href="#内存对齐"></a> 内存对齐</h2><h2 id="c语言的存储层次"><a class="markdownIt-Anchor" href="#c语言的存储层次"></a> C语言的存储层次</h2><p>参考资料:</p><ul><li><a href="https://blog.csdn.net/xiandang8023/article/details/126036564">C语言的内存层次</a></li></ul><h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2><p>关于虚存,<strong>每个进程都有虚存</strong>,比如32位的os就给每个进程弄个4GB的虚存,用虚存可以相较于用真实的物理地址:</p><ul><li>可以给人制造扩大内存的假象(无限大),<strong>规避内存不足的问题</strong>(当然如果真的物理内存不足了,就会通过内存页面置换策略,把久没用到的页帧放到swap分区里面,然后把要用的页帧替上去,不过这个过程涉及到硬盘读取,slow);</li><li>然后也<strong>不存在</strong>同时<strong>访问同一地址</strong>修改造成的<strong>数据冲突</strong>;</li><li>也可以对<strong>碎片化的内存</strong>进行使用;</li></ul><p>通过<strong>MMU(Memory Management Unit)<strong>这个部件来实现</strong>VA -&gt; PA</strong>(CPU收到VA交给它翻译成PA),它是通过<strong>TLB(快表)<strong>和</strong>页表(Page Table)<strong>这俩个表来实现VA-&gt;PA的(<strong>页表是放在进程的内存里面的</strong>),TLB里面放置的是Page Table的常用页表项(局部性原理)<br />这俩表里面放的都是叫做&quot;<strong>页表项</strong>&quot;的东东,是</strong>VA-&gt;PA的映射</strong><br /><strong>每个物理页和虚拟页是大小相等的4KB,它们的映射关系就是一对页表项</strong></p><p>什么时候会出现<strong>缺页异常</strong>呢?显然是在我们的TLB和Page Table都找不到映射关系或没有权限,就报异常(Page Fault)了,而这个异常,会让你的CPU读不到数据,它就罢工,进程就出现了缺页中断,用户态就切换到了内核态,就交由内核的PageFaultHandler来处理:<br />分三类缺页中断:</p><ul><li><strong>Hard Page Fault/Major Page Fault</strong>: 就是找不到这个映射关系了(页帧),要CPU去打开磁盘设备读取到物理内存中,再让MMU建立VA-&gt;PA的映射关系;</li><li><strong>Soft Page Fault/Minor Page Fault</strong>: 实际上物理内存有这个页帧,是被别的进程调入的,我们这个进程不知道而已.只需要MMU建立VA-&gt;PA的映射关系即可.(一般出现在多进程共享内存区域);</li><li><strong>Invalid Page Fault</strong>: 内存地址越界,解空指针引用,权限问题,那么内核就会报Segment Fault,中断你的进程(挂掉你的进程)</li></ul><p><strong>内存的惰性分配(或者叫延时分配),malloc并无真正分配,只是用到你申请的物理内存时,发现没有才会启动申请,这期间就会出现Page Fault</strong></p><p>参考资料:</p><ul><li><a href="https://blog.csdn.net/fwb330198372/article/details/107343468">深入浅出：操作系统之虚拟内存</a></li><li><a href="https://blog.csdn.net/Mind_programmonkey/article/details/116722530">【计算机操作系统-内存管理】-内存的缺页异常是什么？现在有逻辑地址，但是物理地址没有加载到内存会怎么样？</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OperatingSystem</tag>
      
      <tag>ComputerNetwork</tag>
      
      <tag>ComputerComposition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GEMM-intrinsic优化</title>
    <link href="/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/"/>
    <url>/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面:</h2><p>对于一个想<strong>自行实现的GEMM算子</strong>,需要<strong>结合芯片的体系结构考虑</strong>,主要分为两步:<strong>①外层循环</strong>;<strong>②微内核</strong></p><ul><li>外层循环主要做的是:<strong>分块+移动数据</strong>,这里<strong>分块要仔细考虑片上缓存和片外缓存的大小</strong>,如CPU就考虑L3 cache,L2 cache,L1 cache的大小来进行大小合适的分块,并且<strong>分块怎么分也有讲究,以提高数据重用率</strong>;然后就是移动数据到缓存上;这里的计算和访存是可以overlap的,下文统一叫<strong>存算重叠</strong>(当然数据预取,双缓冲其实意思差不大多)</li><li><strong>微内核则主要考虑存算重叠(取指,计算,写回),指令重排,指令打包,以发挥硬件的最大性能</strong></li></ul><p>而我们这里的微内核没有精细到ILP(Instruction Level Parallel),而是采用向量intrinsic编程,来实现汇编上一层的优化,因此最终并不能完全将硬件的性能发挥到巅峰</p><p>但是intrinsic function是在如AVX2指令集上封装了一层的类C的可无缝兼容于C/C++函数的function,编写起来更加顺手一些,因此先在这之上进行算子编写,之后再转用内联汇编~</p><h2 id="内积和外积"><a class="markdownIt-Anchor" href="#内积和外积"></a> 内积和外积</h2><p>在矩阵乘中的内积和外积,与我们数学物理中所认识的内积外积不同,如下图所示:</p><img src="https://s2.loli.net/2024/04/01/9jZVnSvBcqyEoQ2.jpg" style="zoom:50%;" /><p>在矩阵中所说的内积外积取决于我们对矩阵乘的操作。在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>M</mi><mo>∗</mo><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{M*K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>K</mi><mo>∗</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{K*N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这两个矩阵上，我们做矩阵乘可以得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>M</mi><mo>∗</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{M*N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>拿出A的第一行与B的第一列相乘，可以得到C阵的第一行第一列的元素，如<code>C[0][0] = A[0][:] * B[:][0]</code>。这种矩阵乘的方式叫<strong>内积</strong>，按如此方式（如图式）计算矩阵有下列伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设矩阵的存储是行优先/行主序的 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123; <span class="hljs-comment">// a_row -&gt; M</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123; <span class="hljs-comment">// b_col -&gt; N</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;K;k++)&#123; <span class="hljs-comment">// a_col == b_row -&gt; K</span><br>            C[i*N + j] += A[i*K + k]*B[k*N + j]; <span class="hljs-comment">//这里采用一维数组存储矩阵的值，可以结合行主序列主序一起理解</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拿出A的第一列与B的第一行相乘，此时可以得到一个跟C阵规模一样的子阵C1：<code>C1=A[M][0]*B[0][N]</code>。这种矩阵乘依次滑动k即可，得到K个子阵，累加起来便是最终的C阵。这种矩阵乘的方式叫做<strong>外积</strong>，伪码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 假设矩阵的存储是按行优先存储的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;K;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;<br>            C[i*N + j] += A[i*K + k] * B[k*N + j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外积的方式显然更适合把两个矩阵按K这个维度对应拆分给多个核心计算，然后最后再AllReduce；</p><p>而两者从单一核心上计算来看，其实都没有很好的利用内存局部性这一性质，不过对于外积，它算完了就切到下一个维度，并没有反复的cache miss，而对于内积，对于B矩阵的来说，cache miss在反复的发生着，因为计算一行C阵的数据，就要过一遍B阵的数据，而每次B阵的数据还得重新拿，且矩阵按行存储，并不能一下就直接拿到一整行的数据，因此对于这种内积方式，需要进行<strong>循环重排以优化内存局部性</strong>，提升性能（不然大量时间耗费在访存上了），重排也很简单，就是由原先的M-&gt;N-&gt;K的遍历方式换成M-&gt;K-&gt;N，如下图式：</p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/InnerProduct-LoopChange.jpg" style="zoom:40%;" /><h2 id="cpu算力"><a class="markdownIt-Anchor" href="#cpu算力"></a> CPU算力</h2><p>单颗CPU{单精度/双精度}flops = 核心数 * 单个核心flops</p><p>单个核心flops = 主频 * 单周期{双精度/单精度}计算性能</p><p>单周期单精度的计算性能 =（ FMA计算单元数目 * 2（一次两条指令）* 寄存器位宽 ）/ 32（单精度）</p><p>主频可以通过<code>lscpu</code>里面查看</p><p>FMA数目应该要翻阅处理器的手册或去官网查详细的参数</p><p>寄存器位宽需要配合FMA支持情况查看，有<code>YMM</code>256位的寄存器，也有<code>ZMM</code>512位的寄存器</p><h2 id="flame的矩阵优化"><a class="markdownIt-Anchor" href="#flame的矩阵优化"></a> FLAME的矩阵优化</h2><p>在学习的时候，跟着参考资料三的项目进行了一些基础的矩阵优化<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="(简易的GEMM优化)[https://github.com/flame/how-to-optimize-gemm]">[3]</span></a></sup>，主要包括的优化思想是<strong>循环展开(loop unroll)，内联函数(inline function)，矩阵分块(blocking)，矩阵打包(packing)，intrinsic编程</strong>。因为原项目的优化有点点啰嗦，我给它重写并合并了一些优化手段</p><p>主要思想：</p><ul><li>通过朴素的矩阵乘，将内积的函数单独<code>add_dot</code>提取出来，然后由<strong>1x1</strong>,即一行乘一列的1次内积变换为<strong>1x4</strong>，即一次做4次内积，取A阵的一行，与B阵的四列分别进行相乘，则一次可以完成四次内积；</li><li>在此之上对<code>add_dot</code>进行<strong>内联</strong>，以减少函数调用次数，和减少循环次数以及利用空间局部性；</li><li>利用<strong>寄存器存储</strong>频繁使用的值</li><li><strong>循环展开</strong></li><li>在<strong>1x4</strong>思想上变为<strong>4x4</strong>，即一次完成十六次内积</li><li>采用<strong>intrinsic编程</strong>（SSE指令集，由于只有128位长的向量寄存器，其实对于64位的双精度浮点数有点不是很够用…）</li><li><strong>分块</strong>，<strong>打包</strong></li></ul><p>相关代码细节：<a href="https://www.github.com/ayyHA/OperatorDev">OperatorDev</a></p><h2 id="矩阵分块"><a class="markdownIt-Anchor" href="#矩阵分块"></a> 矩阵分块</h2><p>针对行主序的矩阵进行计算,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>M</mi><mo>×</mo><mi>K</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{M×K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>K</mi><mo>×</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{K×N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>M</mi><mo>×</mo><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{M×N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>我们以BLAS(基本的线性代数函数接口规范)有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>α</mi><mi>A</mi><mi>B</mi><mo>+</mo><mi>β</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">C = \alpha AB + \beta C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>接口声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><p>在进行矩阵计算的时候，我们一个很大的矩阵无法放进寄存器里，也可能无法放进L1,L2cache中，因此需要对矩阵分块放置在这些</p><h2 id="micro-kernel"><a class="markdownIt-Anchor" href="#micro-kernel"></a> micro-kernel</h2><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:0" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">intel-intrinsic</a><a href="#fnref:0" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/593537184">x64 CPU GEMM优化</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.cnblogs.com/myseries/p/14458367.html">CPU流水线并行</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>(简易的GEMM优化)[<a href="https://github.com/flame/how-to-optimize-gemm">https://github.com/flame/how-to-optimize-gemm</a>]<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>GEMM</tag>
      
      <tag>intrinsic优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-learning</title>
    <link href="/2024/02/29/leetcode-learning/"/>
    <url>/2024/02/29/leetcode-learning/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2><p>🔴 -&gt; 一般是指hard的题目,且没pass出来的,就是连暴力解法都想不到的</p><p>🔵 -&gt; 表示十拿九稳的题目</p><h2 id="c的字符数组和c的string转换以及常用函数"><a class="markdownIt-Anchor" href="#c的字符数组和c的string转换以及常用函数"></a> C的字符数组和C++的string转换以及常用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c_s = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>c++中通过导入iomanip,可以用fixed来使浮点数定位(无论double d 里的值是整数浮点数,统统给它输出浮点数形式)<br />通过setprecision(n)来确定整体数字位数,若没有结合fixed使用,则代表的位数是整数位+小数位n;<mark>结合fixed使用则代表的位数是小数位n</mark></p>          </div><h2 id="c一些流"><a class="markdownIt-Anchor" href="#c一些流"></a> C++一些流</h2><p><code>istream&amp; getline(istream&amp; is,string&amp; s,char delim)</code></p><ul><li><code>is</code>是输入流对象, 可以是<strong>标准输入cin</strong>,可以是<strong>输入文件流对象ifstream</strong>,可以是<strong>输入字符串流对象istringstream</strong>等等</li><li><code>s</code>存储读到的一行文本的字串</li><li><code>delim</code>分隔符,<strong>表示在哪个字符处停止读取,默认是<code>\n</code></strong></li><li>返回值是输入流对象的引用</li></ul><p>参考文件:</p><ul><li><a href="http://vcsos.com/article/pageSource/160122/20160122233408.shtml">io流,文件流,字串流</a></li></ul><h2 id="algorithm一些算法"><a class="markdownIt-Anchor" href="#algorithm一些算法"></a> algorithm一些算法</h2><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3><p>排序算法,很经典,c++里用的是快排实现的,我们的容器可以通过如下方式使用它:</p><p><code>sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</code></p><ul><li>第一个参数是迭代器的起始地址</li><li>第二个参数是迭代器的结束地址(就是那个<code>end()</code>,结束位置的下一位)</li><li>第三个参数是排序规则</li></ul><p>这里主要讲自定义排序规则,<strong>默认是升序(即默认采用<code>&lt;</code>运算符进行比较,谁小谁排前面)</strong>.可以通过:</p><ul><li><p><strong>lambda表达式(本质上是定义一个返回值为bool的两个待比较参数的比较函数)</strong></p></li><li><p><strong>重载运算符</strong></p><p><strong>主要运用在结构体里,以指示如何对结构体里的成员进行比较</strong>,然后调用c++自带的仿函数<code>less&lt;T&gt;()</code>/<code>greater&lt;T&gt;()</code>(头文件是<code>&lt;functional&gt;</code>)来对序列中的<code>T</code>类型排序,示例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>  <span class="hljs-comment">// 重载&gt;运算符</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> Person&amp; other) <span class="hljs-keyword">const</span>&#123;<br>  <span class="hljs-keyword">if</span>(score != other.score)<br>  <span class="hljs-keyword">return</span> score &gt; other.score;<br>  <span class="hljs-keyword">return</span> id &lt; other.id;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">// 使用greater仿函数来通过&#x27;&gt;&#x27;运算符进行比较,则会调用到Person里重载的&#x27;&gt;&#x27;运算符里的规矩来进行排序</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:people)<br>    cout &lt;&lt; p.id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; p.score &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png" alt="cpp_functional_greater" style="zoom:80%;" /></li><li><p><strong>仿函数</strong></p><p><strong>仿函数(functor)是一个类/结构体,里面重载了<code>operator()</code>,从而仿函数的对象可以像函数一样被调用,大致如下:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greater</span>&#123;</span><span class="hljs-comment">// 定义一个仿函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x&gt;y;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>&#125;;<br>Greater g;<span class="hljs-comment">// 仿函数的对象</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),g); <br><br>    <span class="hljs-comment">// 下面这种也可以,跟c++提供的仿函数greater&lt;int&gt;()一样,这里的greater是个struct</span><br>    <span class="hljs-comment">//sort(v.begin(),v.end(),Greater());</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>以上三种方式的任一方式来实现自己的排序功能,乃至多级排序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是对vector降序排序*/</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; j)-&gt;<span class="hljs-keyword">bool</span>&#123;<span class="hljs-keyword">return</span> i&gt;j;&#125;);<br></code></pre></td></tr></table></figure><p>可以这么理解i&gt;j就是谁大谁排前面(i是第一个参数,j是第二个参数),当然上面的也可以写成普通的函数;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是多级排序,对自定义结构体Person*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    排序规则:</span><br><span class="hljs-comment">    1.先按分数由高到低排</span><br><span class="hljs-comment">    2.分数相同的id小的排前面</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> Person&amp; a,<span class="hljs-keyword">const</span> Person&amp; b)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score != b.score)<br>            <span class="hljs-keyword">return</span> a.score &gt; b.score;<br>        <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料:</p><ul><li><a href="https://www.jb51.net/article/263333.htm">c++自定义sort()函数的排序方法介绍</a></li></ul><h2 id="一些stl容器回顾"><a class="markdownIt-Anchor" href="#一些stl容器回顾"></a> 一些STL容器回顾</h2><p>这里主要记着主要方法,后续有新的会来补充,以便于一开始训练的时候查方法,当然也会说一下不同容器/相似容器间的差别</p><p>参考资料:</p><ul><li><a href="https://www.cnblogs.com/lvshen/p/17839484.html">STL容器</a></li><li><a href="https://blog.csdn.net/m0_57190374/article/details/127042161">C++常用容器介绍</a></li></ul><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>因为字符串涉及的函数非常多,且有些函数很少用,但在一些机试的时候会遇到,而且自己重写非常繁琐,因此这里记录一下一些函数,这里会混杂字符的内容</p><p><strong>数字,字母,大小写部分:</strong></p><ul><li><code>isalpha()</code>用于判断一个字符是否是字母</li><li><code>isalnum()</code>用于判断一个字符是否是字母或数字</li><li><code>isupper()</code>用于判断一个字符是否是大写的</li><li><code>islower()</code>用于判断一个字符是否是小写的</li><li><code>toupper()</code>将一个字符转为大写</li><li><code>tolower()</code>将一个字符转为小写</li></ul><p>上面的是针对字符的,源自<code>&lt;ctype.h&gt;</code></p><p>对于字串来说的话,导入algorithm库可有以下转换方式:</p><ul><li><strong><code>transform(s.begin().s.end(),s.begin(),::tolower)</code></strong> 转换整个字串为小写,其中第一二个参数是输入容器的起始和终止迭代器(终止不含),第三个参数是输出容器的开始迭代器,第四个参数是一元函数对象</li><li><strong><code>transform(s.begin(),s.end(),s.begin(),::toupper)</code></strong> 转换整个字串为大写</li></ul><p><strong>字符串和整型的转换:</strong></p><ul><li><strong><code>stoi(string,nullptr,base)</code></strong> 字串转整数,base是string的进制,比如string是二进制的,则这里就写个2,会自动做进制转换</li><li><strong><code>to_string(int/long/float)</code></strong> 将一个数字常量转为字符串</li></ul><p>还有一种<code>atoi()</code>,<code>itoa</code>的字串和整型的转换,但是需要注意这种针对的是字符数组,而非string</p><p><strong>字符串做切片</strong></p><ul><li><strong><code>substr(start,len)</code></strong> 从<code>start</code>处,切len这么长的子串,不指定len则到结尾</li><li><s><code>substring(start,end)</code> 从start处开始,切到end,其中不包括end索引的字符,不指定end则到结尾</s><mark>[这是java/js才有的,搞错了= =]</mark></li></ul><p><strong>初始化函数</strong></p><p>在结构体或者类中,需要对一些为指针的成员实现初始化(别的也尽量初始化),不然会报内存不对齐的错误,传统的C在<code>cstring</code>这个库里有**<code>memset(void* s,int c,size_t n)</code>**可以对一块内存进行初始化,如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        isEnd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意:由于<code>memset</code>是按字节对内存块进行初始化,也就是说第二个参数c只会取低八位,然后赋值给一块地址(一块地址是一字节).比如int是4字节,那如果给的c是1,就会变成<code>0x01010101</code>,每个字节分别是<code>0000 0001</code>这么一个情况,所以一般第二位填0或-1就好了,它跟那种<code>vector&lt;int&gt;v(10,5) // 十个数,每个都是5</code>不一样</p><div class="note note-info">            <p>由于LeetCode检测机制更加严格，所以我们在创建节点是，还需将指针域赋值。</p><p>参考文件:<a href="https://blog.csdn.net/Zhenyu_Coder/article/details/132273442">runtime error: member access within misaligned address(力扣最常见错误之一)</a></p>          </div><h3 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h3><h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4><ul><li><code>push_back()</code></li><li><code>emplace_back()</code></li></ul><div class="note note-info">            <p>上面两个函数都是向容器尾部添加元素</p><p>push_back():1. 创建元素; 2. 调用移动构造函数/拷贝构造函数,将元素弄到容器中</p><p>emplace_back(): 1. 直接在容器尾部创建元素,减少了拷贝/移动的开销</p><p>其中<strong>移动构造函数</strong>和<strong>拷贝构造函数</strong>是不同的:<strong>后者是将一个已存在的对象复制到一个新的对象中;前者是将一个对象的资源移动到一个新的对象中</strong>.因为一般自己写的拷贝构造是深拷贝(为了避免浅拷贝指向同一块内存的问题)所以涉及到<strong>内存分配</strong>,而拷贝又涉及到<strong>数据复制</strong></p><p>而其中移动构造涉及到右值引用的知识,可以看看参考文件</p><p>参考文件:</p><ul><li><a href="https://gitcode.csdn.net/65eed6611a836825ed79f6e7.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NTk3OTAyMCwiZXhwIjoxNzE3MTIwNTQyLCJpYXQiOjE3MTY1MTU3NDIsInVzZXJuYW1lIjoid2VpeGluXzQ1Mzg4MzEyIn0.NhR7qBK3BAP_eFFZfFm1NLr7JxVF3TFaKd_tDLsOZ-4">【C++11】之 emplace_back() 与 push_back() 的区别</a></li><li><a href="https://blog.csdn.net/weixin_44355021/article/details/129369368">移动构造函数与拷贝构造函数对比</a> (未看完)</li></ul>          </div><h4 id="queue容器适配器"><a class="markdownIt-Anchor" href="#queue容器适配器"></a> queue[容器适配器]</h4><ul><li><code>push()</code></li><li><code>pop()</code></li></ul><div class="note note-info">            <p>push,pop遵循FIFO</p>          </div><ul><li><code>size()</code></li><li><code>empty()</code></li><li><code>front()</code></li><li><code>back()</code></li></ul><p>queue参考资料:<a href="https://blog.csdn.net/m0_59068776/article/details/130549065">queue基本方法</a></p><h4 id="deque双端队列"><a class="markdownIt-Anchor" href="#deque双端队列"></a> deque(双端队列)</h4><p>相比于vector,可以更好更迅速的处理头部元素</p><h4 id="list双向链表"><a class="markdownIt-Anchor" href="#list双向链表"></a> list(双向链表)</h4><h4 id="forward_list单链表"><a class="markdownIt-Anchor" href="#forward_list单链表"></a> forward_list(单链表)</h4><h4 id="stack栈容器适配器"><a class="markdownIt-Anchor" href="#stack栈容器适配器"></a> stack(栈)[容器适配器]</h4><ul><li><code>push()</code> #压入</li><li><code>pop()</code> # 弹出</li><li><code>top()</code> # get栈顶</li><li><code>back()</code> # get栈底</li><li><code>empty()</code></li><li><code>size()</code></li></ul><p>不能通过索引遍历,用<code>while(!s.empty())</code>遍历</p><p>stack参考资料:<a href="https://blog.csdn.net/H1727548/article/details/130857503">stack基本方法</a></p><h4 id="priority_queue优先队列容器适配器"><a class="markdownIt-Anchor" href="#priority_queue优先队列容器适配器"></a> priority_queue(优先队列)[容器适配器]</h4><p><strong>底层是通过堆实现的优先队列,常数时间的最大/最小元素查找,默认是大顶堆(<code>less&lt;T&gt;</code>),则最大元素位于<code>top()</code>,当调用<code>pop()</code>则会发生类似<code>adjust_down()</code>一类的内部函数的操作</strong></p><p>具备<strong>自动排序</strong>的特性,所以对如<strong>前k个…最大/最小</strong>的题目都很适用</p><p>优先队列的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq; <span class="hljs-comment">// 其中只有第一个是要具体定义的,三个分别是:元素类型,容器类型,比较函数类型</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注:这里传入的是比较函数的类型,而不是具体的对象,因此不用像sort里的加多个<code>()</code></p>          </div><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>top()</code></li><li><code>size()</code></li><li><code>empty()</code></li></ul><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/weixin_68278653/article/details/131015181">priority_queue</a></li><li><a href="https://zhuanlan.zhihu.com/p/498045886">[C++STL] Priority Queue 介绍及源码分析</a></li></ul><h3 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h3><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4><p>内部是通过<strong>红黑树</strong>实现的,<strong>去重且递增</strong>(自动有序),<strong>遍历只可以通过iterator遍历</strong>,插入值是insert的方式</p><p><img src="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png" alt="set方法大全" /></p><p>以下这俩函数是针对的容器中的数值是有序的,而set有序,故可以用:</p><ul><li><code>lower_bound()</code>:实参用个val,会找到set容器中&gt;=val的iterator,找不到就滑到<code>end()</code>了</li><li><code>upper_bound()</code>:实参用个val,会找到set容器中&gt;val的首个iterator,找不到就滑到<code>end()</code></li></ul><p>set参考资料:<a href="https://blog.csdn.net/H1727548/article/details/130800542">set</a></p><h4 id="unordered_map"><a class="markdownIt-Anchor" href="#unordered_map"></a> unordered_map</h4><p>底层是通过<strong>哈希表实现的无序map</strong></p><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4><ul><li><code>insert()</code></li><li><code>begin()</code></li><li><code>end()</code></li><li><code>clear()</code></li><li><code>count()</code> # 返回指定元素出现的次数,key唯一就是0/1</li><li><code>empty()</code></li><li><code>erase()</code> # 删除一个元素,并返回下一个元素的迭代器(使用特别注意,要承接这个return值,而不是自增)</li><li><code>find()</code> # 查找一个元素,找得到返回对应位置迭代器,否则滑倒<code>end()</code>去</li><li><code>size()</code></li><li><code>rbegin()</code></li><li><code>rend()</code></li><li><code>lower_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>给定元素的第一个位置</li><li><code>upper_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">\gt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>给定元素的第一个位置</li><li><code>swap()</code> # 交换两个map</li></ul><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/m0_58086930/article/details/120393227">map和multimap的解释c++</a></li><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法详解</a></li><li><a href="https://www.cnblogs.com/nntzhc/p/14606368.html">erase神奇用法!</a></li></ul><h4 id="multimap"><a class="markdownIt-Anchor" href="#multimap"></a> multimap</h4><p><strong>允许key重复,没有重载<code>operator[]</code>,底层红黑树</strong></p><ul><li><code>insert()</code></li></ul><div class="note note-info">            <p>注:只可以用这个加值,不像map可以用<code>[]</code>来加值,需要注意</p>          </div><h2 id="一些板子"><a class="markdownIt-Anchor" href="#一些板子"></a> 一些板子</h2><p>写题记录总结,并记忆一些板子,以便后期快速完成题目</p><h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3><p><em><strong>不撞南墙不回头</strong></em></p><p>实现手段: 递归</p><p>适用于: 树,图</p><p>经典题目: 迷宫找通路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-comment">/*状态*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*递归结束条件*/</span>)&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*找寻新状态*/</span>)&#123;<br>        <span class="hljs-comment">// 定义新状态</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*新状态满足边界条件*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足标志位*/</span>)&#123;<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置标志位</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-comment">/*新状态*/</span>);<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置为旧的flag以回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>状态是指比如迷宫里的坐标xy一类的东西</p>          </div><h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h3><p><em><strong>像波一样,由近及外</strong></em></p><p>实现手段: 队列</p><p>适用于: 最短路径</p><p>因为广度优先搜索和层序遍历概念很像,这里举的模板是按着层序遍历的写的,可以在这基础上根据题意进行变通,变通版本在下面:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(node); <span class="hljs-comment">// 这里push的是类似于&quot;头节点&quot;或&quot;符合题目要求的!首类节点!&quot;</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">// 遍历队列里的点</span><br>    <span class="hljs-comment">/*跳出条件*/</span> <span class="hljs-comment">// 有些题目需要设置跳出条件</span><br>    <span class="hljs-keyword">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<span class="hljs-comment">// 一层层的遍历,这个sz代表的是这一次波及到的点,可以从树的层序遍历和矩阵中点逐个向外扩散进行想象</span><br><span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>         q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*候选点*/</span>)&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            获取一个候选点</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*满足边界*/</span> &amp;&amp; <span class="hljs-comment">/*满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*满足标志位*/</span>)&#123;<span class="hljs-comment">// 筛选符合状态的点</span><br>        flags[candidateNode] = ... <span class="hljs-comment">// 设置标志位</span><br>                 q.<span class="hljs-built_in">push</span>(candidateNode);<span class="hljs-comment">// 满足条件的点加入队列中(这是下一层)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3><p>使用场景:原数组不变动,但需要对子数组进行频繁的累和操作,则可以构建<strong>前缀和数组</strong></p><p>前缀和数组即<code>prefix[i]</code>表示的是原数组nums在<code>[0,i-1]</code>这个区间的元素的累和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//假设题目给的数组是:vector&lt;int&gt;&amp; nums</span><br><span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span>* prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要多一个位置</span><br>prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=len; i++)<br>    prefix[i] = prefix[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">... 对前缀和数据的操作,如想获得[i,j]区间的累和,则可以通过prefix[j+1] - prefix[i]获得</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> []prefix;<br></code></pre></td></tr></table></figure><h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3><h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3><p>滑动窗口常见于字符串匹配一类的题目,通常暴力求解会遇到TLE的问题,因此需要借助滑动窗口这一算法思想来实现</p><p><strong>滑动窗口本质上是左右指针,通过右端的指针不断扩张,直至满足一定条件,再经由左端的指针不断收缩,收缩到一定条件,则继续右端指针扩张,循环往复,直至右端指针越了字串的界</strong></p><p>右端指针扩张的过程,可以看作是正在寻找可行解,<strong>当满足可行解的条件,则停止扩展</strong>,通过左端指针收缩,来<strong>优化可行解,寻找到当前小区间里的局部最优解</strong>,当不再满足可行解的条件,则不再收缩,而是还给右端指针继续扩张.如此遍历完整个数组,我们便在局部最优解中挑选出了全局最优解(<mark>有些题目是要找全局最优解,有些是要收集所有符合条件的解,因题而异,这里只是说一种思想</mark>)</p><p>模板如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s,string t)</span></span>&#123;<br>    <span class="hljs-comment">// need表示需要满足的条件,window表示的是滑动窗口内的数据</span><br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; need,window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)<br>        need[c]++;<br>    <span class="hljs-comment">// 左右指针,左闭右开[left,right)</span><br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// valid表示符合要求的字符数目,比如t=&quot;aabc&quot;; need = &#123;&#123;&#x27;a&#x27;,2&#125;,&#123;&#x27;b&#x27;,1&#125;,&#123;&#x27;c&#x27;,1&#125;&#125;;</span><br>    <span class="hljs-comment">// 则当&#x27;a&#x27;的数目window中收集满了2个,才会给valid自增(后续还可能收集到a,且没有达到进入收缩区间的条件,即a的数目&gt;=2),因此当valid数目和need.size()相等时,则表明t中的字符都在我们的滑动区间里,且可能是&quot;aaabaababc&quot;的形式,则需要收缩区间,找到符合题意的!</span><br>    <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 1.对c处理,怎么个扩张法</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-comment">/* 2.满足条件,开始收缩*/</span>)&#123;<br>            <span class="hljs-comment">// 3.怎么更新局部最优解</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 4.对d处理,怎么收缩法</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个模板,在写同类型题目的时候要思考以下四个问题:</p><ol><li><p>右端指针扩张,怎么更新值;</p></li><li><p>满足什么条件开始收缩;</p><p>一般来说,如果是字串匹配系列的题目,我们会有两个字串,一个字串s(source)要包含另一个字串t(target),当<code>valid==need.size()</code>的时候,则说明目前滑动窗口[left,right)里面已经包含了该字串t(滑动窗口是在s上滑动的)</p><ul><li>[<strong>76-最小覆盖字串</strong>] : 目的最小覆盖,则意味着覆盖(包含)之后再收缩,并在里面更新局部最优解,收缩至不再覆盖为止,则跳出收缩.即此时的收缩条件是<code>valid == need.size()</code></li><li>[<strong>567-字符串的排列</strong> <strong>438-找到字符串的所有字母异位词</strong>] : 明确要找匹配到字串t的别的排列形式(即<code>t=&quot;abc&quot;</code>,s里有<code>&quot;cab&quot;</code>也满足),即意味滑动窗口里的尺寸如果比字串t大,必不满足字串t的排列,因此收缩条件应该是<code>right-left == t.size()</code>,而判断是不是满足排列(这里就不是局部最优解的问题了,因为没有最…之类的限定词),就是<code>valid==need.size()</code></li><li>[<strong>3-无重复字符的的最长子串</strong>] : 这个题目它只有s没有t,则不要need这个容器了,直接在滑动窗口里统计就好,当window[c]&gt;1则表明有重复的了,那就要开始收缩,直至没有重复的,此刻则需要在收缩循环的外面统计最长字串</li></ul></li><li><p>怎么更新局部最优解;(结合2看)</p></li><li><p>左端指针收缩,怎么更新值;</p></li></ol><p>参考资料:</p><ul><li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-">leetcode评论区大佬对于滑动窗口的高见</a></li></ul><h3 id="dp背包系列"><a class="markdownIt-Anchor" href="#dp背包系列"></a> DP背包系列</h3><p>在说起背包系列的问题前,先说下动规题的四大步骤:</p><ol><li><strong>确定子问题/状态</strong>,这一步需要好好分析,一般是<strong>前k个…/直到第k个…的最大/最小…</strong>,要保证<strong>无后效性</strong>,<strong>后来的结果不会影响前面的结果</strong>,可以通过叠定语或增加数组维度来实现,如果读起来自己觉得有问题的一般就是有问题;子问题是具备<strong>最优子结构</strong>的,<strong>可以通过求解子问题,最终获得原问题的解</strong>,如果奔头不是这个,那求来也没用</li><li><strong>推导出状态转移方程</strong>,DP具备<strong>子问题重叠</strong>的性质,也就是说状态转移方程会出现至少两个dp的某种转移的等式</li><li>确定初值</li><li>确定原问题的答案</li></ol><p>其中当涉及到多维dp的时候,遍历的顺序也是一个考虑的点,如0/1背包滚动数组版本和完全背包滚动数组版本,内嵌循环的正向遍历和倒序遍历就是这两个问题的关键区别,即取的物品可否重复</p><h4 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 0/1背包</h4><p>有一个承重为W的背包,N件物品,第i件物品对应的重量是weight[i],对应的价值是value[i],<strong>每件物品只能被取一次</strong>,问如何能使得背包的物品总价值最大?</p><ol><li><p>状态定义</p><p><code>dp[i][j]</code>表示当背包容量为j时,前i件([0,i-1])物品中的最大价值</p></li><li><p>转移方程</p><p><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i-1]]+value(i-1));</code></p></li><li><p>初始状态</p><p>当<code>i=0</code>,表示前0件物品,则统统填0;</p><p>当<code>j=0</code>,表示背包容量为0,则亦填0;</p><p>物品价值没有负数的初始状态才填零;如果物品价值有负数,则填-INF</p></li><li><p>最终输出</p><p><code>dp[N][W]</code>是最终输出,表示前N件物品中任意抽取,且当背包容量为W时的最大价值,即原题意</p></li></ol><p>遍历顺序:<mark>需要好好思考</mark>(说是先遍历物品数量,再遍历背包容量;和反过来的情况是一样的)</p><h4 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h4><p>有一个承重为W的背包,N件物品,第i件物品对应的重量是weight[i],对应的价值是value[i],<strong>每件物品能无限次取</strong>,问如何能使得背包的物品总价值最大?</p><h2 id="排序系列"><a class="markdownIt-Anchor" href="#排序系列"></a> 排序系列</h2><h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3><p>一种<strong>选择算法</strong>,<strong>不稳定</strong>(相同值的元素的相对位置可能发生改变),<strong><code>O(nlogn)</code></strong></p><p><strong>堆排序步骤:</strong></p><ol><li><strong>构建大顶堆(升序排序)</strong></li><li><strong>根节点与末尾元素交换</strong></li><li><strong>在除去末尾元素的剩余元素中,重新下沉根节点,以构建大顶堆</strong></li></ol><p>重复以上步骤,直至整个序列有序</p><p>代码(给出的是小顶堆的构建,是降序):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 左孩子节点</span><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (child &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// 在两个孩子节点找最小的</span><br>        <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[child + <span class="hljs-number">1</span>] &lt; nums[child])<br>        &#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-comment">// 孩子节点中最小的那个比父节点还小,则这个更小的值要上浮到父节点</span><br>        <span class="hljs-keyword">if</span> (nums[child] &lt; nums[parent])<br>        &#123;<br>            <span class="hljs-comment">// swap(nums[child], nums[parent]);</span><br>            <span class="hljs-keyword">int</span> tmp = nums[child];<br>            nums[child] = nums[parent];<br>            nums[parent] = tmp;<br>            <span class="hljs-comment">// 检查孩子节点往下是不是满足小顶堆结构,因为值的上浮可能会破坏原有的小顶堆结构</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从最后一个非叶子节点开始,直至根节点;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">adjustDown</span>(nums, i, heapSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMinHeap</span>(nums, n);<br>    <span class="hljs-comment">// 交换首尾元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// swap(nums[0], nums[i]);</span><br>        <span class="hljs-keyword">int</span> tmp = nums[<span class="hljs-number">0</span>];<br>        nums[<span class="hljs-number">0</span>] = nums[i];<br>        nums[i] = tmp;<br>        <span class="hljs-comment">// 上面的交换破坏了根节点的堆结构,重新构建小顶堆</span><br>        <span class="hljs-built_in">adjustDown</span>(nums, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>大顶堆是一棵完全二叉树,每个节点的值都大于等于其左右孩子节点的值</strong>(反之小于等于的则是小顶堆,用于降序排列)</p><p><strong>完全二叉树第<code>i</code>个节点的</strong>(这里的**<code>i</code>是根据层序遍历得到的编号,从0开始**)<strong>左右孩子节点分别是<code>2*i+1</code><strong>和</strong><code>2*i+2</code></strong>(这是它的性质)</p><p>用数组表示,即有<code>arr[i] &gt;= arr[2*i+1]</code>和<code>arr[i] &gt;= arr[2*i+2]</code></p><p>也正因为完全二叉树的性质,所以整棵树可以通过简单的数组表示而非复杂的树结构</p><p>在构建堆结构的时候,我们要从最后一个非叶子节点开始,从右往左,从下往上(就是最后一个非叶子节点的编号自减1,直至根节点),对它和它的孩子节点实现交换以满足堆有序(大顶堆或小顶堆的父子节点的性质).而这个<strong>最后一个非叶子节点是通过整个数组的size除以2再减1得到(如果编号从0开始,则要-1;如果编号从1开始,则不用-1</strong>)</p>          </div><p>参考资料:<a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解堆排序</a></p><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p><strong>核心:分治算法</strong></p><p><strong>稳定的<code>O(nlogn)</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 左区间的左端点,右区间的左端点</span><br>    <span class="hljs-keyword">int</span> l = left, r = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = left;<br>    <span class="hljs-comment">// 构建一个临时数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right-left+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">// l不大于左区间的右端点,r不大于右区间的右端点</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid &amp;&amp; r&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[l]&lt;nums[r])&#123;<br>            tmp[k++] = nums[l++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[r++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对区间剩余的数值搬到tmp上去</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid)&#123;<br>        tmp[k++] = nums[l++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r &lt;= right)&#123;<br>        tmp[k++] = nums[r++];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 把结果从临时数组搬运到nums中去</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=left; q&lt;=right; q++)&#123;<br>        nums[q] = tmp[q];<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">: nums - 待排序数组</span><br><span class="hljs-comment">: left - 区间左端点</span><br><span class="hljs-comment">: right - 区间右端点,即整个区间是[left,right]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">if</span>(left&gt;=right)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 这里是划分区间为更小的区间</span><br>    <span class="hljs-built_in">mergeSort</span>(nums,left,mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-comment">// 这里是区间合并</span><br>    <span class="hljs-built_in">merge</span>(nums,left,mid,right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p><strong>核心:左右指针+分治算法</strong></p><p><strong>交换排序中的一种,不稳定的<code>O(nlogn)</code></strong></p><p>思想:根据选定的基准(一般是最初确定左指针后,左指针指向的值),将数据分为大于基准的放在右侧,小于基准的放在左侧,然后对左侧和右侧的列表分别重复上述步骤(此刻即分治),最后直至整个序列有序.</p><p>快速排序步骤:</p><ol><li>确定当前的左右指针,并选择基准(注意:取得是基准的索引);</li><li>循环,先处理右指针,右指针一直自减,除非遇到小于基准的值(得&gt;=),则暂停处理右指针,开始处理左指针;左指针一直自增,除非遇到大于(得&lt;=,之所以=是得跳过基准,不然左指针指向的不符合的就一直是基准了)基准的值,则暂停处理左指针,此刻左右指针指向的是各自均错误的值,交换,继续循环,直至左指针不再小于右指针;</li><li>交换基准和左指针;</li><li>对未排序好的左右列表进行快排</li></ol><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// left是左指针,right是右指针+1,即整个区间是:[left,right)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 选定基准索引</span><br>    <span class="hljs-keyword">int</span> key = left;<br>    <span class="hljs-comment">// 确定左右指针</span><br>    <span class="hljs-keyword">int</span> l = left,r=right<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;= nums[key])<br>            r--;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt;= nums[key])<br>            l++;<br>        <span class="hljs-built_in">swap</span>(nums[l],nums[r]);<br>    &#125;<br>    <span class="hljs-comment">// 把基准交换到属于它的位置,此刻索引&lt;基准的是值&lt;=它的,索引&gt;基准的是值&gt;=它的</span><br>    <span class="hljs-built_in">swap</span>(nums[l],nums[key]);<br>    <span class="hljs-keyword">if</span>(l &gt; left)<br>        <span class="hljs-built_in">quickSort</span>(nums,left,l); <span class="hljs-comment">// [left,l),其中l是基准确定的位置</span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span> &lt; right)<br>        <span class="hljs-built_in">quickSort</span>(nums,l+<span class="hljs-number">1</span>,right); <span class="hljs-comment">// [l+1,right)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shell排序"><a class="markdownIt-Anchor" href="#shell排序"></a> shell排序</h3><h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3><p>拓扑排序是用于有向无环图(下称DAG)来生成一个线性序列,这个序列满足:</p><ul><li>序列中的每个顶点有且仅出现一次</li><li>在图中如果存在u到v的一条路径,那么在序列中u一定出现在v之前</li></ul><p>对于拓扑排序,经典的应用问题是AOV图(Activity Of Vertex),用于给一个活动网络进行排序,以获取其执行的序列</p><p>对于拓扑排序,此处采用的是BFS算法进行实现: 通过邻接矩阵装载图信息,并构建一个入度列表,对入度列表中入度为0的点,push进队列,然后依次执行如下步骤:</p><ul><li>出队,放入toplo数组</li><li>根据邻接矩阵找到以它作为弧尾的点,对它们的入度-1</li><li>若有节点入度为0,则push进队列</li></ul><p>重复以上三个步骤,则当队列为空时,说明以拓扑排序完毕</p><p>需要注意:拓扑排序仅针对DAG图,同时也可以利用上述方法增加一些条件来检查有向图中是否有环(有环的节点,入度无法通过上述操作减为0,但队列会跳出,即意味着toplo数组中的节点数量肯定少于图中给出的节点数量,否则的话是相等的)</p><p>板子代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    B</span><br><span class="hljs-comment">  /  \ </span><br><span class="hljs-comment">A      D</span><br><span class="hljs-comment">  \  /</span><br><span class="hljs-comment">   C</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> vertexNum; <span class="hljs-comment">// 顶点数</span><br><span class="hljs-keyword">int</span> edgeNum;   <span class="hljs-comment">// 边数</span><br><span class="hljs-comment">// 4 4</span><br>cin &gt;&gt; vertexNum &gt;&gt; edgeNum;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(vertexNum); <span class="hljs-comment">// 邻接矩阵</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(vertexNum,<span class="hljs-number">0</span>)</span></span>;   <span class="hljs-comment">// 入度列表 </span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   A B</span><br><span class="hljs-comment">   A C</span><br><span class="hljs-comment">   B D</span><br><span class="hljs-comment">   C D</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edgeNum;i++)&#123;<br><span class="hljs-keyword">char</span> a,b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-keyword">int</span> A;<br><span class="hljs-keyword">int</span> B;<br>A = a - <span class="hljs-string">&#x27;A&#x27;</span>;<br>B = b - <span class="hljs-string">&#x27;A&#x27;</span>;<br>adjacency[A].<span class="hljs-built_in">push_back</span>(B);<span class="hljs-comment">// 记录有向图的边信息&lt;a,b&gt;</span><br>indegrees[B]++;   <span class="hljs-comment">// b的入度增加</span><br>&#125;<br>queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;  <span class="hljs-comment">// 将入度为零的点,即源点放入队列中</span><br><span class="hljs-keyword">if</span>(!indegrees[i])<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; toplo;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">// BFS</span><br><span class="hljs-keyword">int</span> pre = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>toplo.<span class="hljs-built_in">push_back</span>(pre);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:adjacency[pre])&#123;<br><span class="hljs-keyword">if</span>(--indegrees[i] == <span class="hljs-number">0</span>)<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125; <br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:toplo)&#123;<br><span class="hljs-keyword">char</span> c = i + <span class="hljs-number">65</span>;<br>cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h2><h2 id="一些数据结构回顾"><a class="markdownIt-Anchor" href="#一些数据结构回顾"></a> 一些数据结构回顾</h2><h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3><p>二叉搜索树(BST)是二叉树的一个特别概念,可以理解为排了序的二叉树</p><p>左孩子 &lt;= 根节点 &lt;= 右孩子</p><p>详细可见<a href="https://ayyha.github.io/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/">BST,AVL,B,B+,RBT</a></p><h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3><h2 id="每日一练"><a class="markdownIt-Anchor" href="#每日一练"></a> 每日一练</h2><h3 id="2864-最大二进制奇数"><a class="markdownIt-Anchor" href="#2864-最大二进制奇数"></a> 2864 最大二进制奇数</h3><h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><h4 id="重写官方思路"><a class="markdownIt-Anchor" href="#重写官方思路"></a> 重写官方思路</h4><h3 id="2789-合并后数组中的最大元素"><a class="markdownIt-Anchor" href="#2789-合并后数组中的最大元素"></a> 2789 合并后数组中的最大元素</h3><h4 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h4><p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p><p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p><ul><li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li></ul><p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">21</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">21</span>,<span class="hljs-number">3</span>] 。<br>最终数组中的最大元素是 <span class="hljs-number">21</span> 。可以证明我们无法获得更大的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">11</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">11</span>] 。<br>最终数组中只有一个元素，即 <span class="hljs-number">11</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4><ol><li><strong>合并</strong></li><li><strong>找最大值</strong></li><li><strong>避免爆int边界</strong></li></ol><p>根据题目,我们可以知道我们会①合并满足条件的数组;②合并了之后它未必是最大值,可能有个很巨大的在一些比较奇怪的地方,比如最左边(因为中间的都会给合并,再大的都给它拼起来,但<code>nums[0]</code>就无能为力),因此我们可以在合并完,再比较一波</p><p>在提交的时候,原本我是利用<code>nums[i] +=nums[i+1]</code>来累加满足条件的值,但是会爆了signed int的可表达的值的边界,其实看题目的函数返回值<code>long long</code>,就知道可能有比较极端的用例会去爆了signed int的边界</p><p><strong>合并的方法仔细观察可以得值,从最右边往左遍历可以大数吃小数</strong>(if满足条件)</p><p><strong>我这里通过<code>tmp</code>来承接累加的值,当然它如果小于前面的就得给它置零,当然得跟max比一下,大的话就让max拿走了,然后最后再跟nums[0]一决高下比一比,最后返回.这里的tmp和max都是longlong类型的.</strong></p><p>注:以下的差距是在于我把后面的一个迭代找最大值换成了<code>max</code>和<code>nums[0]</code>比较得到的提升~</p><p><img src="https://s2.loli.net/2024/03/15/aAFU2nBLR5VY7Z8.jpg" alt="maxArrayValue-effect" /></p><h4 id="重写官方思路-2"><a class="markdownIt-Anchor" href="#重写官方思路-2"></a> 重写官方思路</h4><h3 id="2684-矩阵中移动的最大次数"><a class="markdownIt-Anchor" href="#2684-矩阵中移动的最大次数"></a> 2684 矩阵中移动的最大次数</h3><h4 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h4><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p><p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p><ul><li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li></ul><p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" alt="img" /></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：grid = [[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：可以从单元格 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 开始并且按下面的路径移动：<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span> -&gt;</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<br>可以证明这是能够移动的最大次数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png" alt="img" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[3,2,4],[2,1,9],[1,1,7]]</span><br>输出：<span class="hljs-number">0</span><br>解释：从第一列的任一单元格开始都无法移动。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 1000</code></li><li><code>4 &lt;= m * n &lt;= 10^5</code></li><li><code>1 &lt;= grid[i][j] &lt;= 10^6</code></li></ul><h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4><p>当时写这道题目的时候是周六23点多吧,然后比较疲惫,也差不多三天没写题目了,有畏惧感,就没写出来,主要在纠结BFS和DFS的模板问题,大脑一直在思考BFS做层序遍历咋做的,对这道题就很烦躁,然后最后写了一种很暴力DFS的,但不知道怎么剪枝,卡在了(810/814)这个用例那,本想着用标签来表明已走过的路,但思路比较混乱,也不想写了,就直接看了答案.</p><p>对于此题,有一种类似BFS的做法,就是将矩阵从<code>[:,0]-&gt;[:,n-1]</code>这么来逐列遍历,然后目的是找可以走多长,最大就是<code>n</code>嘛,把右边可以走的路径点亮,然后看最远可以走到哪即可(比较抽象的描述,等等写完贴下方)</p><p>而对于DFS剪枝可以采用标签,还有一种针对此题,非常绝杀的:<code>grid[row][col]=0</code>当该点深搜完毕后,则给它置零!只要在我原来被卡住的代码里面加上这一句,通过并且耗时直接超了77%的人,非常恐怖的思想.细细想下来,这个设置还可以牵扯出类似动规的思想:</p><p>随机掉落到<code>(row,col)</code>这个点,它后面能到哪里取决于该点本身,而是否能到该点,则取决于前面的节点的值,意思即是,<code>(row,col)</code>这个点我们前面确定了是可以走的,后面它的路线其实是确定的,能走到的路也是确定的,有记载就好了,不用重复记载,因此它走完了它的路,就打一个走完的标志了,后面想要从这个点出发的点,知道了它是一个已完成的任务点,就不会走了,而设置的标志便是给它置零(因为整个数组都是正整数,置零了就走不过去了,不符合要求了),这种剪枝方法非常变态,因为是一条路径都给剪了,之后想往这走的都知道走过了,就不会走了.效率极高</p><p>原思路如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m,n,max;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>,row=<span class="hljs-number">0</span>,col=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(row=<span class="hljs-number">0</span>;row&lt;<span class="hljs-keyword">this</span>-&gt;m;row++)<br>            <span class="hljs-built_in">dfs</span>(grid,step,row,col);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,<span class="hljs-keyword">int</span> step,<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> col)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row<span class="hljs-number">-1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>            <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row][col+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row,col+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;m<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row+<span class="hljs-number">1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max&lt;step)<br>                <span class="hljs-keyword">this</span>-&gt;max = step;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max &lt; step)<br>            <span class="hljs-keyword">this</span>-&gt;max = step;<br>        grid[row][col]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自写类BFS:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags; <span class="hljs-comment">//(表示是否可通行)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-comment">// 按列主序的方式遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; (flags[i][j] || j == <span class="hljs-number">0</span>))<br>                &#123;<br>                    max = max &lt; j ? j : max;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (i &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (grid[i][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; flags[i][j])<br>                    max = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></td></tr></table></figure><p>自写DFS(普通剪枝):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m, n, max;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col) -&gt; <span class="hljs-keyword">void</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (col &gt; max)<br>                max = col;<br>            <span class="hljs-keyword">if</span> (col &lt; n - <span class="hljs-number">1</span> &amp;&amp; !flags[row][col])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (row &gt; <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row - <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (grid[row][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                    <span class="hljs-built_in">dfs</span>(row, col + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (row &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 走完了所有分支，下次别走这</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 无路可走，其实可以不设这个</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m; row++)<br>            <span class="hljs-built_in">dfs</span>(row, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/20/bw56tSoifDCcrGJ.png" alt="2684-maxMoves-flags" /></p><p>如果把flags去掉，换成置零，就是一个点的分支走完，然后置零，性能（时间和空间）都超过了90%的人==（有点不解，我true别人也进不来，为啥置零会快那么多）==</p><h4 id="重写官方思路-3"><a class="markdownIt-Anchor" href="#重写官方思路-3"></a> 重写官方思路</h4><p>重写了一个大佬的思路（就看了思路，代码自己写的，都通过了）</p><h2 id="73-矩阵置零"><a class="markdownIt-Anchor" href="#73-矩阵置零"></a> 73 矩阵置零</h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img" /></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br>输出：<span class="hljs-string">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><p><strong>进阶：</strong></p><ul><li>一个直观的解决方案是使用  <code>O(mn)</code> 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个仅使用常量空间的解决方案吗？</li></ul><h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3><p>当时我写的思路是暴力解法，就是用一个标记数组<code>nflags</code>标记列数，一个标记变量<code>mflags</code>标记行数，之所以这样设置标记是因为行主序的矩阵，一行里有一个是0，那就全部都是0；而列则需要逐行读的时候匹配（就是根据标记数组匹配）再置零。然后当一行全部置为0后，再把行标记变量<code>mflags</code>置否，最后根据标记数组<code>nflags</code>去重新扫一遍，避免有些列数匹配的元素没置零。</p><p>官方给出的方法（这里借鉴的是方法二）是采用两个标记数组来对元素为0的行列进行分别记录，然后再通过一个二重循环遍历，判断<code>row[i] || col[j]</code>来给元素置零。方法二则是在这个方法一的基础上，把两个标记数组用原矩阵的第一行和第一列来存储，而第一行和第一列的状态情况则用两个状态变量来存储，先处理除第一行和第一列外的剩余矩阵，然后再扫第一行和第一列，如果有0，则给它置零了。</p><h3 id="重写官方代码"><a class="markdownIt-Anchor" href="#重写官方代码"></a> 重写官方代码</h3><h2 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合"></a> 77 组合</h2><h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3><p>当时写这题的时候看题目看了半天没看懂，后来才发现就是排列组合那个组合的意思，就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>的意思。想了很久，用递归写的。其中n定了边界<code>[1,n]</code>,k定了一次要拿多少个数字出来。</p><p>当时的想法很质朴，就比如k=2那就需要两层循环，为3就需要3层循环，就用递归写（一开始想用别的，但想了很久，没想到）。然后最初提交的版本，漏判断了一个边界条件，还有一些简单的错误，改了之后就报超时的错，通过剪枝让其pass了。</p><p>官方思路则感觉很套路，很模板，但又很有道理，它利用一种回溯的思想来做，就是先从简单的二进制枚举来说起，比如有一个长度为n的序列，要求其所有子序列。那么则可以用一个游标cur来在<code>[1,n]</code>这个范围内由小到大的滑动，而每一个cur指向的字符/数字，则有选和不选两种情况，选了的进递归一次，不选的进递归一次，然后当游标cur滑过了边界则将值塞进结果数组里，并return。</p><p>而这个题目官方管它叫组合枚举，我感觉就是多了个临时值的大小判断，就是这个临时的数组它长度到k了，就给它塞进结果数组里，并return。然后再根据可能达不到k进行剪枝就好了。</p><h3 id="重写官方代码-2"><a class="markdownIt-Anchor" href="#重写官方代码-2"></a> 重写官方代码</h3><h2 id="86-分隔链表"><a class="markdownIt-Anchor" href="#86-分隔链表"></a> 86 分隔链表</h2><h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="img" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[2,1]</span>, x = 2<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>-200 &lt;= x &lt;= 200</code></li></ul><h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3><p>我一开始写这道题，只看到了示例2的情况，就是当<code>head.val == x</code>，因此直接进行了分类讨论，后来写着写着发现代码冗余很多，才发现一开始思路错了。不过最后还是做了出来，虽然比较暴力和耗了很长的时间。思路是要用两个指针，来做标识，分别是<code>cur_left</code>和<code>cur_right</code>，其中需要先确定<code>cur_right</code>的位置，就是第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点的位置，因为此后要往前插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点，而<code>cur_right</code>前面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点则为<code>cur_left</code>，掌管着左边界（因为要保留原来节点们的相对位置），之后遇到的<code>&lt; x</code>的节点就往这里面插入，然后滑动<code>cur_left</code>。当遇到<code>head.val == x</code>的情况，其实已经定好了<code>cur_right</code>，就是往左增加了一个节点，要移动head和<code>cur_left</code>节点为该节点。之后则化为上面的普通情况了。</p><p>官方思路，我看了一下觉得很符合题目意思，又看了一下题目描述，感觉就是在暗示你，把它分成两个链表来看待。即是有两个链表，<code>small_list</code>的值都小于<code>big_list</code>的，最后需要将<code>small_list</code>末尾节点的指针指向<code>big_list</code>的头指针，而<code>big_list</code>的末尾节点的指针需要置为<code>nullptr</code>，不然可能出错。</p><h3 id="重写官方代码-3"><a class="markdownIt-Anchor" href="#重写官方代码-3"></a> 重写官方代码</h3><h2 id="43-字符串相乘"><a class="markdownIt-Anchor" href="#43-字符串相乘"></a> 43 字符串相乘</h2><h3 id="题目描述-7"><a class="markdownIt-Anchor" href="#题目描述-7"></a> 题目描述</h3><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p>**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><p><strong>示例 1:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li><li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li><li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li></ul><h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3><p>根据题目给出的<code>m,n</code>边界可以知道,如果是最大的<code>num1</code>和最大的<code>num2</code>相乘,得到的数的指数部分是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>400</mn></msup></mrow><annotation encoding="application/x-tex">10^{400}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,即差不多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1200</mn></msup></mrow><annotation encoding="application/x-tex">2^{1200}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,显然32位的int和64位的long,都无法存下这么大的数,因此是利用字串相乘来做<strong>大数乘法</strong></p><p>可能太久没怎么写代码了,写这个的时候那个进位数不知道咋处理(确实很离谱😢 ),因此通过构建一个<code>vector&lt;vector&lt;int&gt;&gt; vec_res</code>这样的二维数组来给它存储,<code>vec_res.size()</code>表示的是有多少个中间值,就比如<code>123*456</code>,可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>100</mn><mo>+</mo><mn>20</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>400</mn><mo>+</mo><mn>50</mn><mo>+</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>6</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(100+20+3)*(400+50+6) = (1*10^2 + 2*10^1 + 3*10^0)* (4*10^2+5*10^1+6*10^0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>其中我们两个数值都逐位数遍历,然后系数相乘,指数相加,其中系数相乘得到的结果是最多为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>∗</mo><mn>9</mn><mo>=</mo><mn>81</mn></mrow><annotation encoding="application/x-tex">9*9=81</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">1</span></span></span></span>,就是只是向前一位进位;指数则通过<code>size()-1-i</code>来表示(<code>i: 0-&gt;size()</code>)</p><p>因此可以得到许多个最多两位数的值,装进vector里面,然后它们的索引表示的是指数值,而<code>vec_res</code>则把这些个数组装进去了,形成了一个稀疏的矩阵,其中每一行最多有两个元素值,最后再累加和reverse并拼接为string,需要注意<code>num1</code>或<code>num2</code>为0的情况,以及结果的string首位为0的情况.</p><p>反思:</p><p>这道题写得久很不应该(思路大概十分钟就出来了),因为本科我记得写过,但是实在是太久没练了,因此很多思维都僵化了,就比如上面并不需要用二维数组来承担结果的装载,直接用个<code>vector&lt;int&gt; vec_res</code>就行了,然后再诸位处理进位的问题,因为是int,比如<code>vec_res[0] = 213</code>,只需要留住3就好,210向前两位进过去就好.</p><p>官方思路:</p><ol><li>思路一就是把比如<code>123*456</code>给弄成<code>123*6</code>,<code>123*50</code>,<code>123*400</code>,然后再利用字符串相加,给它们加起来;</li><li>思路二跟我这个思路差不太多,不过巧妙很多,因为我的还需要reverse,它是计算了下两个数相乘后最小的位数情况为<code>m+n-1</code>,最大位数情况为<code>m+n</code>(其中:<code>m = num1.size();n = num2.size();</code>),因此直接给<code>vector&lt;int&gt; vec_res(m+n)</code>,然后第零位就是最高位(它不一定有数填充,可能是前导零),就比如<code>123*456</code>中的<code>3*6</code>,则放置在第五位(第三位*第三位=第六位,但是是[0,5],所以是第五位,如果有进位则是进在第四位),因而最后判断一下最高位是否前导0就可以把其转为字串;</li><li><mark>还有一种是可以把它考虑成卷积的情况,然后利用fft加速好像(这个方法还没细看)</mark></li></ol><h3 id="重写官方代码-4"><a class="markdownIt-Anchor" href="#重写官方代码-4"></a> 重写官方代码</h3><h2 id="10-正则表达式匹配"><a class="markdownIt-Anchor" href="#10-正则表达式匹配"></a> 10 正则表达式匹配🔴</h2><h3 id="题目描述-8"><a class="markdownIt-Anchor" href="#题目描述-8"></a> 题目描述</h3><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><ul><li><code>'.'</code> 匹配任意单个字符</li><li><code>'*'</code> 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;aa&quot;</span>, p = <span class="hljs-comment">&quot;a*&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3><h3 id="重写官方代码-5"><a class="markdownIt-Anchor" href="#重写官方代码-5"></a> 重写官方代码</h3><h2 id="103-二叉树的锯齿形层序遍历"><a class="markdownIt-Anchor" href="#103-二叉树的锯齿形层序遍历"></a> 103 二叉树的锯齿形层序遍历</h2><h3 id="题目描述-9"><a class="markdownIt-Anchor" href="#题目描述-9"></a> 题目描述</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h3><p>首先,当我一开始看到题目的描述,①要层序遍历,②锯齿形就是给它左一下右一下,就是奇数次的时候(就是某个一维数组位于奇数索引),是从右到左的层序遍历.因此最初的思路是:BFS+reverse,完美解题,轻而易举!</p><p>但是问题来了,我忘了bfs咋写,于是经过漫长思想纠结,用了一下之前类似回溯(其实不是回溯,bad)的dfs形式实现的(其中大多数花费的时间是在考虑怎么来度量是同一层,因为这样才可以放入<code>vector&lt;vector&lt;int&gt; res</code>中的同一层), 主要的思路是:写了个递归,然后该递归函数的声明:<code>void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; res,int height,TreeNode* node)</code>,通过如下的方式控制height:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; (height))<br>    &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        res[height].<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>    &#125;<br>    height++;<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;left);<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>官方思路则是使用了bfs(才记起来要用队列),不过它的方法没有用reverse,而是给了个flag,来标记从左开始还是从右开始push,其实就是头插和尾插,因为要用头插,所以用了个deque双端队列来存储.</p><h3 id="重写官方代码-6"><a class="markdownIt-Anchor" href="#重写官方代码-6"></a> 重写官方代码</h3><p>这里采用的是广搜的方法写的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *node;<br>            <span class="hljs-keyword">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (flag)<br>                    deq.<span class="hljs-built_in">push_front</span>(node-&gt;val);<br>                <span class="hljs-keyword">else</span><br>                    deq.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            flag = !flag;<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;deq.<span class="hljs-built_in">begin</span>(), deq.<span class="hljs-built_in">end</span>()&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 之前的方法</span><br><span class="hljs-comment">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="hljs-comment">        if(root == nullptr)</span><br><span class="hljs-comment">            return res;</span><br><span class="hljs-comment">        bfs(res,0,root);</span><br><span class="hljs-comment">        for(int i=0;i&lt;res.size();i++)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if(i%2!=0)</span><br><span class="hljs-comment">                reverse(res[i].begin(),res[i].end());</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return res;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 之前的方法,写是bfs实则dfs</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            v = res[height];<br>        v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            res[height]=v;<br>        <span class="hljs-keyword">else</span><br>            res.<span class="hljs-built_in">push_back</span>(v);<br>        TreeNode* left = node-&gt;left;<br>        <span class="hljs-built_in">bfs</span>(res,++height,left);<br>        height--;<br>        TreeNode* right = node-&gt;right;<br>        <span class="hljs-built_in">bfs</span>(res,++height,right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/19/DApaJQ6qH4lFwG8.png" alt="103-zigzagLevelOrder-effect" /></p><h2 id="146-lru缓存"><a class="markdownIt-Anchor" href="#146-lru缓存"></a> 146 LRU缓存</h2><h3 id="题目描述-10"><a class="markdownIt-Anchor" href="#题目描述-10"></a> 题目描述</h3><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><h3 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h3><p>因为这个题目要求<code>get</code>和<code>put</code>的时间复杂度是要在<code>O(1)</code>,显然对于数组来说,在随机位置读是<code>O(1)</code>,而增删则为<code>O(n)</code>,对于链表来说任意位置增删则为<code>O(1)</code>,因为不需要搬移元素,但如果指定位置增删则需要移动过去,这个过程会比较慢,比如单链表,那要删除尾巴节点则需要移动到尾巴那里,即使把尾巴节点存了也没意义,因为删了之后又得遍历一次存一次,因此对于这个题,显然我们需要一个链表来管理元素,即表示元素的优先级,优先级越高的越靠前,表明它使用的次数越多,而在尾巴节点的则表明有淘汰的风险,一旦有新的节点要加入,就要删除,因此本题需要使用双向链表<code>list</code>来管理元素的优先级,然后采用<code>vector&lt;int&gt;</code>来存储键值对,<code>list&lt;int&gt;</code>则用来管理索引.</p><p>一开始因为时间限制卡住了,后来在lolored的提醒下,<code>find</code>这个函数很耗时间,可以换下位置减少调用次数,就通过了,不过数据不大好看,但代码蛮简洁的~,以下是我的代码部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:     <br>    <span class="hljs-keyword">int</span> capacity;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>    list&lt;<span class="hljs-keyword">int</span>&gt; ls;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10001</span>,<span class="hljs-number">-1</span>);<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-number">-1</span> != <span class="hljs-keyword">this</span>-&gt;vec[key])<br>        &#123;<br>            list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            <span class="hljs-comment">// 调整至头部</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;vec[key];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-comment">// 为新值 且 长度到界 则需要弹出一个</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-keyword">this</span>-&gt;capacity &amp;&amp; <span class="hljs-keyword">this</span>-&gt;vec[key] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">back</span>();<br>                <span class="hljs-comment">// 链表弹出</span><br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">// 数组置-1</span><br>                <span class="hljs-keyword">this</span>-&gt;vec[t] = <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 以下是不同时满足上述两种情况的剩余情况</span><br>            <span class="hljs-comment">// 这个key在链表中没有(新值),头插</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">-1</span> == <span class="hljs-keyword">this</span>-&gt;vec[key])<br>            &#123;<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            &#125;<br>            <span class="hljs-comment">// 这个key链表有(旧值),调整至头部</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);   <br>            &#125;  <br>            <span class="hljs-keyword">this</span>-&gt;vec[key] = value;   <br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>官方思路其实也差不大多,因为这个问题的关键是<strong>快速查找到元素和快速增删元素</strong>,那有一种融合了这两种(数组和链表)优点的数据结构,叫<strong>哈希表</strong>.在C++中存储键值对的数据结构有<code>map,unordered_map,ordered_map</code>等等,其中<code>map</code>内部实现了红黑树(有序)和<code>unordered_map</code>内部则实现了哈希表,即它查找会更快,但是相对来说更占空间一点.</p><p>双向链表则自己实现,然后用它来存k,v(虽然<code>unordered_map</code>的key也是k,这里主要便于后期操作,所以加了个k),则有大概如下的结构<mark>这道题其实</mark>,可以实现查找O(1),增删O(1),其实还有个移动节点,分为删+增,也是O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d_node</span>&#123;</span><br>    d_node *prev,*next;<br>    <span class="hljs-keyword">int</span> key,value;<br>&#125;<br>unordered_map&lt;<span class="hljs-keyword">int</span>,d_node*&gt; u_m; <br></code></pre></td></tr></table></figure><p>比起我自己的方法来说,这种方法更好,因为我的方法实际上在查找确实是O(1),但是增删的时候多了一个<code>find()</code>操作,这一步是O(n)的.而且确实,我的vector跟list并没有实质意义上过大的链接关系,就是说它们唯一的共通点是vector的索引是key,而list里面的值是key,并没有真正把它们linked到一起.</p><h3 id="重写官方代码-7"><a class="markdownIt-Anchor" href="#重写官方代码-7"></a> 重写官方代码</h3><h2 id="14-最长公共前缀"><a class="markdownIt-Anchor" href="#14-最长公共前缀"></a> 14 最长公共前缀🔵</h2><h3 id="题目描述-11"><a class="markdownIt-Anchor" href="#题目描述-11"></a> 题目描述</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><h3 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h3><p>这个实际写了大概20分钟不到,这个题目比较直,即使暴力解也有好的结果,只要适当剪枝就好.抓一个string出来,然后跟别的比就好,只要出现了不匹配的就跳出来就好(用个标志位)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string ans;<br>        string tmp = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">bool</span> break_flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;tmp.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;strs.<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(strs[j].<span class="hljs-built_in">size</span>() &lt;= i)<br>                &#123;<br>                    break_flag=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp[i] != strs[j][i])<br>                    break_flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(break_flag)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans += tmp[i];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153 寻找旋转排序数组中的最小值</h2><h3 id="题目描述-12"><a class="markdownIt-Anchor" href="#题目描述-12"></a> 题目描述</h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br>解释：原数组为 <span class="hljs-string">[1,2,3,4,5]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：原数组为 <span class="hljs-string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[11,13,15,17]</span><br>输出：<span class="hljs-number">11</span><br>解释：原数组为 <span class="hljs-string">[11,13,15,17]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h3 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h3><p>一开始写这题的时候非常烦躁,感觉写题目是一件非常私人的事情,不要随着别人的时间写,不然很影响自己的状态.</p><p>后面我重新看了题目,确定了是二分查找,因为你要做到<code>O(logn)</code>这么一个时间复杂度,但是二分查找呢是排好序了的.于是自己又写了几个案例来观察:</p><p><code>[2,3,4,5,6,7,8,9,0,1]</code> | <code>[7,8,9,0,1,2,3,4,5,6]</code></p><p>不难发现,根据旋转的次数,我们的最小值可能在中点的左边,也可能在右边:</p><ul><li>最小值在中点左边,说明旋转次数少,左边的值偏大;</li><li>最小值在中点右边,说明旋转次数多,右边的值偏小;</li></ul><p>因此,我就选择拿最左端与中点的值进行比较,一步步缩小区间(a表示左侧端点,mid表示中点):</p><p><code>if(nums[mid]&gt;nums[a]) // 最小值在右边的区间 向右收缩区间</code></p><p><code>if(nums[mid]&lt;nums[a] // 最小值在左边的区间) 向左收缩区间</code></p><p>其中向右收缩区间则<code>mid</code>和<code>nums.size()</code>相加除2,把mid往右移,a把原来mid的索引给拿走;</p><p>其中向左收缩区间则<code>mid</code>和<code>a</code>相加除2,把mid往左移;</p><p>因为收缩到的子区间也是满足这种旋转的情况的(就是两个升序的序列,但是拼接处是最大值和最小值),直到<code>a</code>和<code>mid</code>相等,说明它俩挨得近,上一次只差了个1,但是左缩了,说明上一次的mid是小于a的值的,但是相等了,说明上一次的值已经是最小的了.</p><h3 id="重写官方代码-8"><a class="markdownIt-Anchor" href="#重写官方代码-8"></a> 重写官方代码</h3><h2 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> 56 合并区间</h2><h3 id="题目描述-13"><a class="markdownIt-Anchor" href="#题目描述-13"></a> 题目描述</h3><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^4</code></li></ul><h3 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h3><p>我真是无语写这道题,因为官方给的示例,我以为左端点是递增的,后面提交才发现,是需要先排个序的…</p><p>不过写分类的时候也是跌跌撞撞试了几次错,再整理思路写出来的,虽然好像看起来结果还挺pass,但方法比较呆瓜(不用一直合并,可以累积一波再合并),之后要重写一遍这题.</p><p>官方的思路是先按左端点排序,则能合尽合,不能合则next one go go.</p><h3 id="重写官方代码-9"><a class="markdownIt-Anchor" href="#重写官方代码-9"></a> 重写官方代码</h3><h2 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和"></a> 53 最大子数组和</h2><h3 id="题目描述-14"><a class="markdownIt-Anchor" href="#题目描述-14"></a> 题目描述</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h3 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h3><p>原思路如下虽通过了,但是有一个压力测试的用例是绕过去的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max,sum;<br>        <span class="hljs-comment">// 这个来定区间</span><br>        <span class="hljs-keyword">int</span> r;<br>        <span class="hljs-comment">// 把边界先给处理了</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;nums.<span class="hljs-built_in">size</span>();l++)&#123;<br>            <span class="hljs-comment">// 初始值设置</span><br>            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>)<br>                max = nums[l];<br>            sum = nums[l];<br>            <br>            <span class="hljs-comment">// 极端情况,全负</span><br>            <span class="hljs-keyword">if</span>(max &lt; nums[l])<br>                max = nums[l];<br>            <span class="hljs-comment">// 左端点和步距表示区间</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s=l+<span class="hljs-number">1</span>;s&lt;nums.<span class="hljs-built_in">size</span>();s++)&#123;<br>                <span class="hljs-comment">// 左端点值小于0直接跳出去</span><br>                <span class="hljs-keyword">if</span>(nums[l] &lt; <span class="hljs-number">0</span>)&#123;<br>                    sum = <span class="hljs-number">0</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 对着用例加的一个无聊的标志位,如果是有负则为false;</span><br>                <span class="hljs-keyword">if</span>(nums[s]&lt;<span class="hljs-number">0</span>)<br>                    flag = <span class="hljs-literal">false</span>;<br><br>                sum += nums[s];<br>                <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(sum&gt;max)<br>                        max = sum;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间里的和只要是大于零(大于max(因为怕有极端情况))的就有反转的余地,不然就废了</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>上面代码的思路是通过l(left)和s(stride)这两个来定区间,然后逐个区间找最大值的可能,什么时候放弃一个区间呢?</p><ul><li>当它开头(区间左端点)是负数(因为如果全负的话,直接从负的找最大的就好),如果有大于等于0的话,那就说明这个负的开头的不可能是最大连续子数组,因为它的起点就比别人低;</li><li>当它区间的总和小于0时,也要跳出,因为你开头不为0,你这时为0了,后面即使有再大的数,也不如直接就挑那一个大数作为最大值的连续子数组</li></ul><p>而当我们区间的总和不为0时,则表示有回转的余地,还可以继续区间的和的最大值的计算</p><p>昨天lolored跟我说她写了一个绝佳的方法,确实牛牛,代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = nums.<span class="hljs-built_in">size</span>(); i &lt; len; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (max &lt; nums[i]) max = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个方法其实是把我上面的方法高度压缩了一波,利用数组内的每个值作为sum来统计,而当其本身小于0或是累和小于0则放弃,当累和比max大则更新max</p><p>这个方法的时间复杂度是<code>O(n)</code>,但我觉得精简程度堪称典范,比官方的dp方法还好.</p><p>官方的思路是采用动态规划的算法,这里采用一个看到的大佬的思路(<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">参考自liweiwei1419</a>),作者详细地讲了这个题目<strong>如何找到/定义状态</strong>(就是子问题,<mark>从有后效性到无后效性(后面对子问题的求解不影响前面已求解完的子问题),好像要么就是给它加定语设条件,要么就是增加状态数组维度</mark>),然后找到<strong>子问题之间的联系,就是状态转移方程</strong></p><p>以<code> [-2,1,-3,4,-1,2,1,-5,4]</code>为例</p><p>比如一开始会想:</p><ul><li>含有<code>-2</code>的连续子序列的最大和 -&gt; <code>dp[0]</code></li><li>含有<code>1</code>的连续子序列的最大和 -&gt; <code>dp[1]</code></li><li>…</li><li>含有<code>4</code>的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li></ul><p>但是这并没有很好的阐述清楚这个问题,子问题间的关系扑朔迷离,且对现在的子问题依旧有<strong>不确定</strong>的因素就判定为仍有后效性(我感觉意思上来说就是只要你感觉怪怪的,就是还有后效性,只要当你的子问题定语够多,前提是不要错,对不对很容易感受出来)</p><p>现在的不确定性就是比如含有<code>-2</code>的连续子序列有很多很多个,含有<code>1</code>的连续子序列也有很多很多个,这里的作者就借助<strong>位置</strong>这个定语来加强子问题的限定</p><ul><li>以<code>-2</code>为末尾元素的连续子序列的最大和 -&gt; <code>dp[0]</code></li><li>…</li><li>以<code>4</code>为 末尾元素的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li></ul><p>这样就有:</p><p>对于以-2为结尾的<code>[-2]</code>即是在所有连续子序列中选一个最大和的,而这个只有一种情况,所以<code>dp[0]=nums[0];</code></p><p>对于以1为结尾的<code>[-2,1]</code>,<code>[1]</code>有这么两种情况,即是在选不选<code>dp[0]</code>的情况下做选择,当然我们如果前一个<code>dp[i-1]</code>的是<code>&lt;=0</code>的数加了只会更小或者说没区别,还不如就不加了.</p><p>因此状态转移方程也就呼之欲出了</p><p>此外,作者也说了动规题的做题路径:</p><ol><li>定义状态/子问题</li><li>定义状态转移方程</li><li>考虑初始值</li><li>考虑输出</li><li><mark>空间优化(这一步先放弃,一般空间不要太离谱也不会爆)</mark></li></ol><h3 id="重写官方代码-10"><a class="markdownIt-Anchor" href="#重写官方代码-10"></a> 重写官方代码</h3><p><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的连续子序列的最大和</p><p>当发生状态转移的时候,即是选择<code>dp[i]</code>选择<code>dp[i] = dp[i-1] + nums[i];</code>或是<code>dp[i] = nums[i];</code>的过程,而这个选择的条件就是<code>dp[i-1]</code>是否<code>&gt;0</code></p><p>定义好状态了,状态转移方程以及相关条件都定义好了,考虑初值,即<code>dp[0]</code>表示以<code>nums[0]</code>结尾的连续子序列的最大和,有且也只有一个<code>[nums[0]]</code>这么一个子序列,所以<code>dp[0] = nums[0];</code></p><p>题目要求我们求出连续子序列的最大和,就是说,并不是一定要以谁结尾,而是要在这些情况中,找个最大的,也就是遍历所有的状态,找个最大的返回出去.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span>)<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + nums[i];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = nums[i];<br>            <span class="hljs-keyword">if</span>(dp[i] &gt; max)<br>                max = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/03/12/H6h2EdPU5xSvKrB.png" alt="53 最大子数组和-前后效果对比" /></p><h2 id="162-寻找峰值"><a class="markdownIt-Anchor" href="#162-寻找峰值"></a> 162 寻找峰值</h2><h3 id="题目描述-15"><a class="markdownIt-Anchor" href="#题目描述-15"></a> 题目描述</h3><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul><h3 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h3><p>这个题目,看到**<code>O(logn)</code><strong>的时候就意识到了要用</strong>二分查找**(因为它就是找类似于极大值点的这么一个情况,就是找某一个满足特殊条件的值),但是它跟普通的二分查找不一样,因为那种是排好序的,那么这个二分查找你在折半区间后,往哪一个新的区间走都还不知道呢</p><p>这个时候就要结合题目分析一波,因为题目说是找峰值:</p><ul><li>当是<code>nums[i]&gt;nums[i-1] &amp;&amp; nums[i]&gt;nums[i+1]</code>的时候则满足条件;</li><li>如果是<code>nums[i-1]&lt;nums[i]&lt;nums[i+1]</code>的说明是个目前处于增函数一侧(方便理解,故如此称呼),则要往右走;</li><li>如果是<code>nums[i-1]&gt;nums[i]&gt;nums[i+1]</code>则说明是处于减函数一侧,要往左走</li></ul><p>然后这里通用的做法的话是<strong>缩区间,区间找中点,判断,循环往复</strong></p><p>但是我不知道为啥写的时候死犟,用了个二分法+进退法,死都想不起来缩区间,而是:先找到中点<code>mid</code>,用它去判断是处于增/减,再往另一个区间去,<code>pre_mid</code>继承<code>mid</code>的位置,则可能存在增-减/减-增的理想情况,也可能存在增-增/减-减的情况,会导致陷入区间,因此要用一些方法将此类情况移除,采用逐次增加步距,跳出陷入区间的可能.此外,也可能存在比较对称的点,导致<code>pre_mid</code>和<code>mid</code>振荡,因此每次陷入的时候都加多个1,避免振荡.然后得出了下面这么一个结果(好得有点惊讶,因为我写到后面甚至不知道我在干嘛了,指振荡那一部分,是遇到了一个用例死活过不去(振荡了),就把步距那一块都加了个1,后来感觉是打破了对称性):</p><p><img src="https://s2.loli.net/2024/03/13/ZM7KdHErQTW2csP.jpg" alt="162 寻找峰值元素-奇怪的运行结果" /></p><p>代码如下,此题需要重写,用正常的写法写(就是我说的缩区间的,官方的解法也是这个)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre_mid=<span class="hljs-number">-1</span>,mid = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>,tmp,stride;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 处理两个边界情况</span><br>            <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[mid+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(mid==nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; nums[mid] &gt; nums[mid<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 可以出去的情况</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果找错极值了,乱弹一下</span><br>            <span class="hljs-keyword">if</span>(mid == pre_mid)&#123;<br>                mid = <span class="hljs-number">2</span> * mid;<br>                <span class="hljs-keyword">if</span>(mid &gt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                    mid = mid % nums.<span class="hljs-built_in">size</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = (mid + nums.<span class="hljs-built_in">size</span>()) / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往右走</span><br>                    tmp = mid;<br>                    mid = (mid + pre_mid) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                    <br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &lt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span> &amp;&amp; <br>                nums[mid] &gt; nums[pre_mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (mid - pre_mid) + <span class="hljs-number">1</span> ;<br>                    mid = mid + stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//if(nums[mid]&gt;nums[mid+1]&amp;&amp;nums[mid]&lt;nums[mid-1])&#123;</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = mid / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往左走</span><br>                    tmp = mid;<br>                    mid = (pre_mid + mid ) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &gt; <span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[pre_mid] <br>                &amp;&amp; nums[mid] &lt; nums[mid<span class="hljs-number">-1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (pre_mid - mid) + <span class="hljs-number">1</span>;<br>                    mid = mid - stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;mid:&quot;</span>&lt;&lt; mid &lt;&lt; <span class="hljs-string">&quot; pre_mid:&quot;</span> &lt;&lt; pre_mid &lt;&lt;<span class="hljs-string">&quot; len:&quot;</span> &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl ;<br>            <span class="hljs-keyword">if</span>(mid&lt;<span class="hljs-number">0</span>)<br>                mid = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(mid&gt;nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                mid = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">题目是查找满足某种条件的值的索引(找峰值)</span><br><span class="hljs-comment">然后说O(logn)</span><br><span class="hljs-comment">那不就是二分查找嘛</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">把示例的输入都化成点图,感觉就是找尖尖的点</span><br><span class="hljs-comment">遇到左&lt;中&lt;右的就往右移动;</span><br><span class="hljs-comment">遇到左&gt;中&gt;右的就往左移动;</span><br><span class="hljs-comment">记录上一个&quot;中&quot;值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="重写官方代码-11"><a class="markdownIt-Anchor" href="#重写官方代码-11"></a> 重写官方代码</h3><h2 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160 相交链表</h2><h3 id="题目描述-16"><a class="markdownIt-Anchor" href="#题目描述-16"></a> 题目描述</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img" /></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img" /></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img" /></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">1</span><br>输出：Intersected at &#x27;<span class="hljs-number">2</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img" /></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h3 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h3><p>题目说要<strong>在两个单链表中找到它们相交的节点</strong>,我的思路是很暴力的,直接两个链表遍历,当有节点相等则意味着找到相交点了,因为相交的点们都是同样的内存地址.本来想着用数值来找的,但是数值有重复的.</p><p>上述这种方法时间复杂度是<code>O(mn)</code>(虽然AC了但是性能一般),等我想到<code>O(m+n)</code>的再看题解,不然怕没逻辑过程~</p><hr /><p>叮~~~(仔细想了半小时左右,指以下过程,还回看了分隔链表的题目,因为觉得它们很像),不小心按到题解(之前做完跳过去的,页面没关),看到<strong>双指针</strong>,看到<strong>后面的长度一样</strong>,然后想了一下,大概知道怎么做了,写一遍</p><hr /><p>新的思路主要是<strong>先对齐数组,然后逐个比较</strong></p><p>对齐数组是指listA和listB长度不一样,而显然交点及之后的大小是一样的长度,而多出来的那部分(就是那些个节点),肯定不是交点会在的地方,因此先对齐,而对齐前要统计两个链表的长度,则这部分的时间复杂度是<code>O(m+n)</code>,之后对齐需要处理长链表的节点,而后的逐个比较则是减去了这部分长链表的节点,所以后面这部分的时间复杂度为<code>O(max(m,n))</code>,假设m&gt;n,则总时间复杂度为<code>O(2m+n)</code>这样子,算是达到了<code>O(m+n)</code>的时间复杂度</p><p>以下为更正后的代码部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *tmpA = headA, *tmpB = headB;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (tmpA != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            tmpA = tmpA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (tmpB != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        tmpA = headA;<br>        tmpB = headB;<br>        pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt = m &gt; n ? <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, m - n) : <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, n - m);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">max</span>(m, n) - cnt.second;<br><br>        <span class="hljs-keyword">while</span> (cnt.second)<br>        &#123;<br>            <span class="hljs-comment">// 处理listB</span><br>            <span class="hljs-keyword">if</span> (cnt.first)<br>                tmpB = tmpB-&gt;next;<br>            <span class="hljs-comment">// 处理listA</span><br>            <span class="hljs-keyword">else</span><br>                tmpA = tmpA-&gt;next;<br><br>            cnt.second--;<br>        &#125;<br>        ListNode *ans = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (tmpB == tmpA)<br>            &#123;<br>                ans = tmpB;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpA = tmpA-&gt;next;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 下面是暴力解法</span><br><span class="hljs-comment">        ListNode* tmpA = headA;</span><br><span class="hljs-comment">        ListNode* tmpB = headB;</span><br><span class="hljs-comment">        ListNode* ans = nullptr;</span><br><span class="hljs-comment">        bool flag = false;</span><br><span class="hljs-comment">        while(tmpA != nullptr)&#123;</span><br><span class="hljs-comment">            while(tmpB != nullptr)&#123;</span><br><span class="hljs-comment">                if(tmpA == tmpB)&#123;</span><br><span class="hljs-comment">                    ans = tmpA ;</span><br><span class="hljs-comment">                    flag = true;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                tmpB = tmpB -&gt;next;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            tmpA = tmpA -&gt;next;</span><br><span class="hljs-comment">            tmpB = headB;</span><br><span class="hljs-comment">            if(flag)</span><br><span class="hljs-comment">                break;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return ans;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="重写官方代码-12"><a class="markdownIt-Anchor" href="#重写官方代码-12"></a> 重写官方代码</h3><h2 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> 98 验证二叉搜索树</h2><h3 id="题目描述-17"><a class="markdownIt-Anchor" href="#题目描述-17"></a> 题目描述</h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左</p><p>子树</p><p>只包含</p><p>小于</p><p>当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h3><p>验证二叉搜索树，就是要根据给定的输入，验证输入的树结构是否是bst</p><p>我们知道，对于bst而言，中序遍历的时候相当于排序，而对于如左子树&lt;根&lt;右子树的情况，则相当于升序</p><p>我一开始写的时候想用广度优先搜索写，主要遵循的是左节点&lt;根&lt;右节点这样规则，但后面过用例的时候会出现，有左子树的部分节点会比根节点的值大，这就不符合bst了。后面想了一下，没想出如何解决，因此转用了dfs做中序遍历，然后看是不是升序的，是则说明是bst</p><h3 id="重写官方思路-4"><a class="markdownIt-Anchor" href="#重写官方思路-4"></a> 重写官方思路</h3><h2 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> 110 平衡二叉树🔴</h2><h3 id="题目描述-18"><a class="markdownIt-Anchor" href="#题目描述-18"></a> 题目描述</h3><p>给定一个二叉树，判断它是否是平衡二叉树</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = []<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在范围 <code>[0, 5000]</code> 内</li><li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li></ul><h3 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h3><p>写这道题太挫败了,简单题我写不出来😢</p><p>一开始的想法是想用bfs,层序遍历树结构,用<code>vector&lt;vector&lt;int&gt;&gt;</code>把树结构的信息装起来,然后遍历,我们知道树的高度为h,则该行长满节点则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>(h是从0开始算的),我的判断依据是当存在两行不满足长满节点,则不是平衡二叉树,然后在一个用例上错了😈,如<code>[1,2,3,4,5,6,null,8]</code>这样的,满足我的不是平衡二叉树的判断,但它又确实是,因为每一个子树都满足左右子树高度差&lt;=1</p><hr /><p>昨天晚上重写了这个题目,看了题解,用了递归写的,但是性能不大好,应该是属于自顶向下的那种?</p><p>主要思路是所有平衡二叉树的子树都是平衡二叉树,因为都要满足左右子树高度差不为1的条件.则对于叶子节点,高度为1,一层层的这样累加上去,则可以知道根的左右子树的高度;并且在检索左右子树的高度时,也对每一个小子树的高度差进行判定,如果超过1,则直接返回-1,且上层对-1直接疯狂返回就行.即使这样时间上也只是超过53%的人</p><p>重写的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> height_l = <span class="hljs-built_in">findHeight</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> height_r = <span class="hljs-built_in">findHeight</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(height_l - height_r) &lt;=<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findHeight</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-comment">// 空节点高度为0</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 叶子节点则高度为1</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> height_l,height_r;<br><br>        height_l = <span class="hljs-built_in">findHeight</span>(node-&gt;left);<br>        height_r = <span class="hljs-built_in">findHeight</span>(node-&gt;right);<br>        <br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span> || height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(height_l - height_r) &gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(height_l,height_r) + <span class="hljs-number">1</span> ;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="重写官方思路-5"><a class="markdownIt-Anchor" href="#重写官方思路-5"></a> 重写官方思路</h3><p>之后看下有没有啥更好的题解</p><h2 id="121-股票i"><a class="markdownIt-Anchor" href="#121-股票i"></a> 121 股票Ⅰ</h2><h3 id="题目描述-19"><a class="markdownIt-Anchor" href="#题目描述-19"></a> 题目描述</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><h3 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h3><p>写这道题的时候我的心路历程如下:</p><ol><li>左右指针,左扫最低,右扫最高,相减为ans,为负则0 -&gt; failed;</li><li>慢慢划过去,找最小值,然后最大值是最小值右边的(历史最低点不一定是赚到最多钱的时候<code>[2,5,1,3]</code>)</li></ol><p>然后不知道触动了哪个叛逆的神经,我想了下,如果动态规划做的话:</p><p><code>dp[i]</code>表示第<code>i</code>天的最大收益,则它这个会模糊不清吗(就是有无后效性),然后就大概的过一过,比如:</p><ul><li><code>dp[0]</code>第一天的最大收益</li><li><code>dp[1]</code>第二天的最大收益</li><li>…</li><li><code>dp[len-1]</code>最后一天的最大收益</li></ul><p>那这个最大收益呢,它并不是说我一定非得要在那天卖出(上面的就有点模糊,有后效性,因为我们不知道在第几天卖出,描述很模糊,但买入一定是之前的某个时间节点),就是<strong>直至到第<code>i</code>天的最大收益</strong>,同时转移方程也出来了(很神奇,感觉只要状态找好了找对了,转移方程就很快出来的):</p><p><code>dp[i] = max(dp[i-1],prices[i]-min)</code></p><p>即直到第<code>i</code>天的最大收益,要么是直到第i-1天的最大收益,要么是今天的卖出价减去之前存储好的相对较低的买入价,两者取max即为所得</p><p>同时初始值<code>dp[0]</code>肯定是0,因为撑死就今天买入,卖出如果是同一天的话,也是0.</p><p>同时期望的输出就是<code>dp[len-1]</code>,直到最后一天的最大收益(战斗到股市最后一刻),因为存的是最大利润,故输出其即可.</p><h3 id="重写官方思路-6"><a class="markdownIt-Anchor" href="#重写官方思路-6"></a> 重写官方思路</h3><p>和你的一样哇哈哈</p><p>思路一倒是居然没有往这里想,就是跟之前有道题类似(好像是组合?),限定左端,然后右端在左端下一位移动;左端往右走一位,右端在左端下一位继续移动;</p><p>限定了区间,但据说会报超时.</p><h2 id="122-股票ii"><a class="markdownIt-Anchor" href="#122-股票ii"></a> 122 股票Ⅱ</h2><h3 id="题目描述-20"><a class="markdownIt-Anchor" href="#题目描述-20"></a> 题目描述</h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><h3 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h3><p>一开始的时候没啥思路,知道这题递归做,虽然说递归做出来了,但是官网跟我类似的方法是贪心算法,bad,分不清了</p><p>我的想法是<code>dp[i]</code>继续表示<strong>直到第i天的最大利润</strong>,但是跟前面的有点不一样,因为我们现在可以<strong>每一天可以多次交易(可以买入卖出),但是任何时候最多只有一股</strong>,也即是说我可能第三天买,第四天价格好就卖了,第五天又买入,第七天行情好了,又卖出去,并不是说买入的时候一定比卖出的早(因为多次交易,可能在之前就有卖出行为了),感觉原来的状态依旧可行,于是修改状态转移方程思路如下:</p><p>dp[i]是我直到第i天的最大利润,它的计算方式是:它如果今天不卖出东西的话(就是没赚钱嘛,我依旧不管什么时候买入的),那它就是dp[i-1],那如果今天卖东西呢(就是卖了,有得赚嘛),那就是dp[i-1]+prices[i]-minPrice.那卖不卖东西,其实看的是赚不赚钱:</p><p><code>dp[i] = dp[i-1] +  max(0,prices[i]-minPrice)</code></p><p>那问题转移到了minPrice怎么找,我们知道,因为任何时候最多持有一股,所以卖了的话,minPrice就得更新(有股且卖).那如果没卖(有股和无股,且不卖,更新minPrice),当天的价格低,就给它换,即是更新到一个价格相对更低的minPrice,当然你得先看它(前一天的价格)卖的话赚不赚钱,赚的话先卖了,再更新,故minPrice变成了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否出售</span><br><span class="hljs-keyword">for</span>(...)&#123;<br>    <span class="hljs-keyword">if</span>(prices[i]-minPrice&gt;<span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,prices[i]-minPrice);<br><span class="hljs-keyword">if</span>(minPrice &gt; prices[i])&#123;<br>        minPrice = prices[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        minPrice = prices[i]; <span class="hljs-comment">// 大的话在之后的遍历会缩</span><br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还加了flag辅助,虽然好像没啥用(简化代码这个flag可以去掉)</p><p>但是官方说这个是贪心算法,我看了下评论区的人的解释:<strong>只要是利润都是赚的,那直接累加利润就是能赚到的最多的钱</strong>,确实如此!</p><p>官方的动态规划的做法则是从<strong>最多只能持有一股股票</strong>入手</p><p>那如果第i天交易结束,我手里要么有一股股票,要么没有股票,所以我们原先121的<code>dp[i]</code>,直到第i天的最大利润,可以加个定语变为:<strong>直到第i天有一股股票的最大利润</strong>和<strong>直到第i天没有股票时的最大利润</strong>,而只增加定语并不能解决真正的问题,则要加个维度来表示这个定语了,于是有新的状态定义如下:</p><p><code>dp[i][0]</code>: 直到第i天交易结束后没有股票时的最大利润</p><p><code>dp[i][1]</code>: 直到第i天交易结束后有一股股票时的最大利润</p><p>对应状态的变化可以这样想,买入一股,相当于赊账买入,则减,卖出相当于进账,则加.则我们的状态表示<code>dp[i]</code>直到第i天的账户余额数</p><p>因此引出状态转移方程如下:</p><p><code>dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])</code></p><p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])</code></p><p>相应的对于如&quot;直到第1天交易结束时的最大利润&quot;这样的初始值的处置也可以分为:<code>dp[0][0] = 0;dp[0][1] = -prices[0]</code></p><p>然后最终的输出是要输出能获得的最大利润,显然<code>dp[n-1][1]</code>是比<code>dp[n-1][0]</code>所赚的钱少的,还有一股股票压箱底呢,因此最终的输出就直接是<code>dp[n-1][0]</code></p><h3 id="重写官方思路-7"><a class="markdownIt-Anchor" href="#重写官方思路-7"></a> 重写官方思路</h3><p>有缘重写一下咯~</p><h2 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46 全排列🔴</h2><h3 id="题目描述-21"><a class="markdownIt-Anchor" href="#题目描述-21"></a> 题目描述</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h3><p>一开始的想法跑偏了,想到动规那里去了,为什么会想到那去呢,因为想着这种排列,它比如<code>[1,2,3,4]</code>,如果是一位数的情况下,以<code>nums[0]</code>结尾的情况,即<code>dp[0][0]</code>只有一种,显而易见,这个二维矩阵的第一行很好填满,而第一列则如<code>dp[1][0]</code>,是两位数的情况下,以<code>nums[0]</code>结尾的情况,很明显,这个东西它好像不大对劲,就是它可以用来统计个数?也可能在过程可以append vector到ans这个二维数组,但就是很奇怪,故直觉觉得奇怪,大多数情况下无法用dp做出;</p><p>后来不知道为何没有想出做法(思路跑到组合那里去了),即使和lolored的想法是相同的(递归处理每个首位数),但处理上出了些问题,导致递归出不去,重写修改并整理思路写于如下:</p><p>以<code>nums=[1,2,3]</code>为例,我们知道,当我们在数学中遇到排列问题,会想着第一个位置可以排列3个,第二个位置就排列2个,最后一个位置则排列1个,因此即是首位数可以排列1,2,3三种情况,首位数的下一个首位数,就是第二位数,可以排列第一位数排列剩下的情况,后面的首位数也是如此,在剔除了上一位选择的数字后,在剩下的数字里选择</p><p>因此,nums如果是3位数,则应该有3个for,用来为每一位数挑选剩余的数字;<strong>如果有n位数,则应该有n个for来为每一位数挑选剩余的数字</strong>(一般n不会太大,不然容易oom,而且也有爆栈的风险),因此是<strong>递归</strong>,且<strong>每个递归函数中处理一位数</strong></p><p>那如何知道这个数字被选了呢,<strong>标志位</strong></p><p>因此有伪代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(flags[i])&#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        flags[i] = <span class="hljs-literal">true</span>;<br>        ...处理下一位数字...<br>        flags[i] = <span class="hljs-literal">false</span>;<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终写好的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flags</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>()&gt; findNumber = [&amp;]()-&gt; <span class="hljs-keyword">void</span>&#123;<br>                <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == len)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(tmp);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(!flags[i])&#123;<br>                        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                        flags[i] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-built_in">findNumber</span>();<br>                        flags[i] = <span class="hljs-literal">false</span>;<br>                        tmp.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">findNumber</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="重写官方思路-8"><a class="markdownIt-Anchor" href="#重写官方思路-8"></a> 重写官方思路</h3><h2 id="47-全排列ii"><a class="markdownIt-Anchor" href="#47-全排列ii"></a> 47  全排列Ⅱ</h2><h3 id="题目描述-22"><a class="markdownIt-Anchor" href="#题目描述-22"></a> 题目描述</h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><h3 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h3><p>容易看出,它是在46题的基础上增加了<strong>重复数字</strong>,这样一来相较于原先的情况,应该多了更多剪枝的方法,比如<code>[1,1,2]</code>就相较于原来的<code>[1,2,3]</code>由6种排列变成了3种,但是想了好久都没想出来新的剪枝如何实现,就用个set在46题的基础上给它主动去重,当然性能也很差,后面看下解析改进一下.</p><h3 id="重写官方思路-9"><a class="markdownIt-Anchor" href="#重写官方思路-9"></a> 重写官方思路</h3><p>细看了一下官方的解题思路,其中关于<strong>剔除重复序列</strong>(也就是这个题的关键)有点看不懂,但是看了下评论区大家的解释,大致了然了,下面以<code>[1,1,1,2]</code>举例:</p><p>从这个含有重复数字的序列中,不难看出,一共就:<code>[1,1,1,2]</code>;<code>[1,1,2,1]</code>;<code>[1,2,1,1]</code>;<code>[2,1,1,1]</code>这么几种排列情况,如果按照A44=4!=24种情况,显然有20种情况是重复的,就比如以顺序给重复的以命名,如:<code>[1a,1b,1c,2]</code>,其中<code>1a1b1c</code>这个排列有6种情况,但其实都是重复的,我们取其中一种,如<code>1a1b1c</code>即可,那么如何过滤掉其余的几种呢?</p><p>显然如果要取<code>1a1b1c</code>这一种,即我们在递归的顶层遍历(即第一个for),可以得到1a,然后第二个for可以得到1b,第三个for可以得到1c,最后一个for得到2,那么期望的数字排列1a1b1c2就出来了,接下来则顶层遍历的for会把1a的标志位给置否,并把它从数组中弹出,则1b登场,显然我们不想要这组排列,包括之后的1c开头的排列也是,如何剔除?</p><p>可以看出,这些有重复数字的得排在一起,如<code>[1,1,1,2]</code>这样,而非<code>[1,2,1,1]</code>,这样能更好且规律地剔除,因此一开始得对nums排个序,使之成为<code>[1,1,1,2]</code>这样,然后,我们不要的是1b,1c开头的,它们前面都有重复的数字<code>nums[i] == nums[i-1]</code>,且此种情况下,前面的排好了,即<code>nums[i-1]</code>它排好了<code>nums[i]</code>的情况,且此时flags[i-1]已经置否,则这个可以作为已排过的标志!</p><p>我们先对nums排序,若是<code>nums[i] == nums[i-1]</code>说明此时滑到了重复的数字上,为了避免越界需加上<code>i&gt;0</code>,而当flags[i-1]还为true的时候,表明正在发生如下的排列:<code>1a...</code>,而当<code>nums[i-1]</code>为false的时候说明已排列好,则此时的排列若是<code>nums[i] == nums[i-1] &amp;&amp; !flags[i-1]</code>说明在排重复的序列了,可以直接continue</p><p>这样做会使得重复数字的第一个数排好情况,而后面重复的那些,就直接continue,continue走掉,直到一个新的重复序列的开头~</p><p>已重写🆗</p><h2 id="49-字母异位词分组"><a class="markdownIt-Anchor" href="#49-字母异位词分组"></a> 49 字母异位词分组</h2><h3 id="题目描述-23"><a class="markdownIt-Anchor" href="#题目描述-23"></a> 题目描述</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 10^4</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h3 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h3><p>写这道题,我只有暴力的想法!非常暴力,以至于很弱智:</p><ol><li>标志flags表征这个字串是否加入过结果数组;</li><li>两层遍历,第一层从左往右,第二层顺着第一层,在它右起新一个位置搜索,两个字串比对长度,长度一致则排序,若一致则加入vecString,并置标志位;</li><li>从第二层遍历出来,判断vecString的size是否不为0,不为0则加入结果数组;</li></ol><p>以上以极高时间复杂度完成了整道题,但是内存开销则还可以(?很怪)</p><p>同时发现了自己在C的字符数组这一块的相关函数忘得差不多了.之后补齐相关的知识</p><h3 id="重写官方思路-10"><a class="markdownIt-Anchor" href="#重写官方思路-10"></a> 重写官方思路</h3><p>官方的思路是用哈希表来处理这个问题,主要是抓住字母异位词的特点来处理,有两种做法一种是排序,一种是根据比如<code>[pet,etp,cat,rag]</code>构造对应的key值,如:<code>1e1p1t,1e1p1t,1a1c1t,1a1g1r</code>这样.</p><p>重写一遍代码如下(29号再写):</p><p>已重写🆗</p><h2 id="61-旋转链表"><a class="markdownIt-Anchor" href="#61-旋转链表"></a> 61 旋转链表</h2><h3 id="题目描述-24"><a class="markdownIt-Anchor" href="#题目描述-24"></a> 题目描述</h3><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 2 * 10^9</code></li></ul><h3 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h3><p>因为我们旋转1次就会把尾节点放到前面,当旋转链表的长度<code>len</code>次的话,就相当于没动,因此旋转的次数<code>k</code>要对长度<code>len</code>取余,避免转圈圈,而当<code>k%len</code>的时候表示需要从尾巴移动这么多个节点,也即相当于我们的链表从第1个节点(即头节点)到<code>len-(k%len)</code>这个节点的时候是不用动的,因此从头节点为1开始计数,直到遇到第<code>len-(k%len)</code>个节点,则此刻该节点的next是要移到前面去的,这时我们可以借用一个空节点<code>preHead</code>(前于head节点)来承接要被切开的节点,并置新的尾节点的next为<code>nullptr</code>.此刻我们有两个链表,一个是以head为代表的,一个是以preHead为代表的,(这时跟分隔链表那道题就基本一样了).让preHead扫到next节点是<code>nullptr</code>的,接上head节点,然后head节点变为preHead节点的next节点,则完成了链表旋转.</p><p>这道题一开始十几分钟有思路,后来被边界卡了一下,就对着failed的用例在写,导致最后写了1个小时出头,非常糟糕,最后还是把前面乱改的部分删掉,然后重新理清思路再写,就AC了</p><div class="note note-info">            <ol><li>做题要先把边界,特殊情况给考虑了;</li><li>要理清思路写,不要根据用例编码,乱了就重新捋一遍思路.</li></ol>          </div><h3 id="重写官方思路-11"><a class="markdownIt-Anchor" href="#重写官方思路-11"></a> 重写官方思路</h3><h2 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> 287 寻找重复数🔴</h2><h3 id="题目描述-25"><a class="markdownIt-Anchor" href="#题目描述-25"></a> 题目描述</h3><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且<strong>只用常量级 <code>O(1)</code> 的额外空间</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,3,4,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,3,4,2]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3 :</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,3,3,3,3]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li></ul><p><strong>进阶：</strong></p><ul><li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li><li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li></ul><h3 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h3><p>一开始的思路完全错误,虽然AC了,但是没有遵循到题目所说的<strong>不修改数组<code>nums</code></strong>,我给它排了个序,但是确实只是开了常量级的额外空间</p><p>根据题目,我们知道需要遵守:</p><ul><li><strong>不修改数组nums</strong></li><li><strong>只允许开常量级O(1)的额外空间</strong></li></ul><p>如果没有第一条,排序就可以解决;如果没有第二条,用哈希表就可以解决.</p><p>但是这两条都得遵守,因此不知道怎么做了(想了好久,其实看到官方题解的<strong>二进制,二分法,快慢指针</strong>这三个方法名称,也试着往上面靠着来解决问题,但failed)</p><p>以下是看了一个<strong>快慢指针的思路</strong>:</p><p>题目说了数组值是在<code>[1,n]</code>这个区间内,且有n+1个数,且只有一个重复的整数,按照一种很乐观的想法,即区间内的每个数各取一个,并且随机重复一个,如n=5:<code>[1,2,3,4,5,3]</code>这种情况,当然,它的顺序是打乱的,如<code>[3,1,2,4,5,3]</code>,当然也有可能是并非n个值都取满,重复的数字重复次数&gt;2的情况,如n=5:<code>[3,2,2,4,5,2]</code></p><p>如果按<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的情况来说,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的散点图是符合题意的,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \in 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的情况则是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">R_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>上随机取一个值,至此是符合题意的,而将其打乱,则亦符合题意,因此,我们可以知道除了0这个元素,我们需要指定它到达,别的可以通过:<code>x = nums[x] </code>到达(可以想象成一个x从1到n,y从1到n的棋盘,0则是一个随机的起点),因此<code>x</code>的初值可以是0,为什么会说这个呢?</p><p>因为可以把这一个数组想象成是一个带环的链表,起点元素0是<code>ListNode*</code>,而<code>nums[0]</code>是<code>ListNode*</code>,也即是<code>0-&gt;nums[0]</code>这也很符合我们的认知,而<code>nums[0]</code>是在[1,n]这个区间的,即是上面将其想象成一个棋盘的原因,即<code>nums[0]</code>的next是<code>nums[nums[0]]</code></p><p>根据题意,确实可以将其以此方式想象成是一个链表,<code>x=0;nums[x] -&gt; nums[nums[x]] -&gt;...</code>.以<code>[2,1,3,4,5,3]</code>为例,有:</p><p><code>2-&gt;3-&gt;4-&gt;5-&gt;3-&gt;4-&gt;5</code>,可知,<strong>这种方式起的链表,不会包含原始数据中所有的值,但会在遇到重复的值的时候,陷入对应的循环,这个循环就是我们链表中的环,而这个循环的入口,就是重复的数值!</strong></p><p>因此目标转换为了找链表的环的入口,链表有环,就或多或少会牵扯到快慢指针了.以<code>[1,2,3,4,5,3]</code>为例,以上述方式写出其链表形式有:</p><pre class="mermaid">graph LR1-->2;2-->3;3-->4;4-->5;5-->3;</pre><p>快指针fast和慢指针slow会在环内相遇(毕竟速度不同),假设慢指针走了n步,快指针是它的两倍,即走了2n步,则有快指针fast在相遇处走多n步即绕一圈遇到的慢指针slow,从起点1到入口3设为m,则慢指针slow在环内走了n-m步,当它再走m步,则相当于转了一圈,就到了<strong>环的入口</strong>,即得到了重复的值,因此在它们相遇时可以起多一个指针从起点走,直到和慢指针slow碰头,则说明当前的值为重复的值</p><p>重写代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">[1,2,3,4,5,3]</span><br><span class="hljs-comment">1,2,[3,4,5],[3,4,5],...</span><br><span class="hljs-comment">fast:2,4,3,5</span><br><span class="hljs-comment">slow:1,2,3 | 4,5,3·</span><br><span class="hljs-comment">ans:       | 1,2,3·</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>; <span class="hljs-comment">// 三个指针</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            fast = nums[nums[fast]];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(fast == slow)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            slow = nums[slow];<br>            ans = nums[ans];<br>            <span class="hljs-keyword">if</span>(slow == ans)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="重写官方思路-12"><a class="markdownIt-Anchor" href="#重写官方思路-12"></a> 重写官方思路</h3><p>没看官方思路,看了别人题解的做法.</p><h2 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> 20 有效的括号</h2><h3 id="题目描述-26"><a class="markdownIt-Anchor" href="#题目描述-26"></a> 题目描述</h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li></ul><h3 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h3><h3 id="重写官方思路-13"><a class="markdownIt-Anchor" href="#重写官方思路-13"></a> 重写官方思路</h3><h2 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215 数组中的第k个最大元素🔴</h2><h3 id="题目描述-27"><a class="markdownIt-Anchor" href="#题目描述-27"></a> 题目描述</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h3 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h3><p>像这种要找第几个最大元素,第几个最小元素,其实考察的点都是堆排序,这里我实现的是一个降序排序,即通过构建一个小顶堆,然后交换首尾元素,然后下沉根节点以满足小顶堆结构,直至整个序列有序</p><p>但其实这种方法不是很好,别人有一种优化的算法,但是没看明白</p><h3 id="重写官方思路-14"><a class="markdownIt-Anchor" href="#重写官方思路-14"></a> 重写官方思路</h3><h2 id="234-回文链表"><a class="markdownIt-Anchor" href="#234-回文链表"></a> 234 回文链表</h2><h3 id="题目描述-28"><a class="markdownIt-Anchor" href="#题目描述-28"></a> 题目描述</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img" /></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p>**进阶：**你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h3 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h3><h3 id="重写官方思路-15"><a class="markdownIt-Anchor" href="#重写官方思路-15"></a> 重写官方思路</h3><h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206 反转链表</h2><h3 id="题目描述-29"><a class="markdownIt-Anchor" href="#题目描述-29"></a> 题目描述</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img" /></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img" /></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h3 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h3><h3 id="重写官方思路-16"><a class="markdownIt-Anchor" href="#重写官方思路-16"></a> 重写官方思路</h3><h2 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200 岛屿数量</h2><h3 id="题目描述-30"><a class="markdownIt-Anchor" href="#题目描述-30"></a> 题目描述</h3><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li></ul><h3 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h3><h3 id="重写官方思路-17"><a class="markdownIt-Anchor" href="#重写官方思路-17"></a> 重写官方思路</h3><h2 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站"></a> 134 加油站</h2><h3 id="题目描述-31"><a class="markdownIt-Anchor" href="#题目描述-31"></a> 题目描述</h3><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [2,3,4], cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 10^4</code></li></ul><h3 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h3><h3 id="重写官方思路-18"><a class="markdownIt-Anchor" href="#重写官方思路-18"></a> 重写官方思路</h3><h2 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> 155 最小栈</h2><h3 id="题目描述-32"><a class="markdownIt-Anchor" href="#题目描述-32"></a> 题目描述</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li></ul><h3 id="思路-32"><a class="markdownIt-Anchor" href="#思路-32"></a> 思路</h3><p>这道题,感觉自己把自己绕进去了,因为看着题目说要构建最小栈,于是想,栈的push和pop执行也很快,那么题目要求常数时间检索到最小元素,就感觉应该三个都是常数时间的级别</p><p>关于栈的构建其实很简单,只要用个vector一类的容器便可以解决,<code>push()</code>对应<code>push_back()</code>,<code>pop()</code>对应<code>pop_back()</code>,<code>top()</code>对应<code>back()</code></p><div class="note note-info">            <p>后面看一个外国人的这道题的代码时,用的是链表来构建栈,不过是头插构建(这让我想到反转链表),这样top就是头节点,pop也就是头节点的移动,push也就是头插,而且关于常数时间检索最小值的处理也很直接,直接通过min来处理当前头值对应的最小值和新值,由此得到最小值</p>          </div><p>而关于常数时间检索最小值,又觉得是本题的关键,可以在push和pop的时候维持一个有序的链表(其实一开始是lolored提出来的,因为我做题目纠结在一些点上会宕机),因为链表增删方便且快速,而有序则在push和pop的时候来进行维护,其中头节点是最小的值(升序的链表),其实一开始会担心这样写会不会超时,但最终其实还是AC了的,然后lolored说这个链表是双向链表,但其实单向应该就ok,毕竟也需要遍历链表嘛,而且也没利用到尾节点干嘛,但考虑到前面LRUCache那道题我用的是list而非自己写的双向链表,便也写了双向链表</p><h3 id="重写官方思路-19"><a class="markdownIt-Anchor" href="#重写官方思路-19"></a> 重写官方思路</h3><p>官方思路十分简洁,通过两个stack来模拟最小栈,一个是数值的栈,一个是最小值的栈,需要注意这两个的push和pop是同步的,不过最小值的栈存储的是当前对应stack的最小值,只需要每次都拿自己的top和新来的value进行一下比较就好,最小的就push进去.</p><h2 id="lcp-52-二叉搜索树染色"><a class="markdownIt-Anchor" href="#lcp-52-二叉搜索树染色"></a> LCP 52 二叉搜索树染色</h2><h3 id="题目描述-33"><a class="markdownIt-Anchor" href="#题目描述-33"></a> 题目描述</h3><p>欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。</p><p>每位勇士面前设有一个<strong>二叉搜索树</strong>的模型，模型的根节点为 <code>root</code>，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， <code>ops[i] = [type, x, y]</code> 表示第 <code>i</code> 次操作为：</p><ul><li><code>type</code> 等于 0 时，将节点值范围在 <code>[x, y]</code> 的节点均染蓝</li><li><code>type</code> 等于 1 时，将节点值范围在 <code>[x, y]</code> 的节点均染红</li></ul><p>请返回完成所有染色后，该二叉树中红色节点的数量。</p><p><strong>注意：</strong></p><ul><li>题目保证对于每个操作的 <code>x</code>、<code>y</code> 值定出现在二叉搜索树节点中</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]</code></p><p>输出：<code>2</code></p><p>解释： 第 0 次操作，将值为 2、3、4 的节点染红； 第 1 次操作，将值为 1、2、3 的节点染红； 第 2 次操作，将值为 3、4、5 的节点染蓝； 因此，最终值为 1、2 的节点为红色节点，返回数量 2<img src="https://pic.leetcode-cn.com/1649833948-arSlXd-image.png" alt="image.png" /></p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>root = [4,2,7,1,null,5,null,null,null,null,6]</code> <code>ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]</code></p><p>输出：<code>5</code></p><p>解释： 第 0 次操作，将值为 2 的节点染蓝； 第 1 次操作，将值为 1、2、4、5 的节点染红； 第 2 次操作，将值为 4、5 的节点染蓝； 第 3 次操作，将值为 5、6、7 的节点染红； 因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5<img src="https://pic.leetcode-cn.com/1649833763-BljEbP-image.png" alt="image.png" /></p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= 二叉树节点数量 &lt;= 10^5</code></li><li><code>1 &lt;= ops.length &lt;= 10^5</code></li><li><code>ops[i].length == 3</code></li><li><code>ops[i][0]</code> 仅为 <code>0</code> or <code>1</code></li><li><code>0 &lt;= ops[i][1] &lt;= ops[i][2] &lt;= 10^9</code></li><li><code>0 &lt;= 节点值 &lt;= 10^9</code></li></ul><h3 id="思路-33"><a class="markdownIt-Anchor" href="#思路-33"></a> 思路</h3><p>我的思路是中序遍历获取树的节点值(因为你树是bst,但其实后面用到的容器如果是map或set的话,因为这俩容器底层实现是红黑树,所以其实前序遍历也行,毕竟最终迭代器遍历也是按升序的顺序遍历的),然后用一个map把数据装着,key用节点值表示,而val则是0-蓝色,1-红色.然后迭代器遍历ops,根据(*ops_iter)[1]和(*ops_iter)[2]的值,也就是x,y,因为恒存在,所以可以通过<code>find()</code>获得它们的迭代器,然后由iter_x遍历到iter_y,给它们的属性值second设置op值(注意迭代器没有重载大于小于,只有等于不等于运算符,所以iter_y在外面设置一下second),然后这个二重循环完了之后,对map用迭代器遍历,统计值为1的key,这样就获得了最终染色为红色的节点数目.</p><p>思路和写法是对的,但是!会超时;</p><p>lolored给我提供了一个建议:倒序思考看看</p><p>倒序的好处是:每个点的状态都是最终确定的,是蓝的就是蓝的,是红的就是红的,不会被覆盖.但是要知道一个点可能被多个区间重叠,即会多次被访问,可以通过标志位去处理(当时没往这里想,应该是可行的,不知道会不会超时),也可以通过删除点去处理(我当时想的是删除区间),但是如何知道一个区间被处理完了呢,这就要用到<code>lower_bound()</code>这个神奇的函数了,这个函数可以根据你给的值,找到<code>&gt;=</code>该值的最近的迭代器(这个函数针对的是有序的情况,而set,map这些天生就是有序),那这样很利于节点的删除,而且一个点被删了的话,找到的就是<code>end()</code>,如果一个x<code>&gt;=</code>y那也说明区间被删干净了,因为这时候<code>lower_bound()</code>找到的是越过了y值的迭代器,而且这样还可以统计最终为红色的节点数目,省了另开一个循环统计的时间</p><h3 id="重写官方思路-20"><a class="markdownIt-Anchor" href="#重写官方思路-20"></a> 重写官方思路</h3><p>这里是依据别人的实现思路重写的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h2 id="560-和为k的子数组"><a class="markdownIt-Anchor" href="#560-和为k的子数组"></a> 560 和为k的子数组</h2><h3 id="题目描述-34"><a class="markdownIt-Anchor" href="#题目描述-34"></a> 题目描述</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^7 &lt;= k &lt;= 10^7</code></li></ul><h3 id="思路-34"><a class="markdownIt-Anchor" href="#思路-34"></a> 思路</h3><p>本题需要统计子数组和,无需变动原数组,且是频繁统计子数组和,因此想到需要<strong>构造前缀和数组</strong>,不然的话,那就得弄个<code>sum(int start,int end)</code>来计算区间和,则这样会加大时间开销,不如遍历一遍原数组,构造前缀和数组</p><p>然后找合适条件的子数组,则是双重循环,计算一下所有子数组和,满足和为k的则cnt++,最终return cnt</p><p>看了别人的思路,可以采用哈希表对这个统计过程进行优化(没细看,大致思路:可以通过一个无序map来放[前缀和:前缀和出现的次数],然后通过计算前缀和的时候,看看[k-当前前缀和]这个前缀和在无序哈希表中是否存在,存在的话,则cnt加上该键值对的值(因为1个当前的前缀和,可以和该键值对的值分别对应搭配,构建出k来))</p><h3 id="重写官方思路-21"><a class="markdownIt-Anchor" href="#重写官方思路-21"></a> 重写官方思路</h3><h2 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> 203 移除链表元素</h2><h3 id="题目描述-35"><a class="markdownIt-Anchor" href="#题目描述-35"></a> 题目描述</h3><h3 id="思路-35"><a class="markdownIt-Anchor" href="#思路-35"></a> 思路</h3><h3 id="重写官方思路-22"><a class="markdownIt-Anchor" href="#重写官方思路-22"></a> 重写官方思路</h3><h2 id="208-实现trie前缀树"><a class="markdownIt-Anchor" href="#208-实现trie前缀树"></a> 208 实现Trie(前缀树)</h2><h3 id="题目描述-36"><a class="markdownIt-Anchor" href="#题目描述-36"></a> 题目描述</h3><h3 id="思路-36"><a class="markdownIt-Anchor" href="#思路-36"></a> 思路</h3><p>最初思路很质朴,这种题目肯定在操作上卡时间,尽量选个插入搜索都快的,关于<code>startswith</code>这种前缀匹配的函数,要手撸.那插入和搜索快的就是哈希表,因此选了<code>unordered_set&lt;int&gt;</code>来存,关于<code>startswith</code>函数的实现则是比较朴素的,遍历哈希表,然后用prefix的长度去截取字串的长度(就是substr嘛),然后比较有无满足的字串,有则置标志位跳出循环,返回true,没有就返回false</p><p>AC了,但是时间也只是刚好过线</p><h3 id="重写官方思路-23"><a class="markdownIt-Anchor" href="#重写官方思路-23"></a> 重写官方思路</h3><p>参考了别人的思考,了解了Trie这种神奇的结构:<strong>非典型的多叉树</strong></p><p>它的节点定义是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>跟别的多叉树不同,别的多叉树里面会存值和指向其所负责的孩子节点;而这里存着的是一个<strong>布尔值</strong>,<strong>表示</strong>到没到终点(即是否是<strong>一个单词的结束</strong>),而<strong>next指针指向的是下一个字符</strong>,如&quot;sea&quot;,&quot;shell&quot;这样的单词,第一个Trie的next的<code>'s'-'a'</code>处索引到的是指向下一个Trie,而此时该索引的指针非nullptr则表示,已有单词的字符是以<code>'s'</code>开头</p><p>构建的前缀树可以用于自动补全</p><p>清楚了它的节点定义后,可以根据题目要求写出三个函数实现了(<code>insert | search | startswith</code>)</p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">前缀树:非典型的多节点树</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> end;<br>    Trie* next[<span class="hljs-number">26</span>];<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;        <br>        end = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:word)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>] != <span class="hljs-literal">nullptr</span>)&#123;<br>                node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Trie *_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>                node-&gt;next[c<span class="hljs-number">-97</span>] = _node;<br>                node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>            &#125;<br>        &#125;<br>        node-&gt;end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:word)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;end;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-盛最多水的容器"><a class="markdownIt-Anchor" href="#11-盛最多水的容器"></a> 11 盛最多水的容器</h2><h3 id="题目描述-37"><a class="markdownIt-Anchor" href="#题目描述-37"></a> 题目描述</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" /></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h3 id="思路-37"><a class="markdownIt-Anchor" href="#思路-37"></a> 思路</h3><p>题目的意思是:找height中的两个值:以索引差值为宽度,以高度小者为高度,二者相乘得到的面积即为所求area,欲求最大的area:<code>int area = (j-i)*min(height[j],height[i])</code>,于是有:</p><ol><li>最朴素的想法,先定右边界j,然后移动左边界i,左边界&lt;右边界(不然就是0了),二次循环,暴力解法.结果超时,意料之中;</li><li>想着在这个方法能不能dp,dp的状态/子问题被描述为:以i为终点的最大雨量是:<code>dp[i]</code>写了好几个状态的表达,发现前后没啥关联.就是<code>dp[0]</code>和<code>dp[1]</code>没啥共同的部分,每个部分算的都是都很独立,无法减少计算,故舍弃;</li><li>如果高度我无法决定,我想要在现有高度下面积最大,则需要宽度最大,基于此,分了两个二重循环写了两个求面积公式,之所以分两个,是因为中点左侧的数据,宽度最大是与最右端点计算;中点及其右侧端点的最大宽度是与最左端点计算,这种实际是方法1的变体:从每个端点的最大面积出发,因为最终的最大面积是立足于某个端点的最大面积,所以求了所有端点的最大面积,最终的最大面积也就在里面了.这种方法较1做了些剪枝</li></ol><h3 id="重写官方思路-24"><a class="markdownIt-Anchor" href="#重写官方思路-24"></a> 重写官方思路</h3><p><strong>双指针</strong>.我没有想过这道题可以这样做…</p><p>主要思想是:以0作为左端点,以n-1作为右端点,所成面积是一个值,这时候选对应height值小的进行索引变动,直至left不再满足小于right,就跳出循环</p><h2 id="3-无重复字符的最长字串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长字串"></a> 3 无重复字符的最长字串</h2><h3 id="题目描述-38"><a class="markdownIt-Anchor" href="#题目描述-38"></a> 题目描述</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="思路-38"><a class="markdownIt-Anchor" href="#思路-38"></a> 思路</h3><p>一开始的思路完全错误,因为我的移动会越过一些不重复的字符,且因为用的方法比较诡异,无法修改,遂放弃;</p><p>后来仔细审了下题目,发现我的原方法错的离谱,但依旧过了300+个用例😂</p><p>不难发现针对如下用例:</p><p><code>abcabcbb</code>,当遇到第二个a的时候我们显然需要移动<u>1</u>个值,使之以b开头;</p><p><code>abcbcaee</code>,当遇到第二个b的时候显然需要移动<u>2</u>个值,使之以c开头;</p><p>也就是说<strong>当遇到前面已出现的值的时候,需要跳过这个已出现过的值,也即是下一个字串要从这个字符之后开始</strong></p><p>也即是需要记录开始的索引<code>start_index</code>,然后找到重复的字符,计算下一个<code>start_index</code>,通过<code>重复字符的索引-start_index+1</code>跳到重复字符的下一位(就是新的<code>start_index</code>),然后重新组织子串,如此统计无重复的最长字串,直至<code>start_index</code>大于len或者说<code>start_index</code>的offset走到len了(即一种是起始索引超过了len,一种是字串走完了)</p><p>这样的结果是勉强过线的结果,还在这基础上改了一版,但超时了😭</p><h3 id="重写官方思路-25"><a class="markdownIt-Anchor" href="#重写官方思路-25"></a> 重写官方思路</h3><p>见到了一种一步一步移动的方法,大致思路如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(len &lt;=<span class="hljs-number">1</span>) <br>   <span class="hljs-keyword">return</span> len;<br><span class="hljs-comment">// start表示滑动窗口的左边界</span><br><span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>,mx=<span class="hljs-number">0</span>;<br>unordered_set&lt;<span class="hljs-keyword">char</span>&gt; st;<br><span class="hljs-comment">// abcbcaad</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>    <span class="hljs-comment">// 存在重复元素</span><br>    <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">find</span>(s[i])!=st.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-comment">// 擦除左端元素并右移,直至把重复元素擦除</span><br>        st.<span class="hljs-built_in">erase</span>(s[start]);<br>        start++;<br>    &#125;<br>    st.<span class="hljs-built_in">insert</span>(s[i]);<br>    mx = <span class="hljs-built_in">max</span>(mx,i-start+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure><p>上面的方法中规定了滑动窗口的左端为start,i则为滑动窗口的右端(一直移动),若遇到已存在的元素(通过find找),那就不断删除左端元素,并将左端向右移动一位,直至去掉这个重复元素,并将新元素加入哈希表中,然后统计此刻的字串大小与mx比较,取大者</p><p>上面的方法的弊端在于用了find,它是一个比较耗时的操作,且右端的i可以换个更加通俗的名字:end</p><p>可以使用如map之类的数据结构来存放数据,已有的数据则为1,没有(默认为0)则为0,若数据重复,则计数一次,在进一步的循环中,不断移出值,更改start,直到计数重新置为0,则有如下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> len;<br>unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,mx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(end&lt;len)&#123;<br>    <span class="hljs-keyword">if</span>(mp[s[end]] &gt; <span class="hljs-number">0</span>)<br>        count++;<br>    mp[s[end]]++;<br>    <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mp[s[start]]&gt;<span class="hljs-number">1</span>)<br>            count--;<br>        mp[s[start]]--;<br>        start++;<br>    &#125;<br>    mx = <span class="hljs-built_in">max</span>(mx,end-start+<span class="hljs-number">1</span>);<br>    end++;<br>&#125;<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure><h2 id="876-链表的中间节点"><a class="markdownIt-Anchor" href="#876-链表的中间节点"></a> 876 链表的中间节点</h2><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><h3 id="思路-39"><a class="markdownIt-Anchor" href="#思路-39"></a> 思路</h3><p>快慢指针,这样找到的中间节点是中间节点或中间偏下的节点</p><h2 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> 21 合并两个有序链表</h2><h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3><h3 id="思路-40"><a class="markdownIt-Anchor" href="#思路-40"></a> 思路</h3><p>归并排序的合并思想</p><h2 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> 148 排序链表🔴</h2><h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3><h3 id="思路-41"><a class="markdownIt-Anchor" href="#思路-41"></a> 思路</h3><p>归并排序进行链表排序,需要①876找到中间节点;②21合并两个有序链表,同时掌握归并排序的知识</p><h2 id="lcr140-训练计划ii"><a class="markdownIt-Anchor" href="#lcr140-训练计划ii"></a> LCR140 训练计划Ⅱ</h2><h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3><p>找链表中的倒数第N个节点</p><h3 id="思路-42"><a class="markdownIt-Anchor" href="#思路-42"></a> 思路</h3><p>快慢指针,快指针先走N步,再快慢指针同步距行进,直至快指针nullptr了,就说明慢指针走到了</p><h2 id="19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第n个节点"></a> 19 删除链表的倒数第N个节点</h2><h3 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h3><h3 id="思路-43"><a class="markdownIt-Anchor" href="#思路-43"></a> 思路</h3><p>思路同上,也是快慢指针,快的先走N步,然后快慢指针再同步距行进,不过需要注意,可能删的是头节点,则快指针此时直接走到nullptr了,因此需要分支判断一下</p><h2 id="92-反转链表ii"><a class="markdownIt-Anchor" href="#92-反转链表ii"></a> 92 反转链表Ⅱ</h2><h3 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h3><h3 id="思路-44"><a class="markdownIt-Anchor" href="#思路-44"></a> 思路</h3><p>需分情况讨论,首先走到区间左右端点,然后记录左右端点的左侧和右侧端点,方便后面拼接,同时把此时的slow节点记录下,后面要跟尾巴拼接,局部区间反转完后,拼接链表即可.</p><p>但需要注意,可能存在整个链表反转,以及区间左端点是head的情况,需要分类讨论一下</p><p>这道题相对做得比较混乱</p><h2 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合"></a> 17 电话号码的字母组合</h2><h3 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h3><h3 id="思路-45"><a class="markdownIt-Anchor" href="#思路-45"></a> 思路</h3><p>每个数字对应一个字串,每次从各自的一个字串取一个字符,按数字的顺序排列.找出所有排列的情况.通过DFS实现,是顺序已定的排列问题(个人思路里说的排列和组合,更多的是往全排列以及组合模板上靠的排列组合思想)</p><h2 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1 两数之和</h2><h3 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h3><h3 id="思路-46"><a class="markdownIt-Anchor" href="#思路-46"></a> 思路</h3><p>哈希表(虽然一开始我是排序+双指针+找索引的方式,而且找索引还不能用unordered_map,比如3+3=6,key唯一的情况会找不到两个索引,用的是朴素的找索引方式找的,很慢)的思路则非常好,一重循环直接完成</p><h2 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> 2 两数相加</h2><h3 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h3><h3 id="思路-47"><a class="markdownIt-Anchor" href="#思路-47"></a> 思路</h3><p>普通的链表加法,但要细心,因为进位可能是9999+1的情况,且最后的carry_bit也要检查是否要new多一个节点</p><h2 id="45-跳跃游戏ii"><a class="markdownIt-Anchor" href="#45-跳跃游戏ii"></a> 45 跳跃游戏Ⅱ</h2><h3 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h3><h3 id="思路-48"><a class="markdownIt-Anchor" href="#思路-48"></a> 思路</h3><ul><li>dp</li><li>滚动的去找</li><li>在每次的跳跃中,已跳跃的步数都是一样的,在遇到此次跳跃的边界end前,要更新下一次跳跃的最远边界,然后在更新边界的时候,也更新已跳跃的步数即可(这个是看别人的方法学来的)</li></ul><h2 id="781-森林中的兔子"><a class="markdownIt-Anchor" href="#781-森林中的兔子"></a> 781 森林中的兔子</h2><h3 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h3><h3 id="思路-49"><a class="markdownIt-Anchor" href="#思路-49"></a> 思路</h3><p>逻辑题</p><h2 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> 15 三数之和</h2><h3 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h3><h3 id="思路-50"><a class="markdownIt-Anchor" href="#思路-50"></a> 思路</h3><p>排序+左右指针,由左及右遍历,根据索引定左右指针,找match的;当下一次索引的值与左边的值是一样的则直接跳过,不必要重复计算,然后可以用set对收集到的三数vector进行去重,最后灌到ans即可</p><h2 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> 102 二叉树的层序遍历</h2><h3 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h3><h3 id="思路-51"><a class="markdownIt-Anchor" href="#思路-51"></a> 思路</h3><p>BFS模板</p><h2 id="128-最长连续序列"><a class="markdownIt-Anchor" href="#128-最长连续序列"></a> 128 最长连续序列</h2><h3 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h3><h3 id="思路-52"><a class="markdownIt-Anchor" href="#思路-52"></a> 思路</h3><p>哈希表,逻辑理通,即可解决(如何用哈希表去找到最长连续序列,最长则意味着start是它)</p><h2 id="54-螺旋矩阵"><a class="markdownIt-Anchor" href="#54-螺旋矩阵"></a> 54 螺旋矩阵</h2><h3 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h3><h3 id="思路-53"><a class="markdownIt-Anchor" href="#思路-53"></a> 思路</h3><p>四个边界u,d,l,r,边界如u&gt;d则跳出,但可==</p><h2 id="283-移动零"><a class="markdownIt-Anchor" href="#283-移动零"></a> 283 移动零</h2><h3 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h3><h3 id="思路-54"><a class="markdownIt-Anchor" href="#思路-54"></a> 思路</h3><p>双指针,区间[l,r)圈养了一堆0,有点像冒泡一样,一直交换非0数与0</p><h2 id="438-找到字符串的所有字母异位词"><a class="markdownIt-Anchor" href="#438-找到字符串的所有字母异位词"></a> 438 找到字符串的所有字母异位词</h2><h3 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h3><h3 id="思路-55"><a class="markdownIt-Anchor" href="#思路-55"></a> 思路</h3><p>滑动窗口,一般都是左指针out,右指针in,通过一定条件判断是否match,则push_back,然后左指针再out掉一个字符这样(具体参考板子部分&quot;“滑动窗口”&quot;的内容)</p><h2 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯"></a> 70 爬楼梯</h2><h3 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h3><h3 id="思路-56"><a class="markdownIt-Anchor" href="#思路-56"></a> 思路</h3><p>经典dp题,走到第n阶楼梯的方式是从第n-1阶往上走,或者n-2阶往上走</p><h2 id="76-最小覆盖字串"><a class="markdownIt-Anchor" href="#76-最小覆盖字串"></a> 76 最小覆盖字串</h2><h3 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h3><h3 id="思路-57"><a class="markdownIt-Anchor" href="#思路-57"></a> 思路</h3><p>从字串s中找到覆盖字串t的最小字串,滑动窗口实现</p><h2 id="567-字符串的排列"><a class="markdownIt-Anchor" href="#567-字符串的排列"></a> 567 字符串的排列</h2><h3 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h3><h3 id="思路-58"><a class="markdownIt-Anchor" href="#思路-58"></a> 思路</h3><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> 239 滑动窗口最大值</h2><h3 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h3><h3 id="思路-59"><a class="markdownIt-Anchor" href="#思路-59"></a> 思路</h3><h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3><h2 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像"></a> 48 旋转图像</h2><h3 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h3><h3 id="思路-60"><a class="markdownIt-Anchor" href="#思路-60"></a> 思路</h3><h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3><h2 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> 78 子集</h2><h3 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h3><h3 id="思路-61"><a class="markdownIt-Anchor" href="#思路-61"></a> 思路</h3><h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3><h2 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> 94 二叉树的中序遍历</h2><h3 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h3><h3 id="思路-62"><a class="markdownIt-Anchor" href="#思路-62"></a> 思路</h3><h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3><h2 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> 39 组合总和</h2><h3 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h3><h3 id="思路-63"><a class="markdownIt-Anchor" href="#思路-63"></a> 思路</h3><h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3><h2 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏"></a> 55 跳跃游戏</h2><h3 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h3><h3 id="思路-64"><a class="markdownIt-Anchor" href="#思路-64"></a> 思路</h3><h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3><h2 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> 22 括号生成</h2><h3 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h3><h3 id="思路-65"><a class="markdownIt-Anchor" href="#思路-65"></a> 思路</h3><h3 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h3><h2 id="994-腐烂的橘子"><a class="markdownIt-Anchor" href="#994-腐烂的橘子"></a> 994 腐烂的橘子</h2><h3 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h3><h3 id="思路-66"><a class="markdownIt-Anchor" href="#思路-66"></a> 思路</h3><h3 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h3><h2 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> 207 课程表</h2><h3 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h3><h3 id="思路-67"><a class="markdownIt-Anchor" href="#思路-67"></a> 思路</h3><h3 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h3>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile简易使用</title>
    <link href="/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2><p>因为在linux上编译多个cpp文件时,需要分别<code>g++ -c</code>生成<code>.o</code>文件,然后将所需的<code>.o</code>文件一起链接以生成可执行文件,比较繁琐且冗余.因此需要使用到makefile工具来帮助我们进行多文件编译(甚至文件可以指定不同目录,更有利于工程项目管理),故有此篇文章</p><h2 id="linux下编译多个cpp的过程"><a class="markdownIt-Anchor" href="#linux下编译多个cpp的过程"></a> linux下编译多个cpp的过程</h2><p>在开始说makefile的一些基本语法前,先说一下在linux下编译多个cpp的过程</p><p>我们通常编译一个<code>.cpp</code>文件都是经过<strong>预处理</strong>---生成<code>.i</code>文件---&gt;<strong>编译</strong>---生成<code>.s</code>文件---&gt;<strong>汇编</strong>---生成<code>.o</code>文件---&gt;<strong>链接</strong>---&gt;生成可执行文件<code>.exe</code>,然后在执行的过程中,会被<strong>加载器</strong>将程序放置到内存上,并通过<strong>动态链接器</strong>链接<code>.dll</code>或<code>.so</code>动态库,以实现程序运行</p><div class="note note-info">            <p><strong>静态链接器</strong>(如<code>ld</code>)负责链接的是<code>.a</code>或<code>.lib</code>这些静态库,这些静态库是通过<code>ar</code>这个工具将多个<code>.o</code>文件构成的.静态链接是构建可执行文件时的最后一步.主要功能是<strong>符号解析</strong>(通过符号表找到.o文件的只声明无定义的函数的定义位置)和<strong>重定位</strong>(定位到虚拟地址(有OS的机子)/物理地址(裸机))</p><p><strong>动态链接器</strong>(如<code>ld-linux.so.2</code>)负责链接的是<code>.so</code>或<code>.dll</code>这些动态库或者叫共享库,要使用到这个工具的时候,我们的程序已经被加载器加载到内存上了,当我们遇到如<code>printf</code>这些动态库定义的函数时,会去检查内存中有没有加载对应的动态库(<a href="http://xn--libc-zi0i964s23c.so">这里是libc.so</a>),没有的话就加载到内存上,有得话就不用加载,取得该动态库在内存中的起始地址,然后我们编译过<code>printf</code>这个函数时,它的调用方式形如<code>call 0xaaaa </code>这样,这里的地址是相对于动态库的地址,因此由获得的动态库起始地址加这个偏移地址就可以得到<code>printf</code>在内存中的真正地址了.这一类库的生成是我们在利用<code>g++</code>编译时通过<code>-shared</code>选项实现的.</p><p>静态链接后的<code>exe</code>文件会包含别的<code>.o</code>文件(静态库)的代码,比较占地方,而动态链接的则没有算到<code>exe</code>文件里面去,毕竟它(动态库)只是在<code>exe</code>运行时动态加载到内存中去的,但是这个动态库要是没有,那就跑不起来,而静态链接的则没事,因为代码已经拷贝到<code>exe</code>里了</p>          </div><p>每个<code>.cpp</code>文件都可以单独用如下方式<code>g++ -c xx.c -o xx.o</code>生成<code>.o</code>形式的目标文件,该文件里的内容是机器码,但是这个文件不能被执行,因为存在两个问题:</p><ol><li>调用了别的<code>.cpp</code>文件定义的函数,但是我们只包含了该函数声明的.h文件:即在其中,<strong>只有符号的引用,而没有实际的定义,这里所说的符号即是函数,需要进行<u>符号解析</u></strong>;</li><li><strong>这里的地址是不对的,并不是实际运行的地址(虚拟地址/物理地址),而是一个标志,是逻辑地址,需要进行<u>重定位</strong></u></li></ol><p>我们这里着重讲第一点,比如我在<code>a.cpp</code>文件中调用了<code>hello()</code>,而只包含了头文件<code>hello.h</code>,而实际实现是在<code>hello.cpp</code>中,我们各自通过<code>g++ -c ...</code>编译得到<code>a.o hello.o</code>,<strong>其中<code>a.o</code>中所有关于<code>hello()</code>的函数调用,会跳到同一个地址,在该地址会<code>call hello</code></strong>,这个<code>call hello</code>的真正地址,需要在<code>hello.o</code>中获得</p><p>这些<code>.o</code>文件有自己的<strong>符号导入表</strong>和<strong>符号导出表</strong>,这些表对应的是<strong>符号---地址</strong>,因此这需要<strong>静态链接器</strong>去在<code>hello.o</code>的符号导出表找到<code>hello</code>这一项对应的地址,并作偏移(两个<code>.o</code>要合并,地址难免有冲突,因此需要偏移),然后写到<code>a.o</code>的符号导入表中<code>hello</code>那一项对应的地址中去,由此<code>call hello</code>这里的hello就可以找到对应的实际的地址了.</p><p>之后的重定位则是将逻辑地址换成实际运行的地址.</p><p><strong>实际上,链接这一过程,解决的就是上面所说的两个问题</strong>,因此,对于一个庞大的工程项目来说,我们可以保留需要的<code>.o</code>文件,然后若有部分cpp有修改,则将之重新编译为<code>.o</code>,没改的则不重新编译(因为对于一个大项目来说,编译的时间可能也很长),然后将所有需要的<code>.o</code>一起链接成一个可执行文件即可,这个过程若是手动管理,繁琐且复杂,还容易出错,因此需要一个工具来进行管理,由此便需要<strong>makefile</strong></p><h2 id="makefile基本语法"><a class="markdownIt-Anchor" href="#makefile基本语法"></a> makefile基本语法</h2><h3 id="makefile三要素"><a class="markdownIt-Anchor" href="#makefile三要素"></a> makefile三要素</h3><p>在makefile中有三要素:<strong>目标</strong>(target),<strong>依赖</strong>(prerequisite)和<strong>执行语句</strong>(recipe)</p><p><img src="https://s2.loli.net/2024/05/02/DJUrKgnVy1qAlY8.png" alt="makefile 3 element" /></p><p><strong>目标<code>main</code>的生成依靠于依赖<code>main.c</code>,当目标不存在或依赖被修改,则执行下方执行语句</strong></p><p>这三要素的描述原文如下(本文关于makefile的部分主要参考参考文件中的一篇blog,不过行文按自己的理解展开):</p><blockquote><p>A <em>target</em> is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’ (see <a href="https://link.zhihu.com/?target=https%3A//www.gnu.org/software/make/manual/make.html%23Phony-Targets">Phony Targets</a>).<br />A <em>prerequisite</em> is a file that is used as input to create the target. A target often depends on several files.<br />A <em>recipe</em> is an action that <code>make</code> carries out. A recipe may have more than one command, either on the same line or each on its own line. <strong>Please note:</strong> you need to put a tab character at the beginning of every recipe line!</p></blockquote><h3 id="关于变量"><a class="markdownIt-Anchor" href="#关于变量"></a> 关于变量</h3><p>我们可以通过一些方式定义变量,变量可以使得我们的操作更加简洁,通过以下方式定义和<code>$(变量)</code>方式引用</p><h4 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h4><ul><li><p><strong>简单赋值</strong><code>:= </code> 与python中的<code>a=4</code>一样</p><p><code>SOURCE_DIR := .</code></p></li><li><p><strong>追加赋值</strong><code>+=</code> 与python中的<code>s = 'a'</code>,<code>s += 'b' #最终s为'ab'</code>,但是makefile中的追加赋值会自动用空格隔开两个值,显示为<code>a b</code></p><p><code>SOURCE_DIR += ./objects #结合上面的. 这里的SOURCE_DIR是. ./objects</code></p></li><li><p><strong>条件复制</strong><code>?=</code> 只在变量未定义时创建变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VAR ?= one<br><span class="hljs-comment"># VAR变量为one</span><br>VAR := two<br>VAR ?= one<br><span class="hljs-comment"># VAR变量为two</span><br></code></pre></td></tr></table></figure></li><li><p><strong>递归赋值</strong><code>=</code>  <mark>使用变量赋值时,会优先展开引用的变量</mark>(没用过,不是很清楚)</p></li></ul><h4 id="变量引用"><a class="markdownIt-Anchor" href="#变量引用"></a> 变量引用</h4><p>通过<code>$(TARGET)</code>一类的方式引用变量</p><h3 id="一些函数"><a class="markdownIt-Anchor" href="#一些函数"></a> 一些函数</h3><p>函数使用的时候和变量的引用差不多,都是通过<code>$()</code>的方式引用,不过函数引用时要在里面加上函数名和对应参数</p><h4 id="wildcard函数"><a class="markdownIt-Anchor" href="#wildcard函数"></a> wildcard函数</h4><p>通配符匹配函数,使用形如:<code>$(wildcard pattern)</code></p><p>比如可以通过:<code>$(wildcard *.c)</code>匹配当前目录下的所有<code>.c</code>结尾的文件</p><h4 id="foreach函数"><a class="markdownIt-Anchor" href="#foreach函数"></a> foreach函数</h4><p>跟c++里的foreach差不多,使用形如:<strong><code>$(foreach var,list,text)</code><strong>其中</strong>list是列表,是某一个变量的引用,var会取得列表的每一个元素,然后交由text进行展开</strong></p><p>例子如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br>SUBDIR += ./object<br><br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(f)</span>)</span><br></code></pre></td></tr></table></figure><p>上面的例子使得INCS的值为:<code>-I. -I./object</code>,这个**<code>-I</code>选项用于gcc编译过程中指定头文件所在路径**</p><h4 id="patsubst函数"><a class="markdownIt-Anchor" href="#patsubst函数"></a> patsubst函数</h4><p>起到替换作用的一个函数，使用形如:<strong><code>$(patsubst pattern,replace,list)</code></strong></p><p>会<strong>从list中取匹配pattern的元素，然后替换为replace</strong></p><p>在举例说明前先说下**<code>%</code><strong>和</strong>自动变量**</p><p>**<code>%</code>**的示例如下(例子好说明):<code>%.o : %.c</code>作为目标的<code>%</code>(就是第一个<code>%</code>)会匹配所有结尾为<code>.o</code>的目标,然后这里比如是有<code>a.o</code>和<code>b.o</code>则会匹配到这俩,然后作为依赖的<code>%</code>(第二个<code>%</code>)会把前面的<code>a</code>和<code>b</code>和<code>.c</code>构成<code>a.c</code>和<code>b.c</code></p><p><strong>自动变量</strong>有(引用无需()):</p><ul><li><strong><code>&lt;</code>表示取依赖列表的第一个依赖,通过<code>$&lt;</code>的方式引用;</strong></li><li><strong><code>@</code>表示取目标(target),通过<code>$@</code>的方式引用;</strong></li><li><strong><code>^</code>表示取依赖列表的所有依赖,通过<code>$^</code>的方式引用</strong></li></ul><p>通过自动变量和<code>%</code>可以简化生成目标文件的语句为:</p><figure class="highlight plaintext"><figcaption><span>: %.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs %.o">%.o : %.c<br>gcc -c $&lt; -o $@<br></code></pre></td></tr></table></figure><p>说回<code>patsubst</code>函数,示例如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br>SUBDIR += ./object<br><br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(f)</span>)</span> <span class="hljs-comment"># 头文件的搜索目录,有的喜欢叫cflags</span><br>SRCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,<span class="hljs-variable">$(SUBDIR)</span>,$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(f)</span>/*.cpp)</span>) <span class="hljs-comment"># 匹配所有cpp</span><br>OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp,%.o,<span class="hljs-variable">$(SRCS)</span>)</span> <span class="hljs-comment"># 把上面的.cpp后缀统一换成.o后缀</span><br><br>test : <span class="hljs-variable">$(OBJS)</span>:<br>g++ <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br>%.o : %.cpp<br>g++ -c <span class="hljs-variable">$(INCS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span> <br></code></pre></td></tr></table></figure><p>这其中把所有的CPP文件的后缀通过SRCS换成了<code>.o</code>(通过<code>%</code>),并放置在OBJS这个变量中</p><h4 id="dir函数"><a class="markdownIt-Anchor" href="#dir函数"></a> dir函数</h4><p>获取目标文件路径的一个函数,可以配合<code>mkdir -p</code>这样的shell语句使用(是的,<strong>makefile里面可以写shell语句</strong>)</p><p>这样我们可以通过makefile来更好的管理工程文件,比如头文件放哪,目标文件放哪这样子,而这其中牵扯到的目录创建,也可以一并交由makefile来做</p><p>dir函数形如:<code>$(dir basedir/file)</code>,它可以从后面的这一坨文本中获取路径,即<code>basedir</code>而去掉<code>file</code>,因此可以这么用:</p><p><code>mkdir -p $(dir $@)</code></p><p>这里我们取的是目标文件的路径</p><h3 id="伪目标phony"><a class="markdownIt-Anchor" href="#伪目标phony"></a> 伪目标<code>.PHONY</code></h3><p>我们之前在配一些项目的时候,不免会用到如<code>make clean</code>一类的指令来清除项目文件夹下多余的内容,然后重新<code>make</code>来构建内容</p><p><strong>在makefile中,我们可以利用target去执行一些动作</strong>,如:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">clean :<br>rm -r <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><p>则可以通过**<code>make clean</code>**来执行对应的执行语句(默认执行第一条target,因此我们前面的都是直接<code>make</code>就行,没有指明target)</p><p>但我们知道!一个目标文件不存在或者依赖文件有修改才会去执行对应的执行语句,若当前目录有个clean文件,那么这个<code>make clean</code>就发挥不了作用,因为它也没依赖,而目标文件又存在</p><p>此问题可以通过<strong>伪目标</strong>来解决,<strong>将clean声明为伪目标,表明它不是文件的命名</strong></p><p><strong>伪目标的声明是通过将fake target声明为<code>.PHONY</code>这个特殊的内置目标的依赖来实现的</strong>,如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.PHONY : clean<br>clean : <br>rm -rf <span class="hljs-variable">$(OBJS)</span> <span class="hljs-variable">$(TARGET)</span><br></code></pre></td></tr></table></figure><h3 id="通过简化输出"><a class="markdownIt-Anchor" href="#通过简化输出"></a> 通过<code>@</code>简化输出</h3><p>不难发现,我们前面在make的过程中,所有的执行语句都打印在了终端上,看起来乱乱的,如果不希望它被打印,可以在执行语句的前面加一个<code>@</code>来不让它打印,示例如下:</p><p><code>@rm -rf $(OBJS) $(TARGET)</code></p><p>这样执行<code>make clean</code>的时候,就不会有<code>rm -rf ...</code>这么一句话被打印了</p><h3 id="自动生成依赖"><a class="markdownIt-Anchor" href="#自动生成依赖"></a> 自动生成依赖</h3><p>我们上面通过<code>wildcard</code>函数匹配到了对应目录(这个<u>对应目录</u>是采用了<code>foreach</code>函数实现的)下的源文件,然后通过<code>patsubst</code>函数替换这些源文件为对应的<code>.o</code>文件,然后通过一些规则去生成最终想要的可执行文件,如<code>test</code>,其中它的一些<code>.o</code>文件如果找不到,则会去匹配到对应的规则利用<code>.cpp</code>文件编译生成<code>.o</code>文件,同时这其中任意一环的依赖被修改或是目标文件不存在,则会去update,去把它生成出来.</p><p>但这时你如果改动了头文件咋办呢?它不在我们的依赖中,改了咋知道要重新生成呢?</p><p>显然我们可以给头文件依次加入我们的依赖中去,但其中若是用了如<code>algorithm</code>(我假设它是静态库啊,这个看具体编译和链接的情况,因为好像有<code>libstdc++.a</code>也有<code>libstdc++.so</code>这样的库),那我岂不是还得去放这个库的比如<code>/usr/lib</code>或什么<code>/usr/local/lib</code>去加入<code>-I</code>选项来扫一下,这样不大方便;若是手动添加,更加痛苦</p><p><strong>gcc提供了一种<u>自动生成依赖</u>的选项<code>-MMD</code>,我们一般还搭配<code>-MP</code>选项来使用</strong>:</p><p><strong><code>MMD</code>作用:①生成依赖关系;②保存依赖关系到<code>.d</code>文件</strong>,其中这个文件是和我们的target即是<code>%.o</code>处在同一目录下</p><p><strong>这里生成的依赖关系是包含了目标文件它的源文件和头文件,比如:<code>a.o : a.cpp head/a.h</code></strong></p><p><strong><code>MP</code>作用是避免头文件删除了(不用了,把它删了),然后因为我们的makefile脚本里又有这么个头文件依赖在,它如果找不到匹配的规则,则会报错,因此,它的作用是生成头文件的没有任何依赖的伪目标</strong></p><div class="note note-info">            <p>为什么需要给头文件也生成一个伪目标呢?这说来话长:</p><p>我的理解是我们make的时候:如针对<code>$(TARGET) : $(OBJS)</code>,我们如果缺少某一些<code>.o</code>文件,则会<strong>先找到匹配的规则</strong>(rule),如<code>%.o : %.c</code>去生成对应的<code>.o</code>文件,<strong>如果遍历所有规则都找不到的话就会报错</strong>(<strong>正是这样,才可以改依赖,比如改头文件,才会影响到我们目标的生成,且是最小程度的影响,只会影响被改动的依赖的目标,然后该目标若是作为某一条规则的依赖,则依次影响,是一个层层递进的过程</strong>);</p><p>那你的头文件如果不用了,从目录下删掉了,那么找不到头文件,会去遍历可以match它的rule,如果找不到,就报错,但显然,我就是想把头文件给它删了,因为没用,实际程序是能运行的,那在编译时增加了<code>-MP</code>选项,则生成头文件的伪目标,这个伪目标很单纯,没有依赖,此时,我的头文件虽然找不到了,但是可以找到与它match的rule,告知我们怎么处理,则可以<strong>规避掉报错的问题</strong>.</p>          </div><p>那我们通过在编译的时候增加<code>-MMD</code>,<code>-MP</code>选项来实现自动生成依赖并存于<code>.d</code>文件中,<strong>怎么将文件中的内容引入makefile脚本中呢?</strong></p><p><strong>通过<code>include</code>即可引入</strong>,但是因为第一次编译的时候<code>.d</code>文件还不存在,这时候include会报错,<strong>通过<code>-include</code>来避免报错</strong>,使得makefile脚本正常运行,使用示例如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">DEPS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,<span class="hljs-variable">$(OBJS)</span>)</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEPS)</span><br></code></pre></td></tr></table></figure><h3 id="通用模板"><a class="markdownIt-Anchor" href="#通用模板"></a> 通用模板</h3><p>通用模板中的内容上面都介绍过,是我目前用的一个通用模板,要改的话在上面改就行了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SUBDIR := .<br><br>OUTPUT := ./obj<br>TARGET := test<br>INCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SUBDIR)</span>,-I<span class="hljs-variable">$(dir)</span>)</span><br>INCS += `pkg-config --cflags opencv4` <span class="hljs-comment"># 通过pkg-config指令,将opencv4的头文件路径列出</span><br><br>SRCS := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> <span class="hljs-built_in">dir</span>,<span class="hljs-variable">$(SUBDIR)</span>,$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dir)</span>/*.cpp)</span>)<br><br>OBJS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.cpp,<span class="hljs-variable">$(OUTPUT)</span>/%.o,<span class="hljs-variable">$(SRCS)</span>)</span><br>DEPS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.o,%.d,<span class="hljs-variable">$(OBJS)</span>)</span><br><br>LIBS := `pkg-config --libs opencv4` <span class="hljs-comment"># 通过pkg-config指令,将opencv4的库文件路径列出</span><br><br><span class="hljs-variable">$(TARGET)</span> : <span class="hljs-variable">$(OBJS)</span><br>@echo linking...<br>@g++ <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$(LIBS)</span><br>@echo complete!<br><br><span class="hljs-variable">$(OUTPUT)</span>/%.o : %.cpp<br>@echo compling...<br>@mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>@g++ -MMD -MP -c <span class="hljs-variable">$(INCS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br>@echo complete!<br><br>.PHONY : clean<br><br>clean :<br>@echo cleaning...<br>@rm -rf <span class="hljs-variable">$(OUTPUT)</span> <span class="hljs-variable">$(TARGET)</span><br>@echo complete!<br><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(DEPS)</span> <br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>注意: Please note: you need to put a tab character at the beginning of every recipe line!</strong></p><p><strong>在每个执行语句要用tab字符(制表符)开头!</strong></p>          </div><h2 id="关于gcc编译选项的一些补充"><a class="markdownIt-Anchor" href="#关于gcc编译选项的一些补充"></a> 关于GCC编译选项的一些补充</h2><ul><li><code>-I</code> 指定搜索头文件的路径</li><li><code>-L</code> 指定搜索库文件的路径</li><li><code>-l</code> 指定链接的库文件如<code>-lm</code>链接数学库</li><li><code>-D</code> 类似于c中的宏定义,在-D中出现的变量在C中可使用,如<code>-D DEBUG=1</code>,然后在C中打印出<code>DEBUG</code>这个变量会显示1的值</li></ul><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/dreamerway/article/details/24991099">C++程序组织：.h .cpp与分离式编译</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/618350718">写给初学者的Makefile入门指南</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_43916755/article/details/128503446">深入理解计算机系统_静态链接和动态链接以及静态库和动态库</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/xieyihua1994/article/details/134782826">一文搞懂系列——动态库的加载方式及应用场景</a> (未细看)<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>C++项目编译工具</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量intrinsic编程</title>
    <link href="/2024/01/24/%E5%90%91%E9%87%8Fintrinsic%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/01/24/%E5%90%91%E9%87%8Fintrinsic%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="simd指令集的发展"><a class="markdownIt-Anchor" href="#simd指令集的发展"></a> SIMD指令集的发展</h2><h3 id="什么是simd"><a class="markdownIt-Anchor" href="#什么是simd"></a> 什么是SIMD</h3><p>我们接触的传统的程序，一般是SISD，即Single Instruction Single Data，单指令单数据流，它是传统的串行计算机架构，即相当于在该计算机上，任何时刻都是从指令流里取一条指令来处理数据流中的一个数据，交由一个核心来处理。</p><p>SIMD则是利用到了计算机的多个核心的较新的并行架构，采用控制器来控制多个处理器，对多个核心的不同数据执行同一条指令，从而实现并行。</p><p>SIMD有对应SIMD指令集，而支持这些SIMD指令集的CPU在设计的时候增加了专用的<strong>向量寄存器</strong>，</p><p>就好像之前一条指令只能处理一个单精度浮点数，而现在采用一条SIMD指令能处理如4个，8个甚至更多个的单精度浮点数，这些数据就存储于向量寄存器中，显然，<strong>向量寄存器较通用寄存器其能容纳更多的位数</strong>。当然，<strong>放入向量寄存器的多个数据的数据类型是一致的</strong>。</p><h3 id="simd指令集的历史进程"><a class="markdownIt-Anchor" href="#simd指令集的历史进程"></a> SIMD指令集的历史进程</h3><p>下图是SIMD指令集随CPU的发展：</p><p><img src="https://s2.loli.net/2024/02/27/ofa25ckdz9A1iwP.jpg" alt="SIMD_Instruction_development" /></p><ul><li>MMX(Multi Media eXtension)，伴生64位的MM寄存器</li><li>SSE(Streaming Simd Extension)，伴生128位的XMM寄存器，XMM0-XMM15，一共十六个寄存器</li><li>AVX/AVX2(Advanced Vector eXtension)，伴生256位的YMM寄存器，YMM0-YMM15,一共十六个寄存器。AVX2增加了乘加融合指令（FMA，这同时也是一个硬件）。低128位对应XMM</li><li>AVX512，伴生512位的ZMM寄存器，ZMM0-ZMM31,一共32个寄存器，还有8个操作掩码寄存器，K0-K7，低128位和低256位对应XMM和YMM</li></ul><h3 id="simd指令集的数据类型"><a class="markdownIt-Anchor" href="#simd指令集的数据类型"></a> SIMD指令集的数据类型</h3><p>虽说有好像很多种指令集，但毕竟都是一家公司发行的，有一定规律可遵循：</p><p><code>__m+位宽+数据类型</code></p><p>其中位宽有128位（SSE），256位(AVX/AVX2)，512位（AVX512）</p><p>数据类型有三种：</p><ul><li>什么都不写，就代表单精度浮点数</li><li>d，代表double，双精度浮点数</li><li>i，整型，对应char,short,int,long这一堆定点数</li></ul><p>因此数据类型可以如下表示：</p><p><code>__m256</code>: 向量长度为256位的单精度浮点数，有8个32位的float</p><p><code>__m128i</code>: 向量长度为128位的整型，有多个整型数值</p><p><code>__m5121d</code>: 向量长度为512位的双精度浮点数，有8个64位的double</p><h3 id="simd指令集的方法"><a class="markdownIt-Anchor" href="#simd指令集的方法"></a> SIMD指令集的方法</h3><p>在说到SIMD指令集，如AVX指令集时，我们知道，可以采用指令集中的汇编指令去操纵YMM寄存器，但是，汇编难写难读难管理，因此有了<strong>Intrinsic Function</strong>。</p><p><strong>Intrinsic Function</strong>就跟C一样，是较于汇编的一种高级语言（但没到C那种高级程度，只是用类C的方式编写汇编），它又与C不同（毕竟面对的寄存器不是通用寄存器了，而是向量寄存器），但可以和C/C++无缝融合</p><p>需要注意：<strong>Intrinsic Function并非完全与指令集一一对应</strong></p><p>SSE/AVX的intrinsic function命名习惯如下:</p><p><code>__&lt;return_type&gt; _&lt;vector_size&gt;_&lt;intrin_op&gt;_&lt;suffix&gt;</code></p><ul><li>返回类型return_type就是上面对应的SIMD数据类型,如<code>__m256d</code>这些</li><li>向量长度vector_size就是代表<strong>函数操作的数据向量的位长度</strong>,如<code>mm</code>表示128位的数据向量(SSE),<code>mm256</code>表示256位的数据向量(AVX/AVX2),<code>mm512</code>表示512位的数据向量(AVX512)</li><li>代表函数具体功能的<code>intrin_op</code></li><li><strong>suffix是后缀,表示函数参数的数据类型</strong>,p=packed,s=single(fp32),d=double(fp64),ep=整型(具体英文指代词没找到)<ul><li>ps</li><li>pd</li><li>epi8/epi16/epi32/epi64</li><li>epu8/epu16/epu32/epu64</li><li>si128/si256: 未指定的128位/256位向量,si=unSpecIfied</li></ul></li></ul><h3 id="常规方法类型"><a class="markdownIt-Anchor" href="#常规方法类型"></a> 常规方法类型</h3><p>SET系列,LOAD系列,STORE系列,MATH系列,COMPARE系列,CONVERT系列,SHUFFLES系列,详情参见<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup></p><p>注:load是往向量寄存器YMM里灌数据,而store给从向量寄存器写到内存去</p><p>其中shuffles中有个<code>_mm256_blendv_pd(__m256d a,__m256d b,__m256d mask)</code>中的v表示的是variable,否则是constant,且它可以这么理解:mask中的false由a填充,true的部分则由b填充</p><h2 id="第一个intrinsic的demo"><a class="markdownIt-Anchor" href="#第一个intrinsic的demo"></a> 第一个intrinsic的demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    __m256 a = _mm256_set_ps(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.1</span>, <span class="hljs-number">3.2</span>, <span class="hljs-number">4.3</span>,<br>                             <span class="hljs-number">5.4</span>, <span class="hljs-number">6.5</span>, <span class="hljs-number">7.6</span>, <span class="hljs-number">8.7</span>);<br><br>    __m256 b = _mm256_set_ps(<span class="hljs-number">3.8</span>, <span class="hljs-number">4.9</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.1</span>,<br>                             <span class="hljs-number">8.2</span>, <span class="hljs-number">9.3</span>, <span class="hljs-number">10.4</span>, <span class="hljs-number">11.5</span>);<br><br>    __m256 c = _mm256_add_ps(a, b);<br><br>    <span class="hljs-keyword">float</span> d[<span class="hljs-number">8</span>];<br><br>    _mm256_storeu_ps(d, c); <span class="hljs-comment">// 这里的u是unaligned的意思</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        cout &lt;&lt; d[i] &lt;&lt; ends;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>immintrin.h</code>是AVX的头文件,然后在编译的时候要加上<code>-mavx</code>以启用AVX指令集</strong></p><h2 id="avx2算子编写"><a class="markdownIt-Anchor" href="#avx2算子编写"></a> AVX2算子编写</h2><p>这部分的内容大量的参考了学习资料<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup>,其中内容编写部分是我看了之后自己重新编写的</p><h3 id="gelu"><a class="markdownIt-Anchor" href="#gelu"></a> GELU</h3><p>参照学习资料<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="玩转SIMD编程">[1]</span></a></sup>自行观看,过于直白,其中tanh是一种近似实现,当然也可以用别的轻量数学库来替换,好像是Intel C++ Compiler没有这个的实现(但是好像MKL是有的),用别的编译器可能存在不支持AVX2指令的情况.查了下百度,原因如下(<strong>要做优化,就别用cmath这些,当然icc针对这些数学公式也有优化的库:mkl</strong>):</p><p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/ICC-tanh%20ask.png" alt="icc-tanh" /></p><h3 id="softmax"><a class="markdownIt-Anchor" href="#softmax"></a> softmax</h3><h3 id="矩阵加"><a class="markdownIt-Anchor" href="#矩阵加"></a> 矩阵加</h3><h3 id="矩阵转置"><a class="markdownIt-Anchor" href="#矩阵转置"></a> 矩阵转置</h3><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:0" class="footnote-text"><span><a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">intel-intrinsic官网</a><a href="#fnref:0" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/591900754">玩转SIMD编程</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qq_17075011/article/details/130555559">AVX/AVX2,内存对齐学习</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/fengbingchun/article/details/18460199/">SSE2 Intrinsic function介绍</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>intrinsic编程</tag>
      
      <tag>AVX/AVX2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>asm内联汇编</title>
    <link href="/2024/01/24/asm%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"/>
    <url>/2024/01/24/asm%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a class="markdownIt-Anchor" href="#写在开头"></a> 写在开头</h2><p>本文所描述的内联汇编主要用于算子开发,因此涉及到的知识面相对可能较窄.如果有内容没涉及到,大概是作者还没使用到相关的知识~</p><p>文中对内联汇编的一些定义解释会引用<strong>GCC Extended-ASM</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="GNU Extended-ASM">[1]</span></a></sup>的原文,毕竟翻译过来容易变味,不利于使用者理解</p><h2 id="基本格式"><a class="markdownIt-Anchor" href="#基本格式"></a> 基本格式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">asm</span> <span class="hljs-keyword">asm</span>-<span class="hljs-built_in">qualifiers</span> ( AssemblerTemplate <br>                 : OutputOperands <br>                 [ : InputOperands<br>                 [ : Clobbers ] ])<br></code></pre></td></tr></table></figure><p>第一个asm是<strong>关键字</strong>,建议使用**<code>__asm__</code>**而非<code>asm</code>,原因如下:</p><blockquote><p>The <code>asm</code> keyword is a GNU extension. When writing code that can be compiled with -ansi and the various -std options, use <code>__asm__</code> instead of <code>asm</code> (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html">Alternate Keywords</a>).</p></blockquote><hr /><p>**asm的修饰符(qualifiers)**有三个</p><ul><li><p><strong>volatile</strong>: 告知GCC这里不用优化(就是这里禁用优化)</p><blockquote><p>The typical use of extended <code>asm</code> statements is to manipulate input values to produce output values. However, your <code>asm</code> statements may also produce side effects. If so, you may need to use the <code>volatile</code> qualifier to disable certain optimizations. See <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Volatile">Volatile</a>.</p></blockquote></li><li><p><strong>inline</strong>:</p></li><li><p><strong>goto</strong>:</p></li></ul><hr /><p><strong>AssemblerTemplate</strong>则用于放置汇编语句,用<code>&quot;&quot;</code>包裹住每一句汇编语句</p><hr /><p><strong>OutputOperands</strong>,这个列表以<code>:</code>开头,用于放置<strong>输出操作数</strong>,列表中的<strong>各个操作数以<code>,</code>分隔</strong>.输出操作数<strong>一般至少用于只写(覆盖)</strong>.操作数的格式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[ [asmSymbolicName] ] constraint (cvariablename)<br></code></pre></td></tr></table></figure><p>其中<code>[asmSymbolicName]</code>是C中变量<code>cvariablename</code>在汇编中的符号名,一般同名更有利于我们编写汇编,在AssemblerTemplate中可以通过**<code>%[asmSymbolicName]</code>**来进行调用</p><p>不想用符号名的话则按照输出操作数到输入操作数的变量名的顺序,依次为<code>%0</code>,<code>%1</code>,…</p><p><code>(cvariablename)</code>则用于填写我们C中的变量名</p><p>constraint约束,是一个<strong>字符串常量</strong>,<strong>指定操作数的约束条件</strong>.它需要以<code>=</code>(覆盖现有值的变量,即只写)或者<code>+</code>(既读又写时)作为字串开头</p><blockquote><p>Output constraints must begin with either ‘=’ (a variable overwriting an existing value) or ‘+’ (when reading and writing). When using ‘=’, do not assume the location contains the existing value on entry to the <code>asm</code>, except when the operand is tied to an input; see <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#InputOperands">Input Operands</a>.</p></blockquote><p>在上面的前缀后,须有一个或多个额外的约束,来<strong>描述值所在的位置</strong>.比如寄存器的<code>r</code>和内存的<code>m</code>.<strong>当列出多个可能的位置,则编译器会根据上下文选择最有效的位置</strong>.</p><blockquote><p>After the prefix, there must be one or more additional constraints (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Constraints.html">Constraints for <code>asm</code> Operands</a>) that describe where the value resides. Common constraints include ‘r’ for register and ‘m’ for memory. When you list more than one possible location (for example, <code>&quot;=rm&quot;</code>), the compiler chooses the most efficient one based on the current context. If you list as many alternates as the <code>asm</code> statement allows, you permit the optimizers to produce the best possible code. If you must use a specific register, but your Machine Constraints do not provide sufficient control to select the specific register you want, local register variables may provide a solution (see <a href="https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html">Specifying Registers for Local Variables</a>).</p></blockquote><hr /><p><strong>InputOperands</strong>用于放置<strong>输入操作数</strong>,列表中的各操作数以<code>,</code>分隔,<strong>只用做输入用,即只读</strong>.它的格式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[ [asmSymbolicName] ] constraint (cexpression)<br></code></pre></td></tr></table></figure><p>这里基本上跟OutputOperands一样,但是<strong>作为约束的字串常量没有<code>=</code>或者<code>+</code>这些prefix,只是用来指示值所在的位置</strong>,比如<code>r</code>或者<code>m</code>.也可以给出多个可能的位置,让编译器根据上下文选择最有效的位置</p><hr /><p><strong>Clobbers</strong>这个列表中的列表项,要么是<strong>寄存器名字</strong>,要么是<strong>特殊的clobber</strong>.每个列表项都是用<code>&quot;&quot;</code>括起来,用<code>,</code>分隔的字串常量</p><div class="note note-info">            <p>虽说编译器知道我们会修改输出操作数,但是这其中的内联代码也会用到额外的寄存器,用的时候一些寄存器的值被覆盖掉了,这些被用的寄存器我们要告知编译器</p><blockquote><p>While the compiler is aware of changes to entries listed in the output operands, the inline <code>asm</code> code may modify more than just the outputs. For example, calculations may require additional registers, or the processor may overwrite a register as a side effect of a particular assembler instruction. In order to inform the compiler of these changes, list them in the clobber list. Clobber list items are either register names or the special clobbers (listed below). Each clobber list item is a string constant enclosed in double quotes and separated by commas.</p></blockquote>          </div><p>而且我们的输入输出操作数可能约束中指定了要用寄存器来存放值,编译器在选择它们要用的寄存器时,不会用clobber列表中提及到的寄存器.因此,clobber中提及的寄存器可以用于汇编代码中任何用途.</p><blockquote><p>When the compiler selects which registers to use to represent input and output operands, it does not use any of the clobbered registers. As a result, clobbered registers are available for any use in the assembler code.</p></blockquote><p><strong>clobber列表中不给用stack pointer寄存器!!</strong></p><p>特殊的clobber:</p><ul><li><p><code>cc</code>:表示汇编代码修改了标志寄存器.某些机器,gcc会将条件代码表示为一个特定的硬件寄存器,cc用来命名该寄存器</p><blockquote><p>The <code>&quot;cc&quot;</code> clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; <code>&quot;cc&quot;</code> serves to name this register. On other machines, condition code handling is different, and specifying <code>&quot;cc&quot;</code> has no effect. But it is valid no matter what the target.</p></blockquote></li><li><p><code>memory</code>: memory clobber告诉编译器,<strong>汇编代码对输入和输出操作数中列出的项以外的项执行内存读取或写入（例如，访问其中一个输入参数指向的内存）</strong>。<strong>为了确保内存包含正确的值，GCC可能需要在执行asm(内联汇编)之前将特定的寄存器值刷新到内存中</strong>。此外，编译器不假设在asm之前从内存读取的任何值在该asm之后保持不变；它会<strong>根据需要重新加载它们</strong>(根据需要做现场保护)。使用memory clobber有效地为编译器形成了一个读/写内存屏障。</p><blockquote><p>The <code>&quot;memory&quot;</code> clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the <code>asm</code>. Further, the compiler does not assume that any values read from memory before an <code>asm</code> remain unchanged after that <code>asm</code>; it reloads them as needed. Using the <code>&quot;memory&quot;</code> clobber effectively forms a read/write memory barrier for the compiler.</p></blockquote></li></ul><h2 id="两个例子"><a class="markdownIt-Anchor" href="#两个例子"></a> 两个例子</h2><h3 id="risc-v的例子通过内联汇编实现系统调用"><a class="markdownIt-Anchor" href="#risc-v的例子通过内联汇编实现系统调用"></a> RISC-V的例子(通过内联汇编实现系统调用):</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__buf, <span class="hljs-keyword">int</span> __n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> bytes;<br>    __asm__ __volatile__(<br>        <span class="hljs-string">&quot;mv a0, %1           # file descriptor\n&quot;</span><br>        <span class="hljs-string">&quot;mv a1, %2           # buffer \n&quot;</span><br>        <span class="hljs-string">&quot;mv a2, %3           # size \n&quot;</span><br>        <span class="hljs-string">&quot;li a7, 63           # syscall read (63) \n&quot;</span><br>        <span class="hljs-string">&quot;ecall \n&quot;</span><br>        <span class="hljs-string">&quot;mv %0, a0&quot;</span><br>        : <span class="hljs-string">&quot;=r&quot;</span>(bytes)                     <span class="hljs-comment">// Output list</span><br>        : <span class="hljs-string">&quot;r&quot;</span>(__fd), <span class="hljs-string">&quot;r&quot;</span>(__buf), <span class="hljs-string">&quot;r&quot;</span>(__n) <span class="hljs-comment">// Input list</span><br>        : <span class="hljs-string">&quot;a0&quot;</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a7&quot;</span>);<br>    <span class="hljs-keyword">return</span> bytes;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> __fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *__buf, <span class="hljs-keyword">int</span> __n)</span></span><br><span class="hljs-function"></span>&#123;<br>    __asm__ __volatile__(<br>        <span class="hljs-string">&quot;mv a0, %0           # file descriptor\n&quot;</span><br>        <span class="hljs-string">&quot;mv a1, %1           # buffer \n&quot;</span><br>        <span class="hljs-string">&quot;mv a2, %2           # size \n&quot;</span><br>        <span class="hljs-string">&quot;li a7, 64           # syscall write (64) \n&quot;</span><br>        <span class="hljs-string">&quot;ecall&quot;</span><br>        :                                 <span class="hljs-comment">// Output list</span><br>        : <span class="hljs-string">&quot;r&quot;</span>(__fd), <span class="hljs-string">&quot;r&quot;</span>(__buf), <span class="hljs-string">&quot;r&quot;</span>(__n) <span class="hljs-comment">// Input list</span><br>        : <span class="hljs-string">&quot;a0&quot;</span>, <span class="hljs-string">&quot;a1&quot;</span>, <span class="hljs-string">&quot;a2&quot;</span>, <span class="hljs-string">&quot;a7&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">11</span>];<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, str, <span class="hljs-number">11</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We already read %d chars&quot;</span>, n);<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, str, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> _start()<br>&#123;<br>    <span class="hljs-built_in">main</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="aarch64的例子加权和dstj-weighted1-array1j-weigthed2-array2j"><a class="markdownIt-Anchor" href="#aarch64的例子加权和dstj-weighted1-array1j-weigthed2-array2j"></a> aarch64的例子(加权和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>e</mi><mi>d</mi><mn>1</mn><mo>∗</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mn>1</mn><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>d</mi><mn>2</mn><mo>∗</mo><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mn>2</mn><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dst[j] = weighted1 * array1[j] + weigthed2 * array2[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>):</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrayWeightSumInAsm</span><span class="hljs-params">(<span class="hljs-keyword">float</span>* array1,<span class="hljs-keyword">float</span> weighted1,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">float</span>* array2,<span class="hljs-keyword">float</span> weighted2,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">int</span> len,<span class="hljs-keyword">float</span>* dst)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> neon_len = len &gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> remain_len = len - (neon_len &lt;&lt; <span class="hljs-number">2</span>);<br> <span class="hljs-comment">// armv8</span><br>    <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">//  Instruction</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 取64位寄存器的低32位,并dup到向量寄存器上</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;mov x0, %[weighted1] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;dup v0.4s, w0 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;mov x1, %[weighted2] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;dup v1.4s, w1 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;0:            \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 预取数据,加载数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;prfm pldl1keep, [%[array1], #128] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;ld1 &#123;v2.4s&#125;, [%[array1]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;prfm pldl1keep, [%[array2], #128] \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;ld1 &#123;v3.4s&#125;, [%[array2]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 做乘法</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fmul v4.4s, v0.4s, v2.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fmul v5.4s, v1.4s, v3.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 做加法</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;fadd v4.4s, v4.4s, v5.4s \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 存数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;st1 &#123;v4.4s&#125;, [%[dst]], #16 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 自减neon_len,并影响状态位</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;subs %[neon_len], %[neon_len], #1 \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-comment">// 满足条件则跳转</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;bgt 0b \n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        :[array1]    <span class="hljs-string">&quot;+r&quot;</span>(array1),</span></span><br><span class="hljs-params"><span class="hljs-function">         [array2]    <span class="hljs-string">&quot;+r&quot;</span>(array2),</span></span><br><span class="hljs-params"><span class="hljs-function">         [dst]       <span class="hljs-string">&quot;+r&quot;</span>(dst),</span></span><br><span class="hljs-params"><span class="hljs-function">         [neon_len]  <span class="hljs-string">&quot;+r&quot;</span>(neon_len)</span></span><br><span class="hljs-params"><span class="hljs-function">        :[weighted1] <span class="hljs-string">&quot;r&quot;</span>(weighted1),</span></span><br><span class="hljs-params"><span class="hljs-function">         [weighted2] <span class="hljs-string">&quot;r&quot;</span>(weighted2)</span></span><br><span class="hljs-params"><span class="hljs-function">        :<span class="hljs-string">&quot;cc&quot;</span>,<span class="hljs-string">&quot;memory&quot;</span>,<span class="hljs-string">&quot;x0&quot;</span>,<span class="hljs-string">&quot;x1&quot;</span>,<span class="hljs-string">&quot;v0&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>,<span class="hljs-string">&quot;v4&quot;</span>,<span class="hljs-string">&quot;v5&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br>    <span class="hljs-comment">// 处理尾部数据</span><br>    <span class="hljs-keyword">while</span>(remain_len&gt;<span class="hljs-number">0</span>)&#123;<br>        *dst = *array1 * weighted1 + *array2 * weighted2;<br>        dst++;<br>        array1++;<br>        array2++;<br>        remain_len--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">GNU Extended-ASM</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_42031299/article/details/132917965">c内嵌汇编总结</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_42258222/article/details/116501867">【ATT 与 Intel】汇编与C语言相互调用及内联汇编</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://blog.csdn.net/I_O_fly/article/details/127089091">RISCV汇编指令</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>内联汇编</tag>
      
      <tag>内嵌汇编</tag>
      
      <tag>assemble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorRT学习</title>
    <link href="/2024/01/20/TensorRT%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/20/TensorRT%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>高性能深度学习支持引擎TensorRT</p><p>在线部署对实时性要求很高,对latency敏感</p><p>TensorRT: GPU Inference Engine;TensorRT works at deploy stage</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CUDA学习积累(持续更新)</title>
    <link href="/2023/12/24/CUDA%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/12/24/CUDA%E5%AD%A6%E4%B9%A0%E7%A7%AF%E7%B4%AF-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2><p>在去重庆参会前，就已经自己构建了一套学习理论（算子编写，算子调度[分布式模型训练]）听了山城会议之后，觉得对于算子编写得尽快提上日程，因此打算结合视频和博客学习CUDA，每天花点时间学习整理，方便后续算子编写的工作。<br />目前第一部分的学习首先是结合B站的视频展开：<a href="https://www.bilibili.com/video/BV1vJ411D73S">CUDA 编程入门</a>，后续学习到的知识重复部分则不予更新，更新尚未了解的部分~</p><h2 id="cuda学习"><a class="markdownIt-Anchor" href="#cuda学习"></a> CUDA学习</h2><h3 id="什么是gpu计算"><a class="markdownIt-Anchor" href="#什么是gpu计算"></a> 什么是GPU计算</h3><p>介绍了CPU的一般架构，可能涉及到多个核心，然后有L1、L2、L3多级cache缓存。主要意思是说：<strong>CPU核心数目不会特别多，一般多的话也就几十个</strong></p><p>介绍GPU一般架构，<strong>有SM（Streaming MultiProcessor）,一个SM里面有多个SP（Streaming Processor），它内存有L1、L2多级cache，也有全局系统显存</strong></p><p><strong>一个SM里面会包含许多SP（也叫CUDA Core）,同时也有指令Cache，warp调度器，寄存器文件等</strong></p><p><strong>GPU和CPU一起做运算，GPU(device)负责计算密集型任务，CPU（host）负责控制密集型任务，它们通过PCIe相连接（拷贝数据到对方的存储空间，好像也有共享内存类型的）</strong></p><p>CPU所谓的线程其实是伪进程（云计算课老师说的），上下文切换开销大</p><p><strong>GPU的线程则是真正意义上的线程，是很轻量级的</strong></p><p>CUDA支持C/C++编程，也支撑Fortran，Python</p><ul><li>编译器：nvcc(nvidia cuda compiler)</li><li>调试器：nvcc-gdb</li><li>性能分析：nsight,nvprof <a href="https://docs.nvidia.com/nsight-compute/NsightCompute/index.html">NsightCompute</a></li><li>函数库：cuBLAS,cuSparse,…</li><li>二进制工具: cuobjdump,nvdisasm <a href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html">cuda-binary-utilities</a></li></ul><h3 id="gpu内存层次"><a class="markdownIt-Anchor" href="#gpu内存层次"></a> GPU内存层次</h3><img src="https://s2.loli.net/2024/07/03/iWIVfJknL79A1aD.png" alt="gpu-logical-memory-hierarchy" style="zoom:67%;" /><p>上图呈现的是GPU的逻辑内存层次结构,分为<strong>grid-block-thread</strong>,其中我们在CUDA中会通过**<code>dim3</code>**类型来对它们进行定义,<code>dim3</code>类型可以理解为结构体,内部有x,y,z三个值(空间直角坐标系),默认缺省值为1</p><p>grid(网格)内部有多个block(线程块),block内部有多个thread(线程),在编写CUDA程序时,会分为host端和device端(异构编程模型嘛),我们在调用核函数的时候,会通过执行配置参数,声明这一个核函数需要用到的grid和block</p><p>而在核函数内部,会有如<code>gridDim</code>,<code>blockDim</code>这两个内置参数来查看外部声明的配置参数的大小,并且可以通过<code>blockIdx</code>,<code>threadIdx</code>找到对应block属于grid的第几行第几列,对应thread在block内的线程号以及相对于整个grid它的线程号等信息</p><p>实际上GPU的内存层次并非上述的<strong>grid-block-thread</strong>,这一概念是为了将软硬件剥离,以提高程序员编写的简易性,但若是考虑到性能优化,就一定需要了解其真正的物理内存层次,下图展示的是Fermi架构的内存层次,gpu硬件的内存层次整体大同小异</p><img src="https://s2.loli.net/2024/07/03/DzW7bO2gwC91IJj.png" alt="gpuFermi-physical-memory-hierarchy" style="zoom:67%;" /><p>可以看到上述分为了两个层次,第一个层次是许多的SM由DRAM(全局内存,就是通俗意义的显存)围绕,而内部所有的SM共享一个L2Cache,也就是SM们可以通过L2Cache进行通信;</p><p>右侧展开了单个SM,可以看到内部有许多的CUDA Core(SP),还有L1Cache和Shared Memory所共享的64KB内存,以及一个超大的Regster File,其中内部还包括warp的调度器,发射单元等部件</p><p>实际上,我们的block它在运行的时候会被调度到SM上(<strong>SM是真正的核心组件</strong>),<strong>一个SM可以调度多个block</strong>,具体多少,看它的资源,因为我们<strong>线程的寄存器,线程块的共享内存,是用的SM的资源</strong>.而<strong>在SM上的一个block会被划分为多个warp,一个warp是32个线程,warp是最基本的执行单元,warp内部遵循SIMT,每个线程同时执行相同的指令</strong>,而每个线程它拥有自己独立的PC和寄存器状态,也即有自己的执行路径</p><p>因此block应该设置为32的倍数,如果不是32的倍数,余下的部分会单独划为1个warp,该warp除了需要的线程,剩余的线程都是inactive</p><p>下面是关于逻辑内存与对应的物理内存的关系,需要牢记哪些内存是片上内存,哪些是板载内存</p><p><img src="https://s2.loli.net/2024/07/03/p6JANBGKTlrvYMO.png" alt="gpu-memory-distribution" /></p><h3 id="gpu一些指标"><a class="markdownIt-Anchor" href="#gpu一些指标"></a> GPU一些指标</h3><ul><li><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>o</mi><mi>c</mi><mi>c</mi><mi>u</mi><mi>p</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mspace width="1em"/><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="1em"/><mi>o</mi><mi>f</mi><mspace width="1em"/><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mspace width="1em"/><mi>w</mi><mi>a</mi><mi>r</mi><mi>p</mi><mi>s</mi></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>i</mi><mi>m</mi><mi>u</mi><mi>m</mi><mspace width="1em"/><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="1em"/><mi>o</mi><mi>f</mi><mspace width="1em"/><mi>w</mi><mi>a</mi><mi>r</mi><mi>p</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">occupancy = \frac{actual\quad number\quad of\quad active\quad warps}{maximum\quad number\quad of\quad warps}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">c</span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25188em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">b</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>占用率</p></li></ul><h2 id="基础的例子向量加"><a class="markdownIt-Anchor" href="#基础的例子向量加"></a> 基础的例子向量加</h2><p>通过向量加这一例子,了解cuda编程的大致形式</p><p>从下面开始,关于CUDA的讲解分为三个部分:<strong>硬件架构</strong>,<strong>库与函数</strong>,<strong>算子系列</strong>来进行展开,三个部分顺序不一定一一对应,可以从硬件部分开始看,也可以从算子系列开始看,遇到奇奇怪怪的函数或库在去库与函数里找解释会更好</p><h2 id="硬件架构"><a class="markdownIt-Anchor" href="#硬件架构"></a> 硬件架构</h2><h2 id="库与函数"><a class="markdownIt-Anchor" href="#库与函数"></a> 库与函数</h2><h3 id="线程束shuffle指令优化"><a class="markdownIt-Anchor" href="#线程束shuffle指令优化"></a> 线程束shuffle指令优化</h3><p><strong>线程束洗牌(shuffle)指令是线程束内线程通信的极佳方式:延迟极低,不消耗内存,通过束内线程相互访问寄存器以传递数据,不用再走共享内存乃至全局内存</strong></p><p><strong><code>laneID</code>(束内索引),就是一个线程束内线程的索引;<code>warpID</code>,表示线程束的ID</strong></p><p>利用block内线程号分别<code>/32</code>,<code>%32</code>来获得<code>warpID</code>,<code>laneID</code></p><p>shuffle指令分为用于<strong>整型</strong>和<strong>浮点型</strong></p><ul><li><p>整型</p><ul><li><strong><code>int __shfl_sync(unsigned int mask,int var,int srcLane,int width=warpSize)</code></strong></li></ul><p><strong><code>mask</code>指示<code>width</code>大小内的线程有哪些线程参与运算</strong>;<strong><code>width</code>缺省值是32,即一个warp的大小,它可以取值为2,4,8,16,32</strong>;比如<code>mask</code>取<code>0xffffffff</code>,表示32个线程都参与运算,如果LSB取0则表示0号线程不参与计算;<strong><code>var</code>表示当前线程提供的值</strong>;<strong><code>srcLane</code>是进行广播的<code>laneID</code>,它广播的值通过返回值承接</strong></p><p>具体来说,比如<code>srcLane</code>选3,就是把线程束内 (之所以是线程束内,是因为默认的width是warpSize,是不是线程束内要看这个width,不然就是width+srcLane作为偏移值,比如width是16,则srcLane对于[0,15]是3,对于[16,31]是19(3+16)) 束内线程索引为3的变量var的值进行广播,给width内的所有线程;</p>  <div class="note note-info">            <p>注: 个人感觉这个width更像是分组,默认warpSize为一组,当然你想自定义也OK,就设置它的值(2,4,8,16,32这几个数里选).同时<strong>需要注意,这个srcLane本质上应该是<code>srcLane=srcLane%width</code></strong>,它可以做到环绕移动(通过<code>srcLane= threadIdx.x+offset</code>使得整个width内的数一起转圈圈,转的步数是offset)</p>          </div></li><li><p><strong><code>int __shfl_up_sync(unsigned int mask,int var,unsigned int delta,int width=warpSize)</code></strong><br /><strong>这个函数取的值是:当前调用线程的束内线程编号减去delta编号的线程的var值,如果变负值(取的数的束内线程号)则保持原来自己的值</strong>;</p><div class="note note-info">            <p>注: 叫up可能是因为前面的束内线程把值往前给</p>          </div><ul><li><p><strong><code>int __shfl_down_sync(unsigned int mask,int var,unsigned int delta,int width=warpSize)</code></strong><br />上面的反转版,这里变成了<strong>调用线程的束内线程号+delta(<code>warpId + delta</code>)</strong>,从这个束内线程号取值,当然<strong>如果越了width,则保持原值</strong>;</p><div class="note note-info">            <p>注: 叫down可能是因为后面的束内线程把值往后给</p>          </div></li><li><p><strong><code>int __shfl_xor_sync(unsigned int mask,int var, int laneMask,int width=warpSize)</code></strong><br />这个指令很神奇,<strong>调用线程的束内线程号和laneMask值做异或,得到的就是目标线程的束内线程号,然后目标线程会把它的var通过返回值给调用线程</strong><br />之所以说神奇,是因为laneMask比如取1,得到的是butterfly exchange</p></li></ul></li><li><p>浮点型</p><p>无需改函数名,已有重载,只需把var的int改成float即可</p></li></ul><p>​以下给出示例代码,其中使用了<code>__shfl_xor_sync()</code>指令来对一个总长度为32的数组,每个线程管理长度为4的数组做一个<code>laneMask=0x00000001</code>的大蝴蝶交换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cuda">#include &lt;cuda_runtime.h&gt;<br>#include &lt;stdio.h&gt;<br><br>#define ARRAY_SIZE 32<br>#define TEST_SIZE 4<br>#define MASK 0xffffffff<br>#define LANEMASK 0x00000001<br><br>__global__ void shuffle(int* src,int* dst)&#123;<br>    int idx = threadIdx.x * TEST_SIZE;<br>    int arr[TEST_SIZE];<br>    for(int i=0;i&lt;TEST_SIZE;i++)<br>        arr[i] = src[idx+i];<br>    __syncwarp();<br>    arr[0] = __shfl_xor_sync(MASK,arr[0],LANEMASK,warpSize);<br>    arr[1] = __shfl_xor_sync(MASK,arr[1],LANEMASK,warpSize);<br>    arr[2] = __shfl_xor_sync(MASK,arr[2],LANEMASK,warpSize);<br>    arr[3] = __shfl_xor_sync(MASK,arr[3],LANEMASK,warpSize);<br>    // printf(&quot;arr[]:%d&quot;,arr[0]);<br>    for(int i=0;i&lt;TEST_SIZE;i++)<br>        dst[idx+i] = arr[i];<br>&#125;<br>int main()&#123;<br>    size_t sizeArray = ARRAY_SIZE * sizeof(int);<br>    int* hSrc = (int*)malloc(sizeArray);<br>    int* hDst = (int*)malloc(sizeArray);<br>    int* dSrc,*dDst;<br>    cudaMalloc(&amp;dSrc,sizeArray);<br>    cudaMalloc(&amp;dDst,sizeArray);<br><br>    for(int i=0;i&lt;ARRAY_SIZE;i++)<br>        hSrc[i] = i;<br><br>    for(int i=0;i&lt;ARRAY_SIZE;i++)<br>        printf(&quot;%2d &quot;,hSrc[i]);<br>    printf(&quot;\n&quot;);<br><br>    cudaMemcpy(dSrc,hSrc,sizeArray,cudaMemcpyHostToDevice);<br><br>    shuffle&lt;&lt;&lt;1,8&gt;&gt;&gt;(dSrc,dDst);<br><br>    cudaMemcpy(hDst,dDst,sizeArray,cudaMemcpyDeviceToHost);<br><br>    for(int i=0;i&lt;ARRAY_SIZE;i++)<br>        printf(&quot;%2d &quot;,hDst[i]);<br>    printf(&quot;\n&quot;);<br><br>    cudaFree(dSrc);<br>    cudaFree(dDst);<br>    free(hSrc);<br>    free(hDst);<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>实验结果如下:</p><p><img src="https://s2.loli.net/2024/07/07/DPN327Hiqd5QMp6.png" alt="test-__shfl_xor_sync" /></p><div class="note note-info">            <p>注: 上面的代码中的<code>__shfl_xor()</code>一类的函数,在CUDA11.x上进行编译的时候报warning,说要用<code>__shfl_xor_sync()</code></p>          </div><h2 id="算子系列"><a class="markdownIt-Anchor" href="#算子系列"></a> 算子系列</h2><h3 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce</h3><p>reduce即为所说的规约操作,较为正式的说法是在一串数据中采用满足结合律的二元操作符最终得到一个结果,而这个操作符一般是求和,求均值,求最大最小值.下面以求和操作为例</p><p>通俗的说就是给定一个长度为n的数组,对n个数进行累加,得到的结果便是规约的结果</p><h3 id="gemm"><a class="markdownIt-Anchor" href="#gemm"></a> GEMM</h3><h4 id="分块双缓冲smem-bank-conliftregister-bank-conflict待解决"><a class="markdownIt-Anchor" href="#分块双缓冲smem-bank-conliftregister-bank-conflict待解决"></a> 分块+双缓冲+smem bank conlift+register bank conflict[待解决]</h4><p>GEMM的优化主要有两个思想:<strong>分块</strong>以及<strong>双缓冲</strong>,同时在其中对A阵进行<strong>打包</strong>,并采用<strong>向量化访存</strong>.做到上述这些操作,已经可以达到cuBLAS的**93%**了.在讨论具体怎么做前，回顾下最朴素的做法：</p><p>朴素的做法是一个线程处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>阵的一个元素，<strong>这需要访问global memory:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi><mo>∗</mo><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2k*m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>次</strong>，很明显，你得频繁访问global memory，这是latency最大的一层存储,这样的开销很大</p><h5 id="分块思路"><a class="markdownIt-Anchor" href="#分块思路"></a> 分块思路</h5><p><strong>我们应该尽量利用GPU的<em>global memory - shared memory - register</em>的存储结构进行分块存储</strong></p><img src="https://s2.loli.net/2024/07/27/dxEze15Nh7Ywtro.png" alt="gpu_gemm_optimize" style="zoom:50%;" /><p>按照上图进行划分，<strong>1个block处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大小的阵</strong>（黄方格），我们可以把A阵的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的小矩阵和B阵的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的小矩阵（浅蓝块）移动到shared memory上，这样整个C阵被划分为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>m</mi><msub><mi>b</mi><mi>m</mi></msub></mfrac><mo>∗</mo><mfrac><mi>n</mi><msub><mi>b</mi><mi>n</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{m}{b_m} * \frac{n}{b_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.140492em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.140492em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个block,每个block需要访问global memory <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>+</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><mfrac><mi>k</mi><msub><mi>b</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">(b_m*b_k + b_k*b_n) * \frac{k}{b_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.330968em;vertical-align:-0.4508599999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4508599999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 次,化简一下可得:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>m</mi></msub><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">(b_m + b_n)*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p><p>因此可知,此时的访问global memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><msub><mi>b</mi><mi>m</mi></msub></mfrac><mo>+</mo><mfrac><mn>1</mn><msub><mi>b</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m*n*k*(\frac{1}{b_m} + \frac{1}{b_n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>.可见,随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的变大,访问global memory的次数越少</p><p>目前来说,一般是将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">b_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均取值为128,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则取值为8(<mark>为什么这样取值啊❓</mark>)</p><p>那既然我们可以把数据腾挪到shared memory上,如果移到register岂不更快,由此我们对黄方格进一步划分(以下针对block进行讨论),我们让1个线程处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub><mo>×</mo><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_m \times t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大小的矩阵.则此时我们可以计算下如果不对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>进行分块,依旧是每个线程处理黄方格的一个元素,则需要访问shared memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">2 * b_k * b_m * b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而进行分块后,一共有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>b</mi><mi>m</mi></msub><msub><mi>t</mi><mi>m</mi></msub></mfrac><mo>×</mo><mfrac><msub><mi>b</mi><mi>n</mi></msub><msub><mi>t</mi><mi>n</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{b_m}{t_m} \times \frac{b_n}{t_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个线程,每个线程需要访问shared memory次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>m</mi></msub><mo>+</mo><msub><mi>t</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">(t_m + t_n)*b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,则该block访问shared memory的次数为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><msub><mi>t</mi><mi>m</mi></msub></mfrac><mo>+</mo><mfrac><mn>1</mn><msub><mi>t</mi><mi>n</mi></msub></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_m * b_n * b_k * (\frac{1}{t_m} + \frac{1}{t_n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2902079999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>,显然随着<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的增大,单个block访问shared memory的次数会变少</p><p>根据经验<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>均取8(<mark>为啥?</mark>)</p><p>梳理一下上面的信息:我们为了减少访问global memory以及shared memory的次数,对C矩阵进行了两次分块,分别将数据搬运到shared memory和register上去,一次的数据搬运量分别是$b_m * b_k $ + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>∗</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k * b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(这是对于block的,将数据搬运到smem上去);<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">t_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(这是对于thread的,将数据从smem搬运到自己的register上去),而我们给出了详细的参数配置:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>=</mo><msub><mi>b</mi><mi>n</mi></msub><mo>=</mo><mn>128</mn></mrow><annotation encoding="application/x-tex">b_m=b_n=128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><msub><mi>t</mi><mi>m</mi></msub><mo>=</mo><msub><mi>t</mi><mi>n</mi></msub><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">b_k=t_m=t_n=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>,由此可以计算出来一个block里的线程数目是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>∗</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">16 * 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>,共计256个线程</p><h5 id="计算正确性"><a class="markdownIt-Anchor" href="#计算正确性"></a> 计算正确性</h5><p>谈论完分块,谈论一下<strong>计算的准确性</strong>,因为分块后的计算你得算得对才有意义,不然优化得再快也没用.</p><p>从外部来看,我们的黄方格是由多个对应的浅蓝块进行外积累加而成(上图左侧);而黄方格内部是通过每个线程计算对应的深绿块得到的,而深绿块是通过对应的天蓝色块的外积累加而成.由此得到的深绿色块是符合计算原理的,而由深绿色块组成的黄方格也是符合计算原理的,因此整个计算过程是可以得到与内积相同的结果,具备计算的正确性</p><h5 id="如何搬运所需的数据"><a class="markdownIt-Anchor" href="#如何搬运所需的数据"></a> 如何搬运所需的数据</h5><p>那计算是正确的,就要想想分块后的数据应该怎么拿到:</p><p>首先是怎么把数据从global memory搬运到shared memory上的,目前我所使用的是V100,得绕一圈才能把数据放到shared memory上:<strong>从global memory经由register再放到shared memory上,因此每个block内的线程就需要各自负责对应的数据搬运</strong>,把计算所需的A分块的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>m</mi></msub><mo>×</mo><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_m \times b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和B分块的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>×</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">b_k \times b_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>搬运到临时的寄存器区域存储,然后放到共享内存去</p><p>这其中可以利用float4来进行向量化访存,同时A阵搬到reg后,再搬回smem时,可以做手动转置,以便于后续reg访问smem时可以利用向量化访存来获取数据;B阵则直接搬到reg,不用转置,直接存回smem即可</p><img src="https://s2.loli.net/2024/07/28/cqbdYjmQKMPW5yg.png" alt="tiled_gmem2smem_packedA" style="zoom:50%;" /><p>那么smem到reg中的数据,则是由每个线程从共享内存中取对应的数据,下图中展示的是block内的0号线程,它需要取左边的在smem上的A阵的8个元素,需要取右边的在smem上的B阵的8个元素,由于smem上的A阵已经转置了,所以可以理解为它重排成按列存储,然后沿着箭头的方向进行迭代,则可以算出0号线程负责的8x8矩阵的值</p><img src="https://s2.loli.net/2024/07/28/3fzoFhjaureYSiO.png" alt="tiled_smem2reg" style="zoom:50%;" /><h5 id="进行双缓冲"><a class="markdownIt-Anchor" href="#进行双缓冲"></a> 进行双缓冲</h5><p>如果按照上面的方式,我们需要定位到当前这个block负责的区域:<code>tmpA</code>和<code>tmpB</code>;</p><p>然后在大迭代中(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> -&gt; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>的迭代)先将数据搬运到smem上,然后再在小迭代中(每个线程1列数据和1行数据,直到滑到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">b_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)把数据从smem搬运到reg上,然后再计算出对应的8x8阵,并累加;</p><p>可以看出,这样的计算方式并不能很好的发挥出计算单元的性能,因为你每次都得取当前要用的数据,然后再计算;</p><p>因此可以用双缓冲来处理这个问题:每次预取下一轮要计算的数据,然后当前要用的数据已经准备好了,即整个流程变为:</p><ol><li>预取数据,放入smem和reg中,需要注意,我们的数组开了原先的两倍,用于分别存储下一轮要用的数据和当前轮使用的数据;</li><li>大迭代中先预取下一轮SMEM的数据;</li><li>小迭代中预取下一次计算的数据,放入reg中;</li><li>小迭代计算</li><li>直到大迭代计算完毕,则将数据存回C阵对应的区域中(tmpC)</li></ol><p>为什么双缓冲这种机制会被支持呢?因为ld/st单元和计算的单元是两个不同的部件</p><p><strong>当我们根据上述的做法进行优化后,我们自制的sgemm可达cuBLAS的93%</strong></p><h4 id="smem-bank-conflict解决"><a class="markdownIt-Anchor" href="#smem-bank-conflict解决"></a> smem bank conflict解决</h4><p>我们知道在定义一个block内线程数目的时候是16x16,即<code>blockDim.x</code>和<code>blockDim.y</code>均为16,这256个线程共需要8个warp,这8个warp根据朴素的思路是按照:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"> 0    1 ...  15 <br>16   17 ...  31  --&gt;  warp0<br>... ... ... ...  --&gt;  ...<br>240 241 ... 255  --&gt;  warp7<br></code></pre></td></tr></table></figure><p>这样的方式排列的.然后我们在用线程去处理值的时候(即把smem中的数据移到reg),是通过tx,ty(<code>threadIdx.x</code>,<code>threadIdx.y</code>)来处理的,并且如0号线程它连续取8个元素(A阵和B阵各八个),以B阵来说,那4号线程就会取到32-39这八个元素,因为是采用float4,即LDS.128的方式进行向量化访存,则T0-T7属于一个quarter warp,它里面的元素会发生一个2 way bank conflict,显然我们应该消除这个smem bank conflict带来的更长的访存时间;</p><p>需要知道,<strong>warp内部的排序,并不是按照上述朴素思路那样规规矩矩进行排列的,我们只需要在x和y这俩方向上各排够16个线程即可,warp内部的顺序,可以是朴素思路的那种规规矩矩2x8的排列,也可以是根据优化需要自己编排出来的如4x8/8x4的warp内线程排布方式,你只要按照你排布的方式去获取值,就会得到正确的结果</strong></p><p>因此我们将warp内的排布形式变成下图所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text"> 0  1 | 16 17<br> 2  3 | 18 19<br> 4  5 | 20 21<br> 6  7 | 22 23<br>-------------  <br> 8  9 | 24 25<br>10 11 | 26 27<br>12 13 | 28 29<br>14 15 | 30 31<br></code></pre></td></tr></table></figure><p>当我们按照这种z-order式以8x4的形式排列warp内部线程的时候,我们可以将整个warp的memory transaction由原先的8个变为2个(对B而言),减少了访存的时间开销</p><p>因此在这种warp内部的排列下,将8个warp排好,如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">warp0 | warp1 | warp2 | warp3<br>warp4 | warp5 | warp6 | warp7<br></code></pre></td></tr></table></figure><p>则满足了x和y方向上的线程各16的要求,然后求出对应的warpId和laneId,取对应的值进行计算,不过需要注意,这里我们把内部的8x8拆成了4个4x4计算,如下图示:</p><img src="https://s2.loli.net/2024/07/28/vtNbw7MP9BxlT1y.png" alt="resharp_warp" style="zoom:50%;" /><p><strong>当解决了shared memory bank conflict之后,我们的性能就能达到cuBLAS的95.6%了(M=N=K=4096)</strong></p><h4 id="register-bank-conflict"><a class="markdownIt-Anchor" href="#register-bank-conflict"></a> register bank conflict</h4><p><mark>暂时没有胆量去碰触SASS,还在积累,希望能看懂PTX和SASS</mark></p><p>这里简要说一下什么是register bank conflict,以便于我有朝一日突然兴起把这个给处理了</p><p>在Volta架构以前,我们每个SM上的RegisterFile是被分为4个bank的,对于Maxwell和Pascal架构而言,寄存器id%4得到的就是bank的id,当一条指令的源寄存器有2个以上来自同一bank,就会发生register的bank conflict,浪费1个cycle以重发射指令;</p><p>而在Volta架构开始,SM的RegisterFile被分为2个bank,只有当源寄存器id全为偶数或是奇数才会有bank conflict(<mark>?bank conflict为何会有这个东西(有的说是资源抢占问题(会影响到整体的并行性),有的说是一个cycle吞吐4B(指smem)),且2way bank和4way bank的bank conflict发生情况为何不同?</mark>)</p><h3 id="gemv"><a class="markdownIt-Anchor" href="#gemv"></a> GEMV</h3><h3 id="spmv"><a class="markdownIt-Anchor" href="#spmv"></a> SPMV</h3><h3 id="attention"><a class="markdownIt-Anchor" href="#attention"></a> Attention</h3><h3 id="ringattention"><a class="markdownIt-Anchor" href="#ringattention"></a> RingAttention</h3><h3 id="flashattention"><a class="markdownIt-Anchor" href="#flashattention"></a> FlashAttention</h3><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章:</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/462191421">GPU内存(显存)的理解与基本使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/423550197">从Fermi到Amphere架构演进的特点</a></li><li><a href="https://zhuanlan.zhihu.com/p/34587739">CUDA编程入门极简教程</a></li><li><a href="https://face2ai.com/program-blog">谭升blog</a></li><li><a href="https://blog.csdn.net/qccz123456/article/details/84971157">thrust库的使用</a></li><li><a href="https://www.zhihu.com/column/c_1437330196193640448">棍子哥-深入浅出GPU优化</a></li><li><a href="https://www.zhihu.com/column/c_1139113249399345152">cloudcore-CUDA编程方法论</a></li><li><a href="https://zhuanlan.zhihu.com/p/410278370">旷世天元-CUDA 矩阵乘法终极优化指南</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CUDA</tag>
      
      <tag>C++</tag>
      
      <tag>HPC</tag>
      
      <tag>Operator Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重庆高性能会议记录</title>
    <link href="/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="graphset-high-performance-graph-mining-through-equivalent-set-transformations"><a class="markdownIt-Anchor" href="#graphset-high-performance-graph-mining-through-equivalent-set-transformations"></a> GraphSet : High Performance Graph Mining through Equivalent Set Transformations</h2><p>GraphSet是一个通过集合等价变换来实现高性能的图挖掘</p><p>图分析问题:①图处理;②※图挖掘(比如找三角形,矩阵)<br />Pattern-Oblivious<br />※Pattern-Aware(利用结构信息,能剪枝) -&gt; NPC问题<br />变换控制流(串行部分-&gt;容斥原理??(求∩∪一类的易于并行的))为集合操作(有无依赖)[这部分应该大多是公式]</p><p>基于架构的优化:</p><ul><li>warp内共做一个集合操作</li><li>warp间独立(通过DFS遍历树)执行</li><li>CPU-GPU协同计算(预测并行度,低的丢给CPU?)</li></ul><p>论文地址: <a href="https://dl.acm.org/doi/pdf/10.1145/3581784.3613213">GraphSet : High Performance Graph Mining through Equivalent Set Transformations</a></p><h2 id="optimizing-direct-convolutions-on-arm-multi-cores"><a class="markdownIt-Anchor" href="#optimizing-direct-convolutions-on-arm-multi-cores"></a> Optimizing Direct Convolutions on ARM Multi-Cores</h2><p>优化卷积算子<br />卷积的四种优化策略:</p><ol><li><p>直接优化:{<br />引入新的张量存储格式;<br />循环优化;<br />微内核设计;<br />并行化<br />}</p></li><li><p>Im2col + GEMM</p></li><li></li><li><p>FFT</p></li></ol><p>ARMv9对DL算子优化度不高</p><p>相关工作(18-23):<br />LIBXSMM-&gt;XNNPACK-&gt;Ansor-&gt;MOpt-&gt;mGEMM-&gt;MBDC</p><p>现有瓶颈:</p><ul><li>主流框架兼容性 -&gt; NCHW(实际上应该是NHWC)</li><li>转换开销 -&gt; 打包</li><li>连续访存降低性能 -&gt; 重叠</li><li>粗粒度的并行策略 -&gt; 细粒度</li><li>基于GEMM的微内核,寄存器复用次优 -&gt;(计算微内核+打包微内核)</li></ul><p>论文地址: <a href="https://eprints.whiterose.ac.uk/202768/1/sc23-2.pdf">Optimizing Direct Convolutions on ARM Multi-Cores</a></p><h2 id="dasp-specific-dense-matrix-multiply-accumulate-units-accelerated-general-sparse-matrix-vector-multiplication"><a class="markdownIt-Anchor" href="#dasp-specific-dense-matrix-multiply-accumulate-units-accelerated-general-sparse-matrix-vector-multiplication"></a> DASP: Specific Dense Matrix Multiply Accumulate Units Accelerated General Sparse Matrix-Vector Multiplication</h2><p>SpMV 稀疏矩阵A*稠密向量x = 稠密向量</p><p>SpMV三部分的开销:1.随机访问向量x;2.A的非零元和对应x的计算;3.读写其他数组</p><p>mma指令处理8*8矩阵</p><p>论文地址: <a href="https://www.ssslab.cn/assets/papers/2023-lu-DASP.pdf">DASP: Specific Dense Matrix Multiply Accumulate Units Accelerated General Sparse Matrix-Vector Multiplication</a></p><h2 id="optimizing-mpi-collectives-on-shared-memory-multi-cores"><a class="markdownIt-Anchor" href="#optimizing-mpi-collectives-on-shared-memory-multi-cores"></a> Optimizing MPI Collectives on Shared Memory Multi-Cores</h2><p>论文地址: <a href="https://eprints.whiterose.ac.uk/202767/1/sc23-1.pdf">Optimizing MPI Collectives on Shared Memory Multi-cores</a></p><h2 id="tetris-accelerating-sparse-convolution-by-exploiting-memory-reuse-on-gpu"><a class="markdownIt-Anchor" href="#tetris-accelerating-sparse-convolution-by-exploiting-memory-reuse-on-gpu"></a> Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU</h2><p>论文地址: <a href="">Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU</a></p><h2 id="liger-interleaving-intra-and-inter-operator-parallelism-for-distributed-large-model-inference"><a class="markdownIt-Anchor" href="#liger-interleaving-intra-and-inter-operator-parallelism-for-distributed-large-model-inference"></a> Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference</h2><p>论文地址: <a href="">Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference</a></p><h2 id="easyscale-elastic-training-with-consistent-accuracy-and-improved-utilization-on-gpus"><a class="markdownIt-Anchor" href="#easyscale-elastic-training-with-consistent-accuracy-and-improved-utilization-on-gpus"></a> EasyScale: Elastic Training with Consistent Accuracy and Improved Utilization on GPUs</h2><p>论文地址: <a href="https://dl.acm.org/doi/pdf/10.1145/3581784.3607054">EasyScale: Elastic Training with Consistent Accuracy and Improved Utilization on GPUs</a></p><div class="note note-info">            <p>以上有论文地址的都是中了SC的，中了PPoPP的好像没挂地址出来，这里没有去找arXiv</p>          </div><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>从目前的SC和PPoPP接收的情况来看,以下领域是高性能计算中的热点工作:</p><ul><li><strong>图挖掘、图处理</strong></li><li><strong>SpMV</strong></li><li><strong>算子优化</strong></li><li><strong>分布式推理</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Graph Mining</tag>
      
      <tag>Graph Processing</tag>
      
      <tag>MLSys Inference</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎知识(持续更新)</title>
    <link href="/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="python-u是啥"><a class="markdownIt-Anchor" href="#python-u是啥"></a> python -u是啥</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.stdout.write(<span class="hljs-string">&quot;correct1&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error1&quot;</span>)<br>sys.stdout.write(<span class="hljs-string">&quot;correct2&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error2&quot;</span>)<br></code></pre></td></tr></table></figure><p>stdout是标准输入,stderr是标准错误,一般来说,标准错误没有缓存区,会直接输出到屏幕上;而stdout会有缓存区,即当出现换行符或者到达一定长度才会输出到屏幕,而增加**-u<strong>这个短指令即是使得stdout变为</strong>unbuffered**,使得我们的代码顺序即为输出顺序</p><p><mark>在python3.6.8的解释器下执行,感觉好像默认了unbuffered</mark>😕</p><h2 id="pty何物是也为啥一些指令都有它"><a class="markdownIt-Anchor" href="#pty何物是也为啥一些指令都有它"></a> pty何物是也,为啥一些指令都有它</h2><p>关于tty(终端，是一种字符型设备，名字源于teletypewriter，电传打字机)：</p><p>pty:pseudo terminal伪终端</p><h2 id="串口并口"><a class="markdownIt-Anchor" href="#串口并口"></a> 串口并口</h2><p>串口（串行接口）：一次传输一位数据，较为稳定，可进行长距离通信（串行口COM1,COM2）<br />并口（并行接口）：一次传输八位数据，但受长度限制，因为长度越长会增加干扰，数据容易出错</p><p>详情可见<a href="https://zhuanlan.zhihu.com/p/622677267">硬件基础：硬件通信常见的串口介绍</a></p><h2 id="什么是异构"><a class="markdownIt-Anchor" href="#什么是异构"></a> 什么是异构</h2><p>异构计算（Heterogeneous Computing）是一种特殊的并行分布式计算系统。它能够经济有效地实现高计算能力，可扩展性强，能够非常高效地利用计算资源。与之相对的概念就是同构计算（Homogeneous Computing），也就是为大家熟知的多核理念。为了突破计算算力受制于功耗的瓶颈，多核CPU技术得到越来越多的应用。强大的CPU采用越来越多的CPU内核这就是传统同构计算系统。很快人们就发现在AI人工智能和自动驾驶爆炸式增长的计算需求下，传统同构计算系统已经无法满足要求，GPU、DSP、FPGA和ASIC由于特定需求下高效性越来越多的被应用。而异构计算技术应运而生，像一个大厨将CPU、GPU、DSP、FPGA和ASIC(Application Specific Integrated Circuit，应用专用集成电路，主流有TPU、NPU、VPU、BPU芯片等)这些优良食材制成一道融合各方口味特点的佳肴<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/63207620/answer/1707221853">[1]</span></a></sup>。</p><ol><li><p>计算场景异构（通俗意义上的异构计算）<br />CPU+GPU/DPU<br />DPU：是对网卡和存储等数据的高效处理<br />何为计算场景的异构呢，就是本来应该是CPU处理的场景，现在解耦出来由专门的芯片进行处理。</p></li><li><p>计算性能的异构<br />相比于传统的X86芯片的同构多核，ARM在芯片架构上进行创新，采用了异构多核的芯片架构，芯片里面的核心分了大小核</p></li><li><p>CPU架构的异构<br />应该就是采用X86，ARM，RISC-V，Alpha，LoongArch等不同的CPU架构</p></li></ol><h2 id="进制单位转换"><a class="markdownIt-Anchor" href="#进制单位转换"></a> 进制单位转换</h2><p><img src="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg" alt="multiple-byte units" /></p><p>左侧代表的是十进制前缀，右侧表示的是二进制前缀</p><p>一般是制造商采用十进制，对于我们来说<strong>存储一般指的是二进制</strong>的，而在说到<strong>带宽一类的速率时，指的是十进制的</strong></p><h2 id="local目录"><a class="markdownIt-Anchor" href="#local目录"></a> ./local目录</h2><p>.local相当于跟全局的python环境进行了一层的隔离，在这里我们可以安装自己需要的库（在本地范围内），而无需提权<br />类似的安装方式大致如下：<br /><code>pip install target=~/.local/lib/python3.8/site-packages &lt;package-name&gt;</code><br />参考自：<a href="https://blog.csdn.net/m0_67402026/article/details/125241407">https://blog.csdn.net/m0_67402026/article/details/125241407</a></p><p>当然，如果知道有多个解释器，也可以安装到对应的解释器的位置，如：<br /><code>D:\path\to\python.exe -m pip install --user &lt;package-name&gt;</code><br />参考自：<a href="https://blog.csdn.net/ThsPool/article/details/132809683">https://blog.csdn.net/ThsPool/article/details/132809683</a></p><p>参考:<a href="https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html">https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html</a></p><h2 id="linux软硬链接"><a class="markdownIt-Anchor" href="#linux软硬链接"></a> linux软硬链接</h2><p>关于linux软链接的创建删除更新，可以这么理解，Linux的软链接相当于快捷方式 ，硬链接好像会共享原来的inode<br />以下是参考文章：<a href="http://www.mobiletrain.org/about/BBS/151003.html">http://www.mobiletrain.org/about/BBS/151003.html</a></p><h2 id="site-packages和distpages区别"><a class="markdownIt-Anchor" href="#site-packages和distpages区别"></a> site-packages和distpages区别:</h2><p><a href="https://blog.csdn.net/weixin_40614261/article/details/90023807">https://blog.csdn.net/weixin_40614261/article/details/90023807</a></p><h2 id="vimrc配置"><a class="markdownIt-Anchor" href="#vimrc配置"></a> vimrc配置</h2><p>注意,要查看vimrc在哪可以在一个利用vim打开的文件内通过:version查看,往下滑动可以看到vimrc文件一般配置在:<br />/etc/vimrc<br />~/.vimrc</p><h2 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h2><p>module全称:<strong>module-environment</strong>是一个用于<strong>管理环境变量的工具</strong></p><h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3><ul><li><code>module avail</code>查看所有的模块</li><li><code>module load/add 需要加载的模块</code>加载需要加载的模块</li><li><code>module unload/rm 需要卸载的模块</code> 卸载需要卸载的模块</li><li><code>module list</code> 列出已加载的模块</li><li><code>module show 模块</code> 查看指定的模块信息</li></ul><p><a href="https://www.fasteda.cn/post/22.html0">Linux 下 Module 工具的介绍与使用</a></p><h2 id="iterableiteratorgenerator"><a class="markdownIt-Anchor" href="#iterableiteratorgenerator"></a> iterable,iterator,generator</h2><p>关于python中iterable,iterator,generator:<a href="https://blog.csdn.net/weixin_44966641/article/details/131501576">https://blog.csdn.net/weixin_44966641/article/details/131501576</a></p><h2 id="不同操作系统的多线程"><a class="markdownIt-Anchor" href="#不同操作系统的多线程"></a> 不同操作系统的多线程</h2><p>Windows用spawn,Unix用fork,主要区别见下文:</p><p><a href="https://www.cnblogs.com/CJTARRR/p/17742597.html">fork和spawn区别</a></p><h2 id="__getattr__-__getattribute_"><a class="markdownIt-Anchor" href="#__getattr__-__getattribute_"></a> __getattr__ __getattribute_</h2><h2 id="descriptor描述器之__get__-__set__-__delete__"><a class="markdownIt-Anchor" href="#descriptor描述器之__get__-__set__-__delete__"></a> descriptor(描述器)之__get__ __set__ __delete__</h2><p><a href="https://www.cnblogs.com/andy1031/p/10923834.html">一些魔法方法</a></p><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><p><a href="https://www.cnblogs.com/tobyqin/p/python-decorator.html">python装饰器1</a></p><p><a href="https://zhuanlan.zhihu.com/p/640193185">python装饰器2</a></p><h3 id="常用装饰器"><a class="markdownIt-Anchor" href="#常用装饰器"></a> 常用装饰器</h3><p>这里介绍三个常用的装饰器语法糖,需注意函数指的是非类方法,方法指的是类内的方法,分为实例方法,类方法,静态方法</p><p><a href="https://zhuanlan.zhihu.com/p/544021480">方法分类及三个常用装饰器语法糖</a></p><ul><li>@property</li></ul><p><a href="https://blog.csdn.net/yingxuanzhang/article/details/125071269">property装饰器详解</a></p><ul><li>@classmethod</li><li>@staticmethod</li></ul><h2 id="类属性和实例属性"><a class="markdownIt-Anchor" href="#类属性和实例属性"></a> 类属性和实例属性</h2><h2 id="一般属性和私有属性"><a class="markdownIt-Anchor" href="#一般属性和私有属性"></a> 一般属性和私有属性</h2><p>参考文章：</p><h2 id="常量表达式constexpr"><a class="markdownIt-Anchor" href="#常量表达式constexpr"></a> 常量表达式constexpr</h2><h2 id="c的lambda表达式"><a class="markdownIt-Anchor" href="#c的lambda表达式"></a> c++的lambda表达式</h2><p>c++11引入的,主要的写作构造如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) specifiers exception -&gt; type &#123; function body &#125; <br></code></pre></td></tr></table></figure><ul><li><code>capture list</code>,捕获列表,捕获我们作用域中的变量,有值捕获(=),引用捕获(&amp;),混合捕获:<ul><li>如[a,b]表示值捕获a,b变量,以const方式;</li><li>如[&amp;a]表示引用捕获a变量,可修改值;</li><li>如[=]/[&amp;]表示值/引用捕获作用域的所有变量</li></ul></li><li><code>parameter list</code>,参数列表,传参嘛</li><li><code>specifiers</code>,限定符,少用,可忽视</li><li><code>exception</code>,异常说明符,少用,可忽视</li><li><code>-&gt; type</code>,返回值</li><li><code>function body</code>,函数体</li></ul><p>使用如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-keyword">int</span> i) -&gt; pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || i == n)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,nums&#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">get(i) 返回一个二元组/键值对,用来处理数组边界,比如nums[-1]/nums[n] (注:n == nums.size())</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="fma和mac"><a class="markdownIt-Anchor" href="#fma和mac"></a> FMA和MAC</h2><p>MAC(Multiply-Accumulation):乘积累加运算</p><p>FMA(fused-multiply-add):融合乘加运算</p><p>它俩实现的都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>←</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leftarrow a+b*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>这么一个操作,只用一条指令就可以完成(否则要用两条嘛),当然有相搭配的硬件(如乘数累加器)</p><p>不同之处在于MAC要规约2次,FMA规约1次即可(更精准,更快速,但也有一些问题)</p><p>参考文件:<a href="https://blog.csdn.net/qq_39444290/article/details/124939546">FMA和MAC区别</a></p><h2 id="ldd"><a class="markdownIt-Anchor" href="#ldd"></a> ldd</h2><p>这是一条神奇的指令,可以查看可执行文件所需要的动态库(<code>.dll</code>,<code>.so</code>)</p><p><code>ldd file</code></p><img src="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png" alt="ldd file" style="zoom:67%;" /><h2 id="神奇的环境变量名"><a class="markdownIt-Anchor" href="#神奇的环境变量名"></a> 神奇的环境变量名</h2><h3 id="ld_library_path"><a class="markdownIt-Anchor" href="#ld_library_path"></a> LD_LIBRARY_PATH</h3><p>在终端通过<code>echo $LD_LIBRARY_PATH</code>可以看到一些路径,这些路径是<strong>用于指定共享库/动态链接库的搜索路径</strong>.因此如果在运行可执行文件时报有<code>.so</code>或<code>.dll</code>库找不到的错误,可以通过ldd指令查看是否有库没有被找到</p><p>如果想添加一些别的动态库搜索路径,可以通过在<code>~/.bashrc</code>文件中导出环境变量,并用<code>source ~/.bashrc</code>刷新一下bashrc文件,即可实现</p><p>导出环境变量可以加在bashrc文件末尾,如:</p><p><code>export LD_LIBRARY_PATH=/lib:$LD_LIBRARY_PATH</code></p><p>其中:是路径的分隔符</p><p>参考文件:<a href="https://blog.csdn.net/qq_44534541/article/details/135500799">Linux环境变量LD_LIBRARY_PATH配置</a></p><h2 id="gdb小工具使用方法"><a class="markdownIt-Anchor" href="#gdb小工具使用方法"></a> GDB小工具使用方法</h2><p><strong>要使用GDB来进行代码调试以完成错误定位，在进行编译的时候要加上<code>-g</code>的选项</strong></p><p>生成可执行文件后，<strong>通过<code>gdb filename</code>的方式进行gdb调试程序</strong></p><p>首先<strong>通过<code>l</code>(list缩写)来查看当前程序的代码</strong></p><div class="note note-info">            <p>一般终端无输入即按回车是重复上一条指令</p>          </div><p><strong>通过<code>break funcName</code>来设置断点，也可以通过<code>break lineNum</code>行数来设置断点。可以通过<code>info break</code>来查看断点设置情况</strong></p><p><strong>执行<code>r</code>(run缩写)执行程序，程序会执行到端点处暂停，然后通过<code>n</code>(next缩写)单步越过执行/<code>s</code>(step缩写)单步步入执行，可以通过<code>c</code>(continue缩写)来直接执行到下一个断点处,又或者通过<code>u lineNum</code>(until缩写)来移动到执行的行数</strong></p><p><strong>通过<code>q</code>(quit退出调试程序)</strong></p><p>若是在执行到某一个函数内部,排查好了问题,想回到原函数,可以<strong>通过<code>finish</code>完成函数剩下的指令返回</strong>,也可以通过<code>return</code>立刻返回,不执行后面的指令</p><p>**如何调试内联汇编?**这是gdb对于算子开发的一个最重要的作用,因为别的错误我们好排查,而一旦牵扯到内联汇编,可能涉及到内存,寄存器的问题:</p><p>我们可以<strong>通过<code>layout asm</code>显示汇编代码的窗口</strong>,我们只需要打断点到指定的内联汇编开头,然后开启这个窗口,<strong>通过<code>si</code>(step instruction),单步执行指令</strong>,然后可以通过<code>p</code>(print)或display(更推荐)来指定一些想要观察的变量或寄存器(寄存器需要<code>display $v0</code>加个<code>$</code>),通过display的话每次执行一条指令都会打印我们跟踪的变量和寄存器的结果,这对于调试内联汇编代码非常有用,可以帮助我们观察一些寄存器和变量的实时变化情况</p><p><strong>参考文件:</strong></p><ul><li><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">GDB调试程序参考</a></li><li><a href="https://blog.csdn.net/litanglian9839/article/details/84966811">GDB-layout-1</a></li><li><a href="https://blog.csdn.net/zhangjs0322/article/details/10152279">GDB-layout-2</a></li><li><a href="https://blog.csdn.net/wohu1104/article/details/125083029">GDB一些参考</a></li></ul><h2 id="c之const的位置"><a class="markdownIt-Anchor" href="#c之const的位置"></a> c++之const的位置</h2><p><strong>const默认作用于其左边的东西,否则作用于其右边的东西</strong></p><blockquote><p>const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.</p></blockquote><p>例子:</p><ul><li><p><code>const int *</code>是一个指针指向一个常量整型 a pointer to a constant integer</p></li><li><p><code>int* const</code> 是一个常量指针指向一个整型 a constant pointer to an integer</p></li><li><p><code>int const * const</code> 是一个常量指针指向一个常量整型 a contanst pointer to a constant integer</p></li><li><p><code>...</code></p></li></ul><p>可以通过<strong>从右往左读</strong>的方式来理解,然后一般写的时候也建议按照<strong>eastern const style</strong>(把const放东边/右边)来写</p><div class="note note-info">            <p>注:看的时候脑子冒出来左结合右结合,搜了一下,<strong>结合性是为了处理具有相同优先级的运算符时,确定他们在表达式中结合的顺序</strong></p><p>左结合即是指在一个表达式中有多个具有相同优先级的运算符,它们在表达式中从左到右依次结合,如:<code>a + b + c</code> -&gt; <code>(a + b) + c</code></p><p>右结合即是指具有相同优先级的多个运算符在表达式中从右到左依次结合,如:<code>a = b = c</code> -&gt; <code>a = ( b = c)</code></p><p>参考文件:</p><ul><li><a href="https://blog.csdn.net/weixin_47441055/article/details/131384865">结合性,左结合,右结合</a></li></ul>          </div><p><strong>参考文件:</strong></p><ul><li><a href="https://www.zhihu.com/question/443195492/answer/1723886545">const位置摆放</a></li></ul><h2 id="c之namespace"><a class="markdownIt-Anchor" href="#c之namespace"></a> C++之namespace</h2><ol><li><strong>全局范围内定义</strong>,通过<code>namespace ns_name&#123;...&#125;</code>这样定义,不可以局部范围内定义;</li><li><strong>namespace可嵌套</strong>;</li><li><strong>namespace目的:避免命名冲突</strong>;</li><li>我们要使用某一命名空间内的变量/函数时:<ul><li><strong>用::(作用域限定符)来获得,如std::cin</strong>;</li><li><strong>命名空间全部展开</strong><mark>不推荐</mark><code>using namespace std;</code>;</li><li><strong>命名空间部分展开</strong><code>using std::endl;</code></li></ul></li></ol><div class="note note-info">            <p>其中作用域限定符有:全局范围的,类范围的,也有namespace范围的,使用如下:</p><ul><li>global scope: <code>::var</code></li><li>class scope: <code>class::var</code></li><li>namespace scope: <code>namespace::var</code></li></ul><p>通过访问左侧的scope来知道想要访问的var是哪里的</p>          </div><p><strong>参考文件:</strong></p><ul><li><a href="https://blog.csdn.net/2202_75303754/article/details/131782875">c++ namespace</a></li><li><a href="https://www.cnblogs.com/holm/articles/13715169.html">作用域限定符</a></li></ul><h2 id="c之左值纯右值将亡值"><a class="markdownIt-Anchor" href="#c之左值纯右值将亡值"></a> C++之左值,纯右值,将亡值</h2><ul><li><strong>左值(left-hand-side value)简称lvalue</strong></li><li><strong>纯右值(pure right-hand-side value)简称prvalue</strong></li><li><strong>将亡值(expiring value)简称xvalue</strong></li></ul><p>三者的由来与函数返回值相关:</p><ul><li><strong>直接存在寄存器里返回</strong></li><li><strong>直接操作用于接收返回值的变量(函数返回值转换为出参,由函数内部直接操作外部的栈空间)</strong></li><li><strong>使用匿名空间接收函数返回值,这是一个临时的内存空间,用完即析构</strong></li></ul><p>prvalue,lvalue,xvalue对应上述三种情况.</p><p>这三种值的出现与C<ins>是C的extension有关,C</ins>的结构体乃至类增加了构造函数和析构函数,并将之与变量的生命周期进行绑定有关</p><p>详细情况参看参考文件中腾讯技术工程对这一块的讲解</p><p><strong>参考文件:</strong></p><ul><li><a href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C++要分左右值</a></li></ul><h2 id="c平凡类型与非平凡类型"><a class="markdownIt-Anchor" href="#c平凡类型与非平凡类型"></a> c++平凡类型与非平凡类型</h2><p><strong>参考文件:</strong></p><ul><li><a href="https://blog.csdn.net/vviccc/article/details/138089766">C++11 内存布局术语解读（平凡类型、平凡可复制类型、标准布局类型）</a></li></ul><h2 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h2><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/650986900">C++11新特性</a></li></ul><h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2><p>参考文件:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/670068158">智能指针</a></li></ul><h2 id="elf文件格式了解"><a class="markdownIt-Anchor" href="#elf文件格式了解"></a> ELF文件格式了解</h2><p>ELF(Excutable Linkable Format)是linux下可执行文件的存储格式,是COFF(Comman File Format)的一种变体</p><p>目标文件,动态库,静态库以及可执行文件都用ELF文件格式来进行存储</p><p>一般二进制文件的存储格式中都有文件头,是通过读文件头来确认如何解析文件(个人感觉文件头存储了许多的元数据)</p><p>补Elf64_Ehdr和Elf64_Shdr,前者是ELF文件头,里面有比如段表(节头表Section Header Table)的信息,比如有多少个段,段大小,段偏移;后者则是记录每个段表的元信息</p><p>参考文件:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/544198038">从零解析ELF目标文件(附源码)</a></li><li><a href="https://blog.csdn.net/qq_42570601/article/details/124695589">链接装载与库：第三章——ELF文件结构</a></li></ul><h2 id="decltype和auto"><a class="markdownIt-Anchor" href="#decltype和auto"></a> decltype和auto</h2><p>参考文件:</p><ul><li><a href="https://www.jianshu.com/p/17503803561e">深入解析decltype和decltype(auto)</a></li><li><a href="https://www.cnblogs.com/linxmouse/p/17567763.html">C++11容易遗忘的特性整理与理解</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/63207620/answer/1707221853">https://www.zhihu.com/question/63207620/answer/1707221853</a><br /><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>little-knowledge-of-loadable-kernel-module</title>
    <link href="/2023/11/15/little-knowledge-of-loadable-kernel-module/"/>
    <url>/2023/11/15/little-knowledge-of-loadable-kernel-module/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>How-to-use-slurm</title>
    <link href="/2023/11/15/How-to-use-slurm/"/>
    <url>/2023/11/15/How-to-use-slurm/</url>
    
    <content type="html"><![CDATA[<h2 id="slurm是什么"><a class="markdownIt-Anchor" href="#slurm是什么"></a> slurm是什么</h2><p>slurm</p><h2 id="基础用法"><a class="markdownIt-Anchor" href="#基础用法"></a> 基础用法</h2><h2 id="slurm脚本编写"><a class="markdownIt-Anchor" href="#slurm脚本编写"></a> slurm脚本编写</h2><p>参考文章:<br />1.<a href="https://zhuanlan.zhihu.com/p/216153362">Slurm概述架构</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>slurm</tag>
      
      <tag>distribution</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Initial bash usage</title>
    <link href="/2023/11/15/Initial-bash-usage/"/>
    <url>/2023/11/15/Initial-bash-usage/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PipeDream-Partition-Algorithm</title>
    <link href="/2023/11/03/PipeDream-Partition-Algorithm/"/>
    <url>/2023/11/03/PipeDream-Partition-Algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="pipedream划分算法理论部分"><a class="markdownIt-Anchor" href="#pipedream划分算法理论部分"></a> PipeDream划分算法理论部分</h2><p><strong>PipeDream会在可用的机器间自动划分模型的层以最小化整体的训练时间</strong></p><p>以下是PipeDream划分算法的工作流程图，不难看出PipeDream对输入的DNN采用PipeDream Profiler进行profile，会获得每一个层的相关数据（下面对profile过程会细讲），之后输入一定数目的机器给PipeDream optimizer，在其上面执行划分算法和确定重复因子。至此，便完成了PipeDream对DNN的划分。</p><p><img src="https://s2.loli.net/2023/11/28/IZoDzmGyEqfCjTB.png" alt="PipeDream partition algorithm workflow" /></p><p>PipeDream划分算法的大致流程如下：对一个给定的N层DNN和M台可用的机器</p><ol><li><strong>PipeDream首先在一个机器上对模型进行profile；</strong></li><li><strong>执行划分算法将层划分为stage；</strong></li><li><strong>同时确定每个stage的重复因子以最小化模型的整体训练时间。</strong></li></ol><h3 id="profile-dnn模型"><a class="markdownIt-Anchor" href="#profile-dnn模型"></a> Profile DNN模型</h3><p>profile是用来记录每个层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>的一些指标的，这里记录的是：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： 在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的前向和反向传递的总计算时间</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层在前向传递时的输出激活的大小/在反向传递时输入梯度的大小</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">w_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层参数的大小</li></ul><p>其中在PipeDream中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是通过多个mini-batch来统计得出的</p><p>而所有的通信都分三个步骤进行：</p><ol><li>将数据从GPU移到发送方的CPU；</li><li>发送数据，从发送到发送到接收方；</li><li>将数据从CPU移到接收方的GPU。</li></ol><p>显然2相较于1和3更耗时长，采用2来估计通信所需花费的时间，即是用该层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>除于对应的带宽，即可以得到层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>到层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>通信所需花费的时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">C_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>而每个worker（计算节点）在配置有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>台机子做数据并行的通信量是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{4(m-1)*|w_l|}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，这个通信量是采用AllReduce计算而得的，则利用一个分布式参数服务器来为该层做权重同步所花费的时间为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>l</mi><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">W_l^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9664379999999999em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span></p><div class="note note-info">            <p>因为朴素的AllReduce和Ring AllReduce一类的通信量是一样的，只是解决了存在的带宽瓶颈问题。这里就以AllReduce的来进行通信量计算</p><p>某一个server（本身也是一个worker，比如是rank0）接收所有worker的参数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，而后将更新后的参数返还给所有worker：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，其中该过程采用FP16来存储参数，故总通信量为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">4(m-1)*|w_l|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span>，每个worker的通信量则为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>4</mn><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi mathvariant="normal">∣</mi><msub><mi>w</mi><mi>l</mi></msub><mi mathvariant="normal">∣</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{4(m-1)*|w_l|}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.02691em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>          </div><h3 id="划分算法"><a class="markdownIt-Anchor" href="#划分算法"></a> 划分算法</h3><p>划分算法是在profile完成后进行的，会用到profile的输出结果</p><p>我们的目标是<strong>最小化模型整体的训练时间即等价于最小化最慢stage的时间</strong></p><p>这里介绍划分算法中涉及到的几个概念：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表示在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">1\rightarrow j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层间使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个机子最优流水线的最慢stage所花费的时间；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>i</mi><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(i\rightarrow j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>表示一个单独的stage在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\rightarrow j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>层，采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个机子做数据并行所花费的时间，其中该时间计算公式如下：(之所以采用二取一是因为通信和计算存在重叠，不用add起来)<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p></li></ul><p>此外，这里还涉及了一个让流水线处于繁忙状态的**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>O</mi><mi>A</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">NOAM</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><strong>，即</strong>最优的mini-batch数目**，通过如下公式计算而得：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>O</mi><mi>A</mi><mi>M</mi><mo>=</mo><mfrac><mi>M</mi><mrow><mi>m</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>s</mi><mspace width="1em"/><mi>i</mi><mi>n</mi><mspace width="1em"/><mi>t</mi><mi>h</mi><mi>e</mi><mspace width="1em"/><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mspace width="1em"/><mi>s</mi><mi>t</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">NOAM=\frac{M}{machines\quad in\quad the\quad input\quad stage}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3534389999999998em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight">e</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span><span class="mspace mtight" style="margin-right:1.4285714285714286em;"></span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>其中动规的公式分为只有一个stage和多个stage的情况：</p><ul><li><p>一个stage</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,m) = T(1\rightarrow j,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>多个stage</p><p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲\begin{split}…'>\begin{align*}\begin{split}A(j,m) = \min_{1\le i\lt j} \min_{1\le m` \lt m} \max \left \{\begin{array}{}A(i,m-m`) &amp;①\\ 2*C_i &amp;②\\T(i+1 \rightarrow j,m`) &amp;③\\ \end{array}\right .\end{split}\end{align*}</p></li><li></li></ul><p>显然我们是在①、②、③这三个公式，找到此时的最慢stage，而后改变行列（行对应层数，列对应数据并行的机子数），找到<strong>最优流水线的最慢stage</strong>。因为是采用动态规划处理，而动态规划具有<strong>最优子结构、无后效性和重叠子问题三大性质</strong>,因此即使是子问题，所求得的结果也是最优的(<strong>最优子结构</strong>)，最后的结果是在最优的子问题上进行叠加的，而后续问题的发展又不会影响到子问题的解(<strong>无后效性</strong>)，而采用表格存储可以避免重复计算(重叠子问题)。当然后续一些多维并行的也会用到动态规划，但会采取融合算子，剪枝等方式减少搜索空间，因为PipeDream的是二维的，且空间很小，所以没用到相应技巧。</p><p>以下是动规的初始化部分，当完成了初始化后，便可以代入上式的公式进行计算，计算到终止条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(N,M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>时则会停止</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(1,m) = T(1\rightarrow 1,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">m \in [1,M]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo>→</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(j,1) =T(1\rightarrow j,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j \in [1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span></li></ul><h2 id="pipedream划分算法代码部分"><a class="markdownIt-Anchor" href="#pipedream划分算法代码部分"></a> PipeDream划分算法代码部分</h2><h3 id="profilesup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream-profile"><a class="markdownIt-Anchor" href="#profilesup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream-profile"></a> 🔷profile<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream-Profile</h3><p>&quot;&gt;[1]</span></a></sup></p><p>profile的目的是获得每个层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">w_l,T_l,a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，主要的函数调用步骤如下：</p><ol><li>在<strong>训练</strong>的时候先获取<code>summary</code>，这个函数(<code>torchsummary.summary()</code>)可以计算网络的参数信息，然后调用<code>create_graph()</code>，这个函数的目的在于通过内部的调用，生成模型的DAG图；</li><li><code>create_graph()</code>内部会调用<code>torchgraph.GraphCreator()</code>，构造一个<code>GraphCreator</code>实例，这个实例的类内部定义了相关的钩子函数<code>hook_modules()</code>，可以为模型的子模块设置钩子，以追踪其内部的关联信息，然后利用<strong>模型运行</strong>，获得该信息，最后<code>unhook_modules()</code>把给子模块设置的钩子撤掉，并将profile的结果通过该类内部的<code>persist_graph()</code>方法给持久化成.dot,.txt,.pdf等类型，便于后续使用；</li><li><code>GraphCreator</code>的实例记作<code>graph_creator</code>,在初始化的时候，会把<code>model</code>,<code>module_whitelist</code>,<code>summary</code>这些作为实例变量，同时增加了<code>forward_original_methods</code>这个字典用来存储子模块和子模块的原生<code>forward</code>方法，还增加了<code>graph</code>类的实例。还有个<code>inputs</code>字典，用来存储<mark>好像是</mark>子模块和子模块经由<code>TensorWrapper</code>包装后的tensor；</li><li><code>graph_creator</code>实例通过调用<code>hook_modules()</code>这个方法，该方法内部通过调用<code>forward_wrapper()</code>和<code>forward_wrapper_root()</code>方法，来将子模块和模型的<code>forward</code>进行替换：<code>sub_module.forward = forward_wrapper().__get__(sub_module,sub_module.__class__)</code>。而这俩方法内部，分别将子模块和模型设置为<code>Tensorwrapper</code>（<mark>这一块的代码看不大懂，输入的是<code>sub_module</code>，但好像用作tensor？（之后debug看下这部分内在怎么运行的）</mark>），并且为图构造边；</li><li>上面说到的<code>TensorWrapper</code>,它内部根据我们输入的<code>node_desc</code>，就是对节点的形容，来判断并从<code>summary</code>中获取对应元素，获取它的forward pass和backward pass的时间，激活大小，参数大小等，包装为<code>_node</code>这个成员变量；</li><li>当模型运行后，获得了profile信息（<strong>整个模型的内部DAG图的构造是在<code>forward_wrapper()</code>这个function里完成的</strong>），采用persist_graph()给持久化成.dot文件（可视化一下），也持久化成.txt，便于后续使用。</li></ol><h3 id="compute-partitionsup-idfnref2-classfootnote-refa-hreffn2-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream计算分区"><a class="markdownIt-Anchor" href="#compute-partitionsup-idfnref2-classfootnote-refa-hreffn2-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream计算分区"></a> 🔷compute partition<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream计算分区</h3><p>&quot;&gt;[2]</span></a></sup></p><p>在计算分区的部分有两个很重要的概念,一个是<strong>增强反链</strong>,一个是<strong>后继反链</strong></p><p><strong>计算增强反链的目的是,更好的计算节点的时间</strong>,即将一个节点的增强反链内的节点视作一个大节点(或者说视作统一的一个状态),它们的输出激活也统一看待.</p><p>**怎么样去找到一个节点的增强反链呢?**首先我们是将本节点纳入到它对应的增强反链的list中,然后在它这个节点的全部前序节点中,找到有分叉的节点,且分叉节点的出边目的节点不在全部前序节点中且也不是本节点,则这个分叉节点就可以加入到该节点的增强反链中去.</p><p>**为什么要找这样的分叉点呢?**我们的模型是可以流水线并行的,也就是说对于节点而言,它的运行时间实际上是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mo stretchy="false">{</mo><mtext>输入时间</mtext><mo separator="true">,</mo><mtext>执行时间</mtext><mo separator="true">,</mo><mtext>输出时间</mtext><mo stretchy="false">}</mo></mrow></mrow><annotation encoding="application/x-tex">max{\{输入时间,执行时间,输出时间\}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord"><span class="mopen">{</span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">输</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">}</span></span></span></span></span>这三个时间中找到最大值,那么对于一个节点的输入,它如果前序节点中存在分叉节点,这个分叉节点要输出数据给至少两个节点,那么这其中是否存在依赖关系是不可而知的,就比如另一个传完了,我才可以将结果向本节点输出,那因为未知,所以把它当作一个整体来考虑则更为妥当.计算出来节点的时间会更加精准合适.</p><p><strong>计算后继反链的目的是找到下一个图分割点</strong></p><p>**怎么去找到一个节点的后继反链呢?**首先,找到该节点的增强反链,获取增强反链中节点的出边的目的节点(后继嘛,就是后面的节点,且这个后继反链是相对于增强反链而言的,所以用增强反链中的去找),根据输入的节点的<code>antichain</code>过滤一波,剩下的预备役后继节点,一个个抓出来,跟增强反链一起丢进一个函数判断是否能成为后继节点,即判断预备役后继节点的successor与增强反链是否存在交集,不存在则说明这个预备役后继节点后面走的路不会又绕回去,则它是一个真正的后继节点.如此判断,将它们加入到对应的dict中.</p><p>而把这两个概念使用在一起的时候是当我们**建立<code>antichain_dag</code>**的时候</p><p><strong>如何建立<code>antichain_dag</code></strong>:</p><p>在graph里有个<code>antichain_dag()</code>,通过这个建立,主要的逻辑是:</p><ol><li>获取sources中的第一个源点,构造其的<code>&#123;tuple(sorted(antichain)) : AntichainNode&#125;</code>(这里的<code>antichain</code>就是[node8]这样的东东,然后将这个antichain去实例化AntichainNode类,就得到了<code>antichain_mapping</code>中的一个item);</li><li>然后把这个用AntichainNode实例后的<code>source_node</code>加入到<code>antichain_dag.source</code>中</li><li>把antichain置入<code>antichain_queue</code>中,后期做类似bfs的操作用到它,把1中的item加入<code>antichain_mapping</code>中</li><li>在类bfs的循环中,通过pop出首个antichain,然后获取它的后继反链,遍历后继反链中的节点,如果没有在<code>antichain_mapping</code>中的话就给它实例化为反链节点(AntichainNode),然后加入mapping中,并将其与antichain构造边(antichain-&gt;next_antichain,反链DAG中的边,注意它的这个节点是antichain和next_antichain对应的AntichainNode实例),然后把这个后继节点加入队列中.</li></ol><p>如此循环,这个反链DAG就完成了,有以下需要注意的:</p><ul><li>因为构建顺序是先增强反链(AntichainNode)后后继反链,所以如果节点antichain在后继反链dict中说明已经被记录过了,则直接continue就好;</li><li>如果后继节点在<code>antichain_mapping</code>里面,说明前面给它构建过反链节点(AntichainNode)了(因为一个节点有可能是多个节点的后继节点),但依旧需要构建新的边,就是你新的大节点/状态,它们对这个后继节点都有指向,这也对应了前面说的找后继节点,就是找图分割点;</li></ul><p><strong>总的来说<code>antichain_dag</code>中的节点就是原生节点对应反链节点(增强反链形成的大节点/状态),而关系,即边的连接则是原dag中的antichain和next_antichain,就是原DAG中的原节点和后继反链节点形成的关系,不过是用反链节点link起来的</strong>(<mark>感觉就是原DAG去了环(其实也不是,因为DAG本来就没环…,只是一种形状上的描述,找不到好的词语形容,自己画图感受),所谓的环通过增强反链替代成大节点,后继反链则是找到大节点的出边节点</mark>)</p><p>计算分区初步做的事情分为以下四步:</p><ol><li>去掉输入的source.因为输入就在第一层,之后convert model再加上,不用让optimizer决定放哪;</li><li>去掉无用的输出,就是sink中<code>node_desc</code>为(<code>__getitem__</code>)这种的;</li><li>构建<code>antichain_dag</code>;</li><li>对<code>antichain_dag</code>进行拓扑排序</li></ol><p>在经过对<code>antichain_dag</code>进行拓扑排序后,可以得到<strong>顺序执行的线性序列</strong>,由<code>states</code>承载.</p><div class="note note-info">            <p>此处对上面的过程做一个总结:</p><p>在<code>antichain_dag()</code>中,我们通过对profile生成的DAG(注意此时已对作为输入的source和无用的sink进行删除)获取它结点的增强反链,并构成<code>AntichainNode</code>,然后找到它的后继反链,对后继反链的结点生成<code>AntichainNode</code>,然后构造<code>AntichainNode[antichain]=&gt;AntichainNode[next_antichain]</code>的边,循环迭代,构造完反链DAG</p><p>据上可知增强反链是反链DAG节点的一个重要属性,而原DAG是依据后继反链来划分的反链节点,而后对反链DAG做拓扑排序(实际就是对增强反链做拓扑排序),最终得到states,states是反链节点的一个list,拓扑排序好了的.</p>          </div><p>获得了states,就到了<strong>自动分区</strong>的部分</p><p>在开始正式自动分区的介绍前,就是进入<code>compute_partitioning()</code>之前,有如下举动:</p><ul><li>计算了每个state的<strong>输出激活值大小</strong>,就是<strong>根据它们的增强反链的节点的输出激活值大小,来累加到<code>states[i].output_activation_size</code></strong>.这里的<strong>输出激活值大小是state的必要前序节点给自己的输出</strong>;</li><li>计算了每个state的<strong>计算时间,激活值大小,参数值大小</strong>,通过遍历原dag每个state的前置节点以进行累加;</li></ul><p>上面这些都是作为state的属性/成员变量而存在的.比如:</p><p><code>state.output_activation_size</code> <code>state.compute_time</code> <code>state.activation_size</code> <code>state.parameter_size</code></p><p><mark>需要注意:<code>output_activation_size</code>和<code>activation_size</code>是不一样的</mark></p><ul><li>计算了个<strong>总输出激活值大小<code>output_activation_sizes</code></strong>;</li><li>计算了<strong>每个state在反链dag的前序节点<code>all_predecessor_ids</code></strong></li></ul><p><mark>需要注意:这里的前序节点是反链DAG的</mark></p><ul><li>计算了states之间的计算时间,激活值大小,参数值大小,这是一个二维数组,表示的是<code>i-&gt;j</code>的时间,激活值,参数值,大致形式如下:</li></ul><p><img src="https://s2.loli.net/2024/03/14/FyRl7a9Vv8Qm31Y.jpg" alt="states之间的差" /></p><p>比如第一行,表示的是<code>state0-&gt;state[0,...,n-1]</code>所花费的计算时间/激活值大小/参数值大小;</p><p>第二行则代表的是<code>state1-&gt;state[1,...,n-1]</code>所花费的计算时间/激活值大小/参数值大小;就是要减去<code>state0</code>的值.以此类推~</p><hr /><p>在开始进入到<code>compute_partitioning()</code>这个函数前,有两个变量不是很懂是干嘛的,希望看完之后可以弄懂==<code>counter</code> <code>num_machines_in_machine</code>==,通过遍历机器集和带宽,进行多次计算分区</p><p><strong>🔷 计算分区(根据dp找最优化结果)<code>compute_partitioning</code></strong></p><p><strong>🔷 分析分区(根据最优化结果做分区)<code>analyze_partitioning</code></strong></p><h3 id="convert-modelssup-idfnref3-classfootnote-refa-hreffn3-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream转换模型"><a class="markdownIt-Anchor" href="#convert-modelssup-idfnref3-classfootnote-refa-hreffn3-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream转换模型"></a> 🔷convert models<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream转换模型</h3><p>&quot;&gt;[3]</span></a></sup></p><h3 id="runtimesup-idfnref4-classfootnote-refa-hreffn4-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream运行时引擎"><a class="markdownIt-Anchor" href="#runtimesup-idfnref4-classfootnote-refa-hreffn4-relfootnotespan-classhinttop-hintrounded-aria-labelpipedream运行时引擎"></a> 🔷runtime<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label=&quot;PipeDream运行时引擎</h3><p>&quot;&gt;[4]</span></a></sup></p><h2 id="pipedream划分算法代码中使用到的自定义类解析"><a class="markdownIt-Anchor" href="#pipedream划分算法代码中使用到的自定义类解析"></a> PipeDream划分算法代码中使用到的自定义类解析</h2><h3 id="graph类"><a class="markdownIt-Anchor" href="#graph类"></a> Graph类</h3><p>PipeDream中的Graph类有的属性和方法大致介绍:<br />涉及到的一些名字介绍:</p><ul><li>source -&gt; 源点,入度为0的点</li><li>sink -&gt; 汇点,出度为为0的点</li><li><strong>链是指节点集合,且里面的节点间是存在单向可达的关系</strong>,即要么x到y是可达的,或者y到x是可达的</li><li><strong>反链是指节点集合,且里面的节点间是不可达的</strong>,即x到y是不可达的且y到x是不可达的</li></ul><p>属性部分:</p><ul><li><p>edges 边dict(出边,key对应的是箭尾的点,value是个list,对应的是箭头的点)</p></li><li><p>in_edges 边dict(入边,key对应的是箭头的点,value是个list,对应的是箭尾的点)</p></li><li><p>nodes 节点dict</p></li><li><p>_predecessors 前序节点dict</p></li><li><p>_successors 后继节点dict</p></li><li><p>_augmented_antichains 增强反链dict <code>&#123;Tuple(Node.node_id) : List[Node.node_id]&#125;</code></p><div class="note note-info">            <p><strong>增强反链 = 当前节点 + 部分前序节点</strong></p><p>找增强反链的部分前序节点的方法:</p><ol><li>获取当前节点的全部前序节点</li><li>若前序节点的出边目的节点不在当前节点的全部前序节点中,也不是当前节点,则将其加入增强反链中</li></ol><p>总之,<strong>增强反链中的部分前序节点,是存在分叉的节点,且其分叉的去向与当前节点的已走过的路径无关</strong></p>          </div></li><li><p>_next_antichains 后继反链dict</p><div class="note note-info">            <p><strong>后继反链的查找方式如下：</strong></p><ol><li>对输入的反链寻找增强反链；</li><li>对其增强反链进行遍历，获取增强反链节点，获取其出边对应的箭头节点</li><li>遍历出边的箭头节点们，已在反链中则不予理睬，而后进入<code>is_next_antichain()</code>进行判断</li><li>若箭头节点的后续节点不在增强反链中，则证明其为后继反链节点</li><li>将其加入输入反链作key的后继反链中</li></ol>          </div></li><li><p>_antichain_dag 反链DAG</p><p>与其说_antichain_dag是反链DAG，其内部的节点是AntichainNode类的实例，它内部的antichain代表的该节点的增强反链，而图的结构关系体现的是后继反链的关系，我们保存了它的source，根据source即可遍历出每一个节点对应的后继反链，可以依次整理出<code>antichain_mapping</code>的关系，这个mapping即是<code>&#123;Tuple(Node.node_id) : AntichainNode&#125;</code>的关系</p></li></ul><p>方法部分:</p><ul><li>copy() # 复制一张新图</li><li>sources() # 返回一个源点列表</li><li>sinks() # 返回一个汇点列表</li><li>add_node()</li><li>remove_node()</li><li>reset() # 重置前序节点集和后继节点集</li><li>add_edge()</li><li>remove_edge()</li><li>to_dot() # 生成dot文件,即是训练模型的dag图</li><li>topological_sort() # 拓扑排序，下面那个helper也是，主要是helper递归，对antichain_dag进行拓扑排序，生成线性序列,利用<code>states</code>存储</li><li>topological_sort_helper()</li><li>augment_antichain # 根据输入的反链，寻找增强反链</li><li>deaugment_augmented_antichain() # 这个没搞懂</li><li>next_antichains() # 根据输入的反链，找到其后继反链</li><li>is_next_antichain() # 判断是否符合后继反链，通过获取输入的<code>new_node</code>的后续节点，来判断该节点的后续节点是否在输入给定的增强反链<code>augmented_antichain</code>中，若不在，则返回True，即是新的后继反链的节点</li><li>construct_antichain() # 构造新的反链，里面调用的是deaugment那个函数，然后这个方法是在后继反链节点被is_next_antichain()判断为True后调用的</li><li>antichain_dag() # 构造反链DAG，实际DAG结构体现后继反链关系，节点内部体现增强反链关系</li></ul><h3 id="node类"><a class="markdownIt-Anchor" href="#node类"></a> Node类</h3><p>属性部分:</p><ul><li>node_id 节点id号,比如<code>node58</code></li><li>node_desc 形容节点作用,比如<code>Add(inplace)</code>这样的</li><li>forward_compute_time</li><li>backward_compute_time</li><li>activation_size</li><li>parameter_size</li><li>stage_id</li><li>depth</li><li>height</li></ul><p>方法部分:</p><ul><li><p>__str__()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%s -- %s -- forward_compute_time=%.3f, backward_compute_time=%.3f, activation_size=%s, parameter_size=%.3f%s&quot;</span> % (<br>            self.node_id, node_desc, self.forward_compute_time, self.backward_compute_time,<br>            activation_size, self.parameter_size, stage_id_str)<br></code></pre></td></tr></table></figure><p>给出的一个例子:<code>node58 -- Add(inplace) -- forward_compute_time=0.000, backward_compute_time=0.000, activation_size=102760448.000, parameter_size=0.000</code></p></li><li><p>from_str() # 静态方法，</p></li></ul><h3 id="antichainnode类"><a class="markdownIt-Anchor" href="#antichainnode类"></a> AntichainNode类</h3><p><strong>该类继承了<code>Node</code>类</strong></p><p>该类在<code>antichain_dag</code>此方法内被频繁实例化，以<strong>构建后继反链节点对应的增强反链</strong>，因为<strong>后继反链节点它是要被用来作分割的</strong>，那么它如果有一些<strong>前序节点</strong>是存在<strong>分叉</strong>的，即<strong>可能存在执行的依赖关系</strong>，因此需要<strong>把这些点看作一个整体，把输出激活统一统计，存放于AntichainNode这个节点中，并且利用相关属性把增强反链涉及到的节点进行存储</strong>。</p><p>属性部分：</p><ul><li>antichain 反链，实际上这里是增强反链</li><li>output_activation_size 统计增强反链的输出激活大小</li></ul><p>方法部分：</p><ul><li><p>__str__() # 就把打印的格式给重构了一下</p><p><code>return &quot;%s -- %s&quot; % (self.node_id, self.antichain)</code></p></li></ul><h3 id="graphcreator类"><a class="markdownIt-Anchor" href="#graphcreator类"></a> GraphCreator类</h3><p>属性部分:</p><ul><li>model 模型,用于后面给子模块</li><li>module_whitelist 白名单,处于子模块白名单</li><li>summary 由torchsummary这个包的summary函数获得</li><li>forward_original_methods 以{sub_module: sub_module.forward}形式存储了原始的子模块的forward函数</li><li>graph Graph类的实例对象</li><li>inputs 这个inputs,它的kv大概是这样的:{sub_module: sub_module TensorWrapper类的实例}</li></ul><p>方法部分:</p><ul><li>hook_modules() # 给子模块加钩子函数,具体做法是通过遍历子模块,为无后继部分的子模块或是白名单中的子模块更换forward函数,通过<code>sub_module.forward = forward_wrapper.__get__(sub_module,sub_module.__class__)</code>方法来更换,此种即是使得<code>forward_wrapper(sub_module)</code>延迟触发.内部还定义了两个方法:<ul><li>forward_wrapper() # 把sub_module给包装成TensorWrapper</li><li>forward_wrapper_root()</li></ul></li><li>unhook_modules() # 利用<code>forward_original_methods</code>把<code>forward</code>函数还原</li><li>persist_graph() # 持久化图,生成<code>graph.dot</code>(可视化的dag图),生成graph.txt,保存为条状图和对应的pdf文件</li></ul><h3 id="tensorwrapper类"><a class="markdownIt-Anchor" href="#tensorwrapper类"></a> TensorWrapper类</h3><p>属性部分:</p><ul><li>tensor</li><li>object_id 这是一个全局参数</li><li>node_desc</li><li>graph_creator</li><li>activation_size</li><li>_node 这个是包装好的node</li></ul><h3 id="torchsummary库下的summary方法"><a class="markdownIt-Anchor" href="#torchsummary库下的summary方法"></a> torchsummary库下的summary方法</h3><p>这个方法是真正进行forward_compute_time等的部分,与pip的torchsummary库不一样,经由TensorWrapper整理(实际上它是把统计好的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>w</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">T_l,a_l,w_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>信息给包装起来,通过Node类包装)</p><p>参考文章:</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/7010557652107264007">PipeDream-Profile</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/7003637901279887367">PipeDream计算分区</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://juejin.cn/post/7005168160466796552">PipeDream转换模型</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://juejin.cn/post/7006591502625275934">PipeDream运行时引擎</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>PipeDream</tag>
      
      <tag>Partition Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Read paper: ZeRO-Infinity</title>
    <link href="/2023/08/29/Read-paper-ZeRO-Infinity/"/>
    <url>/2023/08/29/Read-paper-ZeRO-Infinity/</url>
    
    <content type="html"><![CDATA[<h2 id="zero-infinity"><a class="markdownIt-Anchor" href="#zero-infinity"></a> ZeRO-Infinity</h2><h3 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h3><p>处理的是<strong>GPU内存墙</strong>的问题,是一个<strong>新的异构系统技术</strong>,利用了<strong>GPU,CPU,NVMe的内存</strong>,在有限的资源去达到史无前例的模型规模,而无需进行代码重构.同时,它能达到优异的训练吞吐量和可扩展性,<strong>不受CPU或者NVMe带宽的限制</strong></p><p>在现在的GPU集群中,能达到万亿乃至十万亿的参数量</p><p>在单个DGX-2节点上能微调万亿参数量级别的模型</p><p>超线性的可扩展性</p><h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><h4 id="how-to-increase-model-scale"><a class="markdownIt-Anchor" href="#how-to-increase-model-scale"></a> How to increase model scale</h4><ul><li>训练模型的系统技术进步</li><li>并行技术如流水线并行,张量并行,ZeRO等的使用</li></ul><h4 id="why-gpu-memory-is-the-bottleneck"><a class="markdownIt-Anchor" href="#why-gpu-memory-is-the-bottleneck"></a> Why GPU memory is the bottleneck</h4><p>DeepSpeed实现的3D并行能在800张V100的卡上扩展到万亿级别的参数量,通过充分利用集群中聚合的GPU内存;对于A100的卡而言,则需要320张才可以做到万亿参数量;而若是想要训练百万亿参数量,即使GPU的内存可以翻5倍(指80GB -&gt; 400GB),也需要6K张卡才可以训练到.<strong>So GPU memory is the bottleneck</strong></p><h4 id="what-does-gpu-memory-wall-effect-data-scientist"><a class="markdownIt-Anchor" href="#what-does-gpu-memory-wall-effect-data-scientist"></a> What does GPU Memory Wall effect data scientist</h4><p>GPU内存墙也限制了Data Scientist对模型进行微调.由于模型量大,微调它们虽然比预训练的工作需要更少的GPU资源,但是也让人举步维艰.即使可以访问特定的计算资源,但是在计算节点上被分配的内存也有限,这又反过来使得想微调的模型大小受限.这样就使得没资源(大规模的GPU集群)的人,无法做大模型微调的工作</p><div class="note note-warning">            <p>原文有一句: For example fine-tuning GPT-3 would require over 8 DGX-2 nodes(128 GPUs) with 3D parallelism to just fit the model for training, even though a single DGX-2 node (16-GPUs) has enough compute to fine-tune it in a reasonable time.</p><p>不知道作者是想表达fine-tune比pre-train更cheap;</p><p>还是说即使更cheap,对大多数研究人员也内存墙;</p><p>还是指有些平台需要fine-tune的资源等价于pre-train的资源,即使可以有更合理更节省的方案</p>          </div><h4 id="3d-parallelism-lack-of-usability-and-flexibility"><a class="markdownIt-Anchor" href="#3d-parallelism-lack-of-usability-and-flexibility"></a> 3D parallelism lack of usability and flexibility</h4><p>3D并行性需要对代码重构,施加DP,PP,TP.但是PP即流水线并行它<strong>对于一些具有复杂依赖的模型无能为力</strong>,因为<strong>不能拆分为负载均衡的stage</strong></p><h4 id="unprecedented-model-scale"><a class="markdownIt-Anchor" href="#unprecedented-model-scale"></a> Unprecedented Model Scale</h4><ul><li><strong>infinity offload engine</strong></li></ul><p>GPU资源是有限,我们可以offload数据到CPU和NVMe上,以此支持训练大模型</p><ul><li><strong>memory-centric tiling</strong></li></ul><p>优化GPU内存,以支持超大参数的单个层放入GPU内存中</p><h4 id="excellent-training-efficiency"><a class="markdownIt-Anchor" href="#excellent-training-efficiency"></a> Excellent Training Efficiency</h4><ul><li><strong>bandwidth-centric partitioning</strong></li></ul><p>引入一种新的数据分区策略以利用所有设备的聚合内存带宽</p><ul><li><strong>communication overlap-centric design</strong></li></ul><p>应该是遮掩通信的开销</p><ul><li><strong>optimization for NVMe access</strong></li></ul><p>优化NVMe访问,应该是对offload数据,以及回传数据进行优化</p><h4 id="ease-of-use"><a class="markdownIt-Anchor" href="#ease-of-use"></a> Ease of Use</h4><p>无需重构代码(<mark>个人感觉是说pretrain的代码finetune无需调动</mark>),无需使用3D并行(<mark>根据contribution的说法来看,应该是不使用TP</mark>),对任意的模型架构均会自动执行训练时所需的所有通信和数据分区</p><h3 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> Related Work</h3><h3 id="memory-requirements"><a class="markdownIt-Anchor" href="#memory-requirements"></a> Memory Requirements</h3><p>用于深度学习训练,本文主要集中于分析基于transformer架构的模型,因为全部超过1billion参数的SOTA的模型都是基于transformer架构的.</p><p>本文的分析是基于<strong>混合精度训练</strong>以及采用<strong>Adam优化器</strong>(采用此optimizer已经变成了基于transformer模型的一个标准,因此用它)</p><p>将讨论的内存分类:</p><ul><li>model state: [optimizer state,gradient,model parameter]</li><li>residual state: 主要指的是激活(activation)内存</li></ul><p><strong>GPU的工作内存</strong>是指<strong>GPU必须的可用于支持训练的最小内存,<em>假设model and residual states可以从GPU内存中被成功的卸载</em></strong></p><h4 id="memory-for-model-states"><a class="markdownIt-Anchor" href="#memory-for-model-states"></a> Memory for Model States</h4><ul><li>parameter和gradient是用<strong>FP16</strong>来存储</li><li>optimizer states包含了momentum,variance,parameters和gradients,都是用<strong>FP32</strong>来存储</li></ul><p>因此我们可得知<strong>一个参数需要20个字节的内存</strong></p><p>用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>来代表hidden dimension,用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">nl</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>表示transformer层的数目.<strong>考虑到在一个transformer块中几乎所有参数是来自块内的四个线性层</strong>:其中两个在多头注意力机制中①input -&gt; QKV ([<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">3hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]);②<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>O</mi></msup></mrow><annotation encoding="application/x-tex">W^O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span></span></span> ([<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]);剩下两个在FFN中③[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>];④[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>].因此<strong>总参数量</strong>可以表示为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>12</mn><mo>∗</mo><mi>n</mi><mi>l</mi><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">12 * nl *{hd}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>Model States所需的<strong>总内存则乘于每个参数所需的20个字节</strong>,即为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>240</mn><mo>∗</mo><mi>n</mi><mi>l</mi><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">240*nl*{hd}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="memory-for-residual-states"><a class="markdownIt-Anchor" href="#memory-for-residual-states"></a> Memory for Residual States</h4><p>Residual States主要包含的是activation memory,它的参数主要取决于模型的架构:批处理大小<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>s</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">bsz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>,序列长度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">seq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span></p><p>本文采用<strong>activation checkpoint</strong>的方式来对activation所需的内存进行减少,因此存储的是激活检查点的数据</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ci</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span></span></span></span>用于表示两个activation checkpoints间的transformer block的个数,因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mi>l</mi></mrow><mrow><mi>c</mi><mi>i</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{nl}{ci}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>表示的是激活检查点的个数</p><p>激活检查点所需的<strong>总内存</strong>为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>∗</mo><mi>b</mi><mi>s</mi><mi>z</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>∗</mo><mi>h</mi><mi>d</mi><mo>∗</mo><mfrac><mrow><mi>n</mi><mi>l</mi></mrow><mrow><mi>c</mi><mi>i</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">2 * bsz * seq * hd * \frac{nl}{ci}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="model-state-working-memorymswm"><a class="markdownIt-Anchor" href="#model-state-working-memorymswm"></a> Model State Working Memory(MSWM)</h4><p>模型状态工作内存是在所有Model States卸载到CPU/NVMe上后,在最大的单个算子上执行forward/backward pass所需的最小的GPU内存</p><p>因此需要从backward pass的最大算子考虑,因为backward需要涉及到parameters和gradient</p><p>在基于transformer架构的模型中,最大的算子是[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>d</mi><mo separator="true">,</mo><mn>4</mn><mi>h</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">hd,4hd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span></span></span>]的线性层,所需的内存大小为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>16</mn><mo>∗</mo><msup><mrow><mi>h</mi><mi>d</mi></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">16 * {hd}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8984479999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span>是通过FP16(2bytes)以及参数和梯度所需的参数量计算而得</p><h4 id="activation-working-memoryawm"><a class="markdownIt-Anchor" href="#activation-working-memoryawm"></a> Activation Working Memory(AWM)</h4><p>激活工作内存是在反向传播重计算时所需的内存(在执行真正的反向传播之前)</p><p>它的大小是取决于两个连续的activation checkpoints.(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表的是两个连续的激活检查点间的transformer block数目)</p><p>所需的内存大小为:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mi>s</mi><mi>z</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mn>16</mn><mo>∗</mo><mi>h</mi><mi>d</mi><mo>+</mo><mn>2</mn><mo>∗</mo><mi>a</mi><mi>t</mi><mi>t</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi><mo>∗</mo><mi>s</mi><mi>e</mi><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">bsz*seq*c_i*(16 * hd + 2 * attn\_heads * seq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>取1,即每个block都有个activation checkpoints</p><p><mark>其中本人并没有计算出来这个数目</mark>,计算过程如下图(仅供参考):</p><p><img src="https://s2.loli.net/2023/11/03/YlnHhujt6J9bNsG.jpg" alt="transformer_block_activation_computation" /></p><h3 id="bandwidth-requirements"><a class="markdownIt-Anchor" href="#bandwidth-requirements"></a> Bandwidth Requirements</h3><p>如果我们要将暂时用不上的数据先offload到CPU或NVMe对应的存储空间,为了确保训练效率不受影响,因此得确保带宽够用,满足带宽需求</p><p>定义以下的字符用来作为<strong>效率的度量指标</strong>:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">peak_{tp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>: 峰值计算吞吐量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>: 数据移动带宽</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>: 算术强度,是总计算量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">total\_computation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span>与计算所需数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">total\_data\_movement</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span>的比率,描述了每次数据移动的计算量,越高的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>则说明对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>要求越低,因为对每个加载的数据,加速器可以做更多的计算</li></ul><p>效率计算公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>+</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">efficiency = \frac{compute\_time}{compute\_time + comm\_time}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.35552em;vertical-align:-0.996em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3595199999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.996em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mrow><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">compute\_time = \frac{total\_computation}{peak_{tp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.366548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi mathvariant="normal">_</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><mrow><mi>b</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">comm\_time = \frac{total\_data\_movement}{bw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9695199999999999em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">m</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.08044em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">ait = \frac{total\_computation}{total\_data\_movement}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.39044em;vertical-align:-0.996em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.39444em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6999999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.996em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>联立上述四个式子,可得:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mi>f</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>∗</mo><mi>b</mi><mi>w</mi></mrow><mrow><mi>a</mi><mi>i</mi><mi>t</mi><mo>∗</mo><mi>b</mi><mi>w</mi><mo>+</mo><mi>p</mi><mi>e</mi><mi>a</mi><msub><mi>k</mi><mrow><mi>t</mi><mi>p</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">efficiency = \frac{ait * bw}{ait * bw + peak_{tp}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.343548em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在讨论<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">bw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>前,需要先量化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ait</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>.我们知道每一个transformer_block的操作都是相同的,因此可以从一个迭代中的总计算量和总数据移动量来考虑算术强度,其中model states和activation checkpoints的ait可以分开考虑(<mark>之所以分开考虑,是因为其相关的参数不同</mark>)</p><h4 id="total-computation-per-iter"><a class="markdownIt-Anchor" href="#total-computation-per-iter"></a> Total Computation per iter</h4><h4 id="ait-wrt-parameters-and-gradients"><a class="markdownIt-Anchor" href="#ait-wrt-parameters-and-gradients"></a> AIT w.r.t. Parameters and Gradients</h4><h4 id="ait-wrt-optimizer-states"><a class="markdownIt-Anchor" href="#ait-wrt-optimizer-states"></a> AIT w.r.t. Optimizer States</h4><h4 id="ait-wrt-activation-checkpoints"><a class="markdownIt-Anchor" href="#ait-wrt-activation-checkpoints"></a> AIT w.r.t. Activation Checkpoints</h4><h3 id="zero-infinity-design"><a class="markdownIt-Anchor" href="#zero-infinity-design"></a> ZeRO-Infinity design</h3>]]></content>
    
    
    
    <tags>
      
      <tag>ZeRO系列</tag>
      
      <tag>NVMe</tag>
      
      <tag>offload</tag>
      
      <tag>Data Parallelism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算卸载和计算迁移的简要介绍</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%81%E7%A7%BB%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E8%BF%81%E7%A7%BB%E7%9A%84%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>边缘计算中有**计算卸载(offload)<strong>和</strong>计算迁移(migration)**这两个概念,通过翻阅网上资料以及部分论文内容,发现二者的概念非常相似,结合chatgpt3.5的说法,以下给出二者的主要区别,而关于其工作流程,性能指标,大致相似,因此则混为一谈</p><h2 id="计算迁移和计算卸载的主要区别"><a class="markdownIt-Anchor" href="#计算迁移和计算卸载的主要区别"></a> 计算迁移和计算卸载的主要区别</h2><p>计算迁移和计算卸载的主要区别在于<strong>任务去向</strong>和<strong>侧重点</strong>不同</p><ul><li><p><strong>任务去向</strong></p><ul><li>对于<strong>计算卸载</strong>,将任务的一部分或全部发送到外部设备(一般<strong>是云服务器或者别的高性能设备</strong>)来进行处理.一般进行卸载的是密集型计算的任务</li><li>对于<strong>计算迁移</strong>,将任务/应用程序从一个设备迁移到另一个设备.一般是因为<strong>资源限制,设备性能差异</strong>等因素导致的迁移</li></ul></li><li><p><strong>侧重点</strong></p><ul><li>对于<strong>计算卸载</strong>,重点在于将密集型的计算任务从本地设备移出,减轻设备负担,提高性能和能效.通过将任务卸载到强大的计算资源上,来实现任务加速和节省能耗</li><li>对于<strong>计算迁移</strong>,重点在于优化任务在不同设备间的分配,以实现更好的资源利用和性能.它着重于将任务从一个设备迁移到另一个设备上,以满足特定的需求,如资源均衡,能量管理或网络切换</li></ul></li></ul><h2 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h2><p>计算卸载/迁移为以下六个步骤:</p><ol><li>节点发现(MCC的高性能服务器或MEC服务器);</li><li>程序切割;</li><li>卸载决策(是否卸载?卸载到哪?卸载策略有静态卸载和动态卸载);</li><li>程序传输(流量/WIFI);</li><li>执行计算(服务器启动虚拟机开始计算);</li><li>计算结果回传</li></ol><h2 id="性能指标"><a class="markdownIt-Anchor" href="#性能指标"></a> 性能指标</h2><p>目前,计算卸载/迁移的性能通常以**时间延迟(等待时间)<strong>和</strong>能量消耗(耗电)**作为衡量指标</p><p>在不执行计算卸载/迁移时:</p><ul><li>时间延迟指在移动设备执行本地计算所花费的时间;</li><li>能量消耗指在移动设备执行本地计算所消耗的能量;</li></ul><p>在执行计算卸载/迁移时:</p><ul><li><p>时间延迟指</p><p>①. 卸载数据到MEC节点的传输时间;</p><p>②. MEC节点执行处理时间;</p><p>③. 接收MEC节点的数据结果传输时间;</p></li></ul><p>① + ② + ③即是时间延迟</p><ul><li><p>能量消耗指</p><p>①. 卸载数据到MEC节点的传输能耗;</p><p>②. 接收来自MEC节点结果的传输能耗;</p></li></ul><p>① + ②即是能量消耗</p><p>一般来说,在做卸载/迁移决策时需要考虑到以上两种指标,使得最小化能耗(满足时延的约束条件下,最小化能耗)或者最小化时延(满足能耗的约束条件下,最小化时延),也可以根据需要,对时延和能耗分别赋权,使二者的加权和最小,即最大化收益的卸载/迁移决策</p>]]></content>
    
    
    
    <tags>
      
      <tag>offload</tag>
      
      <tag>migration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some-hardware-knowledge</title>
    <link href="/2023/07/28/Some-hardware-knowledge/"/>
    <url>/2023/07/28/Some-hardware-knowledge/</url>
    
    <content type="html"><![CDATA[<h2 id="导引"><a class="markdownIt-Anchor" href="#导引"></a> 导引</h2><p>为什么会想着写一篇关于硬件(SSD)的博文呢,在之前的一篇<strong>ZeRO-Infinity</strong>的论文中,讲到了利用<strong>NVMe</strong>来用作GPU,CPU内存的扩充,而对NVMe这个东西从未耳闻,因此看了一些资料来查缺补漏,便有了本文关于SSD这一硬件的简单讲解.其中主要涉及到的内容是<strong>PCIe</strong>的协议栈以及<strong>NVMe</strong>协议的讲解</p><h2 id="ssd"><a class="markdownIt-Anchor" href="#ssd"></a> SSD</h2><h3 id="物理接口"><a class="markdownIt-Anchor" href="#物理接口"></a> 物理接口</h3><p>常用的物理接口有<strong>PCIe接口</strong>,<strong>SATA接口</strong>,<strong>M.2接口</strong>等</p><p>前两个接口是根据通道而起的名字</p><p>M.2接口则可以跑PCIe或SATA通道,具体要看主板或硬盘的支持情况,主流的用于接入SSD的接口</p><h3 id="通道"><a class="markdownIt-Anchor" href="#通道"></a> 通道</h3><p>在谈及PCIe前,</p><p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/bus%20development(test).png" alt="bus%20development" /></p><h4 id="pcie"><a class="markdownIt-Anchor" href="#pcie"></a> PCIe</h4><h3 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h3><h4 id="nvme"><a class="markdownIt-Anchor" href="#nvme"></a> NVMe</h4><p>NVMe(Non-Volatile Memory Express),非易失性内存主机控制器接口规范</p><h2 id="pcie-switch"><a class="markdownIt-Anchor" href="#pcie-switch"></a> PCIe Switch</h2><h2 id="hbm2"><a class="markdownIt-Anchor" href="#hbm2"></a> HBM2</h2><h2 id="nvlink"><a class="markdownIt-Anchor" href="#nvlink"></a> NVLink</h2><p>个人感觉是一个升级版的PCIe,双工双路信道</p><p><img src="https://s2.loli.net/2023/11/03/k314GUpmHgVtsRz.png" alt="NVLink Development" /></p><h2 id="nvswitch"><a class="markdownIt-Anchor" href="#nvswitch"></a> NVSwitch</h2><p>内部整合了多个NVLink</p><p><img src="https://s2.loli.net/2023/11/03/pjwqnB5CkEVDRIb.png" alt="NVSwitch Development" /></p><h2 id="dgx"><a class="markdownIt-Anchor" href="#dgx"></a> DGX</h2><p>DGX(Data Gpu eXtend,知乎捡回来的解释,NVIDIA也没有解释)系列产品(另还有HGX,EGX,分别对应HPC,Edge等领域):</p><ul><li><p>DGX Station</p><p>可自行DIY或购买的DGX工作站</p></li><li><p>DGX-1(卖点是P100和NVLink)</p><p>采用的是可以搭载8块GPU的SXM插槽,最初是P100(Pascal架构的,16GB),后面换成了V100(Volta架构,32GB)</p><p>DGX-1 Pascal架构的内部连接对AllGather优化没做好,但应该在DGX-1 Volta架构中增加了更多的NVLink通道解决了这个问题,P100有4个NVLink通道,V100有6个NVLink通道</p><p>以上参考:<a href="https://www.zhihu.com/question/42770716/answer/137835011">李沐关于DGX-1的描述</a></p><p>关于下方注释中的SXM的解释参考自<a href="https://en.wikipedia.org/wiki/SXM_(socket)">wiki-SXM</a></p><div class="note note-info">            <p><strong>SXM(Server pci eXpress Module),是一种高带宽的插槽</strong>,用于连接NVIDIA计算加速器到系统的一种解决方案,自P100以来,每一代的Nvidia Tesla,DGX计算系列,HGX板子都配有SXM插槽,可为匹配的GPU实现高带宽等功能</p><p><strong>在DGX系列中,SXM用于Pascal架构的GPU,SXM2,SXM3用于Volta架构,SXM4用于Ampere架构,SXM5用于Hopper架构的GPU</strong></p><p><strong>这些插槽是对应于特定的加速器型号</strong></p>          </div></li><li><p>DGX-2(卖点是V100和NVSwitch)</p></li><li><p>DGX A100</p></li><li><p>DGX H100</p><ul><li>8个H100GPU,总显存高达640GB</li></ul></li><li><p>DGX BasePOD</p></li><li><p>DGX SuperPOD</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/26172972">PCI和PCIe硬件讲解</a></p><p><a href="https://www.syrr.cn/news/291472.html?action=onClick">DGX-1和DGX-2以及其中架构</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>NVMe</tag>
      
      <tag>PCIe</tag>
      
      <tag>GPU</tag>
      
      <tag>SSD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pipeline Parallelism GPipe And PipeDream</title>
    <link href="/2023/05/17/Pipeline-Parallelism-GPipe-And-PipeDream/"/>
    <url>/2023/05/17/Pipeline-Parallelism-GPipe-And-PipeDream/</url>
    
    <content type="html"><![CDATA[<h2 id="从模型并行讲起"><a class="markdownIt-Anchor" href="#从模型并行讲起"></a> 从模型并行讲起</h2><p>模型并行有两种并行方式,一种是<strong>层间并行(inter-layer)</strong>,一种是<strong>层内并行(intra-layer)</strong>.</p><p><img src="https://s2.loli.net/2023/11/27/4ObapWrEQudJ97j.png" alt="inter-layer parallelism and intra-layer parallelism" /></p><p><strong>流水线并行属于层间并行的一种特殊情况</strong>,下文在讲解GPipe的时候会进行提及</p><p>层内并行可以看作是张量并行,张量并行的经典文章Megatron-LM是对transformer的三个维度之一[batch_size,sequence_length,hidden_dimmension]中的hidden_dimension进行划分,从而并行</p><p>后续也有一些文章是对sequence_length进行划分来达到并行的目的</p><p>不难看出,传统的数据并行是对数据集进行划分,即比如数据集有3200张图片,一个batch_size取32,则一个epoch有100个iteration,</p><h2 id="gpipe"><a class="markdownIt-Anchor" href="#gpipe"></a> GPipe</h2><h3 id="micro-batch"><a class="markdownIt-Anchor" href="#micro-batch"></a> micro-batch</h3><h3 id="re-materialization"><a class="markdownIt-Anchor" href="#re-materialization"></a> re-materialization</h3><h3 id="可挖掘的创新点"><a class="markdownIt-Anchor" href="#可挖掘的创新点"></a> 可挖掘的创新点</h3><ol><li>在文章<em><strong>Performance Optimization</strong></em>这一部分提及了可以更早安排反向传递时的recompute,我们知道,要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">B_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的梯度,需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>层的梯度以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">F_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的激活值,因此<strong>如果可以较为精准的提前开始重新计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">F_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>层的激活值,当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">B_{k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>的值通过PCI-E也好,通过Infiniband,甚至用NVLink也好,要是可以适应各类设备,而遮掩掉recompute的时间的话(大约<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>),那跟别的模型比起来,等于白赚了recompute而节省的那一堆内存</strong></li><li>在文章<em><strong>Design Features and Trade-Offs</strong></em>这一部分中提及了GPipe假设的是单个层符合单个加速器的内存需求,因此**如果单个加速器无法满足单个层的需求,应该如何处理?**文中提出的是可以通过把矩阵乘拆分来解决</li><li>不同层内存需求不平衡,因此<strong>需要更好的分区算法,以达到负载均衡</strong>,如果实在无法通过分区达到平衡,可以<strong>通过合适的卸载计算,将计算卸载到周边的计算节点处理,感觉这里可以借鉴MEC(移动边缘计算)一类的方法</strong></li><li><strong>micro-batch划分需要复杂的策略以支持需要跨micro-batch(即在mini-batch中)计算的层(如BN层)</strong></li></ol><h2 id="pipedream"><a class="markdownIt-Anchor" href="#pipedream"></a> PipeDream</h2><h3 id="weight-stashing"><a class="markdownIt-Anchor" href="#weight-stashing"></a> weight stashing</h3><h3 id="vertical-sync"><a class="markdownIt-Anchor" href="#vertical-sync"></a> vertical sync</h3>]]></content>
    
    
    
    <tags>
      
      <tag>distributed system</tag>
      
      <tag>pipeline parallelism</tag>
      
      <tag>data parallelism</tag>
      
      <tag>model parallelism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSD理解及代码解析</title>
    <link href="/2023/03/23/SSD%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/23/SSD%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="ssd理解"><a class="markdownIt-Anchor" href="#ssd理解"></a> SSD理解</h2><p>SSD(Single Shot MultiBox Detector)是一个one-stage的目标检测模型,它的网络结构如下:</p><p><img src="https://s2.loli.net/2023/11/03/obM92IFdutTJzAV.png" alt="ssd-yolo-arch-contrast" /></p><p>根据上面的网络结构图,有:</p><ul><li>SSD的<strong>backbone采用的是VGG的前五层</strong>,后面的maxpool以及fc层都被换成卷积层</li><li>SSD有6个feature map用于预测分类和回归,即<strong>多尺度检测</strong></li><li>SSD是<strong>通过卷积操作来预测分类和定位回归</strong>,而YOLO则是通过全连接层变换到指定维度</li><li>SSD是<strong>基于anchor来预测</strong>的,而<strong>不同feature map的cell/grid是对应不同的anchor数目</strong></li></ul><p>SSD具体的操作,如<strong>default box(就是anchor)生成,正负样本匹配策略</strong>等会在下面结合代码一起理解</p><h2 id="写于代码分析前"><a class="markdownIt-Anchor" href="#写于代码分析前"></a> 写于代码分析前</h2><p>我们知道,目标检测由以下组件组成:<strong>backbone,neck,head</strong></p><ul><li>backbone: <strong>骨干网络</strong>,用来进行<strong>特征提取</strong>.我们之前学习的分类任务中提及的网络都有良好的特征提取能力,因此用来充当backbone</li><li>neck: 用于<strong>特征融合</strong>,以<strong>获取不同尺度的感受野信息</strong></li><li>head: <strong>检测头</strong>,用来<strong>预测目标类别和定位回归</strong></li></ul><h2 id="ssd代码分析"><a class="markdownIt-Anchor" href="#ssd代码分析"></a> SSD代码分析</h2><p>整体流程如下:</p><ol><li><p>ResNet50基础网络</p></li><li><p>backbone用于提取特征</p></li><li><p>ssd_model完成整个训练及预测的流程</p><ol><li>构建多尺度特征图用于预测分类和回归</li><li>default_box生成</li><li>正负样本匹配</li></ol><ul><li>训练<ul><li>loss计算<ul><li>定位loss</li><li>分类loss(hard negative mining)</li></ul></li></ul></li><li>预测<ul><li>后处理,如nms</li></ul></li></ul></li></ol><p>因此本文将以上述顺序进行分析</p><p>注:本文分析的是输入为300*300的SSD</p><h3 id="resnet-50"><a class="markdownIt-Anchor" href="#resnet-50"></a> ResNet-50</h3><p>由于这是16年的模型,所以当时作者用的是VGG,但在本文,我们用ResNet-50来作为backbone(ResNet具体信息查看<a href="https://ayyha.github.io/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/#resnet">image-classification的一些常用模型</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bottleneck</span>(<span class="hljs-params">nn.Module</span>):</span><br>    expansion = <span class="hljs-number">4</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channel, out_channel, stride=<span class="hljs-number">1</span>, downsample=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(Bottleneck, self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels=in_channel, out_channels=out_channel, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.bn1 = nn.BatchNorm2d(out_channel)<br>        self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.conv2 = nn.Conv2d(in_channels=out_channel, out_channels=out_channel, kernel_size=<span class="hljs-number">3</span>, stride=stride,<br>                               bias=<span class="hljs-literal">False</span>, padding=<span class="hljs-number">1</span>)<br>        self.bn2 = nn.BatchNorm2d(out_channel)<br>        self.conv3 = nn.Conv2d(in_channels=out_channel, out_channels=out_channel * self.expansion, kernel_size=<span class="hljs-number">1</span>,<br>                               stride=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>)<br>        self.bn3 = nn.BatchNorm2d(out_channel * self.expansion)<br>        self.downsample = downsample<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        identity = x<br>        <span class="hljs-keyword">if</span> self.downsample <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            identity = self.downsample(x)<br>        residual = self.conv1(x)<br>        residual = self.bn1(residual)<br>        residual = self.relu(residual)<br><br>        residual = self.conv2(residual)<br>        residual = self.bn2(residual)<br>        residual = self.relu(residual)<br><br>        residual = self.conv3(residual)<br>        residual = self.bn3(residual)<br><br>        residual += identity<br>        residual = self.relu(residual)<br><br>        <span class="hljs-keyword">return</span> residual<br></code></pre></td></tr></table></figure><p>我们知道,ResNet-50相较于ResNet-18/34,其残差结构块是由三个卷积构成,分别:<strong>降维-&gt;卷积-&gt;升维</strong>这三个步骤,呈现两头大中间细,因此称为<strong>Bottleneck结构</strong>,而对于每一次的卷积操作,都是要经历<strong>卷积-&gt;Batch Normalization-&gt;Non Linearity(ReLU)<strong>这几步操作.以上便是Bottleneck的代码部分,其中</strong>expansion</strong>是用于标识第三层卷积的卷积核数目相较于第一层卷积的卷积核数目的<strong>膨胀系数</strong>;<strong>downsample</strong>则是用于<strong>identity mapping的维度变换</strong>(因为同样shape才可以和residual mapping进行相加)</p><p>下图中<strong>绿色框标识</strong>的则为每一个Bottleneck的<code>out_channel</code>,<strong>黄色框标识</strong>则为<code>in_channel</code>,而右边灰色框框住的则为每一个Bottleneck需要迭代的次数,因此我们需要定义一个方法用来逐层执行(一层有多个Bottleneck)</p><p><img src="https://cdn.staticaly.com/gh/ayyHA/imageBed@main/img/resnet-arch-for-code.png" alt="resnet-arch-for-code" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_make_layer</span>(<span class="hljs-params">self, block, channel, block_num, stride=<span class="hljs-number">1</span></span>):</span><br>    downsample = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> stride != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> self.in_channel != channel * block.expansion:<br>        downsample = nn.Sequential(<br>            nn.Conv2d(self.in_channel, channel * block.expansion, kernel_size=<span class="hljs-number">1</span>, stride=stride, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(channel * block.expansion)<br>        )<br>    layers = []<br>    layers.append(block(self.in_channel, channel, downsample=downsample, stride=stride))<br>    self.in_channel = channel * block.expansion<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, block_num):<br>        layers.append(block(self.in_channel, channel))<br><br>    <span class="hljs-keyword">return</span> nn.Sequential(*layers)<br></code></pre></td></tr></table></figure><p><code>_make_layer</code>便是逐层执行的方法,其中<code>block</code>是<code>Bottleneck</code>类,而<code>block_num</code>代表的是一个Bottleneck迭代的次数</p><p>由此,可以根据<code>_make_layer</code>方法构建出整个网络的结构,ResNet类的<code>__init__</code>和<code>forward</code>方法如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, block, blocks_num, num_classes=<span class="hljs-number">1000</span>, include_top=<span class="hljs-literal">True</span></span>):</span><br>    <span class="hljs-built_in">super</span>(ResNet, self).__init__()<br>    self.include_top = include_top<br>    self.in_channel = <span class="hljs-number">64</span><br><br>    self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, self.in_channel, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>, bias=<span class="hljs-literal">False</span>)<br>    self.bn1 = nn.BatchNorm2d(self.in_channel)<br>    self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br><br>    self.maxpool = nn.MaxPool2d(<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>)<br><br>    self.layer1 = self._make_layer(block, <span class="hljs-number">64</span>, blocks_num[<span class="hljs-number">0</span>])<br>    self.layer2 = self._make_layer(block, <span class="hljs-number">128</span>, blocks_num[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)<br>    self.layer3 = self._make_layer(block, <span class="hljs-number">256</span>, blocks_num[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)<br>    self.layer4 = self._make_layer(block, <span class="hljs-number">512</span>, blocks_num[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">if</span> self.include_top:<br>        self.avgpool = nn.AdaptiveAvgPool2d((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>        self.fc = nn.Linear(<span class="hljs-number">512</span> * block.expansion, num_classes)<br><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> self.modules():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(m, nn.Conv2d):<br>            nn.init.kaiming_normal_(m.weight, mode=<span class="hljs-string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="hljs-string">&#x27;relu&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>    x = self.conv1(x)<br>    x = self.bn1(x)<br>    x = self.relu(x)<br>    x = self.maxpool(x)<br><br>    x = self.layer1(x)<br>    x = self.layer2(x)<br>    x = self.layer3(x)<br>    x = self.layer4(x)<br><br>    <span class="hljs-keyword">if</span> self.include_top:<br>        x = self.avgpool(x)<br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br>        x = self.fc(x)<br>    <span class="hljs-keyword">return</span> x<br><br></code></pre></td></tr></table></figure><p>至此,便完成了ResNet50的代码部分</p><h3 id="backbone"><a class="markdownIt-Anchor" href="#backbone"></a> backbone</h3><p>在开始介绍之前,我们先看下用Resnet-50作为backbone的SSD的网络结构图:(图源B站up:<a href="https://space.bilibili.com/18161609/">霹雳吧啦Wz</a>)</p><p><img src="https://s2.loli.net/2023/11/03/NcUbuve9rpKgMR2.png" alt="res50-backbone-ssd-arch" /></p><p>由图中可知:并非整个ResNet-50都用做backbone,我们选取<code>conv4</code>这一层作为第一个做预测的特征图(<code>conv5</code>及后面的层全部抛弃).因此backbone便是截取到<code>conv4</code>,也即是对于<code>nn.Module.children()</code>而言,即是取到索引的第7位,然后根据SSD论文,需要对第四层的步距修改为1,因此也需要对identity mapping的<code>stride</code>也进行修改,代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Backbone</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, pretrain_path=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(Backbone, self).__init__()<br>        net = resnet50()<br>        <span class="hljs-comment"># 用于后面的特征图的channel</span><br>        self.out_channels = [<span class="hljs-number">1024</span>, <span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>]<br><br>        <span class="hljs-keyword">if</span> pretrain_path <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            net.load_state_dict(torch.load(pretrain_path))<br><br>        self.feature_extractor = nn.Sequential(*<span class="hljs-built_in">list</span>(net.children())[:<span class="hljs-number">7</span>])<br><br>        conv4_block1 = self.feature_extractor[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># 这一行代码不是必须的,是用于ResNet-18/34的</span><br>        conv4_block1.conv1.stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        conv4_block1.conv2.stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        conv4_block1.downsample[<span class="hljs-number">0</span>].stride = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.feature_extractor(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>由此,我们便完成了backbone的构造,当我们通过如下方式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">image_test = torch.randn(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">300</span>,<span class="hljs-number">300</span>)<br>backbone = Backbone()<br>feature_extractor = backbone(image_test) <br></code></pre></td></tr></table></figure><p>便可以得到<code>1*1024*38*38</code>这样大小的tensor</p><h3 id="ssd_model"><a class="markdownIt-Anchor" href="#ssd_model"></a> ssd_model</h3><h4 id="多尺度特征图的构建"><a class="markdownIt-Anchor" href="#多尺度特征图的构建"></a> 多尺度特征图的构建</h4><p>根据上面的网络结构图,可知六个特征图分别为:<code>[38*38*1024,19*19*512,10*10*512,5*5*256,3*3*256,1*1*256]</code>,在经过backbone后,我们即可以得到<code>38*38*1024</code>尺寸的特征图,而后的特征图中,均需要经过两个卷积层后得到其尺寸,因此以下的方法便是为获取后续的特征图做的操作,并将相应操作存于模型容器中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_build_addtional_features</span>(<span class="hljs-params">self, input_size</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param input_size [1024,512,512,256,256,256]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    additional_blocks = []<br>    middle_channels = [<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>]<br>    <span class="hljs-keyword">for</span> i, (in_ch, out_ch, mid_ch) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(input_size[:-<span class="hljs-number">1</span>], input_size[<span class="hljs-number">1</span>:], middle_channels)):<br>        padding, stride = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>        layer = nn.Sequential(<br>            nn.Conv2d(in_ch, mid_ch, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(mid_ch),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Conv2d(mid_ch, out_ch, kernel_size=<span class="hljs-number">3</span>, padding=padding, stride=stride, bias=<span class="hljs-literal">False</span>),<br>            nn.BatchNorm2d(out_ch),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        )<br>        additional_blocks.append(layer)<br>    self.additional_blocks = nn.ModuleList(additional_blocks)<br></code></pre></td></tr></table></figure><h4 id="多尺度特征图预测分类和回归"><a class="markdownIt-Anchor" href="#多尺度特征图预测分类和回归"></a> 多尺度特征图预测分类和回归</h4><p>在提及预测分类和回归前,我们先需要知道每一个特征图对应的grid/cell有几个default box</p><p>在论文关于<strong>scale和aspect ratio</strong>中,作者所提及的scale的计算公式如下示:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub><mo>=</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>+</mo><mfrac><mrow><msub><mi>s</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>s</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s_{k}=s_{min}+\frac{s_{max}-s_{min}}{m-1}(k-1),k\in[1,m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.0296600000000002em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>根据<em>Suppose we want to use m feature maps for prediction</em>原文这句话可以知道是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>,即多尺度特征图的个数,但由于下面的aspect ratio即default box的长宽比部分,提及了除了某些比例外,每个特征图还有一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo>=</mo><msqrt><mrow><msub><mi>s</mi><mi>k</mi></msub><msub><mi>s</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msqrt></mrow><annotation encoding="application/x-tex">s^{\prime}_{k}=\sqrt{s_{k}s_{k+1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.3438855em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6961145em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.6561145em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3438855em;"><span></span></span></span></span></span></span></span></span>,显然至少需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,而以下是作者的<a href="https://github.com/weiliu89/caffe/blob/ssd/examples/ssd/ssd_pascal_resnet.py">GitHub代码部分</a>关于此处的处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">min_dim = <span class="hljs-number">300</span><br><span class="hljs-comment"># res3b3_relu ==&gt; 38 x 38</span><br><span class="hljs-comment"># res5c_relu ==&gt; 19 x 19</span><br><span class="hljs-comment"># res5c_relu/conv1_2 ==&gt; 10 x 10</span><br><span class="hljs-comment"># res5c_relu/conv2_2 ==&gt; 5 x 5</span><br><span class="hljs-comment"># res5c_relu/conv3_2 ==&gt; 3 x 3</span><br><span class="hljs-comment"># pool6 ==&gt; 1 x 1</span><br>mbox_source_layers = [<span class="hljs-string">&#x27;res3b3_relu&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv1_2&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv2_2&#x27;</span>, <span class="hljs-string">&#x27;res5c_relu/conv3_2&#x27;</span>, <span class="hljs-string">&#x27;pool6&#x27;</span>]<br><span class="hljs-comment"># in percent %</span><br>min_ratio = <span class="hljs-number">20</span><br>max_ratio = <span class="hljs-number">95</span><br>step = <span class="hljs-built_in">int</span>(math.floor((max_ratio - min_ratio) / (<span class="hljs-built_in">len</span>(mbox_source_layers) - <span class="hljs-number">2</span>)))<br>min_sizes = []<br>max_sizes = []<br><span class="hljs-keyword">for</span> ratio <span class="hljs-keyword">in</span> xrange(min_ratio, max_ratio + <span class="hljs-number">1</span>, step):<br>  min_sizes.append(min_dim * ratio / <span class="hljs-number">100.</span>)<br>  max_sizes.append(min_dim * (ratio + step) / <span class="hljs-number">100.</span>)<br>min_sizes = [min_dim * <span class="hljs-number">10</span> / <span class="hljs-number">100.</span>] + min_sizes<br>max_sizes = [[]] + max_sizes<br></code></pre></td></tr></table></figure><p>我们将它稍加修改用torch打印出来即是:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>30</mn><mo separator="true">,</mo><mn>60</mn><mo separator="true">,</mo><mn>114</mn><mo separator="true">,</mo><mn>168</mn><mo separator="true">,</mo><mn>222</mn><mo separator="true">,</mo><mn>276</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>60</mn><mo separator="true">,</mo><mn>114</mn><mo separator="true">,</mo><mn>168</mn><mo separator="true">,</mo><mn>222</mn><mo separator="true">,</mo><mn>276</mn><mo separator="true">,</mo><mn>330</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min\_sizes[30,60,114,168,222,276] \\ max\_sizes[60,114,168,222,276,330]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">3</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">6</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span></p><p>显然,跟上面论文给出的计算方法及结果均不一样,估计是后期又调了参,而在本文讲解中,采用的是如下这一组scale:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>21</mn><mo separator="true">,</mo><mn>45</mn><mo separator="true">,</mo><mn>99</mn><mo separator="true">,</mo><mn>153</mn><mo separator="true">,</mo><mn>207</mn><mo separator="true">,</mo><mn>261</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mn>45</mn><mo separator="true">,</mo><mn>99</mn><mo separator="true">,</mo><mn>153</mn><mo separator="true">,</mo><mn>207</mn><mo separator="true">,</mo><mn>261</mn><mo separator="true">,</mo><mn>315</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min\_sizes[21, 45, 99, 153, 207, 261]\\max\_sizes[45, 99, 153, 207, 261, 315]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">2</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">1</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></span></p><p>来源<a href="https://github.com/amdegroot/ssd.pytorch/blob/master/data/config.py">amdegroot/ssd.pytorch</a></p><p>而关于aspect ratio,在Experiment中作者说到<em>For conv4_3,conv10_2 and conv11_2, we only associate 4 default boxes at each feature map location–omitting aspect ratios of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>and 3</em></p><p>也即是1,5,6这三个特征图中只有对应<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,\frac{1}{2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>这几个宽高比例以及刚刚提及的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>s</mi><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">s^{\prime}_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span></span></span></span>,即1,5,6这三个特征图的grid上只有4个default box,而2,3,4则是6个default box</p><p>而在我们预测分类和回归的时候,我们需要将多尺度特征图的channel转换为<code>k*(4+num_classes)</code>,其中k表示的是该特征图grid对应的default box数目,4是用于分类的四个回归参数(偏移值),num_classes则是用于分类的类别数目</p><p>因此,构建用于分类和定位的module如下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">self.num_defaults = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>   location_extractors = []<br>   confidence_extractors = []<br>   <span class="hljs-keyword">for</span> nd, oc <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.num_defaults, self.feature_extractor.out_channels):<br>       location_extractors.append(nn.Conv2d(oc, nd * <span class="hljs-number">4</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br>       confidence_extractors.append(nn.Conv2d(oc, nd * num_classes, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>))<br><span class="hljs-comment"># 用于定位回归的位置提取器</span><br>self.loc = nn.ModuleList(location_extractors)<br><span class="hljs-comment"># 用于预测分类的分类提取器</span><br>self.conf = nn.ModuleList(confidence_extractors)<br></code></pre></td></tr></table></figure><p>我们结合构建好的多尺度特征图以及上述用于预测分类和回归的module,则有下述代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox_view</span>(<span class="hljs-params">self, features, loc_extractor, conf_extractor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param features: 多尺度特征图</span><br><span class="hljs-string">    :param loc_extractor: self.loc</span><br><span class="hljs-string">    :param conf_extractor: self.conf</span><br><span class="hljs-string">    :return: locs:Tensor[N,4,8732] confs:Tensor[N,num_classes,8732] N-&gt;batch_size</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    locs = []<br>    confs = []<br>    <span class="hljs-keyword">for</span> f, l, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(features, loc_extractor, conf_extractor):<br>        <span class="hljs-comment"># view-&gt;给tensor做维度变换,不改变数据</span><br>        <span class="hljs-comment"># [batch_size,n*4,feature_size,feature_size] -&gt; [batch_size,4,-1]</span><br>        locs.append(l(f).view(f.size(<span class="hljs-number">0</span>), <span class="hljs-number">4</span>, -<span class="hljs-number">1</span>))<br>        confs.append(c(f).view(f.size(<span class="hljs-number">0</span>), self.num_classes, -<span class="hljs-number">1</span>))<br>    <span class="hljs-comment"># 将每一张图的不同尺度的矩阵给拼接起来,然后改变其内存的存储结构 [batch_size,4,8732], [batch_size,num_classes,8732]</span><br>    locs, confs = torch.cat(locs, <span class="hljs-number">2</span>).contiguous(), torch.cat(confs, <span class="hljs-number">2</span>).contiguous()<br>    <span class="hljs-keyword">return</span> locs, confs<br></code></pre></td></tr></table></figure><p>其中代码中注解的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8732</mn></mrow><annotation encoding="application/x-tex">8732</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mord">3</span><span class="mord">2</span></span></span></span>是所有尺寸的特征图的default box的总数目</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>38</mn><mo>∗</mo><mn>38</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>19</mn><mo>∗</mo><mn>19</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>10</mn><mo>∗</mo><mn>10</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>5</mn><mo>∗</mo><mn>6</mn><mo>+</mo><mn>3</mn><mo>∗</mo><mn>3</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>1</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>8732</mn></mrow><annotation encoding="application/x-tex">38*38*4+19*19*6+10*10*6+5*5*6+3*3*4+1*1*4=8732</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span><span class="mord">3</span><span class="mord">2</span></span></span></span></span></p><p>以上便是SSD利用多尺度特征图预测分类和定位回归的过程</p><h4 id="default-box生成"><a class="markdownIt-Anchor" href="#default-box生成"></a> default box生成</h4><p>在训练和预测前,①需要利用匹配策略将default box与ground truth box进行匹配,从而得到正负样本,②而得到了正负样本我们才可以执行论文里的hard negative mining(即使得正负样本比例<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1:3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>),用以处理密集检测中的正负样本极不平衡的情况,③之后才可以计算训练需要用的loss;④而之于预测阶段,我们需要利用回归参数对default box移动到对应的位置,得到预测框,⑤而后再进行NMS去除冗余框,得到最终的结果</p><p>因此在开展后续的代码讲解前,需要先对default box的生成做一个讲解</p><p>在上面的介绍中,我们知道了每个feature map的grid对应不同数目的default box,而每个default box又由scale和aspect ratio决定,这里补充一下如何利用scale和aspect ratio计算对应default box的宽高</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>=</mo><msub><mi>s</mi><mi>k</mi></msub><msqrt><msub><mi>a</mi><mi>r</mi></msub></msqrt><mspace linebreak="newline"></mspace><msub><mi>h</mi><mi>k</mi></msub><mo>=</mo><mfrac><msub><mi>s</mi><mi>k</mi></msub><msqrt><msub><mi>a</mi><mi>r</mi></msub></msqrt></mfrac></mrow><annotation encoding="application/x-tex">w_{k}=s_{k}\sqrt{a_{r}} \\h_{k}=\frac{s_{k}}{\sqrt{a_{r}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.265845em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.774155em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.734155em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.265845em;"><span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1082799999999997em;vertical-align:-1.00072em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.72528em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.68528em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31472em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.00072em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">s_{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是该feature map的scale,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示的是对应的宽高比,至此,我们便可以计算出不同特征图的default box不同宽高比的尺寸大小,而每个default box都是在其所属的grid的中心,因此我们可以计算出每一个default box的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo separator="true">,</mo><mi>c</mi><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">{cx,cy,w,h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span></span></span></span></span>坐标</p><p>由此可以得出生成default box的代码,如下示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultBoxes</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, fig_size, feature_size, steps, scales, aspect_ratios, scale_xy=<span class="hljs-number">.1</span>, scale_wh=<span class="hljs-number">.2</span></span>):</span><br>        <span class="hljs-comment"># 输入图像的大小300</span><br>        self.fig_size = fig_size<br>        <span class="hljs-comment"># 多尺度特征图的大小[38,19,10,5,3,1]</span><br>        self.feature_size = feature_size<br><br>        <span class="hljs-comment"># 用于后期加速loss收敛</span><br>        self.scale_xy_ = scale_xy<br>        self.scale_wh_ = scale_wh<br><br>        <span class="hljs-comment"># 特征图在原图上的跨度 [8,16,32,64,100,300]</span><br>        self.steps = steps<br>        <span class="hljs-comment"># 每一个特征图对应的default_box的大小 [21,45,99,153,207,261,315]</span><br>        self.scales = scales<br>        <span class="hljs-comment"># 每一个特征图对应的default_box的宽高比 [[2],[2,3],[2,3],[2,3],[2],[2]]</span><br>        self.aspect_ratios = aspect_ratios<br>        <span class="hljs-comment"># 每一个特征图的fk,按原论文应是featur_size,但是这里用了别的方法</span><br>        fk = fig_size / np.array(steps)<br><br>        self.default_boxes = []<br>        <span class="hljs-comment"># 计算每一个特征图的default box</span><br>        <span class="hljs-keyword">for</span> idx, single_feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.feature_size):<br>            <span class="hljs-comment"># 计算相对坐标</span><br>            sk1 = scales[idx] / fig_size<br>            sk2 = scales[idx + <span class="hljs-number">1</span>] / fig_size<br>            sk3 = sqrt(sk1, sk2)<br>            <span class="hljs-comment"># 添加两个宽高比为1的default box的宽高</span><br>            all_sizes = [(sk1, sk1), (sk3, sk3)]<br><br>            <span class="hljs-comment"># 处理feature_map不同宽高比</span><br>            <span class="hljs-keyword">for</span> alpha <span class="hljs-keyword">in</span> aspect_ratios[idx]:<br>                w, h = sk1 * sqrt(alpha), sk1 / sqrt(alpha)<br>                all_sizes.append((w, h))<br>                all_sizes.append((h, w))<br><br>            <span class="hljs-comment"># 计算default_box对应的坐标</span><br>            <span class="hljs-keyword">for</span> w, h <span class="hljs-keyword">in</span> all_sizes:<br>                <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">range</span>(single_feature), repeat=<span class="hljs-number">2</span>):<br>                    <span class="hljs-comment"># 计算每一个小格子对应的default box的中心坐标</span><br>                    cx, cy = (j + <span class="hljs-number">0.5</span>) / fk[idx], (i + <span class="hljs-number">0.5</span>) / fk[idx]<br>                    self.default_boxes.append((cx, cy, w, h))<br>        <span class="hljs-comment"># 转换数据类型为Tensor</span><br>        self.dboxes = torch.as_tensor(self.default_boxes, dtype=torch.float32)<br>        <span class="hljs-comment"># 把范围夹紧在[0,1],超出1的划为1,小于0的划为0</span><br>        self.dboxes.clamp_(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 将(cx,cy,w,h)转换为(xmin,ymin,xmax,ymax) left top right bottom,便于IoU计算</span><br>        self.dboxes_ltrb = self.dboxes.clone()<br>        self.dboxes_ltrb[:, <span class="hljs-number">0</span>] = self.dboxes[:, <span class="hljs-number">0</span>] - <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">2</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">1</span>] = self.dboxes[:, <span class="hljs-number">1</span>] - <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">3</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">2</span>] = self.dboxes[:, <span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">2</span>]<br>        self.dboxes_ltrb[:, <span class="hljs-number">3</span>] = self.dboxes[:, <span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span> * self.dboxes[:, <span class="hljs-number">3</span>]<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_xy</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.scale_xy_<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_wh</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.scale_wh_<br><br>    <span class="hljs-comment"># 要用哪个形式的default box,任君选择</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, order=<span class="hljs-string">&#x27;ltrb&#x27;</span></span>):</span><br>        <span class="hljs-keyword">if</span> order == <span class="hljs-string">&quot;ltrb&quot;</span>:<br>            <span class="hljs-keyword">return</span> self.dboxes_ltrb<br><br>        <span class="hljs-keyword">if</span> order == <span class="hljs-string">&quot;xywh&quot;</span>:<br>            <span class="hljs-keyword">return</span> self.dboxes<br></code></pre></td></tr></table></figure><p>从上面我们知道default box有两种格式,其中一种是<code>xywh​</code>,即是位于grid的中心,因为我们预测的是回归参数,即偏移值,是相对于这一格式而言的,因此想要得到最终的预测框,需要在这种格式上对其进行变换得到</p><p>另一种格式为<code>ltrb​</code>,此种格式便于我们计算IoU,同时也是VOC数据集提供的GTbox的格式.而计算IoU这一metric,即存在于正负样本匹配,也存在于最后的非极大值抑制中</p><p>因此这两种格式在求解目标检测问题时是时常相互转换的,二者均不可或缺</p><h4 id="正负样本匹配"><a class="markdownIt-Anchor" href="#正负样本匹配"></a> 正负样本匹配</h4><p>在完成了default box的生成后,我们要开始训练前,需要根据匹配策略,区分什么样的default box为正样本,什么样的default box为负样本</p><p>在论文中,作者提出了两步的匹配策略:</p><p><img src="https://s2.loli.net/2023/11/03/s5HMxcgn4FaLIfD.png" alt="ssd-matching-strategy" /></p><p>即是按照以下策略匹配:</p><ol><li>每个GTbox匹配到的最大IoU的default box为正样本</li><li>每个default box匹配到的最大IoU的GTbox,其IoU&gt;阈值(0.5)则为正样本</li></ol><p>即一张图片比如有<code>2</code>个GTbox,有4个default box,其IoU如下所示:</p><table><thead><tr><th></th><th>dbox1</th><th>dbox2</th><th>dbox3</th><th>dbox4</th></tr></thead><tbody><tr><td>GTbox1</td><td>0.4</td><td>0.3</td><td>0</td><td>0</td></tr><tr><td>GTbox2</td><td>0.2</td><td>0.8</td><td>0.6</td><td>0.3</td></tr></tbody></table><p>根据第一条匹配策略,匹配到的:(GTbox1,dbox1)=0.4和(GTbox2,dbox2)=0.8,这俩为正样本</p><p>根据第二条匹配策略,匹配到的:(GTbox2,dbox3)=0.6&gt;阈值(0.5),也为正样本</p><p>若是没匹配到,则为负样本,则其匹配到的是背景类,而该default box的位置信息则无意义(定位loss只算正样本的)</p><p>因此,有以下代码,注意,传入<code>encode</code>的<code>bboxes_in</code>和<code>labels_in</code>是通过对数据集标注文件进行解析得到的GTbox的真实位置和真实标签(如对VOC数据集进行解析)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Encoder</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-comment"># [8732,4]</span><br>        self.dboxes = dboxes(order=<span class="hljs-string">&quot;ltrb&quot;</span>)<br>        <span class="hljs-comment"># [1,8732]</span><br>        self.dboxes_xywh = dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).unsqueeze(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 8732</span><br>        self.nboxes = self.dboxes.size(<span class="hljs-number">0</span>)<br>        self.scale_xy = dboxes.scale_xy<br>        self.scale_wh = dboxes.scale_wh<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">self, bboxes_in, labels_in, criteria=<span class="hljs-number">0.5</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        正负样本匹配,其中nboxes是ground truth boxes</span><br><span class="hljs-string">        :param bboxes_in: [nboxes*4]</span><br><span class="hljs-string">        :param labels_in: [nboxes]</span><br><span class="hljs-string">        :param criteria: IoU阈值,用于判断正样本</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># [nboxes,8732],这里的dboxes是ltrb格式</span><br>        ious = calc_iou_tensor(bboxes_in, self.dboxes)<br>        <span class="hljs-comment"># 每个default box对应GTbox的最大值 [8732]</span><br>        best_dbox_ious, best_dbox_idx = ious.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 每个GTbox对应default box的最大值 [nboxes]</span><br>        best_gtbox_ious, best_gtbox_idx = ious.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 匹配策略一:GTbox最匹配的default box为正样本</span><br>        <span class="hljs-comment"># 因此,将对应的default box匹配GTbox的IoU更改为&gt;0.5的值,使后面置之为正样本 [8732]</span><br>        best_dbox_ious.index_fill_(<span class="hljs-number">0</span>, best_gtbox_idx, <span class="hljs-number">2.0</span>)<br>        <span class="hljs-comment"># 更换满足匹配一的default box的索引,使之与GTbox匹配,因为后面要用GTbox的坐标和标签</span><br>        idx = torch.arange(<span class="hljs-number">0</span>, best_gtbox_idx.size(<span class="hljs-number">0</span>), dtype=torch.int64)<br>        best_dbox_idx[best_gtbox_idx[idx]] = idx<br><br>        <span class="hljs-comment"># 匹配策略二:与任意GTbox IoU&gt;0.5的default box即为正样本</span><br>        mask = best_dbox_ious &gt; criteria<br><br>        <span class="hljs-comment"># [8732],默认填充为0 0匹配的是背景</span><br>        labels_out = torch.zeros(self.nboxes, dtype=torch.int64)<br>        <span class="hljs-comment"># 给正样本打上与对应GTbox同样的标签</span><br>        labels_out[mask] = labels_in[best_dbox_idx[mask]]<br><br>        <span class="hljs-comment"># 给正样本赋予对应GTbox同样的坐标</span><br>        bboxes_out = self.dboxes.clone()<br>        bboxes_out[mask, :] = bboxes_in[best_dbox_idx[mask], :]<br><br>        <span class="hljs-comment"># 转换为xywh格式</span><br>        x = <span class="hljs-number">0.5</span> * (bboxes_out[:, <span class="hljs-number">0</span>] + bboxes_out[:, <span class="hljs-number">2</span>])<br>        y = <span class="hljs-number">0.5</span> * (bboxes_out[:, <span class="hljs-number">1</span>] + bboxes_out[:, <span class="hljs-number">3</span>])<br>        w = bboxes_out[:, <span class="hljs-number">2</span>] - bboxes_out[:, <span class="hljs-number">0</span>]<br>        h = bboxes_out[:, <span class="hljs-number">3</span>] - bboxes_out[:, <span class="hljs-number">1</span>]<br>        bboxes_out[:, <span class="hljs-number">0</span>] = x<br>        bboxes_out[:, <span class="hljs-number">1</span>] = y<br>        bboxes_out[:, <span class="hljs-number">2</span>] = w<br>        bboxes_out[:, <span class="hljs-number">3</span>] = h<br>        <span class="hljs-keyword">return</span> bboxes_out, labels_out<br></code></pre></td></tr></table></figure><h4 id="训练"><a class="markdownIt-Anchor" href="#训练"></a> 训练</h4><p>我们完成了上述工作后,便可以开始训练.而训练过程中,我们会通过一些处理工作,获取到<strong>一批</strong>(上面是单张)数据的正负样本,即:<code>location:Tensor[N,4,8732],confidence:Tensor[N,8732]</code>,因此接下来,我们将对这批数据进行loss计算</p><h5 id="loss计算"><a class="markdownIt-Anchor" href="#loss计算"></a> loss计算</h5><p>我们对default box预测的是它相对于中心位置的回归参数,也就是说,是相对于中心位置的偏移值,而在论文中,<strong>偏移值的计算定义</strong>如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><msubsup><mi>g</mi><mi>j</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup><mo>−</mo><msubsup><mi>d</mi><mi>i</mi><mrow><mi>c</mi><mi>x</mi></mrow></msubsup></mrow><msubsup><mi>d</mi><mi>i</mi><mi>w</mi></msubsup></mfrac><mspace width="1em"/><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup><mo>=</mo><mfrac><mrow><msubsup><mi>g</mi><mi>j</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup><mo>−</mo><msubsup><mi>d</mi><mi>i</mi><mrow><mi>c</mi><mi>y</mi></mrow></msubsup></mrow><msubsup><mi>d</mi><mi>i</mi><mi>h</mi></msubsup></mfrac><mspace linebreak="newline"></mspace><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mi>w</mi></msubsup><mo>=</mo><mi>log</mi><mo>⁡</mo><mfrac><msubsup><mi>g</mi><mi>j</mi><mi>w</mi></msubsup><msubsup><mi>d</mi><mi>i</mi><mi>w</mi></msubsup></mfrac><mspace width="1em"/><msubsup><mover accent="true"><mi>g</mi><mo>^</mo></mover><mi>j</mi><mi>h</mi></msubsup><mo>=</mo><mi>log</mi><mo>⁡</mo><mfrac><msubsup><mi>g</mi><mi>j</mi><mi>h</mi></msubsup><msubsup><mi>d</mi><mi>i</mi><mi>h</mi></msubsup></mfrac></mrow><annotation encoding="application/x-tex">\hat{g}^{cx}_{j} = \frac{g^{cx}_{j}-d^{cx}_{i}}{d^{w}_{i}} \quad \hat{g}^{cy}_{j} = \frac{g^{cy}_{j}-d^{cy}_{i}}{d^{h}_{i}}\\\hat{g}^{w}_{j} = \log{\frac{g^{w}_{j}}{d^{w}_{i}}} \quad\hat{g}^{h}_{j} = \log{\frac{g^{h}_{j}}{d^{h}_{i}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0975000000000001em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.442076em;vertical-align:-0.9628639999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.479212em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6461920000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.583044em;vertical-align:-0.9977719999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5852720000000002em;"><span style="top:-2.279092em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.830908em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.802972em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9977719999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0975000000000001em;vertical-align:-0.383108em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714392em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4120280000000003em;vertical-align:-0.9628639999999999em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4491640000000001em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6461920000000001em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9628639999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.631652em;vertical-align:-0.9977719999999999em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.63388em;"><span style="top:-2.279092em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.830908em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.0448000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7847720000000002em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9977719999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><p><strong>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个GTbox,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box,上标的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo separator="true">,</mo><mi>c</mi><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">cx,cy,w,h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span></span></span></span>表示计算的对象(中心坐标x等),<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>表示的是GTbox,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span></span></span></span>表示的是default box</strong></p><p>我们<strong>通过等式右边的计算便可以得到左侧的偏移值</strong>,而我们的<strong>目标是使得网络学习的偏移值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>,尽量地与真实的偏移值相近,即误差越小越好</strong>,本文中采用的<strong>定位回归loss函数是SmoothL1Loss</strong></p><p>而对于分类损失,本文则采取了交叉熵损失函数,形式如下(拆成了正负样本来写):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi></mrow></msub><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>P</mi><mi>o</mi><mi>s</mi></mrow><mi>N</mi></munderover><mrow><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>p</mi></msubsup><mi>log</mi><mo>⁡</mo><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mi>p</mi></msubsup></mrow><mo>+</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>N</mi><mi>e</mi><mi>g</mi></mrow></munder><mrow><mi>log</mi><mo>⁡</mo><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mn>0</mn></msubsup></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{conf} = - (\sum_{i \in Pos}^{N}{x^{p}_{ij}\log{\hat{c}^{p}_{i}}} + \sum_{i \in Neg}{\log{\hat{c}^{0}_{i}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.150042em;vertical-align:-1.321706em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7822999999999999em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.480449em;vertical-align:-1.430444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">x^{p}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1952720000000001em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span>是一个指示器,它的取值是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>,表示的是匹配第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box和类别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个GTbox,对数函数里面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover accent="true"><mi>c</mi><mo>^</mo></mover><mi>i</mi><mi>p</mi></msubsup></mrow><annotation encoding="application/x-tex">\hat{c}^{p}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.059164em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.19444em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7823em;"><span style="top:-2.4231360000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>表示的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>个default box预测属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>这一类别的概率值,之所以有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow></mrow><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span>是因为这是经过softmax后的结果</p><p>以下是loss计算的<code>__init__</code>方法,定义了上述所说的损失函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loss</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-built_in">super</span>(Loss, self).__init__()<br>        self.scale_xy = <span class="hljs-number">1.0</span> / dboxes.scale_xy  <span class="hljs-comment"># 10</span><br>        self.scale_wh = <span class="hljs-number">1.0</span> / dboxes.scale_wh  <span class="hljs-comment"># 5</span><br><br>        self.location_loss = nn.SmoothL1Loss(reduction=<span class="hljs-string">&#x27;None&#x27;</span>)<br>        <span class="hljs-comment"># [8732,4] -&gt; [4,8732] -&gt; [1,4,8732] 8732 -&gt; number of anchors</span><br>        self.dboxes = nn.Parameter(dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).unsqueeze(dim=<span class="hljs-number">0</span>),<br>                                   requires_grad=<span class="hljs-literal">False</span>)<br>        self.confidence_loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;None&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们知道,对于定位问题,我们只对正样本计算loss(负样本的loss没有意义),而正样本的位置信息就是GTbox的位置信息(<code>xywh这一类型的</code>),而预测的结果是default box的偏移值,因而需要对传入的正样本信息计算出偏移值,才可以计算定位损失,以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_location_vec</span>(<span class="hljs-params">self, loc</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算gtbox相较于default box的回归参数</span><br><span class="hljs-string">    :param loc: gtbox</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># [batch_size,2,8732]</span><br>    gxy = self.scale_xy * (loc[:, :<span class="hljs-number">2</span>, :] - self.dboxes[:, :<span class="hljs-number">2</span>, :]) / self.dboxes[:, <span class="hljs-number">2</span>:, :]<br>    <span class="hljs-comment"># [batch_size,2,8732]</span><br>    gwh = self.scale_wh * (loc[:, <span class="hljs-number">2</span>:, :] / self.dboxes[:, <span class="hljs-number">2</span>:, :]).log()<br>    <span class="hljs-comment"># [batch_size,4,8732]</span><br>    <span class="hljs-keyword">return</span> torch.cat((gxy, gwh), dim=<span class="hljs-number">1</span>).contiguous()<br></code></pre></td></tr></table></figure><p>将以上的返回值和预测的回归信息交由前面定义的SmoothL1Loss便可以计算出定位损失</p><p>而分类损失则是对正负样本均要计算,但在计算之前,我们需要知道,一张图片,目标可能只有几个,但我们的default box有8k多个,如果正负样本全拿来计算loss,那正样本的loss其实对网络的学习起的作用微乎其微,因为正负样本极不平衡</p><p>因此本文提出了<em>hard negative mininng</em>的思想,即正负样本保持<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>:</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1:3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的比例,负样本是根据置信度损失大小降序排序而被挑选出来的(就是挑置信度损失高的,也就是难以区分为背景的)</p><p>以下是Loss类的forward的代码部分,包括了上述说的定位损失以及分类损失的计算,也包括了hard negative mining的处理部分,其中对两种损失的处理是直接相加得到的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, ploc, plabel, gloc, glabel</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param ploc: predicted location [N,4,8732]</span><br><span class="hljs-string">    :param plabel: predicted label [N,num_classes,8732]</span><br><span class="hljs-string">    :param gloc: gt location [N,4,8732]</span><br><span class="hljs-string">    :param glabel: gt label [N,8732]</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获取正样本的mask Tensor [N,8732]</span><br>    mask = torch.gt(glabel, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 计算每一张图片的正样本数目 [N]</span><br>    pos_num = mask.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 计算ground truth的回归参数 [N,4,8732]</span><br>    vec_gd = self._location_vec(gloc)<br><br>    <span class="hljs-comment"># 计算定位损失 [N,4,8732] -&gt; [N,8732]</span><br>    loc_loss = self.location_loss(ploc, vec_gd).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 只计算正样本的loss [N,8732] -&gt; [N] (即每张图片(N的其中一份子)的定位loss组成的)</span><br>    loc_loss = (mask.<span class="hljs-built_in">float</span>() * loc_loss).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 以下是hard negative mining的过程</span><br>    <span class="hljs-comment"># out:[N,8732]</span><br>    conf = self.confidence_loss(plabel, glabel)<br><br>    conf_neg = conf.clone()<br>    <span class="hljs-comment"># 将正样本的分类loss置零,便于后面对置信度loss高的负样本进行获取</span><br>    conf_neg[mask] = <span class="hljs-number">0.0</span><br>    <span class="hljs-comment"># 按置信度loss降序排序,其中获取到的sorted_矩阵表示的是排序后的值,</span><br>    <span class="hljs-comment"># 而conf_idx则是排序后的值对应原conf_neg矩阵对应值的索引矩阵</span><br>    sorted_, conf_idx = conf_neg.sort(dim=<span class="hljs-number">1</span>, descending=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 升序排一次,使得conf_rank矩阵为原conf_neg矩阵的位次阵,即对应元素代表了其大小(0最大)</span><br>    sorted__, conf_rank = conf_idx.sort(dim=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 负样本是正样本的三倍,总数要小于8732 out:[N,1]</span><br>    neg_num = torch.clamp(<span class="hljs-number">3</span> * pos_num, <span class="hljs-built_in">max</span>=mask.size(<span class="hljs-number">1</span>)).unsqueeze(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 保留置信度loss高的负样本</span><br>    neg_mask = torch.lt(conf_rank, neg_num)<br><br>    <span class="hljs-comment"># confidence计算 [N,8732] -&gt; [N] 对每一幅图片的正负样本计算loss,并合在一起(单张图的正负样本的分类loss) [N]</span><br>    conf_loss = (conf * (mask.<span class="hljs-built_in">float</span>() + neg_mask.<span class="hljs-built_in">float</span>())).<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 总的loss</span><br>    total_loss = conf_loss + loc_loss<br>    <span class="hljs-comment"># 避免某一些图片的gt为0</span><br>    num_mask = torch.gt(pos_num, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>()<br>    <span class="hljs-comment"># 避免gt为0的图片作为分母时无法被除</span><br>    pos_num = pos_num.<span class="hljs-built_in">float</span>().clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">1e-6</span>)<br>    <span class="hljs-comment"># 计算gt非0的图片的loss(每张图片平均gt的loss,再对这一批图片loss取均值)</span><br>    ret = (total_loss * num_mask / pos_num).mean(dim=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h4 id="预测"><a class="markdownIt-Anchor" href="#预测"></a> 预测</h4><h5 id="后处理"><a class="markdownIt-Anchor" href="#后处理"></a> 后处理</h5><p>在验证阶段或者预测阶段,我们需要计算出最终预测框的位置(default box加上偏移值),计算出类别概率,并且对冗余的预测框进行去除,最终用一些metric验证当下模型的性能或者输出预测后的图像</p><p>以下是后处理部分的<code>__init__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PostProcess</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dboxes</span>):</span><br>        <span class="hljs-built_in">super</span>(PostProcess, self).__init__()<br>        <span class="hljs-comment"># [8732,4] -&gt; [1,8732,4]</span><br>        self.dboxes_xywh = nn.Parameter(dboxes(order=<span class="hljs-string">&quot;xywh&quot;</span>).unsqueeze(dim=<span class="hljs-number">0</span>), requires_grad=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 0.1</span><br>        self.scale_xy = dboxes.scale_xy<br>        <span class="hljs-comment"># 0.2</span><br>        self.scale_wh = dboxes.scale_wh<br>        <span class="hljs-comment"># NMS的阈值</span><br>        self.criteria = <span class="hljs-number">.5</span><br>        <span class="hljs-comment"># 一张图片允许的最多框数</span><br>        self.max_output = <span class="hljs-number">100</span><br><br></code></pre></td></tr></table></figure><h6 id="最终预测框"><a class="markdownIt-Anchor" href="#最终预测框"></a> 最终预测框</h6><p>要得到最终预测框,就要将模型预测的回归参数作用到default box上,同时也需要对模型预测的类别进行<code>softmax</code>处理,以转换为概率值,以下是获得最终预测框的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale_back_batch</span>(<span class="hljs-params">self, bboxes_in, scores_in</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    传入的bboxes_in和scores_in,是</span><br><span class="hljs-string">    经过预测后的多张图片多个default box的回归参数以及多个类别的置信度</span><br><span class="hljs-string">    本方法目的:</span><br><span class="hljs-string">    ①得到最终预测框;</span><br><span class="hljs-string">    ②对预测框变换坐标格式,便于后期nms;</span><br><span class="hljs-string">    ③对多个类别置信度用softmax获得类别概率</span><br><span class="hljs-string">    :param bboxes_in: [N,4,8732]</span><br><span class="hljs-string">    :param scores_in: [N,num_classes,8732]</span><br><span class="hljs-string">    :return: (bboxes_in,scores_in)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># [N,8732,4]</span><br>    bboxes_in = bboxes_in.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># [N,8732,num_classes]</span><br>    scores_in = scores_in.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># loss为了加速收敛分别对xy和wh除以了0.1和0.2,这里要乘回来,得到预测的回归参数</span><br>    bboxes_in[:, :, :<span class="hljs-number">2</span>] = self.scale_xy * bboxes_in[:, :, :<span class="hljs-number">2</span>]<br>    bboxes_in[:, :, <span class="hljs-number">2</span>:] = self.scale_wh * bboxes_in[:, :, <span class="hljs-number">2</span>:]<br><br>    <span class="hljs-comment"># 最终预测框的位置</span><br>    bboxes_in[:, :, :<span class="hljs-number">2</span>] = bboxes_in[:, :, :<span class="hljs-number">2</span>] * self.dboxes_xywh[:, :, <span class="hljs-number">2</span>:] + self.dboxes_xywh[:, :, :<span class="hljs-number">2</span>]<br>    bboxes_in[:, :, <span class="hljs-number">2</span>:] = bboxes_in[:, :, <span class="hljs-number">2</span>:].exp() * self.dboxes_xywh[:, :, <span class="hljs-number">2</span>:]<br><br>    <span class="hljs-comment"># 转换为ltrb格式,便于之后计算nms</span><br>    l = bboxes_in[:, :, <span class="hljs-number">0</span>] - <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">2</span>]<br>    r = bboxes_in[:, :, <span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">2</span>]<br>    t = bboxes_in[:, :, <span class="hljs-number">1</span>] - <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">3</span>]<br>    b = bboxes_in[:, :, <span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span> * bboxes_in[:, :, <span class="hljs-number">3</span>]<br><br>    bboxes_in[:, :, <span class="hljs-number">0</span>] = l<br>    bboxes_in[:, :, <span class="hljs-number">1</span>] = t<br>    bboxes_in[:, :, <span class="hljs-number">2</span>] = r<br>    bboxes_in[:, :, <span class="hljs-number">3</span>] = b<br><br>    <span class="hljs-comment"># 对置信度用softmax转换为概率值 [N,8732,num_classes]</span><br>    <span class="hljs-keyword">return</span> bboxes_in, F.softmax(scores_in, dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h6 id="nms"><a class="markdownIt-Anchor" href="#nms"></a> nms</h6><p>当我们得到最终的预测框以及概率值,我们便要进入非极大值抑制(nms),这一步的目的是去除冗余框</p><p>比如人脸检测的时候,在一个人的周围会生成很多框,但是只应留下一个最合适的,很明显即应该留下预测为人的概率值最大的</p><p>若是在一幅图片中有两张人脸需要检测,也依旧如此:①保留概率最大的预测框②与概率最大的预测框进行IoU计算,若大于阈值则认为检测的是同一张人脸,应该删去③若小于等于阈值则认为可能是别的人脸,则此时在剩下的预测框中(原先①中最大的已被剔除,②中大于阈值的也被剔除了)重复以上过程</p><p>最终即可以得到我们所期望的对应的预测框</p><p>以下是nms代码(官方给我们调用的以及自己写的),其中pytorch官方有提供相应函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nms</span>(<span class="hljs-params">boxes, scores, iou_threshold</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    非极大值抑制,去除冗余框</span><br><span class="hljs-string">    :param boxes: tensor[N,4]</span><br><span class="hljs-string">    :param scores: tensor[N]</span><br><span class="hljs-string">    :param iou_threshold: float be used to remove the similarity region boxes</span><br><span class="hljs-string">    :return: tensor,one dimension,refer to the useful boxes indexes</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> torch.ops.torchvision.nms(boxes, scores, iou_threshold)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nms_</span>(<span class="hljs-params">boxes: Tensor, scores: Tensor, iou_threshold: <span class="hljs-built_in">float</span></span>) -&gt; Tensor:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据scores排序,将最大分值的box的索引加入keep,然后用最大分值的box与其他boxes相比(IoU),大于阈值则滤去,</span><br><span class="hljs-string">    然后在剩下的scores又拿最大的进行比较,直至全部比较完毕</span><br><span class="hljs-string">    :param boxes: Tensor[N,4]</span><br><span class="hljs-string">    :param scores: Tensor[N]</span><br><span class="hljs-string">    :param iou_threshold:</span><br><span class="hljs-string">    :return: keep:Tensor</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 最终留下来的boxes的索引用keep存储</span><br>    keep = []<br>    <span class="hljs-comment"># 对scores升序排序,取索引</span><br>    idxs = scores.argsort()<br>    <span class="hljs-comment"># 当idxs还有元素,就继续循环,除非元素都没了(或移除,或留下至keep)</span><br>    <span class="hljs-keyword">while</span> idxs.numel() &gt; <span class="hljs-number">0</span>:<br>        max_score_idx = idxs[-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># [1,4]</span><br>        max_score_box = boxes[max_score_idx][<span class="hljs-literal">None</span>, :]<br>        keep.append(max_score_idx)<br>        <span class="hljs-comment"># 表示当前只剩下最后一个元素,且已经加入keep中,直接退出循环即可</span><br>        <span class="hljs-keyword">if</span> idxs.size(<span class="hljs-number">0</span>) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 去除得分最大框</span><br>        idxs = idxs[:-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># [M,4],其中M表示是idxs的size,指取出还没处理的框</span><br>        other_boxes = boxes[idxs]<br>        <span class="hljs-comment"># [1,M]</span><br>        ious = calc_iou_tensor(max_score_box, other_boxes)<br>        <span class="hljs-comment"># 去除冗余框!</span><br>        idxs = idxs[ious[<span class="hljs-number">0</span>] &lt;= iou_threshold]<br><br>    keep = idxs.new(keep)<br>    <span class="hljs-keyword">return</span> keep<br></code></pre></td></tr></table></figure><p>而从上述代码,我们也不难看出来nms是只对同一类别进行处理,若是多个类别呢?我们当然可以一个类别逐次进行nms,但是这样效率较慢</p><p>我们知道<strong>IoU计算实际上就是计算两个框的重叠性</strong>,那也即是说<strong>IoU本质上也是受到空间距离因素影响</strong>的,我们只要<strong>将不同类别的框的空间距离拉开不同的距离,而同类别框的空间距离拉开相同的距离</strong>,就可以使得nms起作用</p><p>以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">batched_nms</span>(<span class="hljs-params">bboxes, scores, idxs, iou_threshold</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes: 位置信息</span><br><span class="hljs-string">    :param scores: 分类概率</span><br><span class="hljs-string">    :param idxs: 标签</span><br><span class="hljs-string">    :param iou_threshold: IoU阈值</span><br><span class="hljs-string">    :return: keep:Tensor 留下来的框的索引</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> bboxes.numel() == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> torch.empty(<span class="hljs-number">0</span>, dtype=torch.int64, device=bboxes.device)<br><br>    <span class="hljs-comment"># 在所有default box的所有坐标中取最大值,作为一个离散因子,离散化不同类别,因为nms是针对同一类别所做的</span><br>    max_factor = bboxes.<span class="hljs-built_in">max</span>()<br>    <span class="hljs-comment"># 偏移值:按照类别离散化</span><br>    offsets = idxs.to(bboxes) * (max_factor + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 对bboxes加上偏移值</span><br>    bboxes_nms = bboxes + offsets[:, <span class="hljs-literal">None</span>]<br>    <span class="hljs-comment"># nms</span><br>    keep = nms(bboxes_nms, scores, iou_threshold)<br>    <span class="hljs-keyword">return</span> keep<br></code></pre></td></tr></table></figure><p>其实在进行nms之前,我们还需要对一些低概率box,面积过小box进行移除,之后再进入nms,以减少不必要的计算</p><p>以下是包含了上述说的以及nms过程的代码,其中该方法是对单张图片进行处理,需要注意,SSD中预测定位与分类是两个不大相干的任务,即预测定位无需关心它是哪一类别的目标,而在这个方法中,我们采取了Faster RCNN的方法,来将一个预测框与多个类别相关联,以便于后面的nms:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_singe_image</span>(<span class="hljs-params">self, bboxes_in, scores_in, criteria, max_output</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes_in: [8732,4]</span><br><span class="hljs-string">    :param scores_in: [8732,num_classes]</span><br><span class="hljs-string">    :param criteria: nms criteria</span><br><span class="hljs-string">    :param max_output: the maximal number of output boxes</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    device = bboxes_in.device<br>    num_classes = scores_in.shape[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># 裁剪边界</span><br>    bboxes_in = bboxes_in.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># default box只关注回归问题 -&gt; default box的回归问题与object类别相关(用于简化nms)</span><br>    <span class="hljs-comment"># [8732,4] -&gt; [8732,21,4]</span><br>    bboxes_in = bboxes_in.repeat(<span class="hljs-number">1</span>, num_classes).reshape(scores_in.shape[<span class="hljs-number">0</span>], -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br><br>    <span class="hljs-comment"># 创建标签,用以与default box们对应</span><br>    <span class="hljs-comment"># [num_classes]</span><br>    labels = torch.arange(num_classes, device=device)<br>    <span class="hljs-comment"># [num_classes] -&gt; [1,num_classes] -&gt; [8732,num_classes]</span><br>    labels = labels.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).expand_as(scores_in)<br><br>    <span class="hljs-comment"># 移除背景类的信息 num_classes -&gt; num_classes - 1</span><br>    bboxes_in = bboxes_in[:, <span class="hljs-number">1</span>:, :]<br>    scores_in = scores_in[:, <span class="hljs-number">1</span>:]<br>    labels = labels[:, <span class="hljs-number">1</span>:]<br><br>    <span class="hljs-comment"># 合并default box的维度(之前扩了num_classes倍)</span><br>    <span class="hljs-comment"># [8732*20,4] 20是用的voc数据集,有21个类别(含背景)</span><br>    bboxes_in = bboxes_in.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># [8732*20]</span><br>    scores_in = scores_in.reshape(-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># [8732*20]</span><br>    labels = labels.reshape(-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 移除低概率目标</span><br>    idxs = torch.where(torch.gt(scores_in, <span class="hljs-number">0.05</span>))[<span class="hljs-number">0</span>]<br>    bboxes_in, scores_in, labels = bboxes_in[idxs, :], scores_in[idxs], labels[idxs]<br><br>    <span class="hljs-comment"># 移除面积很小很小的box</span><br>    widths, heights = (bboxes_in[:, <span class="hljs-number">2</span>] - bboxes_in[:, <span class="hljs-number">0</span>]), (bboxes_in[:, <span class="hljs-number">3</span>] - bboxes_in[:<span class="hljs-number">1</span>])<br>    keep = (widths &gt;= <span class="hljs-number">1</span> / <span class="hljs-number">300</span>) &amp; (heights &gt;= <span class="hljs-number">1</span> / <span class="hljs-number">300</span>)<br>    keep = torch.where(keep)[<span class="hljs-number">0</span>]<br>    bboxes_in, scores_in, labels = bboxes_in[keep, :], scores_in[keep], labels[keep]<br><br>    <span class="hljs-comment"># NMS</span><br>    keep = batched_nms(bboxes_in, scores_in, labels, iou_threshold=criteria)<br><br>    <span class="hljs-comment"># 按iou高的取预测框</span><br>    keep = keep[:max_output]<br>    bboxes_out = bboxes_in[keep, :]<br>    scores_out = scores_in[keep]<br>    labels_out = labels[keep]<br><br>    <span class="hljs-keyword">return</span> bboxes_out, scores_out, labels_out<br></code></pre></td></tr></table></figure><p>以下是<code>PostProcess</code>这个类的forward方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, bboxes_in, scores_in</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :param bboxes_in: [N,4,8732]</span><br><span class="hljs-string">    :param scores_in: [N,num_classes,8732]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 获得最终预测框,并且对置信度做softmax运算获得每个类别的概率</span><br>    <span class="hljs-comment"># [N,8732,4],[N,8732,num_classes]</span><br>    bboxes, probs = self.scale_back_batch(bboxes_in, scores_in)<br><br>    <span class="hljs-comment"># 用于TorchScript的</span><br>    outputs = torch.jit.annotate(<span class="hljs-type">List</span>[<span class="hljs-type">Tuple</span>[Tensor, Tensor, Tensor]], [])<br><br>    <span class="hljs-comment"># 逐张图片做出预测结果</span><br>    <span class="hljs-keyword">for</span> bbox, prob <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(bboxes.split(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), (probs.split(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>))):<br>        <span class="hljs-comment"># [1,8732,4],[1,8732,num_classes] -&gt; [8732,4],[8732,num_classes]</span><br>        bbox = bbox.squeeze(<span class="hljs-number">0</span>)<br>        prob = prob.squeeze(<span class="hljs-number">0</span>)<br>        outputs.append(self.decode_singe_image(bbox, prob, self.criteria, self.max_output))<br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>至此,本文已经讲完了SSD进行目标检测任务的整体模型搭建过程,而在实际应用中,还需要涉及到如<strong>数据库数据解析</strong>(比如VOC或COCO数据集的解析),<strong>数据预处理</strong>,<strong>优化器选择</strong>,<strong>学习率调整</strong>等部分</p><p>最后给出一张利用SSD进行预测的图像:</p><p><img src="https://s2.loli.net/2023/11/03/qRyNa4DuYB1Tlfo.png" alt="ssd_experiment" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>SSD</tag>
      
      <tag>Object Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some lib of Python</title>
    <link href="/2023/03/14/Some-lib-of-Python/"/>
    <url>/2023/03/14/Some-lib-of-Python/</url>
    
    <content type="html"><![CDATA[<h2 id="tqdm"><a class="markdownIt-Anchor" href="#tqdm"></a> tqdm</h2><p>tqdm是一个可视化的进度条,用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br>range_object = <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)<br>t_bar = tqdm(range_object)<br><span class="hljs-keyword">for</span> i,e <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(t_bar):<br>    time.sleep(<span class="hljs-number">0.2</span>)<br></code></pre></td></tr></table></figure><p>上述便是tqdm的一个例子,无需print便会在控制台自动输出对应内容的进度条信息</p><p>以下是tqdm这个类可接收的参数信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, iterable=<span class="hljs-literal">None</span>, desc=<span class="hljs-literal">None</span>, total=<span class="hljs-literal">None</span>, leave=<span class="hljs-literal">True</span>, file=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             ncols=<span class="hljs-literal">None</span>, mininterval=<span class="hljs-number">0.1</span>, maxinterval=<span class="hljs-number">10.0</span>, miniters=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             <span class="hljs-built_in">ascii</span>=<span class="hljs-literal">None</span>, disable=<span class="hljs-literal">False</span>, unit=<span class="hljs-string">&#x27;it&#x27;</span>, unit_scale=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             dynamic_ncols=<span class="hljs-literal">False</span>, smoothing=<span class="hljs-number">0.3</span>, bar_format=<span class="hljs-literal">None</span>, initial=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             position=<span class="hljs-literal">None</span>, postfix=<span class="hljs-literal">None</span>, unit_divisor=<span class="hljs-number">1000</span>, write_bytes=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             lock_args=<span class="hljs-literal">None</span>, nrows=<span class="hljs-literal">None</span>, colour=<span class="hljs-literal">None</span>, delay=<span class="hljs-number">0</span>, gui=<span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">             **kwargs</span>):</span> <br></code></pre></td></tr></table></figure><ul><li>iterable: 接收可迭代对象</li><li>desc: 接收str,用于进度条左侧显示文字</li><li>total: iterable的迭代总次数</li><li>leave: 接收bool值,迭代完成后是否保留进度条,默认True</li><li>file: 输出位置,默认终端</li><li>ncols: 进度条宽度</li><li>unit: 进度条里的单位,默认是<code>it</code>,显示于<code>2.28 it/s</code>,即更改的是<code>it</code>这个单位</li><li>unit_scale:默认False,开启则代表根据国际标准对速度单位进行换算</li><li>postfix: 接收dict,传入信息显示于进度条右侧</li><li>colour: 进度条颜色</li></ul><p>此外,除了在构建进度条时设置的内容,在进度条内部的迭代对象在迭代过程中的元素也可以加入进度条中进行显示,通过如下方式增加:</p><p><code>set_description()</code>: 显示于进度条左侧<br /><code>set_postfix()</code>: 显示于进度条右侧</p><p>例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br><br>iter_object = <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>)<br>tbar = tqdm(iter_object, desc=<span class="hljs-string">&quot;train&quot;</span>, colour=<span class="hljs-string">&quot;green&quot;</span>)<br><span class="hljs-keyword">for</span> i, e <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tbar):<br>    time.sleep(<span class="hljs-number">0.4</span>)<br>    tbar.set_description(<span class="hljs-string">&quot;epoch[&#123;&#125;/&#123;&#125;]&quot;</span>.<span class="hljs-built_in">format</span>(i, <span class="hljs-number">200</span>))<br>    tbar.set_postfix(loss=random.random(), cost_time=random.randrange(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><p>注意:set_postfix传入的参数是<code>**kwargs</code>,即可传入<code>dict</code>(** -&gt; 表示接收可变长参数,以字典形式接收之,同样单星号也是接收可变长参数,不过是以list形式接收之),也可以关键字形式传入</p><h2 id="argparse"><a class="markdownIt-Anchor" href="#argparse"></a> argparse</h2><p>用于编写命令行接口.对我们指定的参数可以通过命令行的长指令写入并在程序中解析.例子如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><span class="hljs-comment"># 1. 定义解析器对象</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;demo of argparse&quot;</span>)<br><span class="hljs-comment"># 2. 添加命令行参数</span><br>parser.add_argument(<span class="hljs-string">&quot;--epoches&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">5</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;epoch of the model&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--lr&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">float</span>, default=<span class="hljs-number">.0001</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;learning rate of the gradient&quot;</span>)<br><span class="hljs-comment"># 3. 解析命令行参数</span><br>args = parser.parse_args()<br><span class="hljs-comment"># 4. 使用命令行参数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoches: &#123;&#125; lr: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(args.epoches, args.lr))<br><br></code></pre></td></tr></table></figure><p>在终端中输入<code>python ./xxx.py --epoches=100 --lr=0.005</code>即可以将对应的参数输入并于程序中解析.同时也可以查看对应的帮助文档<code>python ./xxx.py -h</code></p><h2 id="torchutilstensorboard"><a class="markdownIt-Anchor" href="#torchutilstensorboard"></a> torch.utils.tensorboard</h2><h3 id="summarywriter"><a class="markdownIt-Anchor" href="#summarywriter"></a> SummaryWriter</h3><p>我们知道tensorboard是用于模型训练验证中的可视化,比如记录loss,accurate变化(以曲线图形式表征之)</p><p>而SummaryWriter这一个类则可以向tensorboard中写入对应的数据信息</p><p>SummaryWriter是tensorboard下属的一个类,它会write out event file在我们的项目下,默认存储事件文件的文件夹是runs,可通过如下方式修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">event_writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br></code></pre></td></tr></table></figure><p>因此当我们run当前的python文件就会在当前项目下产生一个logs文件夹,并且里面存放着刚刚运行后的event file.</p><p>有了event file后便可以查看可视化后的内容,在终端输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tensorboard --logdir=logs<br></code></pre></td></tr></table></figure><p>之后便可以打开终端显示的链接<code>localhost:6006</code>来查看可视化后的内容(端口号可以通过<code>--port=xxx</code>来修改)</p><p>显然,此时你看不到有啥可视化后的内容,因为你还没将需要可视化的数据写入tensorboard中</p><h4 id="add_scalar"><a class="markdownIt-Anchor" href="#add_scalar"></a> add_scalar</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWritter<br><span class="hljs-comment"># ...</span><br>event_writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>event_writer.add_scalar(tag,scalar_value,step)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tag -&gt; 在tensorboard上显示的名字,类似于该图对应的标题</span><br><span class="hljs-string">scalar_value -&gt; 相当于纵坐标对应的值</span><br><span class="hljs-string">step -&gt; 相当于横坐标对应的值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># e.g.:绘制训练模型过程中的loss值随epoch的变化</span><br>event_writer.add_scalar(<span class="hljs-string">&quot;train_loss&quot;</span>,train_loss,epoch)<br></code></pre></td></tr></table></figure><h4 id="add_image"><a class="markdownIt-Anchor" href="#add_image"></a> add_image</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">event_writer.add_image(tag,img_tensor,step,dataformats)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tag -&gt; 在tensorboard上显示的名字,类似于该图对应的标题</span><br><span class="hljs-string">img_tensor -&gt; img的数据,允许numpy.ndarray;torch.Tensor;string等</span><br><span class="hljs-string">step -&gt; 好像也是横坐标对应的值</span><br><span class="hljs-string">dataformats -&gt; img的shape对应的是HWC还是CHW</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-comment"># e.g.:</span><br>img_path = <span class="hljs-string">&quot;./tulip.jpeg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br>img_ndarray = np.array(img)<br>event_writer.add_image(<span class="hljs-string">&quot;tulip&quot;</span>, img_ndarray, <span class="hljs-number">1</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br></code></pre></td></tr></table></figure><p>最后,使用完后记得关闭之<code>event_writer.close()</code></p><h2 id="torchoptimlr_scheduler"><a class="markdownIt-Anchor" href="#torchoptimlr_scheduler"></a> torch.optim.lr_scheduler</h2><h2 id="fvcorenn"><a class="markdownIt-Anchor" href="#fvcorenn"></a> fvcore.nn</h2><p>fvcore是Facebook开源的轻量核心库,<strong>可以用于计算浮点运算量(FLOPs,计算量),模型参数量</strong>等</p><p>注:</p><ul><li>FLOPS是floating point operations per second,每秒浮点运算次数,即计算速度;</li><li>FLOPs是floating point operations,浮点运算量,即计算量</li></ul><h3 id="flopcountanalysis"><a class="markdownIt-Anchor" href="#flopcountanalysis"></a> FlopCountAnalysis</h3><p>简单使用如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet50<br><span class="hljs-keyword">from</span> fvcore.nn <span class="hljs-keyword">import</span> FlopCountAnalysis,parameter_count_table<br><br>model = resnet50(num_classes=<span class="hljs-number">1000</span>)<br>tensor = torch.rand(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">224</span>,<span class="hljs-number">224</span>)<br>FLOPs = FlopCountAnalysis(model,tensor)<br><span class="hljs-built_in">print</span>(parameter_count_table(model))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FLOPs: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(FLOPs.total()))<br></code></pre></td></tr></table></figure><h2 id="itertools"><a class="markdownIt-Anchor" href="#itertools"></a> itertools</h2><h3 id="product"><a class="markdownIt-Anchor" href="#product"></a> product</h3><p>用于计算笛卡尔积,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>output = itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele))<br></code></pre></td></tr></table></figure><p>输出结果:</p><p><img src="https://s2.loli.net/2023/11/03/YQ7BwxTmiqESg6U.jpg" alt="itertools-product" /></p><p>它的property有repeat,即是将前面的元素笛卡尔积的结果,作为新元素,重复repeat遍,然后做笛卡尔积,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>output = itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], repeat=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(output):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele), end=<span class="hljs-string">&quot;\t&quot;</span>)<br>    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果:</p><p><img src="https://s2.loli.net/2023/11/03/rfB5W76Y8jLidaF.jpg" alt="itertools-product-repeat" /></p><h2 id="python的一些新学到的小知识"><a class="markdownIt-Anchor" href="#python的一些新学到的小知识"></a> Python的一些新学到的小知识</h2><h3 id="property"><a class="markdownIt-Anchor" href="#property"></a> @property</h3><p>在方法中标注<code>@property</code>这样的注解,可用于将变量私有化(毕竟python提供的伪私有类型是伪的),此时方法便可以像成员变量一样使用.e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, _scale</span>):</span><br>        self._scale = _scale<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scale</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._scale<br><br><br>t = Test(<span class="hljs-number">5.0</span>)<br><span class="hljs-built_in">print</span>(t.scale)<br><span class="hljs-comment"># 5.0</span><br><span class="hljs-built_in">print</span>(t.scale())<br><span class="hljs-comment"># TypeError: &#x27;float&#x27; object is not callable</span><br></code></pre></td></tr></table></figure><p>由此可见,加上<code>@property</code>就是把一个function变成了variable,用以保护其内部真正的成员变量名</p><h2 id="torchsummary"><a class="markdownIt-Anchor" href="#torchsummary"></a> torchsummary</h2><p>torchsummary和torchstat、profile这些库一样，可以计算出模型中每层的参数量，总参数量，参数大小等信息，后面的两个库可以计算出flops等信息，这些库需要提前安装一下。</p><p>以下是torchsummary的使用案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet50<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>net = resnet50()<br>net.to(device)<br>summary(net, (<span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br></code></pre></td></tr></table></figure><p>输出结果为</p><p><img src="https://s2.loli.net/2023/11/28/JVWoFUtE1fMhNv2.png" alt="torchsummary_resnet18" /></p><h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> copy</h2><p>copy这个库，可以当我们在需要的时候对对象做深浅拷贝</p><p>以下是示例，结合示例进行分析，其中<code>copy.copy()</code>是浅拷贝，<code>copy.deepcopy()</code>是深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>one = <span class="hljs-string">&#x27;def&#x27;</span><br>l1 = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], one]<br>l2 = l1<br>l3 = copy.copy(l1)<br>l4 = copy.deepcopy(l1)<br>l1[-<span class="hljs-number">1</span>] = l1[-<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;g&#x27;</span><br>l1[-<span class="hljs-number">2</span>].append(<span class="hljs-string">&#x27;d&#x27;</span>)<br>l1.append(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;one:&quot;</span>, one)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l1:&quot;</span>, l1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l2:&quot;</span>, l2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l3:&quot;</span>, l3)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;l4:&quot;</span>, l4)<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2023/11/29/Me6VtRXgdKvwOfu.png" alt="copy lib" /></p><p>不难看出在<code>l1</code>中我们增加了作为<code>str</code>对象的<code>one</code>，但是<code>l1</code>并没有跟<code>one</code>一起指向同一块地址（那就是new了一块新的空间给它），因此在后续对该列表值修改的时候，并没有影响到<code>one</code>对象的值；</p><p>对于直接赋值的<code>l2</code>应该跟<code>l1</code>指的是同一块地址；</p><p>对于浅拷贝的<code>l3</code>，只是拷贝了深拷贝的第一层（父对象），对于里面的父对象内部的对象，则是指的同一块地址；</p><p>对于深拷贝的<code>l4</code>，则对全部对象内容进行了拷贝</p>]]></content>
    
    
    
    <tags>
      
      <tag>python lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some knowledge of Pytorch</title>
    <link href="/2023/03/14/Some-knowledge-of-Pytorch/"/>
    <url>/2023/03/14/Some-knowledge-of-Pytorch/</url>
    
    <content type="html"><![CDATA[<h2 id="torch中涉及到的一些函数记录"><a class="markdownIt-Anchor" href="#torch中涉及到的一些函数记录"></a> torch中涉及到的一些函数记录</h2><h2 id="torchnnmodule中的modules和children的区别"><a class="markdownIt-Anchor" href="#torchnnmodule中的modules和children的区别"></a> torch.nn.Module中的modules()和children()的区别</h2><p>首先构建一个全连接网络,看看它的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_dim, hidden_dim1, hidden_dim2, hidden_dim3, out_dim</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.layer1 = nn.Sequential(<br>            nn.Linear(in_dim, hidden_dim1),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        )<br>        self.layer2 = nn.Sequential(<br>            nn.Linear(hidden_dim1, hidden_dim2),<br>            nn.Sigmoid()<br>        )<br>        self.layer3 = nn.Sequential(<br>            nn.Linear(hidden_dim2, hidden_dim3),<br>            nn.Tanh()<br>        )<br>        self.layer4 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.layer1(x)<br>        x = self.layer2(x)<br>        x = self.layer3(x)<br>        x = self.layer4(x)<br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># net arch</span><br>    <span class="hljs-built_in">print</span>(net)<br></code></pre></td></tr></table></figure><p>其结构为:</p><p><img src="https://s2.loli.net/2023/11/03/DiRezlK3bdN8BAp.jpg" alt="fcn arch" /></p><p>其结构图大致如下(Sequential以layer的标识号区别之,别的亦同)</p><pre class="mermaid">graphTestNet-->Sequential1 & Sequential2 & Sequential3 & ReLUSequential1 --> Linear1 & ReLU1Sequential2 --> Linear2 & SigmoidSequential3 --> Linear3 & Tanh%% layer4 --> ReLU4</pre><p>而当我们利用<code>net.children()</code>打印时,发现其是generator类型,也即是iterator类型,因此可以通过循环将其输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># children arch</span><br>    <span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(net.children()):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, ele))<br></code></pre></td></tr></table></figure><p>其输出结果如下:</p><p><img src="https://s2.loli.net/2023/11/03/57SYoj3rz4Lmftv.jpg" alt="fcn-children-arch" /></p><p>可见<strong>通过children()获得的结构仅包含最外一层</strong>,也即可以通过如下方式获得其最外层:<code>print(list(net.children())[0])</code>,即可以获得第0个Sequential:</p><p><img src="https://s2.loli.net/2023/11/03/DFwYUoTCq4em1uP.jpg" alt="fcn-children-arch-0" /></p><p>而通过modules()获得的也是generator类型,因此也用循环将其输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    net = TestNet(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># modules arch</span><br>    <span class="hljs-keyword">for</span> i,ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(net.modules()):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i,ele))<br></code></pre></td></tr></table></figure><p>其输出结果为:</p><p><img src="https://s2.loli.net/2023/11/03/dG2D8SmkpXiHUAJ.png" alt="fcn-modules-arch" /></p><p>可见,其结果类似于深搜,直接把整个结构DFS了一遍</p><p>因此可得<code>children()</code>和<code>modules()</code>的区别如下:</p><ul><li>通过<code>children()</code>获取网络层级结构,只会取最外层,即根节点下的一层</li><li>通过<code>modules()</code>获取网络层级结构,则类似对网络结构进行DFS,依次输出</li></ul><div class="note note-info">            <p>关于<code>named_children()</code>和<code>named_modules()</code>就不再赘述,因为是在<code>children()</code>和<code>modules()</code>的基础上加了个名字,同样的,它们也是generator类型,可以通过循环遍历,不过对应的是<code>name</code>和<code>module</code>(就是上面代码中的<code>ele</code>),可以通过列表推导式查看相应的结果:</p><p><code>net_named_children = [x for x in net.named_children()]</code></p><p><code>net_named_modules = [x for x in net.named_modules()]</code></p><p>而<code>net.parameters()</code>和<code>net.named_parameters()</code>打印的是模型每层的参数,而多了个<code>named</code>的方法则是把对应的层/子模块的名称也带上了.可以通过列表推导式来查看相应的结果.通过它们的类型也是generator.</p><p><code>net_parameters = [x for x in net.parameters()]</code></p><p><code>net_named_parameters =[x for x in net.named_parameters()]</code></p>          </div><h2 id="pytorch中的模型容器"><a class="markdownIt-Anchor" href="#pytorch中的模型容器"></a> pytorch中的模型容器</h2><p>利用模型容器,可以<strong>自动的将module注册到网络上</strong>,以及<strong>将module的parameters添加到网络上</strong></p><h3 id="nnsequential"><a class="markdownIt-Anchor" href="#nnsequential"></a> nn.Sequential</h3><p>将如<code>Conv2d</code>,<code>BatchNorm2d</code>,<code>ReLU</code>等的module放入<code>nn.Sequential</code>容器中,将会<strong>按照放置的顺序执行</strong>,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br>layer1 = nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br>    nn.BatchNorm2d(<span class="hljs-number">256</span>),<br>    nn.ReLU(),<br>    nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>),<br>    nn.BatchNorm2d(<span class="hljs-number">512</span>),<br>    nn.ReLU()<br>)<br><span class="hljs-built_in">print</span>(layer1)<br></code></pre></td></tr></table></figure><p>其网络层级结构如下所示</p><p><img src="https://s2.loli.net/2023/11/03/iw6r3x1fDpNsymY.png" alt="sequential-arch" /></p><p>其还可以用<code>OrderedDict</code>去为每个module命名,e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> collections<br><br>layer1 = nn.Sequential(collections.OrderedDict([<br>    (<span class="hljs-string">&quot;conv1&quot;</span>, nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>    (<span class="hljs-string">&quot;bn1&quot;</span>, nn.BatchNorm2d(<span class="hljs-number">256</span>)),<br>    (<span class="hljs-string">&quot;relu1&quot;</span>, nn.ReLU()),<br>    (<span class="hljs-string">&quot;conv2&quot;</span>, nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)),<br>    (<span class="hljs-string">&quot;bn2&quot;</span>, nn.BatchNorm2d(<span class="hljs-number">512</span>)),<br>    (<span class="hljs-string">&quot;relu2&quot;</span>, nn.ReLU())<br>]))<br><span class="hljs-built_in">print</span>(layer1)<br></code></pre></td></tr></table></figure><p>网络层级结构如下示</p><p><img src="https://s2.loli.net/2023/11/03/n8zqxsmtRYagSuG.png" alt="sequential-arch-orderedDict" /></p><h3 id="nnmodulelist"><a class="markdownIt-Anchor" href="#nnmodulelist"></a> nn.ModuleList</h3><p>该模型容器类似于list,较之<code>nn.Sequential</code>可以更灵活的使用,充当了存放module的容器,执行的顺序在<code>forward</code>中自行定义,较之原生的list,则是可以注册module于网络以及对其参数添加进<code>nn.Parameters()</code>中.e.g.:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        self.bn1 = nn.BatchNorm2d(<span class="hljs-number">256</span>)<br>        self.relu1 = nn.ReLU(inplace=<span class="hljs-literal">True</span>)<br>        self.layer1 = [nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">100</span>), nn.Linear(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>)]<br>        self.layer2_ = [nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">200</span>), nn.Linear(<span class="hljs-number">200</span>, <span class="hljs-number">10</span>)]<br>        self.layer2 = nn.ModuleList(self.layer2_)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.conv1(x)<br>        x = self.bn1(x)<br>        x = self.relu1(x)<br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.layer1:<br>            x = l(x)<br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> self.layer2:<br>            x = l(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>其执行结果表示,用list充当容器,并不能将所需的module注册,而ModuleList则可以,结果如下图示</p><p><img src="https://s2.loli.net/2023/11/03/mZ2ADBWYPflF31V.png" alt="modulelist-arch" /></p><h2 id="datasetsamplerdataloader三者关系"><a class="markdownIt-Anchor" href="#datasetsamplerdataloader三者关系"></a> Dataset,Sampler,DataLoader三者关系</h2><p>当我们需要对数据文件进行解析获得数据或者自己创建的数据集<code>ImageFolder</code>不能够满足我们的要求,我们则需要自定义一个<code>Dataset</code>类</p><p>而定义好一个<code>Dataset</code>类后,我们可以通过循环或索引得到对应的一条数据,形如<code>data,target</code>,而<code>Sampler</code>则是对这些一条条的数据进行采样的工具,Pytorch提供的主要有<code>SequentialSampler</code>和<code>RandomSampler</code>,这些采样器采样得到的都是这些数据的索引</p><p>显然我们一条条读取数据并不能满足我们的需求,我们更期望的是以batch为单位的读取数据,因而有<code>BatchSampler</code>这么一个批采样器,它会对我们Sampler,如<code>SequentialSampler</code>采样得到的一个个索引整理成一个<code>batch_size</code>大小的索引序列</p><p>在DataLoader里面,我们便是对<code>BatchSampler</code>这个批采样器采样得到的索引序列进行处理,通过传入的<code>dataset</code>参数读取一条条数据,整理成一个<code>List[Tuple[Tensor,Tensor]]</code>这么一个<code>batch_list</code>的形式,交由<code>collate_fn</code>对这一个<code>batch_size</code>大小的数据进行整理,而后得到我们在循环里对<code>DataLoader</code>遍历的数据</p><p>以下展现的是工作进程(num_worker)为0的<code>DataLoader</code>处理方式(跟我上面说的流程一样):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dataloader.py:</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataLoader</span>(<span class="hljs-params"><span class="hljs-type">Generic</span>[T_co]</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_iterator</span>(<span class="hljs-params">self</span>) -&gt; &#x27;_BaseDataLoaderIter&#x27;:</span><br>        <span class="hljs-keyword">if</span> self.num_workers == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> _SingleProcessDataLoaderIter(self)<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SingleProcessDataLoaderIter</span>(<span class="hljs-params">_BaseDataLoaderIter</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_next_data</span>(<span class="hljs-params">self</span>):</span><br>        index = self._next_index()  <span class="hljs-comment"># may raise StopIteration</span><br>        data = self._dataset_fetcher.fetch(index)  <span class="hljs-comment"># may raise StopIteration</span><br>        <span class="hljs-keyword">if</span> self._pin_memory:<br>            data = _utils.pin_memory.pin_memory(data)<br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># fetch.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MapDatasetFetcher</span>(<span class="hljs-params">_BaseDatasetFetcher</span>):</span><br> <span class="hljs-comment"># ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">self, possibly_batched_index</span>):</span><br>        <span class="hljs-keyword">if</span> self.auto_collation:<br>            data = [self.dataset[idx] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> possibly_batched_index]<br>        <span class="hljs-keyword">else</span>:<br>            data = self.dataset[possibly_batched_index]<br>        <span class="hljs-keyword">return</span> self.collate_fn(data)<br></code></pre></td></tr></table></figure><p>自定义一个<code>Dataset</code>类需要的工作:</p><ul><li>继承<code>torch.utils.data.Dataset</code></li><li>在<code>__init__</code>中传入需要处理的数据(可能是数据的目录啥的),对数据的预处理方法</li><li>在**<code>__getitem__</code>**中完成对数据的解析,预处理,然后返回对应的数据,如<code>return data,target</code></li><li>在<code>__len__</code>中反应需要处理的数据集的大小</li></ul><p>自定义一个Sampler类需要的工作:</p><ul><li>继承<code>torch.utils.data.Sampler</code></li><li>在<code>__iter__</code>方法中返回一个iterator</li></ul><h2 id="torchutilsdatadataloader中的collate_fn"><a class="markdownIt-Anchor" href="#torchutilsdatadataloader中的collate_fn"></a> torch.utils.data.DataLoader中的collate_fn</h2><p>在涉及到数据集处理的时候,我们需要考虑到<code>torch.utils.data.Dataset</code>类,以及<code>torch.utils.data.DataLoader</code>类</p><p>其中前者是我们对数据集的处理,比如解析数据集数据,然后<strong>重写<code>__len__()</code>以及<code>__getitem__()</code>方法</strong>,而后在其中对数据进行<strong>预处理</strong>操作,然后才会得到**<code>data,target</code><strong>这样的数据,其中<code>data</code>可以是图像之类的,而<code>target</code>则可能是标签,GTbox的位置等信息,这时我们通过<code>__getitem__</code>方法</strong>只是获取到一条<code>data,target</code>数据**,处理批量数据的任务则由<code>DataLoader</code>承担</p><p>我们在不考虑这一部分将要提及的<code>collate_fn</code>方法前,看一看<code>DataLoader</code>是怎么样将一条数据变成一个<code>batch_size</code>的数据的</p><p>以下是代码部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> Data<br>data = torch.tensor([<br>    [<span class="hljs-number">0.4698</span>, <span class="hljs-number">0.6971</span>, <span class="hljs-number">0.9499</span>, <span class="hljs-number">0.3641</span>],<br>    [<span class="hljs-number">0.0896</span>, <span class="hljs-number">0.5345</span>, <span class="hljs-number">0.5603</span>, <span class="hljs-number">0.5409</span>],<br>    [<span class="hljs-number">0.4988</span>, <span class="hljs-number">0.2155</span>, <span class="hljs-number">0.1244</span>, <span class="hljs-number">0.3456</span>],<br>    [<span class="hljs-number">0.4812</span>, <span class="hljs-number">0.0108</span>, <span class="hljs-number">0.1885</span>, <span class="hljs-number">0.8593</span>],<br>    [<span class="hljs-number">0.6564</span>, <span class="hljs-number">0.3428</span>, <span class="hljs-number">0.8815</span>, <span class="hljs-number">0.3558</span>]])<br>target = torch.tensor([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])<br>dataset = Data.TensorDataset(data, target)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dataset:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br>batch_size = <span class="hljs-number">2</span><br>dataloader = Data.DataLoader(batch_size=batch_size, dataset=dataset)<br><br><span class="hljs-keyword">for</span> d, t <span class="hljs-keyword">in</span> dataloader:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;data:<span class="hljs-subst">&#123;d&#125;</span>\ntarget:<span class="hljs-subst">&#123;t&#125;</span>\n&quot;</span>)<br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">(tensor([0.4698, 0.6971, 0.9499, 0.3641]), tensor(4))</span><br><span class="hljs-string">(tensor([0.0896, 0.5345, 0.5603, 0.5409]), tensor(4))</span><br><span class="hljs-string">(tensor([0.4988, 0.2155, 0.1244, 0.3456]), tensor(1))</span><br><span class="hljs-string">(tensor([0.4812, 0.0108, 0.1885, 0.8593]), tensor(3))</span><br><span class="hljs-string">(tensor([0.6564, 0.3428, 0.8815, 0.3558]), tensor(1))</span><br><span class="hljs-string">data:tensor([[0.4698, 0.6971, 0.9499, 0.3641],</span><br><span class="hljs-string">        [0.0896, 0.5345, 0.5603, 0.5409]])</span><br><span class="hljs-string">target:tensor([4, 4])</span><br><span class="hljs-string"></span><br><span class="hljs-string">data:tensor([[0.4988, 0.2155, 0.1244, 0.3456],</span><br><span class="hljs-string">        [0.4812, 0.0108, 0.1885, 0.8593]])</span><br><span class="hljs-string">target:tensor([1, 3])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>可见,<code>dataset</code>的结构应是一个<code>Sequential[Tuple[Tensor,Tensor]]</code>,而其中一条数据中的tuple里面则包含了<code>data</code>以及<code>target</code>,也即是说通过<code>Dataset</code>我们逐条获取数据得到的是形如<code>(data,target)</code>这样的数据</p><p>而显然我们更加希望<code>data</code>归为<code>data</code>,而<code>target</code>归为<code>target</code>,就如用普通的<code>DataLoader</code>得到的结果一样,输出的结果是一个batch的data和一个batch的target</p><p>显然<code>DataLoader</code>在其内部即帮我们完成了①按batch_size划分数据;②<code>data</code>为<code>data</code>,<code>target</code>为<code>target</code></p><p>以下,我们采用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的形式于<code>collate_fn</code>看下输出的结果是什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">loader = Data.DataLoader(batch_size=batch_size, dataset=dataset, collate_fn=<span class="hljs-keyword">lambda</span> x: x)<br>it = <span class="hljs-built_in">iter</span>(loader)<br>batch_data = <span class="hljs-built_in">next</span>(it)<br><span class="hljs-built_in">print</span>(batch_data)<br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># [(tensor([0.4698, 0.6971, 0.9499, 0.3641]), tensor(4)), (tensor([0.0896, 0.5345, 0.5603, 0.5409]), tensor(4))]</span><br></code></pre></td></tr></table></figure><p>根据输出结果不难看出: 在进入<code>collate_fn</code>之前,数据已经按<code>batch_size</code>划分好了,其结构为:<code>List[Tuple(Tensor,Tensor)]</code>,其中List的大小是batch_size的大小,但是数据格式依旧是<code>dataset</code>的结构,因而<code>collate_fn</code>这个方法是用来<strong>调整数据格式</strong>的,在我们不调用自定义的<code>collate_fn</code>时,会用系统默认的函数,将输出调整为batch_size大小的data和target这两个部分</p><p>以下是等价于系统默认的<code>collate_fn</code>(能将输出划分为data和target两部分):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># input x: List[Tuple[Tensor,Tensor],...]</span><br>collate_func = <span class="hljs-keyword">lambda</span> x:(<br>torch.cat(<br>        <span class="hljs-comment"># data: [4] -&gt; [1,4] -&gt; [N,4]</span><br>        <span class="hljs-comment"># target: [1] -&gt; [1,1] -&gt; [N,1]</span><br>        [x[i][j].unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x))],<span class="hljs-number">0</span><br>    ) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x[<span class="hljs-number">0</span>]))<br>)<br></code></pre></td></tr></table></figure><p>以上是分别对data,target数据进行取出,然后扩充维度,而后对扩充的维度进行拼接,便得到了期望的结果</p><p>一般来说,不会用到它,但<mark>我在网上以及个人思考后</mark>(pytorch这方面源码没看懂😂),应该是通过<code>torch.stack()</code>进行的维度堆叠,因而如果图片的尺寸或者target中如标签的数目不等,则需要自定义</p><p>比如说一个batch_size是2,那两张图片分别是有两个和三个目标,即对应的target为<code>[2,5]/[3,5]</code>无法用<code>stack()</code>对它们简单的拼接,因而需要自己定义一个<code>collate_fn</code>去处理这个问题,自己去定义一个batch出来的数据的格式</p><h2 id="torch数据并行"><a class="markdownIt-Anchor" href="#torch数据并行"></a> torch数据并行</h2><p>以下内容参考文章:</p><p><a href="https://zhuanlan.zhihu.com/p/648596428">分布式训练</a></p><p><a href="https://zhuanlan.zhihu.com/p/467103734">快速上手</a></p><h3 id="torchnndataparallel"><a class="markdownIt-Anchor" href="#torchnndataparallel"></a> torch.nn.DataParallel</h3><h3 id="torchnndistributeddataparallel"><a class="markdownIt-Anchor" href="#torchnndistributeddataparallel"></a> torch.nn.DistributedDataParallel</h3><h3 id="torchdistributed"><a class="markdownIt-Anchor" href="#torchdistributed"></a> torch.distributed</h3><h2 id="计算图"><a class="markdownIt-Anchor" href="#计算图"></a> 计算图</h2><p>计算图可以表示模型中的<strong>数据</strong>经过<strong>运算</strong>后的流向，是一个有向无环图（DAG），<strong>有利于用链式法则计算梯度</strong>。它是由node和edge构成，node表示的是数据，如Tensor等，edge则表示的是计算，如加减乘除、卷积、非线性函数变换等</p><p><img src="https://s2.loli.net/2023/11/03/lFW9cqwrdLek2xS.jpg" alt="ComputationGraphExample" /></p><p>以上的计算图中，利用代码表示并计算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（即偏导/梯度的分量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>w = torch.tensor([<span class="hljs-number">1.</span>],requires_grad = <span class="hljs-literal">True</span>)<br>x = torch.tensor([<span class="hljs-number">2.</span>],requires_grad = <span class="hljs-literal">True</span>)<br><br>a = torch.add(w,x)<br>b = torch.add(w,<span class="hljs-number">1</span>)<br>y = torch.mul(a,b)<br><br>y.backward()<br><br><span class="hljs-built_in">print</span>(w.grad)<br><br><span class="hljs-comment"># 运行结果如下，其中grad属性是取w的梯度</span><br><span class="hljs-comment"># tensor([5.])</span><br></code></pre></td></tr></table></figure><p>根据链式法则，我们知道，要求</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow></mfrac><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>b</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w} = \frac{\partial y}{\partial a}\frac{\partial a }{\partial w} + \frac{\partial y}{\partial b}\frac{\partial b}{\partial w} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>即是对y到w上涉及到的路径进行求和，而路径则是依次求偏导相乘得到的。从图及上式可知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial w} = a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，所求得的结果与代码计算的无异</p><p>此外，我们知道原函数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>w</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a = w+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = a*b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，它们的不同会影响到求导过程中的计算（乘法和加法求导时的区别），因此<code>Tensor</code>中提供了<code>grad_fn</code>属性，便于获取不同运算方式时的求导规则。</p><p>以下是在上面代码补了几行<code>print</code>，打印出<code>grad_fn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.grad_fn)<br><span class="hljs-built_in">print</span>(b.grad_fn)<br><span class="hljs-built_in">print</span>(y.grad_fn)<br><span class="hljs-comment"># 运行结果如下</span><br><span class="hljs-comment"># &lt;AddBackward0 object at 0x000002AA99CA6208&gt;</span><br><span class="hljs-comment"># &lt;AddBackward0 object at 0x000002AA99CA6208&gt;</span><br><span class="hljs-comment"># &lt;MulBackward0 object at 0x000002AA99CA6208&gt;</span><br></code></pre></td></tr></table></figure><p>上图给出的例子中，<code>x</code>和<code>w</code>均是输入值，是作为图中的叶子节点存在的，如果没有特别标明，在反向传播求完梯度后，非叶子节点的梯度是会被释放的，只保留叶子节点的梯度，如需保留非叶子节点的梯度，可以利用<code>retain_grad</code>属性标明</p><p>以下是演示代码及结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>w = torch.tensor([<span class="hljs-number">1.</span>],requires_grad = <span class="hljs-literal">True</span>)<br>x = torch.tensor([<span class="hljs-number">2.</span>],requires_grad = <span class="hljs-literal">True</span>)<br><br>a = torch.add(w,x)<br>b = torch.add(w,<span class="hljs-number">1</span>)<br>y = torch.mul(a,b)<br><br>a.retain_grad()<br>b.retain_grad()<br><br>y.backward()<br><br><span class="hljs-built_in">print</span>(w.grad)<br><span class="hljs-built_in">print</span>(a.grad_fn)<br><span class="hljs-built_in">print</span>(b.grad_fn)<br><span class="hljs-built_in">print</span>(y.grad_fn)<br><br><span class="hljs-built_in">print</span>(a.is_leaf,b.is_leaf,y.is_leaf)<br><span class="hljs-built_in">print</span>(x.is_leaf,w.is_leaf)<br><br><span class="hljs-built_in">print</span>(a.grad,b.grad,y.grad)<br><span class="hljs-comment"># 运行结果如下</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">tensor([5.])</span><br><span class="hljs-string">&lt;AddBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">&lt;AddBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">&lt;MulBackward0 object at 0x00000266EE747208&gt;</span><br><span class="hljs-string">False False False</span><br><span class="hljs-string">True True</span><br><span class="hljs-string">tensor([2.]) tensor([3.]) None</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>详细区别可见：<a href="http://cs231n.stanford.edu/slides/2018/cs231n_2018_lecture08.pdf">cs231n-lecture08-pdf</a></p><h3 id="pytorch和tensorflow计算图比较"><a class="markdownIt-Anchor" href="#pytorch和tensorflow计算图比较"></a> PyTorch和Tensorflow计算图比较</h3><p>PyTorch中的计算图是动态生成的，即类似于解释型语言，它是在运行过程中动态生成的；</p><p>Tensorflow的计算图则是静态生成的，即类似于编译型语言，是先生成计算图，而后进行运算。</p><p>显然动态生成的更灵活，利于定位错误，进行debug；静态生成的则可以进行优化，更高效些。</p><p>PyTorch和Tensorflow现也各自都有动态和静态的计算图于各自的子库中</p><p><img src="https://s2.loli.net/2023/11/03/nvNOErxZqjhtWbk.png" alt="Computation Graph Difference" /></p><h2 id="逐层遍历模型子模块"><a class="markdownIt-Anchor" href="#逐层遍历模型子模块"></a> 逐层遍历模型子模块</h2><p>当我们从<code>torchvision.models</code>中去导入一个模型的时候，比如resnet18</p><p><code>from torchvision.models import resnet18</code></p><p>我们通过<code>print(model) # resnet18</code>会打印出模型详细的层信息，这些个层信息是经由<code>OrderedDict</code>包装过的，即是通过该结构对层信息进行重命名</p><p>我们可以通过<code>model.__dict__</code>来查看模型的内部信息，为了便于查看，我们遍历着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18<br><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model = resnet18().to(device)<br><span class="hljs-built_in">print</span>(model)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> model.__dict__.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, v)<br></code></pre></td></tr></table></figure><p>以下是模型内部信息打印结果(没截全)：</p><p><img src="https://s2.loli.net/2023/12/04/DNfQgtswnzu9UPe.png" alt="model-dict" /></p><p>不难看出，模型内部信息包含了丰富的内容，其中我们这里关注<code>_modules</code>属性，通过它我们可以很方便地对模型的层信息（子模块）逐层遍历</p><p>我们通过<code>model.__dict__[_modules]</code>获取模型的层信息，其中获取到的层信息是用<code>OrderedDict</code>包装过的，因此进行如下遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">m_dict = model.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br><span class="hljs-keyword">for</span> name, sub_module <span class="hljs-keyword">in</span> m_dict.items():<br>    sub_module_class = sub_module.__class__<br>    sub_module_name = sub_module.__class__.__name__<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_class:&quot;</span>, sub_module_class)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_name:&quot;</span>, sub_module_name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span> % name)<br></code></pre></td></tr></table></figure><p>以下是部分遍历结果：</p><p><img src="https://s2.loli.net/2023/12/04/FvhKZHnsbom3SeG.jpg" alt="model_sub_module_iteration" /></p><p>通过递归可以对子模块进行完整的遍历，因为有些子模块是通过模型容器封装的，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torchvision.models <span class="hljs-keyword">import</span> resnet18<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursively_iter_sub_module</span>(<span class="hljs-params">module_dict, module_forward_dict</span>):</span><br>    <span class="hljs-keyword">for</span> name, sub_module <span class="hljs-keyword">in</span> module_dict.items():<br>        <span class="hljs-keyword">if</span> sub_module <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(sub_module, torch.nn.Module) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>            <span class="hljs-keyword">break</span><br>        sub_module_class = sub_module.__class__<br>        sub_module_name = sub_module.__class__.__name__<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sub_module_class:%s\nsub_module_name:%s\nname:%s&quot;</span> %<br>              (sub_module_class, sub_module_name, name))<br>        sub_sub_modules = sub_module.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sub_sub_modules) == <span class="hljs-number">0</span>:<br>            module_forward_dict.update(&#123;sub_module: sub_module.forward&#125;)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(sub_sub_modules) &gt; <span class="hljs-number">0</span>:<br>            recursively_iter_sub_module(sub_sub_modules, module_forward_dict)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>    model = resnet18().to(device)<br>    sub_modules = model.__dict__[<span class="hljs-string">&#x27;_modules&#x27;</span>]<br>    sub_module_forward_dict = &#123;&#125;<br>    recursively_iter_sub_module(sub_modules, sub_module_forward_dict)<br>    <span class="hljs-keyword">for</span> module, forward <span class="hljs-keyword">in</span> sub_module_forward_dict.items():<br>        <span class="hljs-built_in">print</span>(module, <span class="hljs-string">&quot;:&quot;</span>, forward)<br><br></code></pre></td></tr></table></figure><p>这里通过<code>&#123;module:forward&#125;</code>把所有的子模块按顺序封装了是为了后续便于对<code>forward</code>重封装</p><p>以下是部分运行结果图：</p><p><img src="https://s2.loli.net/2023/12/05/Bpr61KqoZsGUI5m.png" alt="recursively_iter_sub_module" /></p><h2 id="pytorch的hook"><a class="markdownIt-Anchor" href="#pytorch的hook"></a> PyTorch的hook</h2><p>pytorch的hook有针对Tensor的,也有针对module的,涉及到的函数如下:</p><pre><code class="mermaid" >graph LRhook --> Tensor & ModuleTensor --> register_hookModule --> register_forward_hook & register_forward_pre_hook & register_full_backward_hook & register_full_backward_pre_hook  </code></pre><h3 id="hook-for-tensor"><a class="markdownIt-Anchor" href="#hook-for-tensor"></a> hook for Tensor</h3><p><code>register_hook(hook)</code>当对应<code>tensor</code>的梯度计算完的时候,这个钩子函数(即里面的hook)会被调用,<strong>该钩子函数可以用来打印中间节点的梯度信息,甚至修改计算完的梯度(虽然pytorch不建议你这么做)</strong>,这个<code>register_hook()</code>返回值是一个<code>handle</code>(<code>RemovableHandle</code>类的),这个<code>handle</code>可以调用<code>remove()</code>方法移除对应<code>tensor</code>的钩子函数</p><p>钩子函数的声明需要遵循如下规则:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(grad) -&gt; Tensor <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>输入是这个tensor对应的梯度,返回值是一个Tensor或一个None值</strong></p><p>用例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = torch.tensor(<span class="hljs-number">2.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    b = torch.tensor(<span class="hljs-number">3.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    c = a * b<br>    <span class="hljs-built_in">print</span>(c)<br>    c_hook = <span class="hljs-keyword">lambda</span> grad: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cc:&quot;</span>, grad)<br>    c.register_hook(c_hook)<br>    d = torch.tensor(<span class="hljs-number">4.</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    d.register_hook(<span class="hljs-keyword">lambda</span> grad: grad * <span class="hljs-number">2</span>)<br>    e = c * d<br>    e.backward()<br>    <span class="hljs-built_in">print</span>(a.grad, b.grad, d.grad)<br><br><span class="hljs-comment"># 输出结果:</span><br>tensor(<span class="hljs-number">6.</span>, grad_fn=&lt;MulBackward0&gt;)<br>cc: tensor(<span class="hljs-number">4.</span>)<br>tensor(<span class="hljs-number">12.</span>) tensor(<span class="hljs-number">8.</span>) tensor(<span class="hljs-number">12.</span>)<br></code></pre></td></tr></table></figure><p>上述<code>a,b,d</code>均为计算图中的叶子节点,<code>c,e</code>为中间节点,因此当我们完成反向传递后,计算图会释放中间节点的梯度,我们可以通过上面说的<code>retain_grad()</code>的方式去保留某些<code>tensor</code>的梯度,也可以像上述通过钩子函数,在该张量算完梯度后,把其梯度值钩出来(因为没有retain,反向传播完后还是会释放)</p><p>此外,上述也通过lambda表达式对<code>d</code>的梯度值进行了修改,变成了原来的2倍,原本应该是6的,现在<code>d</code>的梯度是12</p><h3 id="hook-for-module"><a class="markdownIt-Anchor" href="#hook-for-module"></a> hook for Module</h3><p>用于<code>Module</code>的钩子函数在注册的时候返回值也是一个<code>handle</code>,也可以通过<code>handle.remove()</code>移除对应<code>Module</code>的钩子函数,以下对它们各自的钩子函数的声明进行介绍,并且展示一个统一的用例</p><p>其中,钩子函数可以用于<code>Module(nn.Module)</code>的子类,如一些基础的算子<code>Conv2d</code>,<code>BatchNorm2d</code>,可以提取它们<code>activation</code>等,也可以将中间层的结果可视化处理</p><ul><li><code>register_forward_hook(hook)</code>注册的钩子函数是在<code>forward</code>完成后被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, args, output) -&gt; <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> modified output<br></code></pre></td></tr></table></figure><ul><li><code>register_forward_pre_hook(hook)</code>注册的钩子函数是在<code>forward</code>执行前被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, args) -&gt; <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> modified <span class="hljs-built_in">input</span><br></code></pre></td></tr></table></figure><ul><li><code>register_full_backward_hook(hook)</code>注册的钩子函数在<code>backward</code>完成后被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, grad_input, grad_output) -&gt; <span class="hljs-built_in">tuple</span>(Tensor) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ul><li><code>register_full_backward_pre_hook(hook)</code>注册的钩子函数在<code>backward</code>执行前被调用,钩子函数的声明如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hook(module, grad_output) -&gt; <span class="hljs-built_in">tuple</span>[Tensor] <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>总用例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TestNet, self).__init__()<br>        self.conv1 = nn.Conv2d(in_channels=<span class="hljs-number">1</span>, out_channels=<span class="hljs-number">2</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>)<br>        self.maxpool = nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>)<br>        self._initial_weights()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_initial_weights</span>(<span class="hljs-params">self</span>):</span><br>        self.conv1.weight[<span class="hljs-number">0</span>].data.fill_(<span class="hljs-number">1</span>)<br>        self.conv1.weight[<span class="hljs-number">1</span>].data.fill_(<span class="hljs-number">2</span>)<br>        self.conv1.bias.data.zero_()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-comment"># x -&gt; [1,1,4,4]</span><br>        x = self.conv1(x)<br>        <span class="hljs-comment"># x -&gt; [1,2,2,2]</span><br>        x = self.maxpool(x)<br>        <span class="hljs-comment"># x -&gt; [1,2,1,1]</span><br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward_hook</span>(<span class="hljs-params">module_name=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_forward_hook</span>(<span class="hljs-params">module, <span class="hljs-built_in">input</span>, output</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>, <span class="hljs-string">&quot;forward pass&quot;</span>, <span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Module Name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(module_name))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>[<span class="hljs-number">0</span>].shape))  <span class="hljs-comment"># 变成了Tuple,取[0],才是输入的tensor</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Input: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(output.shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Output: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(output))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">104</span>)<br>    <span class="hljs-keyword">return</span> _forward_hook<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward_hook</span>(<span class="hljs-params">module_name</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_backward_hook</span>(<span class="hljs-params">module, grad_input, grad_output</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>, <span class="hljs-string">&quot;backward pass&quot;</span>, <span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">15</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Module Name: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(module_name))<br>        <span class="hljs-keyword">if</span> grad_input[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Input Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_input[<span class="hljs-number">0</span>].shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Input: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_input))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Output Shape: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_output[<span class="hljs-number">0</span>].shape))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Gradient Output: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(grad_output))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">105</span>)<br>    <span class="hljs-keyword">return</span> _backward_hook<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    model = TestNet()<br>    loss_function = nn.MSELoss()<br>    optimizer = optim.SGD(model.parameters(), lr=<span class="hljs-number">.0001</span>)<br><br>    forward_hooks_dict = &#123;&#125;<br>    backward_hooks_dict = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> name, module <span class="hljs-keyword">in</span> model.named_modules():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module, nn.Module) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:  <span class="hljs-comment"># 确保取到的模块可以注册hook</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(module._modules) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 确保取到的模块是子模块,而非中间的模块,如nn.Sequential之类的</span><br>            f_handle = module.register_forward_hook(forward_hook(name))<br>            forward_hooks_dict[name] = f_handle  <span class="hljs-comment"># 存入对应dict,便于之后remove对应name的hook</span><br>            b_handle = module.register_full_backward_hook(backward_hook(name))<br>            backward_hooks_dict[name] = b_handle<br><br>    fake_data = torch.ones([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br>    fake_label = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], dtype=torch.<span class="hljs-built_in">float</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;fake label shape: &#123;&#125;\nfake label:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(fake_label.shape, fake_label))<br>    y_logit = model(fake_data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y_logit shape:&#123;&#125;\ny_logit&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y_logit.shape, y_logit))<br>    loss = loss_function(y_logit, fake_label)<br>    optimizer.zero_grad()<br>    loss.backward()<br>    optimizer.step()<br></code></pre></td></tr></table></figure><p>运行结果如下图:</p><p><img src="https://s2.loli.net/2023/12/10/vFOdzJ5gT4Pt2eY.png" alt="forward_backward_hook_example" /></p><p>具体使用可以参考:<a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module.register_forward_hook">pytorch-hook使用指南</a></p><h2 id="dataloader中的num_worker和torch中的set_num_threads"><a class="markdownIt-Anchor" href="#dataloader中的num_worker和torch中的set_num_threads"></a> DataLoader中的num_worker和torch中的set_num_threads</h2><h3 id="先说说一些cpu的概念"><a class="markdownIt-Anchor" href="#先说说一些cpu的概念"></a> 先说说一些CPU的概念</h3><p>通过以下指令查看<strong>物理CPU数目</strong>:</p><p><code>cat /proc/cpuinfo | grep 'physical id'| sort | uniq | wc -l </code></p><p>通过以下指令查看<strong>每个CPU的核心数</strong>:</p><p><code>cat /proc/cpuinfo | grep 'core id' | sort | uniq | wc -l</code></p><p>以上,我们就可以计算出<strong>CPU的总核心数</strong></p><p><code>总核心数=物理CPU数目*每个CPU的核心数</code></p><p>而一般来说,一个核心就对应一个物理线程,而有个叫<strong>超线程</strong>的技术,可以把一个核心当作两个线程来用,也就相当于像两个核心一样.而总逻辑CPU数就是在总核心数的基础上乘上超线程的倍数</p><p><code>总逻辑CPU数目=物理CPU数目*每个CPU的核心数*超线程系数</code></p><p>可以通过以下指令查看<strong>总逻辑CPU数目</strong></p><p><code>cat /proc/cpuinfo | grep 'processor' |sort | uniq | wc -l </code></p><p>关于逻辑CPU的体现,比如<code>top</code>指令中的<code>%CPU</code>表示的是占用的逻辑CPU数目</p><h3 id="关于torchset_num_threads"><a class="markdownIt-Anchor" href="#关于torchset_num_threads"></a> 关于torch.set_num_threads()</h3><p>这个<strong>线程数默认是CPU核心总数</strong>,可以通过<code>torch.get_num_threads()</code>获得,且<strong>一般默认的运算效率是最高的</strong></p><p>需要设置这个的场景是当<strong>多人共享CPU资源进行模型运算</strong>时用的,<strong>以避免一个进程抢占过多的CPU核心</strong></p><p>除了通过<code>torch.set_num_threads()</code>设置,还可以通过环境变量设置,如:<code>MKL_NUM_THREADS和OMP_NUM_THREADS</code>来设置,它们的优先级如下:<code>torch.set_num_threads() &gt; MKL_NUM_THREADS &gt; OMP_NUM_THREADS</code></p><p>其中<strong>一般要运用到这个设置是利用CPU进行大量张量操作</strong>,若是大部分的张量操作都是在GPU上,那设置这个也没啥用,且设置的时候由于PyTorch文档没有说哪些运算会从这个设置上受益,因此建议一边看着CPU利用率一边调整线程数,以最大化CPU利用率</p><p>这些设置的线程应该是用于<strong>算子内并行</strong>(intra-op parallelism)的</p><h3 id="关于dataloader中的参数num_worker"><a class="markdownIt-Anchor" href="#关于dataloader中的参数num_worker"></a> 关于DataLoader中的参数num_worker</h3><p>DataLoader中的num_worker是用于指定加载数据和执行变换的并行worker的数目.如果你在加载很大的图片或者有着复杂的变换操作时,即是此时你的GPU处理数据很快,但是你的DataLoader喂数据给GPU很慢而导致不能连续feed GPU,这种情况下就可以设置较多的worker来解决问题</p><p>一般对num_worker的设置是直到epoch中的一个step是足够快的(也就是数据可以及时喂给GPU)</p><p>注意:num_worker用到的也是计算机的CPU核心数</p><p>本部分内容大多学习自:<a href="https://blog.csdn.net/a_piece_of_ppx/article/details/123714865">ddp中的核心数和线程数</a>、<a href="https://www.zhihu.com/question/394952301/answer/1225338415">pytorch模型在multiprocessing下前馈速度明显降低的原因是什么？</a></p><p><mark>疑惑点:如果我是CPU+GPU计算,那么设置num_worker加速数据读取就好,那如果我是纯CPU计算,我默认我set_num_threads用的是CPU所有核心数,那我num_worker会抢占资源嘛,还是用的是超线程的(如果有)</mark></p><h2 id="trainevalno_grad三者区别"><a class="markdownIt-Anchor" href="#trainevalno_grad三者区别"></a> train(),eval(),no_grad()三者区别</h2>]]></content>
    
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>image-classification的一些常用模型</title>
    <link href="/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/03/09/image-classification%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="cnn"><a class="markdownIt-Anchor" href="#cnn"></a> CNN</h2><p><strong>CNN</strong>,即<strong>卷积神经网络</strong>,我们所<strong>设计</strong>的<strong>filter</strong>(kernel/neuron),让它去跟图片做卷积,就可以<strong>学习我们想要学习的特征</strong>.比如我们所设计的filter可以识别出图片的边界情况,则输出的那一个通道的特征图就可以反映图片的边界情况.</p><p>但是当我们输入一张猫的图片时,想要学习到猫的特征就需要很多很多个filter.因为一个filter可能学习的是猫的耳朵,一个学的是猫的尾巴,<strong>因此需要多个filter,才可以将学习到的局部特征逐渐堆叠称为全局特征.从而完成图像识别的功能</strong>.<strong>需注意filter的通道数需与输入的特征图的通道数相等</strong>.</p><p><strong>以上便是卷积层conv所作的事情,即学习图像的特征</strong></p><p>而后学习到的图像会有相应尺寸的变化,即原先是一张3*224*224的图片,通过4个3*3*3的filter以1步距的方式卷积后,所得的尺寸变为:4*222*222.很明显<strong>图片变小</strong>了,此外<strong>原图像的边界相较于内部,计算的次数更少</strong>,<strong>因此可以通过填充空白区域的方式即padding来使得边界像素点和内部像素点获得相同的计算次数.且有padding填充,卷积后的图片大小不变.</strong></p><p>而<strong>图片中的像素点,并非全部有用</strong>.因此卷积后得到的特征图需要经由<strong>池化层pooling来减少参数数量,也可以防止模型过拟合,提取图像的更主要的特征</strong>.一般来说,我们卷积的操作就是对应元素相乘后求和,因此如果是需要学习的特征,则经卷积层计算后其对应的输出位置的值会比较大.由此,我们的池化层可以对一个小区域内,即利用2*2的filter(步距为2),对区域内的比较大的值进行保留.即为我们的<strong>maxPooling</strong>.同时也有一种中庸的方法,即对区域内的值取平均,此为<strong>averagePooling</strong>.</p><p><strong>以上便是池化层pooling所做的事情,即提取主要特征并减少参数数量,防止过拟合</strong></p><p>最后,我们通过层层的局部特征学习,主要特征提取如此反复的过程,终于得到了一个像样的可以反映输入图片特征的总体特征图,则可以进行分类了.而在分类之前,我们得到的特征图,是一个多维的矩阵,我们期望的输出结果是一个值,因此需要通过<strong>全连接层Fully Connected</strong>来进行处理.在进入全连接层处理前,我们需要对多维的矩阵进行展平处理,即对应的维度相乘(如1024(C)*7(H)*7(W)),然后通过全连接层(即最基础的神经网络计算方式)将神经元数目变为如100个,然后再经过一个全连接层,将神经元数目变为可分类的种数,如10,再经由softmax处理后,即可取概率值最大的为图像分类的输出值.</p><p>需注意,我们的卷积层和全连接层后面都需要跟着激活函数,即对其输出进行非线性化处理.</p><p>输入输出尺寸变换计算公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>o</mi><mi>u</mi><msub><mi>t</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>i</mi><msub><mi>n</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>−</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub><mo>+</mo><mn>2</mn><mi>P</mi><mo stretchy="false">)</mo></mrow><mi>S</mi></mfrac><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">out_{size}=\frac{(in_{size}-F_{size}+2P)}{S}+1 \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span></span></span></span></p><p>其中P是Padding，S是Stride</p><h2 id="alexnet"><a class="markdownIt-Anchor" href="#alexnet"></a> AlexNet</h2><h3 id="亮点"><a class="markdownIt-Anchor" href="#亮点"></a> 亮点</h3><ul><li>利用双GPU对网络加速训练</li><li>采用ReLU激活函数</li><li>全连接层采用Dropout随机失活神经元,以避免过拟合</li></ul><center><img src="https://s2.loli.net/2023/11/03/bSRlK1FQsU4TrwO.png" alt="dropout" style="zoom:67%;" /></center><ul><li>采用LRN(后经证实无用)</li></ul><h3 id="网络结构图"><a class="markdownIt-Anchor" href="#网络结构图"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/eOdMbmTFIVr2Ely.png" alt="alexnet-arch" style="zoom:60%;" /></center><h2 id="vgg"><a class="markdownIt-Anchor" href="#vgg"></a> VGG</h2><h3 id="亮点-2"><a class="markdownIt-Anchor" href="#亮点-2"></a> 亮点</h3><p><strong>通过堆叠多个3*3的卷积核来代替大尺度的卷积核</strong> ，比如AlexNet里的11*11，7*7这样子的卷积核</p><p>如：可以<strong>通过堆叠两个3*3的卷积核来替代5*5的卷积核，或者三个3*3的卷积核来替代7*7的卷积核</strong>。感受野相同的同时，还减少了计算量。常用的是VGG-16和VGG-19</p><p><strong>理论依据：它们拥有相同的感受野</strong></p><h3 id="感受野receptive-filed"><a class="markdownIt-Anchor" href="#感受野receptive-filed"></a> 感受野(receptive filed)</h3><p><strong>在CNN中，某一层输出结果中的一个单元所对应于输入层的区域大小，即为感受野</strong>.也就是说在输出的特征矩阵的某一个元素，它对应于输入层上的区域大小<br />感受野计算公式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi>e</mi><mo>+</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F(i) = (F(i+1) -1) * Stride + filter_{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>层的感受野，Stride是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>层的步距，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><msub><mi>r</mi><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">filter_{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是卷积核或者池化核尺寸</p><h3 id="网络结构图-2"><a class="markdownIt-Anchor" href="#网络结构图-2"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/05/GLsyjINliPQfO97.png" alt="vgg-arch" style="zoom:60%;" /></center><h2 id="googlenet"><a class="markdownIt-Anchor" href="#googlenet"></a> GoogLeNet</h2><h3 id="亮点-3"><a class="markdownIt-Anchor" href="#亮点-3"></a> 亮点</h3><ul><li>引入了inception结构，融合不同尺度的特征信息</li><li>使用1*1的卷积核进行降维以及映射处理</li><li>添加两个辅助分类器帮助训练</li><li>丢弃全连接层，使用平均池化层，减少模型参数</li><li>VGG等只有一个输出层，GoogLeNet有三个输出层（有两个是辅助分类层）</li></ul><p><strong>其中最重要的便是前两个创新点，通过借鉴NiN(Network in Network)的思想，利用1*1的卷积核进行降维，此外还增加了网络的非线性（最后用平均池化层替换FC也是出自NiN的思想）；而inception结构，所导致的融合多尺度特征信息是指利用横向排列的多个不同尺度的卷积核来获取图像中的信息，即从横向，而非纵向（深度）来进行创新</strong></p><h3 id="inception结构块"><a class="markdownIt-Anchor" href="#inception结构块"></a> inception结构块</h3><center><img src="https://s2.loli.net/2023/11/03/qGU3IA8l6xF4SuE.png" alt="inception-arch" style="zoom:60%;" /></center><p>先看图a，我们的输入层会经过1*1，3*3，5*5这几个不同尺度的卷积核来提取特征以及3*3的最大池化层提取特征。再提取特征通过对padding进行调整使得最终得到的输出的特征矩阵的大小一致，然后在深度上进行堆叠。因此inception结构快可以看作是在水平方向上加深网络；</p><p>之所以采取多尺度的卷积核，是因为我们的物体在图片里可大可小，因此若是卷积核选取的不恰当，那么则需要通过加深网络去学习对应的特征，但是随之而来的梯度消失问题也会导致最终的分类效果差强人意。而多尺度的卷积核则规避了卷积核尺寸选取的问题。</p><p>而图b是在图a的基础上，增加了1*1的卷积核去降维、聚合以及增加非线性；这可以降低我们的计算量</p><p>其实inception结构块可以看作<strong>既保持网络的稀疏性（局部连接[相对的是全连接]），又利用了密集矩阵高计算性能</strong></p><h3 id="辅助分类器"><a class="markdownIt-Anchor" href="#辅助分类器"></a> 辅助分类器</h3><p>其实在最后inference的时候，并没有利用到辅助分类器，因为作者认为，中间层产生的特征具有较强的识别力，因此它们对参数修正很重要，所以主要是利用它们的loss来反向更新参数的（除了正常网络的loss外，它们的loss也会乘以一定权重后加到主网络的loss中）。</p><h3 id="网络结构图-3"><a class="markdownIt-Anchor" href="#网络结构图-3"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/wv5SdZY7RLVeuFq.png" alt="googlenet-arch" style="zoom:67%;" /></center><h2 id="resnet"><a class="markdownIt-Anchor" href="#resnet"></a> ResNet</h2><h3 id="亮点-4"><a class="markdownIt-Anchor" href="#亮点-4"></a> 亮点</h3><ul><li>提出了残差结构块</li><li>利用Batch Normalization加速训练，丢弃了dropout</li></ul><h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3><p>在介绍接下来的残差结构块和批归一化的操作前。ResNet与先前的VGG或是GoogLeNet的一大差别在与它的layer很多。</p><p>而VGG这些先前的网络若是加大layer的话，会面临层数多的反而比层数少的top1error更大，也即分类的结果更加不准确了。</p><p>从逻辑上来说，应该不会造成此结果，即我们加多的层若是对原来的特征矩阵只做恒等变换，那么应该不会导致结果更差。</p><p>而之所以加多层数出现更糟糕的结果的原因在于：</p><ul><li>梯度消失/梯度爆炸</li><li>网络退化问题</li></ul><p>梯度消失和梯度爆炸都发生在反向传播的过程中，若系数&lt;1或&gt;1则向前传播误差的时候，则会导致梯度消失或是梯度爆炸的问题，导致结果难以收敛。而层数加深则导致了这个结果。可以通过归一化操作和标准初始化这些操作来处理，本文提出了BN层，用于卷积后对数据的分布进行归一化处理；</p><p>而网络退化问题是：当我们适当增加网络层数，训练集loss逐渐下降并趋于饱和，而此时若再增加网络层数，则会出现loss增大的情况（过拟合是loss一直减小）。此时若之前以达到最优，则新加上的层若只是进行恒等映射，那么结果应该依旧是最优的，但是实际结果并非如此，则可以猜测：恒等映射并不容易被神经网络去拟合（实际上并不是恒等映射，而是一些非线性层，是利用非线性层去近似恒等映射，但是很难做到）。而残差结构则解决了这一问题。</p><h3 id="残差结构块"><a class="markdownIt-Anchor" href="#残差结构块"></a> 残差结构块</h3><center><img src="https://s2.loli.net/2023/11/03/2cLFywINGXOQSvr.png" alt="residual-block" style="zoom:67%;" /></center><p>在残差结构中，右边的分支则是恒等映射，而主分支则是残差映射，得到的结果是二者相加（而非堆叠）。当我们的网络最优时，残差映射则会为0，它比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">F(x)=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>易于学习！</p><p>从信息论的角度来说的话，可以理解为越到深层次的特征图，所含有的信息越来越少了，而通过残差结构则可以使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>层的信息比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层多</p><p>在ResNet中，像ResNet-18和ResNet-34这种较低层次的网络残差结构块如下图左图所示，而像ResNet-50、ResNet-101以及ResNet-152这种深层的网络残差结构块则如下图右图所示：</p><center><img src="https://s2.loli.net/2023/11/03/pqbZ9Hy4Fc5CXYf.png" alt="different-deeper-residual-block" style="zoom:67%;" /></center><p>可见shortcut connection(就是右边的分支，执行的是identity mapping)和主分支它们输出的特征矩阵的shape需要一样才可以相加。而右侧的则考虑了计算量的因素，利用了1*1的卷积核去做降维以及升维的操作。</p><p>而在论文中ResNet-34的结构图中，如下示：</p><center><img src="https://s2.loli.net/2023/11/03/oitGubIhfULBCNz.png" alt="ResNet-34-arch" style="zoom:80%;" /></center><p>可以看到，有一些shortcut的线是实线，即我们上面的残差结构块；而有一些是虚线，则是因为没有池化层，需要对步距进行调整来使得shortcut connection和主分支（也要对步距进行调整）的输出符合论文中给出的网络结构的shape。其残差结构图如下所示：</p><center><img src="https://s2.loli.net/2023/11/03/vJsnQ57IxA4u3io.png" alt="dotted-residual-block" style="zoom:67%;" /></center><center><img src="https://s2.loli.net/2023/11/03/iSO18I3bW4Aqc2o.png" alt="dotted-residual-block-deeper" style="zoom:67%;" /></center><p>而对于较深层次的网络（如ResNet-50），conv2_x的第一层即conv2_1，可以看见其输入为[56,56,64]，而最终的输出为[56,56,256]，显然此时就需要在两个分支上都对深度进行变换。</p><h3 id="batch-normalization"><a class="markdownIt-Anchor" href="#batch-normalization"></a> Batch Normalization</h3><p>Batch Normalization是由Google团队在15年提出的（<strong>Batch Normalization:Accelerating Deep Network Training by Reducing Internal Covariate Shift</strong>），<strong>通过使用BN层，可以加速网络收敛以及提升准确率</strong>。</p><p>一般来说我们会在预处理阶段对图片进行标准化处理，目的是加速网络收敛。所谓标准化，就是使得我们的特征矩阵满足某一分布规律，又或者说，就是将一些不太标准的数据通过一定的计算方法将数据统一到指定的格式。</p><p>而我们在预处理阶段对图片的标准化处理，只会影响输入层的数据，但是对于中间隐藏层，却没有做到标准化操作。而利用BN层，则可以。</p><p><strong>Batch Normalization即批标准化，它的操作对象是batch内的同一layer下同一channel的特征矩阵，对它们进行标准化，使得<u>标准化后的数据满足均值为0，方差为1</u>的分布规律</strong>。</p><p>大致操作就是：计算出batch内的一layer下的一channel的均值和方差，然后通过对应变换使得生成的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><msup><mn>1</mn><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0,1^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的分布</p><p>显然，batch size应该越大越好，因为希望能代表的是整个训练集的分布规律。而我们在前向传递的过程中统计到的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(\mu,\sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的值，然后反向传递会得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的值，这两个分别是对统计到的分布规律作scale和shift操作。</p><p>此外BN层是放在conv层和激活层间的，而且conv层不要用bias，因为用了结果也一样</p><h4 id="后期补充"><a class="markdownIt-Anchor" href="#后期补充"></a> 后期补充</h4><p>batch normalization计算公式如下:</p><img src="https://jsd.cdn.zzko.cn/gh/ayyHA/imageBed@main/img/bn_formula.png" alt="bn_formula" style="zoom:67%;" /><p>一共涉及到四个参数,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>代表的是训练阶段forward pass时统计得到的两个数值,用于对同一batch内的<strong>同维</strong>数据做标准化,将同一个batch内的数据分布标准化为正态分布;而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>则是训练阶段backward pass时的两个learnable parameter,用于将标准化后的数据做一个仿射变换;</p><div class="note note-info">            <p><strong>同维</strong></p><ul><li>对于四维的卷积<code>[N,C,H,W]</code>指的是同一个channel,而另外的三个维度则拼成一个维度<code>[C,N*H*W]</code>,逐channel来计算均值和方差,同样的这时的四个参数的维度都是C维,即有C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>,C个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li><li>对于二维的线性层<code>[N,n]</code>,指的是同一列,即同一个特征,这是四个参数的维度都是n维</li></ul><p>个人理解:因为我们是对同一个batch的数据来做normalization(与单纯的standardize不同,还有仿射变换拉回原来的分布特征),那么期望得到的是一个batch内的均值方差,对于图片来说,是规律化的信息,而channel的信息需要单独处理,如果混合处理,会破坏原有的信息</p>          </div><p>对于训练阶段,会对每个batch都计算各自的均值和方差,并应用该阶段的均值和方差(即<code>batch_mean</code>和<code>batch_var</code>),同时会将该阶段的均值和方差利用滑动平均的技巧与之前那些batch的均值方差进行统计(以得到<code>moving_mean</code>和<code>moving_var</code>),以用作推理阶段;</p><p>对于推理阶段,会对每个sample采用训练阶段训练好的滑动均值和滑动方差(<code>moving_mean</code>和<code>moving_var</code>),而另外两个参数则是训练时学到的</p><p>具体的计算公式如下:</p><img src="https://s2.loli.net/2024/06/06/wHiZQaXj1AxPLre.png" alt="bn_detail_formula" style="zoom:67%;" /><p>其中这个滑动平均的思想在训练过程中的做法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">moving_mean = moving_mean * momentum + batch_mean * (<span class="hljs-number">1</span>-momentum)<br>moving_var = moving_var * momentum + batch_var * (<span class="hljs-number">1</span>-momentum)<br></code></pre></td></tr></table></figure><p>momentum是动量参数,在Tensorflow中是0.99,在PyTorch中是0.9,初始的<code>moving_mean=0</code>,<code>moving_var=1</code>即为标准正态分布</p><p><strong>参考文件:</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/93643523">【基础算法】六问透彻理解BN(Batch Normalization）</a></li><li><a href="https://zhuanlan.zhihu.com/p/522525435">吃透bn</a></li><li><a href="https://zhuanlan.zhihu.com/p/521535855">超细节的bn,ln知识点</a></li></ul><h3 id="迁移学习"><a class="markdownIt-Anchor" href="#迁移学习"></a> 迁移学习</h3><p>迁移学习即是使用别人预训练好的模型参数（需要注意别人的预处理方式），能快速训练出较理想结果，且在数据集较小的情况下也能如此。</p><p>为何能进行迁移学习呢，就拿卷积来说，我们一开始学习到的是低级特征，比如一些角点信息、纹理信息，其实是通用的，而后学习到的是五官这一类的高级抽象信息，而后再由全连接层对这些信息进行组合输出对应类别的概率。显然前面的低级信息应是通用的。</p><p>迁移学习的方式</p><ul><li>载入权重训练所有参数</li><li>载入权重后只训练最后几层的参数，如全连接层</li><li>载入权重后在原net上加多一个fc，只训练最后一个fc</li></ul><h3 id="网络结构图-4"><a class="markdownIt-Anchor" href="#网络结构图-4"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/jdz5WgZEM2StRCk.png" alt="resnet-arch" style="zoom:67%;" /></center><h2 id="resnext"><a class="markdownIt-Anchor" href="#resnext"></a> ResNeXt</h2><h3 id="亮点-5"><a class="markdownIt-Anchor" href="#亮点-5"></a> 亮点</h3><p><strong>利用分组卷积对原来ResNet的主分支变为多个分支进行多路卷积。在参数量相同计算速度相差不大的情况下，提升了准确率</strong>，又或者说是融合了Inception结构（split-transform-merge,输入分配到多路，每一路进行变换，最后多路进行结果融合）和ResNet残差结构。</p><h3 id="分组卷积"><a class="markdownIt-Anchor" href="#分组卷积"></a> 分组卷积</h3><p>如下图示，对输入图片的维度记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，对输出图片的维度记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，对卷积核的大小记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">k*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.对于传统的卷积来说，则每一个卷积核的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k*k*c_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，然后需要有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个卷积核，参数量则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k*k*c_{in}*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p><p>对于分组卷积而言，我们假设分组的数目是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，则每一组卷积核的大小应为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><mfrac><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">k*k*\frac{c_{in}}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1925999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而多组卷积核最后得出的结果需要拼接使得输出的channel为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，则意味着我们每一组需要有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>n</mi><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1764999999999999em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个卷积核。则其参数量为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∗</mo><mi>k</mi><mo>∗</mo><msub><mi>c</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>∗</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">k*k*c_{in}*n*\frac{1}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>.可见参数量变为原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>g</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{g}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>倍。</p><center><img src="https://s2.loli.net/2023/11/03/DqwHk1ucSGFJ6zM.png" alt="group-conv" style="zoom:50%;" /></center><h3 id="resnext残差结构"><a class="markdownIt-Anchor" href="#resnext残差结构"></a> ResNeXt残差结构</h3><p>在下图的右边便是ResNeXt的残差结构，可见，它增加了分组的部分，图中的path又或者论文中所提到的cardinality其实指的都是分组的数目。通过Inception结构的split-transform-merge来进行变换。</p><center><img src="https://s2.loli.net/2023/11/03/gaOzPJvTboqWLpc.png" alt="resnext-residual-block" style="zoom:67%;" /></center><p>下图的block模块在数学上是等价的，图C可以看出与原先的ResNet模型的降维卷积升维的操作是一样的，但是在卷积的过程中则利用了分组卷积的思想去减少参数量。</p><center><img src="https://s2.loli.net/2023/11/03/BtUqd95VmpNbKoH.png" alt="resnext-equivalent" style="zoom:67%;" /></center><p>而图B是由图C转换而来的：一个分支对应于一个组，我们的一共有32个分支，也即是有32个分组，因此对输入进行降维的操作，可以将卷积核个数128分配到每一个分支上，即每一个分支的卷积核大小都一样且均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>128</mn><mn>32</mn></mfrac><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\frac{128}{32}=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>个（注意，此操作不是分组卷积）。而后经由分组卷积操作，然后对结果进行深度方向的拼接再经由升维的1*1的卷积操作，而后便是主分支和shortcut分支相加。</p><p>图A则是对图B进行变换而来的：其本质是对卷积核原先内部的相加操作（就是1*1的卷积核原先是对某一坐标下的128个元素分别对应channel相乘而后将各channel的乘值相加，现在依旧是对应channel相乘，但是只有4个channel，而后各对4个channel的乘值相加后变得出特征矩阵，则最后的相加操作，是原先对应坐标下的元素的相加）进行切分</p><p>需要注意：ResNeXt的残差结构需要用在ResNet残差结构里有三层以上的才有意义，即需要用在ResNet-50/101/152这些模型身上才有意义。</p><h3 id="网络结构图-5"><a class="markdownIt-Anchor" href="#网络结构图-5"></a> 网络结构图</h3><center><img src="https://s2.loli.net/2023/11/03/rTMqnO91mta2Vfw.png" alt="resnext-arch" style="zoom:67%;" /></center><p>从以上的网络结构图可以看出ResNeXt-50与ResNet-50结构基本相同，除了多了个分组卷积之外，其中ResNeXt-50右边有个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>×</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">32×4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span>，其中32指代的是分组的数目，4d指代的是每一个组内的卷积核的个数。之所以选择<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn><mo>×</mo><mn>4</mn><mi>d</mi></mrow><annotation encoding="application/x-tex">32×4d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathnormal">d</span></span></span></span>是因在同等计算量下，它的准确度最高。见下图：</p><center><img src="https://s2.loli.net/2023/11/03/sUQl4DMunECm7gi.png" alt="resnext-cardinality-effection" style="zoom:67%;" /></center><h2 id="mobilenet"><a class="markdownIt-Anchor" href="#mobilenet"></a> MobileNet</h2><p>前面所提及的模型，它们的权重文件都很大（几百兆），而且对算力也有一定要求，不便于在移动设备上使用。这一部分提及的MobileNet则可以，它是一种轻量级的卷积网络。在准确率小幅下降的情况下，模型参数和运算量大大减少。</p><center><img src="https://s2.loli.net/2023/11/03/LaBjtmelCPb74rk.png" alt="mobilenetv1-effect" style="zoom:67%;" /></center><h3 id="mobilenetv1"><a class="markdownIt-Anchor" href="#mobilenetv1"></a> MobileNetV1</h3><h4 id="亮点-6"><a class="markdownIt-Anchor" href="#亮点-6"></a> 亮点</h4><ul><li>深度可分离卷积</li><li>控制卷积核个数倍率的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和控制图像大小的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li></ul><h4 id="深度可分离卷积"><a class="markdownIt-Anchor" href="#深度可分离卷积"></a> 深度可分离卷积</h4><center><img src="https://s2.loli.net/2023/11/03/fiIk21aKgoWzC6b.png" alt="depthwise-separable-convolution" style="zoom:67%;" /></center><p>上图便是深度可分离卷积(DSC)和传统卷积的对比图。</p><p>深度可分离卷积分为两个过程:<strong>逐深度卷积(DW(depthwise)卷积)和逐点卷积(PW(pointwise)卷积)</strong> ，其中逐点卷积和普通卷积没啥区别，就是1*1的卷积核卷积。</p><p>DW卷积则是逐通道卷积，即卷积核大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">D_K*D_K*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.若输入特征图的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>则其卷积核的个数亦为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，其输出特征图的深度亦为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>。</p><p>PW卷积，则对DW卷积输出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">D_F*D_F*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>的特征图进行卷积，卷积核大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mn>1</mn><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">1*1*M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，卷积核个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>,最终输出的特征图大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC相较于传统卷积的好处在于输入输出特征图的大小相同，而计算量和参数量的则大大减少</p><p>传统卷积计算量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M*D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC计算量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>F</mi></msub><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*D_F*D_F*M+M*D_F*D_F*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>计算量之比: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>D</mi><mi>S</mi><mi>C</mi><mtext>计算量</mtext></mrow><mtext>传统卷积计算量</mtext></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><msup><msub><mi>D</mi><mi>K</mi></msub><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{DSC计算量}{传统卷积计算量}=\frac{1}{N}+\frac{1}{ {D_K}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">统</span><span class="mord cjk_fallback mtight">卷</span><span class="mord cjk_fallback mtight">积</span><span class="mord cjk_fallback mtight">计</span><span class="mord cjk_fallback mtight">算</span><span class="mord cjk_fallback mtight">量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">计</span><span class="mord cjk_fallback mtight">算</span><span class="mord cjk_fallback mtight">量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.308964em;vertical-align:-0.46385600000000005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6364490000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7907871428571429em;"><span style="top:-2.830472857142857em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.46385600000000005em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>传统卷积参数量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>DSC参数量: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><msub><mi>D</mi><mi>K</mi></msub><mo>∗</mo><mi>M</mi><mo>+</mo><mi>M</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_K*D_K*M+M*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></p><p>参数量之比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>D</mi><mi>S</mi><mi>C</mi><mtext>参数量</mtext></mrow><mtext>传统卷积参数量</mtext></mfrac><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><msup><msub><mi>D</mi><mi>K</mi></msub><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{DSC参数量}{传统卷积参数量}=\frac{1}{N}+\frac{1}{ {D_K}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传</span><span class="mord cjk_fallback mtight">统</span><span class="mord cjk_fallback mtight">卷</span><span class="mord cjk_fallback mtight">积</span><span class="mord cjk_fallback mtight">参</span><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback mtight">参</span><span class="mord cjk_fallback mtight">数</span><span class="mord cjk_fallback mtight">量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.308964em;vertical-align:-0.46385600000000005em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6364490000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7907871428571429em;"><span style="top:-2.830472857142857em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.46385600000000005em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br />而卷积核一般是3*3的，因此能给参数量和计算量降至原来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mn>1</mn><mn>9</mn></mfrac><mo separator="true">,</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{1}{9},\frac{1}{8}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span><br />在传统的卷积层中，我们常用的是Conv+BN+ReLU这一套作为卷积层。而在DSC中，我们的设置如下图示：</p><center><img src="https://s2.loli.net/2023/11/03/lLpHyMTSendUbmc.png" alt="mobilenetv1-conv-arch" style="zoom:67%;" /></center><p>另外，在MobileNetV1中，采用的是ReLU6激活函数，相较于ReLU函数，它有一个上界，其表达式为: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mn>6</mn><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLU6 = min(max(0,x),6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span>。在低精度浮点数计算时，如8/16位浮点数计算，表达不了那么的大的数，因此用ReLU6在低精度浮点数表示下可以取得比较好的性能。增强鲁棒性。</p><h4 id="超参数alpha和beta"><a class="markdownIt-Anchor" href="#超参数alpha和beta"></a> 超参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>在原论文中称为width multiplier，即宽度乘数，是用它来控制我们每一层的卷积核的个数，它的取值范围是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，常用的取值是0.25,0.5,0.75,1。根据个人任务需求来自行在精度和速度（计算量以及内存所占的参数量）取得一个平衡。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的各取值效果如下：</p><center><img src="https://s2.loli.net/2023/11/03/ynIupeLdbg2PKJv.jpg" alt="mobilenetv1-width multiplier" style="zoom:67%;" /></center><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>在原论文中称为resolution multiplier，即分辨率乘数，隐式的设置，用来控制我们的输入的分辨率。β的取值范围是(0,1]，常用的输入分辨率为224,192,160,128。用于在精度和速度（计算量）上取得一个平衡。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的各取值效果如下：</p><center><img src="https://s2.loli.net/2023/11/03/uFcEhUvwgd1PDoA.png" alt="mobilenetv1-resolution multiplier" style="zoom:67%;" /></center><h4 id="网络结构图-6"><a class="markdownIt-Anchor" href="#网络结构图-6"></a> 网络结构图</h4><p>在下图所示的网络结构图中，conv dw即代表DW卷积，在其后面的示PW卷积。可见其即是将通用的卷积层全部替换为DSC。(实际上的网络结构跟VGG差不多)</p><center><img src="https://s2.loli.net/2023/11/03/4KwMeD81Ih9ZGYv.png" alt="mobilenetv1-arch" style="zoom:67%;" /></center><h3 id="mobilenetv2"><a class="markdownIt-Anchor" href="#mobilenetv2"></a> MobileNetV2</h3><h4 id="亮点-7"><a class="markdownIt-Anchor" href="#亮点-7"></a> 亮点</h4><ul><li>倒残差结构</li><li>线性的bottleneck</li></ul><h4 id="问题提出"><a class="markdownIt-Anchor" href="#问题提出"></a> 问题提出</h4><p>在MobileNetV1,存在部分DW卷积核训练出来为0的情况,其产生的原因可以归咎于以下几点：</p><ul><li>DW卷积所用的卷积核个数太少了，因而权重数量太少</li><li>ReLU激活函数，导致一些负数在前向传播置为零，而反向传播其梯度亦为0，使之无法更新</li><li>低精度，导致小于某一值后，并不能取得值，则归为0</li></ul><p>在原文的附录中，其实有对DW为0的情况进行数学分析，可以这么认为，即是ReLU激活函数导致的<strong>低维度的信息丢失</strong>。下图是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover><mo>=</mo><msup><mi>T</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>T</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{x} = T^{-1}ReLU(Tx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，对T的维度进行变换以查看ReLU函数对不同维度信息的丢失程度。可以看出高维的信息经ReLU后丢失较少，而低维信息则丢失较多。</p><p><img src="https://s2.loli.net/2023/11/03/TEtU7BSGfXp3NuL.png" alt="mobilenetv2-relu transformation" /></p><p>在原先的DSC结构中，我们的DW卷积包含以下过程：DW卷积-&gt;BN-&gt;ReLU，而一开始的channel的个数其实很少，这即是所谓的低维度，然后经过ReLU处理，很多信息即丢失了，也即意味着:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>B</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y=ReLU(Bx)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，在这个等式中，我们并不可逆，因而导致了信息丢失。其中x即输入的维度，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">B_{m * n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.175696em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则代表对应的权重矩阵，经ReLU操作后，我们的信息会丢失。从数学角度来说，即无法找到唯一解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>。那么我们现在期望的是尽可能使这个方程能找到唯一解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，即意味着可逆（无信息丢失）。</p><p>论文中找出了其可逆的条件：<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi></mrow><annotation encoding="application/x-tex">\bold{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.63888em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span></span>中至少<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\bold{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">n</span></span></span></span></span>个激活为正且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\bold{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span>中对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\bold{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">n</span></span></span></span></span>个向量应线性无关</strong></p><p>第二个条件易于满足，而第一个条件在论文中，作者说到：当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≫</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \gg n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≫</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>即使之升维，则较大概率保持可逆。因而需要对输入进行升维处理，使之在DW卷积后经ReLU变换，其信息尽量不丢失；对应的在低维度的情况下，我们则不应该采用ReLU变换。并且通过shortcut连接，将DW卷积过程中可能存在的信息丢失予以弥补。</p><p>因而提出了inverted residual block（相较于ResNet的先降维后升维而言是inverted）和linear bottleneck（bottleneck是指两个低channel的tensor，这里与ResNet中的bottleneck恰好相反，linear则是代表最后一个低channel的tensor是采用线性激活函数）</p><h4 id="倒残差结构"><a class="markdownIt-Anchor" href="#倒残差结构"></a> 倒残差结构</h4><p>在ResNet中，残差结构是先降维然后进行卷积最后升维以及Add操作，而在MobileNetV2中，则是先升维然后DW卷积而后降维以及Add操作，因而称之为倒残差结构(使得低维信息和非线性变换二者解耦)。</p><p>可以对倒残差结构利用压缩文件的思想进行理解：</p><p>压缩包（低维度的输入） -&gt; 解压（升维）-&gt; 处理（DW卷积） -&gt; 压缩（降维）</p><center><img src="https://s2.loli.net/2023/11/03/4BLuhCpSvGFemPc.png" alt="mobilenetv2-inverted residual block" style="zoom:80%;" /></center><p>以下是一个倒残差结构的过程图表：</p><center><img src="https://s2.loli.net/2023/11/03/yhqYpdAxa3VnMOD.png" alt="mobilenetv2-inverted residual block table" style="zoom:67%;" /></center><h4 id="线性的bottleneck"><a class="markdownIt-Anchor" href="#线性的bottleneck"></a> 线性的bottleneck</h4><p>在ResNet中，bottleneck结构是指代残差结构中的卷积过程，而在MobileNetV2中，bottleneck则是指代在DW卷积前后的输入输出两端的低channel的tensor。而线性的bottleneck则是指倒残差结构最后降维处采用了线性激活函数而后输出低维的特征矩阵。</p><h4 id="网络结构图-7"><a class="markdownIt-Anchor" href="#网络结构图-7"></a> 网络结构图</h4><p>bottleneck则是我们上面的倒残差结构，t则代表了扩展因子，即channel经升维扩充为原来的t倍，c则是降维后的channel个数，n则是指该倒残差结构重复的次数，s则是指dw卷积的步距（该block第一个bottleneck的步距,而后的都是1）。</p><p>需要注意，我们可以使得主分支和shortcut分支相加的条件是s=1且两个低维的tensor的shape要相等。</p><center><img src="https://s2.loli.net/2023/11/03/MA1jzymQpGP5vCx.png" alt="mobilenetv2-arch" style="zoom:50%;" /></center><h3 id="mobilenetv3"><a class="markdownIt-Anchor" href="#mobilenetv3"></a> <mark>MobileNetV3</mark></h3><h4 id="亮点-8"><a class="markdownIt-Anchor" href="#亮点-8"></a> 亮点</h4><h4 id="网络结构图-8"><a class="markdownIt-Anchor" href="#网络结构图-8"></a> 网络结构图</h4><h2 id="shufflenet"><a class="markdownIt-Anchor" href="#shufflenet"></a> <mark>ShuffleNet</mark></h2><h2 id="efficientnet"><a class="markdownIt-Anchor" href="#efficientnet"></a> <mark>EfficientNet</mark></h2><h2 id="transformer"><a class="markdownIt-Anchor" href="#transformer"></a> transformer</h2><p>见blog</p><h2 id="vit"><a class="markdownIt-Anchor" href="#vit"></a> ViT</h2><p>见blog</p><h2 id="mobilevit"><a class="markdownIt-Anchor" href="#mobilevit"></a> <mark>MobileViT</mark></h2><h2 id="一些tricks"><a class="markdownIt-Anchor" href="#一些tricks"></a> <mark>一些tricks</mark></h2>]]></content>
    
    
    
    <tags>
      
      <tag>CNN</tag>
      
      <tag>ResNet</tag>
      
      <tag>MobileNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAN的基础理解及代码解析</title>
    <link href="/2022/10/24/GAN%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/10/24/GAN%E7%9A%84%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>在先前的图像方法增强合集(<mark>这个还没写</mark>)里,了解到GAN可以用于生成图像,且是无监督学习,即意味着我们无需人为对样本打标签,就可以学习到样本数据里的相关图像信息</p><p>论文原文:<a href="https://proceedings.neurips.cc/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf">Generative Adversarial Nets</a></p><div class="note note-info">            <p>注:PO在上面的是作者后面经修改的版本,在arXiv上的是14年的初稿,related work部分比较空荡荡</p>          </div><h2 id="模型介绍"><a class="markdownIt-Anchor" href="#模型介绍"></a> 模型介绍</h2><p><strong>GAN</strong>(Generative Adversarial Nets)<strong>生成对抗网络</strong>,它是由两个部分组成,一个部分是<strong>生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span></strong>(Generator),用于<strong>生成图像</strong>;一个部分是<strong>判别器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></strong>(Discriminator),用于判别图像的真假,即图像来源是我们的样本数据集,还是生成的图像</p><p>我们通过名字以及引言部分的介绍,可以知道GAN是用来生成图像的网络,那么对抗指的是什么?</p><p>在原论文中,作者是以一个制造假币的团伙和警察来介绍对抗的概念:制造假币的罪犯(这个就是生成模型)希望自己制造的假币能像真币一样流通在市场上,即假币假得跟真币一样;而警察(这个是判别模型)则是负责抓造假币的罪犯.二者是一个对立、对抗的关系.那么通过警察识别并查获假币,造假币的罪犯为了使假币流通不断提升技术以期假币能以假乱真,在二者的对抗关系下,发展到最后,警察将无法试别假币与真币.</p><p>上述即解释了整个模型的思想,<strong>生成模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>期望能生成足够类似样本数据集的图片以欺骗判别模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,而判别模型则期望能够最大限度的区分输入的图片是来自样本数据集的还是生成模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的</strong>.</p><h2 id="原理解释"><a class="markdownIt-Anchor" href="#原理解释"></a> 原理解释</h2><p>上述对GAN的模型解释,从原文中抽象一点的角度来说,即生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>是用于学习样本数据的数据分布情况,当我们学习到合适的分布情况下,则通过高斯分布或是均匀分布生成的噪音变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>用于生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的输入,可以映射到对应的分布中去,生成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>,则此刻判别模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>无法判别输入的图片是来自数据集中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>还是生成的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6905600000000001em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6905600000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span class="svg-align" style="width:calc(100% - 0.05556em);margin-left:0.05556em;top:-3.43056em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span>,则此刻判别概率达到最优,为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>因此我们为了使生成器<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>能学习到在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>上的分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">p_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,定义了输入噪音变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_z(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>作为先验,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的多层感知机的参数为(论文中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>都是这个模型,便于利用反向传播更新参数)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\theta_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,利用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">\theta_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>共同表示由G到数据分布空间的映射函数:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">;</mo><msub><mi>θ</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(z;\theta_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>;而我们的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>的映射函数则用:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>θ</mi><mi>d</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x,\theta_d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示<br />根据本节开头所述,我们所期望的是:<br />1.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>尽可能的区分开真实样本和生成样本;<br />2.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>尽可能的骗过D,让它无法分辨真是样本和生成样本;<br />于是就有以下价值函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G,D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>成立</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mo><mi>min</mi><mo>⁡</mo></mo><mi>G</mi></munder><munder><mo><mi>max</mi><mo>⁡</mo></mo><mi>D</mi></munder><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="double-struck">E</mi><mrow><mi>x</mi><mo>∼</mo><msub><mi>p</mi><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo fence="true">[</mo><mi>log</mi><mo>⁡</mo><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo fence="true">]</mo></mrow><mo>+</mo><msub><mi mathvariant="double-struck">E</mi><mrow><mi>z</mi><mo>∼</mo><msub><mi>p</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></msub><mrow><mo fence="true">[</mo><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\min_{G}\max_{D}V(D,G) = \mathbb{E}_ {x \sim p_{data}(x)}\left[\log{D(x)} \right] +\mathbb{E}_ {z \sim p_z(z)}\left[\log{(1-D(G(z)))} \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.494331em;vertical-align:-0.7443310000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.355669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.744331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999983em;"><span style="top:-2.355669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7443310000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">E</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mrel mtight">∼</span><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p><p>我们知道对于映射<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>来说,其输出是一个介于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[0,1 \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span>的概率值,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{2}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span>对应的是单调递增函数,则欲使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>取得max,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>趋于1,即分辨出来自样本数据集中的图片,让<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>趋于0,即分辨出来自<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中生成的图片,则可以使得整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(D,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>max;此刻则满足期望的第1点;<br />而欲使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>取得min,则是使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(G(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>为1,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>将其误认为是样本数据集中的数据,则此刻整个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>取值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>,为最小(当然D(G(z))也取不到1,只是趋向1),则此刻满足期望的第二点</p><p>以下是论文中的算法部分:</p><p><img src="https://s2.loli.net/2023/11/03/jIwGiqoT74WkR23.png" alt="GAN-Algorithm" /></p><p>从上图可以看出,我们先是对判别模型通过循环进行了优化,对于它而言,它的优化是对其参数加上所求得的梯度值以更新模型(即增强其区分能力);<br />而后出了判别模型优化的循环后再对我们的生成模型做部分的改变,于它而言对参数的更新则是减去梯度值,以更新模型,增强图形的生成能力.</p><p>我们肯定注意得到,它先是对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>优化,再对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>做小部分的优化.从前面那个造假币的例子中其逻辑可以想清,此处不赘述</p><p>当然,这一部分算法最大的问题,应该(<mark>我觉得</mark>)是出在超参数难以调控,难以达到收敛情况,即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>的判断变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h2 id="代码讲解"><a class="markdownIt-Anchor" href="#代码讲解"></a> 代码讲解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">block</span>(<span class="hljs-params">in_feat, out_feat, normalize=<span class="hljs-literal">True</span></span>):</span><br>            layers = [nn.Linear(in_feat, out_feat)]<br>            <span class="hljs-keyword">if</span> normalize:<br>                layers.append(nn.BatchNorm1d(out_feat, <span class="hljs-number">0.8</span>))<br>            layers.append(nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>))<br>            <span class="hljs-keyword">return</span> layers<br><br>        self.model = nn.Sequential(<br>            *block(opt.latent_dim, <span class="hljs-number">128</span>, normalize=<span class="hljs-literal">False</span>), <br>*block(<span class="hljs-number">128</span>, <span class="hljs-number">256</span>),<br>            *block(<span class="hljs-number">256</span>, <span class="hljs-number">512</span>), <br>*block(<span class="hljs-number">512</span>, <span class="hljs-number">1024</span>),<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-built_in">int</span>(np.prod(img_shape))), <br>nn.Tanh())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, z</span>):</span><br>        img = self.model(z)  <span class="hljs-comment"># [64,784]</span><br>        img = img.view(img.size(<span class="hljs-number">0</span>), *img_shape)  <span class="hljs-comment"># [64,1,28,28]</span><br>        <span class="hljs-keyword">return</span> img<br></code></pre></td></tr></table></figure><p>上面这个是Generator的代码,通过一个<code>nn.Sequential</code>的序列容器严格规定网络中layer的执行顺序,前一层输出作为后一层输入,严格遵守,否则报<code>RuntimeError</code><br />初始进去的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>的维度是[64,100],64是batch_size,100是它的初始维度,维度通过全连接层变成了1024后变为img_shape:[1,28,28]的所有元素的乘积即784,然后通过view将维度转换为[64,1,28,28]<br />此即完成了由一个高斯分布生成的噪声变为灰度图片的过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Discriminator</span>(<span class="hljs-params">nn.Module</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self.model = nn.Sequential(nn.Linear(<span class="hljs-built_in">int</span>(np.prod(img_shape)), <span class="hljs-number">512</span>),<br>                                   nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>),<br>                                   nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">256</span>),<br>                                   nn.LeakyReLU(<span class="hljs-number">0.2</span>, inplace=<span class="hljs-literal">True</span>),<br>                                   nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>), <br>   nn.Sigmoid())<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, img</span>):</span><br>        <span class="hljs-comment"># img: [64,1,28,28]</span><br>        img_flat = img.view(img.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)  <span class="hljs-comment"># img_flat: [64,784]</span><br>        validity = self.model(img_flat)  <span class="hljs-comment"># validity: [64,1]</span><br>        <span class="hljs-keyword">return</span> validity<br></code></pre></td></tr></table></figure><p>上面这个是Discriminator的代码,其实就是Generator的反过程,将输入的MNIST数据集中的手写图片转为[64,784]后由model训练,根据sigmoid做分类,其中LeakyReLU激活函数就是在ReLU的负半轴开启了衰弱的梯度衰减(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>e</mi><mi>a</mi><mi>k</mi><mi>y</mi><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>e</mi><mi>a</mi><mi>k</mi><mo>∗</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LeakyReLU= \max(0,x) + leak * \min(0,x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>),返回的分类结果是[64,1]的向量,里面的值是图片来自generator或是数据集的概率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">adversarial_loss = torch.nn.BCELoss()<br></code></pre></td></tr></table></figure><p>采用的损失函数是二分类交叉熵,我们的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(D,G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>价值函数可以从该损失函数公式推得<mark>具体没细看</mark></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer_g = torch.optim.Adam(generator.parameters(),<br>                               lr=opt.lr,<br>                               betas=(opt.b1, opt.b2))<br>optimizer_d = torch.optim.Adam(discriminator.parameters(),<br>                               lr=opt.lr,<br>                               betas=(opt.b1, opt.b2))<br></code></pre></td></tr></table></figure><p>对生成器和判别器都采用了Adam优化器,之后就是对优化器使用的三部曲:</p><ol><li>梯度清零</li><li>backward</li><li>更新梯度</li></ol><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(opt.n_epochs):<br>    <span class="hljs-keyword">for</span> i, (imgs, _) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        <span class="hljs-comment"># imgs: [64,1,28,28]</span><br>        <br>valid = Variable(<br>            Tensor(imgs.size(<span class="hljs-number">0</span>), <span class="hljs-number">1</span>).fill_(<span class="hljs-number">1.0</span>),  <span class="hljs-comment"># [64,1]值为1的向量</span><br>            requires_grad=<span class="hljs-literal">False</span>)<br>        fake = Variable(<br>            Tensor(imgs.size(<span class="hljs-number">0</span>), <span class="hljs-number">1</span>).fill_(<span class="hljs-number">0.0</span>),  <span class="hljs-comment"># [64,1]值为0的向量</span><br>requires_grad=<span class="hljs-literal">False</span>)<br>        <br><span class="hljs-comment"># 配置输入</span><br>        real_imgs = Variable(imgs.<span class="hljs-built_in">type</span>(Tensor))  <span class="hljs-comment"># 转换type类型为torch.cuda.FloatTensor, [64,1,28,28]</span><br>        <br><span class="hljs-comment"># 训练G</span><br>        optimizer_g.zero_grad()  <span class="hljs-comment"># 梯度置0/梯度清零</span><br><br>        <span class="hljs-comment"># 噪声作为输入</span><br>        z = Variable(Tensor(np.random.normal( <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,  <span class="hljs-comment"># normal-&gt;符合高斯分布的概率密度随机数</span><br>                    (imgs.shape[<span class="hljs-number">0</span>], opt.latent_dim))))  <span class="hljs-comment"># [64,100]</span><br><br>        <span class="hljs-comment"># 生成批量images</span><br>        gen_imgs = generator(z)<br><br>        <span class="hljs-comment"># generator&#x27;s loss 尽可能欺骗D</span><br>        g_loss = adversarial_loss(discriminator(gen_imgs), valid)<br><br>        g_loss.backward()  <span class="hljs-comment"># backward</span><br>        optimizer_g.step()  <span class="hljs-comment"># 更新梯度</span><br><br>        <span class="hljs-comment"># 训练D</span><br>        optimizer_d.zero_grad()<br><br>        <span class="hljs-comment"># discriminator&#x27;s loss 尽可能试别数据集图片和生成器生成的图片</span><br>        real_loss = adversarial_loss(discriminator(real_imgs), valid)<br>        fake_loss = adversarial_loss(discriminator(gen_imgs.detach()), fake)<br>d_loss = (real_loss + fake_loss) / <span class="hljs-number">2</span><br><br>d_loss.backward() <span class="hljs-comment"># backward</span><br>        optimizer_d.step() <span class="hljs-comment"># 更新梯度</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>代码参考源于这个大佬:<a href="https://github.com/eriklindernoren/PyTorch-GAN">GitHub跳转</a></p>          </div><h2 id="实验展示"><a class="markdownIt-Anchor" href="#实验展示"></a> 实验展示</h2><p>所用数据集是MNIST<br />以下是100个epoch出来的结果</p><p><img src="https://s2.loli.net/2023/11/03/1kdphc5VC4mFG6R.png" alt="GAN-EX-0" /></p><p><img src="https://s2.loli.net/2023/11/03/m6MuJrNWAsgf27j.png" alt="GAN-EX-1" /></p><p><img src="https://s2.loli.net/2023/11/03/NbrQc9XMhB1qiPE.png" alt="GAN-EX-2" /></p><p>可以看出GAN的生成器学到了一些东西,但其实效果不是那么好,因为超参数很难控制好,置其收敛</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>总的来说,GAN是一个开创性的想法,随它之后可以看到与之相关的论文呈井喷式增加,GAN的他引次数也达50k加次,确实很厉害<br />它的效果虽然不尽人意,但是开创性的思维带来了一个领域的突破,后期会更新1~2个改良后的GAN.</p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>GAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BST,AVL树,B树,B+树,红黑树</title>
    <link href="/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>算法课老师讲到了二叉搜索树(BST),因为大四背面经接触过下面几种类型,因此想简单mark一下</p><p><mark>注:本篇文章对树的操作并无图,可自行绘制理解</mark><br /><mark>另:里面的操作部分的文字描述是我看了较多文章自己综合口述的,有可能有错</mark></p><h2 id="bst"><a class="markdownIt-Anchor" href="#bst"></a> BST</h2><p>BST(Binary Search Tree)二叉搜索树,也叫二叉查找树<br />它是由<strong>二分法+二叉树</strong>构成,即以树结构呈现的二分法.左子树的节点值均小于根节点,右子树的节点值均大于根节点</p><p><img src="https://s2.loli.net/2023/11/03/jncKkUFz6fuepSx.png" alt="BST" /></p><p>对于查找,插入,删除,平均时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,而其最坏状况,若是依有序数据构建树,则会退化成链表,则对应的时间复杂度都是最坏的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>对于其查找,插入,都跟二分法类似,不赘述;而对于删除问题,因删除后需保持BST的二分特性,因此需要对删除后的树进行一些修改,分三种情况讨论:</p><ol><li>删除的是叶子节点: 直接删除,无影响</li><li>删除的是中间节点,且只有一个子树: 直接把子树根节点对中间节点进行顶替</li><li>删除的是中间节点,且有两个子树: 若删除的节点位于根节点的左子树,则用删除节点的左子树顶替之,并将删除节点的右子树移到其原兄弟节点的右子树下即可;另一侧是对称操作,不赘述.</li><li>删除的是非空根节点:与左子树中最大值交换后删除即可或与右子树中最小值交换后删除即可</li></ol><h2 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h2><p>AVL树叫做<strong>平衡二叉树</strong>,是对BST的一种改进,引进了<strong>平衡机制</strong>,后面要谈的红黑树也是一种balance tree,但是AVL树的平衡更是一种<strong>强平衡</strong><br />平衡机制:<strong>任意节点的左右子树高度差不超过1</strong>,我们管这个1叫做平衡因子(Balance factor),即bf=1<br />通过平衡机制的强硬限制,规避了退化成链表的可能</p><p><img src="https://s2.loli.net/2023/11/03/pgPmINA3vBsoS9i.png" alt="AVL树" /></p><p>AVL树在查找,插入,删除的平均及最差的时间复杂度均为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></p><p>对于其查找,与二分法类似,不赘述.之于插入删除问题,由于会影响树的高度,需为维持平衡机制,因此存在<strong>左旋,右旋</strong>的概念,示意图如下:</p><p><img src="https://s2.loli.net/2023/11/03/xBVQnWizqAfYU42.png" alt="AVL-ROTATE" /></p><p>右旋:<code>rotateRight(Q)</code>,将节点Q作为其左孩子的右孩子<br />左旋:<code>rotateLeft(P)</code>,将节点P作为其右孩子的左孩子</p><p>针对插入情况的讨论(假设原始状态均满足平衡机制):</p><table><thead><tr><th style="text-align:center">插入位置</th><th style="text-align:center">状态</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><strong>在节点T的left child的left tree上插入元素</strong></td><td style="text-align:center">LL</td><td style="text-align:center">右旋</td></tr><tr><td style="text-align:center"><strong>在节点T的right child的right tree上插入元素</strong></td><td style="text-align:center">RR</td><td style="text-align:center">左旋</td></tr><tr><td style="text-align:center"><strong>在节点T的left child的right tree上插入元素</strong></td><td style="text-align:center">LR</td><td style="text-align:center">先左旋,再右旋</td></tr><tr><td style="text-align:center"><strong>在节点T的right child的left tree上插入元素</strong></td><td style="text-align:center">RL</td><td style="text-align:center">先右旋,再左旋</td></tr></tbody></table><p>以下以一个插入导致的LL情况作为示例,图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/xwBtuDjr1alMizo.png" alt="AVL-LL" /></p><div class="note note-info">            <p>注:图示的例子是给原树插了两个元素,其实这里一个或是两个元素数量都一样,因为都是挂载在同一棵树上,主要目的是导致了有的节点左右子树高度差超过了1</p>          </div><div class="note note-warning">            <p>特别注意:AVL树插入位置的条件与后面介绍的红黑树的插入位置的条件并不等价!其不等价的原因与各自平衡机制相关</p>          </div><p>以下是插入元素后的旋转情况概览图:</p><p><img src="https://s2.loli.net/2023/11/03/OiU9uRWroFMnIsQ.png" alt="AVL-ALL-ROTATE" /></p><p>删除的情况太多了,大致其实都是删了之后进行1~2次的旋转即可.此处不讨论</p><h2 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> B-树</h2><p>B-树就是B树(Balance Tree),中间的一杠是连字符.它是MongoDB的WiredTiger引擎中索引采用的数据结构.而数据库持久化的数据都是放在硬盘上的,索引也是.而对于硬盘的一次访问即是一次I/O操作,它的时间消耗是毫秒级别的.因此,我们需要减少I/O操作的次数以提高访问速度(毕竟存储结构没办法改变)</p><p>而之所以采用树形结构对索引进行存储,是因其于等值查询和区间查询都具备一定优势,而这些正是我们数据库中绝大多数涉及到的操作.</p><p>那么为什么用B-树呢?</p><p>因为B-树跟上面的树相比更加<strong>矮胖</strong>.B树允许一个节点有多个子节点,且节点内部可以存储多个元素.这就使得我们树的高度可控,不会太高,即树会变得矮胖.而之所以期望树可以更矮胖是因为我们从硬盘中读数据是以磁盘块为单位的,磁盘块有固定大小(一般4096B,4K大小),读出来的数据就等价于我们数据库中的页的概念,<strong>页和磁盘块是一样大小的</strong>,因此我们<strong>树的一个节点对应的是一个磁盘块大小的数据</strong>,那么<strong>减少I/O操作</strong>即转换成<strong>减少访问树的节点个数</strong>.<strong>B树是多路查找树,也是平衡树,它的bf=0</strong>.因此<strong>树的宽度(节点大小)决定了一次I/O操作获取到的数据量,树的高度决定了访问的I/O次数</strong></p><p>一颗m阶B树有如下特点:(这里将节点分为:[根节点,内部节点,叶子节点])</p><ul><li>根节点或是叶子节点,或是拥有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>个孩子节点的非叶子节点;</li><li>所有内部节点都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个孩子节点,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo stretchy="false">⌉</mo><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil \le k \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li>所有叶子节点都包含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>m</mi><mn>2</mn></mfrac><mo stretchy="false">⌉</mo><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\lceil \frac{m}{2} \rceil \le k \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li>所有叶子节点位于同一层(bf=0的体现)</li><li>每个节点中的key值是升序排列的,节点中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个key值可以划分出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>个孩子节点</li></ul><p>一颗普通的B树如下图示:</p><p><img src="https://s2.loli.net/2023/11/03/sBtZgD4XKPezi5E.png" alt="B-Tree" /></p><div class="note note-info">            <p>注:上图的P1,P2这些是指针,我们的树与子树的关系基本都是通过指针维系的,别的也是,没画出来而已,这里如磁盘块2,它只画了索引值,其实还有个叫卫星数据(不知道为啥叫这个)的东西,它所指代的是索引元素指代的数据记录,那就比如是某张表的某一行数据</p>          </div><p>看完上面对B树的特点定义会好奇<strong>为何根节点要么是叶子节点,要么至少有两个子节点</strong>,<strong>它的插入删除咋执行的</strong>,其实这些问题都源于以下两句话:</p><ul><li><strong>插入key值至超出阈值(上面所说的节点内key值的上界),会致使节点产生分裂,分裂伴随着该节点中值的上溢(上移),甚至有的情况节点上溢会递归导致一个新的根节点的产生</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/RWnkedmxQgXzGM8.png" alt="插入致使上溢,有新节点产生" /></p><p><img src="https://s2.loli.net/2023/11/03/4azrdDiW7AsbCHU.png" alt="插入致使上溢,无新节点产生" /></p><div class="note note-info">            <p>注:可以很清晰地看出来,B-树以及下面要将的B+树,跟以往的树的构造不一样,它们是由下至上构建的,而先前学的二叉树啥的都是自顶向下构建的</p>          </div><ul><li><strong>删除叶子节点的key值至超出阈值(上面所说的节点内key值的下界),会致使其向兄弟节点借一个key值,如果它的兄弟节点key值也不够,那就要三合一(删了key值的节点,它的兄弟节点,它们间的父节点的key值即使其下溢(下移)),甚至可能导致父节点的key值也刚好不够,则递归下溢直至所有节点满足要求</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/pgaXild1emSo4kJ.png" alt="叶子节点删除key,向兄弟借key" /></p><p><img src="https://s2.loli.net/2023/11/03/kwKOUiA6LZbnyBc.png" alt="叶子节点删除key,做合并" /></p><ul><li><strong>删除内部节点(中间节点)的key值至超出阈值,向有足够key值的子节点借一个key值,如果不够,就只可以合并,这个合并也是三合一(跟上面的一样)</strong></li></ul><p><img src="https://s2.loli.net/2023/11/03/fIWJdQPM28Ygzui.png" alt="内部节点删除key,向子节点借key" /></p><p><img src="https://s2.loli.net/2023/11/03/m8ISEgL3NYc4i6U.png" alt="内部节点删除key,做合并" /></p><h2 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B+树</h2><p>我们知道B+树是MySQL的InnoDB引擎中索引采用的数据结构,而B+树是B树的升级版,它增加了如下的特点:(树的节点于此处分为:[根节点,内部节点,叶子节点])</p><ol><li>非叶子节点内含有k个子节点,亦含有k个key值,每个key值对应一个子节点;</li><li>非叶子节点内不含数据,只有key值用于索引;key值及数据全存放于叶子节点,叶子节点间的key值依升序链接,叶子节点间通过链表链接;</li><li>非叶子节点的key值都存在于子节点中,且是子节点中key值的最大或最小的</li></ol><p>1,3制造冗余边界数据,便于插入和删除的方式改进,将对树的变形控制在单一分支(<mark>其实如插入也存在上溢的情况,也要比较猛烈的变形,但对删除有了很大改变</mark>),避免了复杂的树变形;<br />2.则扩增了每个节点的key值数目,进而使得树更加<strong>矮胖</strong>,有利于减少I/O操作次数;而数据全放在叶子节点,树更稳定(查询都要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>),也利于MySQL常用的区间查询</p><p>以下是B+树的一个普通示例图:</p><p><img src="https://s2.loli.net/2023/11/03/4YXZ8RCWmz7phH2.png" alt="B+Tree" /></p><div class="note note-info">            <p>MongoDB是文档型的数据库,是NoSQL中的一种,用JSON格式存数据(这是一种聚合型的方式,与MySQL的表结构的设计思路很不同,MySQL的表间关系通过外键进行链接,而JSON对有关系的可以直接编到一个map里),于MongoDB而言更多进行的是单一数据查询,不涉及遍历查询,那么我们此刻B+树的优点于它而言就没啥意义,而B-树的值也存在于非叶子节点中,它的时间复杂度处于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>的状态,相较于B+树的稳定的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,B-树更适用于MongoDB数据库;<br />MySQL则是我们都熟悉的关系型数据库,很显然,它涉及到较多遍历操作和区间查询,因此更适用于B+树,B-树的遍历和区间查询(需找边缘值后中序遍历)会产生更多的IO操作,不值得</p>          </div><div class="note note-danger">            <p>勘误:经过看MongoDB官方文档,底层用的也是B+树,网上各类博客害人不浅<br />援引如下:</p><blockquote><p>WiredTiger maintains a table’s data in memory using a data structure called a B-Tree ( B+ Tree to be specific), referring to the nodes of a B-Tree as pages. Internal pages carry only keys. The leaf pages store both keys and values.</p></blockquote>          </div><h2 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h2><p>前面说过,AVL树是一种强平衡的树,而红黑树则是弱平衡的BST.它较之于AVL树而言,正由于它的弱平衡性,导致我们在插入删除时不必要进行那么多的旋转操作!</p><p>红黑树的平衡性体现在:<strong>从根到叶子的最长路径不会比最短路径长超过两倍</strong></p><p>之所以说它是弱平衡的,是因为它没有将bf强制约束于某个值,而是通过如下5条性质来维持弱平衡性:</p><ul><li><strong>节点是红色或黑色的</strong></li><li><strong>根节点是黑色的</strong></li><li><strong>叶子节点都是黑色的,它们都是空节点,data为null</strong></li><li><strong>不能出现连续的两个红色节点(即一个红色节点的父节点及其子节点一定都是黑色的)</strong></li><li><strong>从任一节点到叶子节点的所有路径都包含相同数目的黑色节点</strong></li></ul><p>针对最后一点性质,红黑树有一个<strong>黑高度(黑高)<strong>的概念:从某个节点出发至一叶子节点,所经历的黑色节点的个数(不包括起始节点,即使它是黑的)称为该节点的黑高bh.因此</strong>某一个节点的bh值应是唯一的</strong>,若不唯一则违背了最后一条性质</p><p>以下是红黑树的一张示意图:</p><p><img src="https://s2.loli.net/2023/11/03/8h6p2cQwK5afSFm.png" alt="RBT" /></p><div class="note note-info">            <p>红黑树的查找,插入,删除的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_{2}{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span>,跟AVL树的一样,但其实AVL树在处理插入和删除问题时,为了保持bf=1,会涉及到复杂的旋转问题.而具有强平衡性的AVL树的查询能力显然更强.因此在设计底层数据结构的时候可以根据侧重进行选择</p>          </div><p>而在之后介绍如插入等的相关操作时,一般会<strong>忽略掉最后的叶子节点</strong>,就是data为null的节点</p><p>一颗红黑树,通过<strong>将红色节点上移至父节点同一高度组成B树节点后</strong>,即<strong>等价于一颗4阶B树</strong>,其变形如下所示:</p><p><img src="https://s2.loli.net/2023/11/03/tUPQXa4YhdIvrox.png" alt="RBT2BTree" /></p><p>由上图可以看出来,红黑树变形为4阶B树后有如下性质:</p><ul><li>红黑树与4阶B树具有等价性</li><li>黑色节点和其红色子节点融合形成一个B树节点</li><li>在一个融合形成的B树节点里,根节点是黑色的,子节点是红的</li><li>红黑树的非叶子节点的黑色节点个数与4阶B树的节点总数相等</li></ul><p>我们先来探讨一下转换为4阶B树的红黑树,对应的节点内部情况.4阶B树节点内部最多允许有3个元素,依据上述的性质3,即存在以下情况:<strong>红黑红,黑红,红黑,黑</strong>,且其中黑色的一定是原红黑树的子树/树本身的根节点,图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/e62NIFW8owYr3XS.png" alt="RBT2BTree-node-classfication" /></p><p><strong>对红黑树的插入删除情况的讨论也转换为对4阶B树的插入删除情况的讨论,但需要满足红黑树的性质</strong></p><p>插入情况讨论:</p><p>首先给出插入情况的红黑树的图:</p><p><img src="https://s2.loli.net/2023/11/03/muwN2zvGIPep7XD.png" alt="RBT2BTree-Insertion" /></p><p>对于B树的插入,是自底向上的.因此对插入情况可分为如下两大类及对应的细分:</p><ul><li>插入导致上溢</li><li>插入不导致上溢<ul><li>父节点是黑色的</li><li>父节点是红色的</li></ul></li></ul><p>而根据红黑树的性质:<strong>某一结点至叶子节点的任意路径的黑色节点个数相等</strong>可知,若插入节点的颜色是黑的,一定会破坏这条规则,且需要花较大功夫来维持这条规则;若插入节点是红的,则可能破坏了<strong>不允许有两个连续的红色节点</strong>这一规则,但对这一规则的维护可以通过旋转及变色来操作,较容易处理.因此<strong>插入节点一定都是红色节点</strong></p><p>根据给出的示意图,可以分析得出如下的插入情况,分别是:</p><ul><li>满足红黑树性质,无需修复</li><li>不满足红黑树性质,需要修复</li></ul><p>对应的图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/i9cyfeSUzraZWnH.png" alt="RBT2BTree-Insertion-without-repair" /></p><p><img src="https://s2.loli.net/2023/11/03/adcunTZI6XSpNO3.jpg" alt="RBT2BTree-Insertion-need-repair" /></p><p>针对上图的<strong>不需上溢</strong>的情况,其实就是做<strong>旋转以及变色</strong>,旋转后变色需遵循上述的<strong>新B树节点内的根节点是黑色的两侧节点是红色的</strong>.之所以<strong>不需上溢</strong>可以通过旋转加变色处理,是因4阶B树允许节点内部最多三个元素,且当是三个元素的时候,是红黑红(根节点黑,俩子节点红)的情况</p><p>以下仅介绍不需上溢的其中一种情况,即LL.LL意味着插入元素位于父节点的左侧(L),而父节点也是位于grand节点的左侧,之于这种情况可通过右旋更新父节点,而后染色成<strong>红黑红</strong>的B树节点即可,过程见下图示:</p><p><img src="https://s2.loli.net/2023/11/03/Lp6GvV5XMJSBgaP.png" alt="RBT2BTree-Insertion-LL-RR" /></p><p>而后面的[LR,RL]这俩情况则是需要双旋,旋转成[LL,RR]后再转一次和进行染色就ok了</p><p>这四种情况[LL,LR,RL,RR]的流程如下表所示:</p><table><thead><tr><th style="text-align:center">插入位置</th><th style="text-align:center">状态</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><strong>插入元素位于其parent节点的left,而其parent位于其grand的left</strong></td><td style="text-align:center">LL</td><td style="text-align:center">右旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的right,而其parent位于其grand的right</strong></td><td style="text-align:center">RR</td><td style="text-align:center">左旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的right,而其parent位于其grand的left</strong></td><td style="text-align:center">LR</td><td style="text-align:center">先左旋,再右旋</td></tr><tr><td style="text-align:center"><strong>插入元素位于其parent节点的left,而其parent位于其grand的right</strong></td><td style="text-align:center">RL</td><td style="text-align:center">先右旋,再左旋</td></tr></tbody></table><p>而针对于<strong>需要上溢</strong>的情况其实更简单,因为我们首要解决的是上溢的问题,即节点分裂,上移,那么此刻就会分裂出两个新的子节点,而这俩子节点是原先父节点的子节点,现在做了独立的B树节点的根节点,即对二者变色即可,则此刻新插入的节点的情况等价于往黑色的根节点插入新节点,即满足红黑树性质,无需修复.这个整体过程可以概括为:<strong>上溢,变色</strong>,无需旋转</p><p>示例图如下:</p><p><img src="https://s2.loli.net/2023/11/03/IRKqyOMLvV6jpYt.png" alt="RBT2BTree-Insertion-upflow" /></p><p>然后对[25&lt;-38&lt;-55]这一个B树节点(LL情况)右旋然后变色即可</p><p>关于删除的部分情况较多,之后有时间再补上:)</p>]]></content>
    
    
    
    <tags>
      
      <tag>tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVM理解</title>
    <link href="/2022/10/10/SVM%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/10/SVM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="svm概念"><a class="markdownIt-Anchor" href="#svm概念"></a> SVM概念</h2><p>SVM(Support Vector Machine)支持向量机,它是一个二分类模型.也存在变体的SVM模型,可用于处理多分类问题</p><p><mark>SVM擅长于处理样本数少于特征维度数的情况,应该也适用于小样本学习</mark></p><p>从二维空间举例来说,我们存在两个点集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,它们是线性可分的,即可以通过一条直线将其进行完全划分.这是二维空间的情况.推广至n维空间,即存在一个<strong>超平面hyperplane</strong>可以对该特征空间下的点集进行划分</p><p>那么很明显,这样的超平面存在无数多个,于二维空间而言,我们可以找多无数多条直线来对点集进行划分.SVM所期望的超平面是<strong>最大间隔超平面</strong></p><p><strong>最大间隔超平面</strong>,即<strong>距离超平面最近的点的距离最大化</strong>.这些离超平面最近的点被称作<strong>支持向量</strong></p><p>之所以以最大间隔作为期望条件,是因其:<strong>间隔越大,两个需要区分的类别差异性更大,更容易做区分</strong></p><h2 id="间隔的表达式"><a class="markdownIt-Anchor" href="#间隔的表达式"></a> 间隔的表达式</h2><p>以二维空间为例,假设我们已经找到了可以将两个点集进行划分的<strong>分割线</strong>,这条分割线的超平面方程式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,根据上面的概念,我们可以通过将该直线上下分别移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>以<strong>恰好</strong>经过一些最近的样本点(即支持向量),来找到对应的间隔上下边界,二者的式子可表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=\pm{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></span></p><p>我们可以对间隔边界的式子进行变形以取得下式:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2+b=\pm{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord"><span class="mord">1</span></span></span></span></span>,我们将这三个式子如下称呼:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>正超平面</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>决策超平面</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><mn>1</mn><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>负超平面</mtext></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\begin{aligned}w_1x_1+w_2x_2&amp;=1 \quad &amp;\text{正超平面} \\w_1x_1+w_2x_2&amp;=0 \quad &amp;\text{决策超平面} \\w_1x_1+w_2x_2&amp;=-1 \quad &amp;\text{负超平面} \end{aligned}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.0000000000000004em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000013em;"><span style="top:-4.5em;"><span class="pstrut" style="height:4.5em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">正超平面</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">决策超平面</span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">负超平面</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0000000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>若点代入式子,有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,则其为正类;<br />若点代入式子,有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>≤</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_1x_1+w_2x_2\le-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>,则其为负类</p><p>我们可以根据向量投影来求得间隔<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>的值,也可以通过线线距离来求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span></span></span></span>的值</p><p><img src="https://s2.loli.net/2023/11/03/CxGoRhzj5YQk1aP.png" alt="margin-of-SVM" /></p><p>根据上图将m,n两点代入正负超平面,做差,而后投影,可得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mfrac><mn>2</mn><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">L=\frac{2}{\Vert \vec{w} \Vert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,我们欲求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\max L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">L</span></span></span></span>,可以转换成求其倒数的最小值,而由于对向量求范式含根号,故对其平方以去根号,因此我们的优化目标转为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\min f(w) = \frac{1}{2}\Vert \vec{w^2} \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3681079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span></p><h2 id="拉格朗日乘数法"><a class="markdownIt-Anchor" href="#拉格朗日乘数法"></a> 拉格朗日乘数法</h2><p>面对存在<strong>一个或多个约束条件</strong>下,我们想求得<strong>目标函数的极值</strong>,可以使用拉格朗日乘数法<br />而在此题中,我们欲求得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>的最小值,则可以通过拉格朗日乘数法来求解<br />首先明确,我们的约束条件是:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>1</mn><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_i(w,b) = y_i * (\vec{w}\vec{x_i} + b) \ge 1 \quad\quad (i=1,2,\cdots,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表的是分类值,为1则为正类,为-1则为负类,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\vec{w}\vec{x}+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79733em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>则是超平面的表达式(其所处的维度空间由向量维度确定),<strong>约束条件表明正负类点集都应分布在正负超平面两侧(亦可恰好分布在正负超平面上)</strong></p><p>对于拉格朗日乘数法,它所处理的是等式约束条件,而我们这里是不等式约束条件,可通过增加<strong>松弛变量</strong>来使得其转化为等式的约束条件,可变换成如下形式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>=</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_i(w,b,p_i) = y_i * (\vec{w}\vec{x_i} + b) -1 = {p_i}^2 \quad\quad (i=1,2,\cdots,s) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span></span></p><p>此时可以通过构造拉格朗日函数来处理极值问题,构造的函数如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>λ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>−</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mo stretchy="false">)</mo><mspace width="1em"/><mspace width="1em"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}L(w,b,\lambda_i,p_i) &amp;= f(w) - \sum_{i=1}^{s}\lambda_ig_i(w,b,p_i) \\&amp;= \frac{\Vert \vec{w^2} \Vert}{2} - \sum_{i=1}^{s}\lambda_i * (y_i * (\vec{w}\vec{x_i} + b) -1 - {p_i}^2) \quad\quad (i=1,2,\cdots,s)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.506843000000001em;vertical-align:-3.0034215em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.503421500000001em;"><span style="top:-5.552132500000001em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.2743555000000004em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0034215em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.503421500000001em;"><span style="top:-5.552132500000001em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.2743555000000004em;"><span class="pstrut" style="height:3.700108em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.700108em;"><span style="top:-2.3371079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.2531079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7001079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0034215em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>此时我们可以知道,若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值为负数,则无法起到罚值作用(相关意义可以见后面软间隔部分),因此其取值应为:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>需注意,根据拉格朗日乘数法,我们需要对<strong>目标函数</strong>,<strong>拉格朗日算子</strong>以及<strong>松弛变量</strong>求偏导,且零其值为0,因此,得下式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>−</mo><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\Vert \vec{w} \Vert - \sum_{i=1}^{s}\lambda_i * y_i * \vec{x_i} = 0 \\ - \sum_{i=1}^{s}\lambda_i * y_i = 0 \\y_i * (\vec{w}\vec{x_i} + b) - 1 - {p_i}^2 = 0 \\2\lambda_ip_i = 0\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.76em;vertical-align:-2.63em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9500200000000008em;"><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.5949900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8899900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1849900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.905010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.20002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1300000000000003em;"><span style="top:-5.130000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.6900000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-0.8100000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.63em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>联立后两个式子(消去<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><msub><mi>p</mi><mi>i</mi></msub><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">{p_i}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>),我们会发现有:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_ig_i(w,b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>这一公式,其只有以下两种情况:</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i=0,g_i(w,b)\neq0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,此刻约束条件非零,则意味着点并非落在正负超平面上,非极值,此刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>必须为0;</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda_i\neq0,g_i(w,b)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,此刻点落在正负超平面上,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以不为零</li></ol><p>因此,对公式重整,我们有:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></msubsup><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>λ</mi><mi>i</mi></msub><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}\Vert \vec{w} \Vert - \sum_{i=1}^{s}\lambda_i * y_i * \vec{x_i} = 0 \\- \sum_{i=1}^{s}\lambda_i * y_i = 0 \\g_i(w,b) \ge 0 \\\lambda_i * g_i(w,b) = 0 \\\lambda_i \ge 0 \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.2000399999999996em;vertical-align:-3.3500199999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.85002em;"><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-0.6949900000000002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.9899900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.2849900000000003em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.5799900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.8749900000000006em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1699900000000008em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.2049900000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.29501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.59001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.885010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.180010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.475010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.770010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.80501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-6.10002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8500000000000005em;"><span style="top:-5.850000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-4.410000000000001em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.9700000000000006em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-0.08999999999999997em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>观察可知,此式现已满足KKT条件,即可对其进行求解</p><h2 id="强对偶"><a class="markdownIt-Anchor" href="#强对偶"></a> 强对偶</h2><p>为了效率及后续操作中使用kernel trick,我们可以利用强对偶性对其进行处理<br /><mark>暂时没看懂,后面再补</mark></p><h2 id="软间隔"><a class="markdownIt-Anchor" href="#软间隔"></a> 软间隔</h2><p>我们知道并不是所有点都可以满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g_i(w,b) \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,有些点会出现在我们的margin里面,那么这时候我们要么缩短margin以满足所有点都在margin两侧(hard margin),要么根据误差做罚值<br />根据margin的定义,margin越大越说明二者差异,越易分类.因此,不可轻易缩短margin,我们要容许部分点落在margin内,因此是对二者做的一个平衡</p><p>我们可以将罚值公式记作如下:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ϵ</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mo stretchy="false">(</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mo>+</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon_i = 1 - y_i * (\vec{w} + \vec{x_i} + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.864em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></p><p>因此,我们所求的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>min</mi><mo>⁡</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\min \frac{\Vert \vec{w^2} \Vert}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.55052em;vertical-align:-0.345em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.20552em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0293142857142856em;"><span style="top:-2.746314285714286em;"><span class="pstrut" style="height:2.746314285714286em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.061628571428572em;"><span class="pstrut" style="height:2.746314285714286em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>需要与不同点的罚值寻找一个平衡,构建出以下公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>min</mi><mo>⁡</mo><mfrac><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msup><mi>w</mi><mn>2</mn></msup><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></mfrac><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>s</mi></munderover><msub><mi>ϵ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\min \frac{\Vert \vec{w^2} \Vert}{2} + \sum_{i=1}^{s}\epsilon_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.386108em;vertical-align:-0.686em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.700108em;"><span style="top:-2.3371079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.2531079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7001079999999997em;"><span class="pstrut" style="height:3.0231079999999997em;"></span><span class="mord"><span class="mord">∥</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.023108em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.309108em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>使用以上公式,以达总体最优,再根据之前的构造出拉格朗日乘数法进行计算即可</p><h2 id="核技巧中的核函数"><a class="markdownIt-Anchor" href="#核技巧中的核函数"></a> 核技巧中的核函数</h2><p>我们在低维空间可能无法对点集进行线性划分,则我们可以通过将其映射到高维来处理,但映射到高维存在计算量过大的问题,而我们在通过强队偶计算的过程中发现,可以利用其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_ix_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的性质来利用核函数.即:<br />以下是两个核函数公式:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>多项式核函数</mtext><msub><mi>K</mi><mi>d</mi></msub><mo stretchy="false">(</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>∗</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo></mrow><mi>d</mi></msup><mspace linebreak="newline"></mspace><mtext>高斯核函数</mtext><mi>K</mi><mo stretchy="false">(</mo><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>γ</mi><msup><mrow><mi mathvariant="normal">∥</mi><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo>⃗</mo></mover><mo>−</mo><mover accent="true"><msub><mi>x</mi><mi>j</mi></msub><mo>⃗</mo></mover><mi mathvariant="normal">∥</mi></mrow><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">\text{多项式核函数}  K_d(\vec{x_i},\vec{x_j}) = {(c + \vec{x_i} * \vec{x_j})}^d \\\text{高斯核函数} K(\vec{x_i},\vec{x_j}) = e^{-\gamma {\Vert \vec{x_i}-\vec{x_j} \Vert}^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord cjk_fallback">多项式核函数</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275116em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord text"><span class="mord cjk_fallback">高斯核函数</span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0369199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369199999999998em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05556em;">γ</span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-2.7139999999999995em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span><span class="mord mtight">∥</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>]]></content>
    
    
    
    <tags>
      
      <tag>SVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像增强方法合集</title>
    <link href="/2022/10/06/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/"/>
    <url>/2022/10/06/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="mixup"><a class="markdownIt-Anchor" href="#mixup"></a> mixup</h2><h2 id="cutout"><a class="markdownIt-Anchor" href="#cutout"></a> cutout</h2><h2 id="cutmix"><a class="markdownIt-Anchor" href="#cutmix"></a> cutmix</h2>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViT理解及实验</title>
    <link href="/2022/10/04/ViT%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/10/04/ViT%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>ViT(Vision Transformer),是ICLR 2021上的一篇<strong>AN IMAGE IS WORTH 16x16 WORDS:TRANSFORMER FOR IMAGE RECOGNITION AT SCALE</strong>论文里提及的模型,将<strong>transformer应用于image classification</strong>上,并在Google的JFT-300M数据集进行预训练后,在ImageNet-1k上做分类达到当时的SOTA!</p><p><img src="https://s2.loli.net/2023/11/05/2owmLrEzqihCtcd.png" alt="ViT-Paper-Result" /></p><p>因此,本文将通过结构结合代码进行介绍,并于文末将采用与预训练好的模型应用于花分类数据集上进行实验.</p><div class="note note-info">            <p>注:本文采用的是ViT-B/16模型进行解析,B-&gt;Base 16-&gt;patch size:16*16,输入图片的shape是(224,224,3)</p>          </div><p><img src="https://s2.loli.net/2023/11/03/FKTfWnXRGQMPYol.png" alt="Details of ViT variants" /></p><p>原论文链接:<a href="https://arxiv.org/pdf/2010.11929.pdf">AN IMAGE IS WORTH 16x16 WORDS:TRANSFORMER IMAGE RECOGNITION AT SCALE</a><br /><a href="https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz">花分类数据集下载</a></p><h2 id="vit整体结构"><a class="markdownIt-Anchor" href="#vit整体结构"></a> ViT整体结构</h2><p>首先看下ViT的整体结构图:</p><p><img src="https://s2.loli.net/2023/11/05/5HgIBdYF8btX7OG.png" alt="ViT-overview" /></p><p>整个ViT由以下三部分组成:</p><ul><li>Linear Projection of Flattened Patches -&gt; 转换为transformer接受的输入</li><li>Transformer Encoder -&gt; 进入Encoder学习图片的相关性,对应特征</li><li>MLP Head -&gt; 做分类,其实就是全连接层</li></ul><h3 id="linear-projection-of-flattened-patches"><a class="markdownIt-Anchor" href="#linear-projection-of-flattened-patches"></a> Linear Projection of Flattened Patches</h3><h4 id="patch-embedding"><a class="markdownIt-Anchor" href="#patch-embedding"></a> patch embedding</h4><p>根据先前介绍的transformer的知识,我们输入的应该是token sequence,如由词向量组成的矩阵,row的个数表示词的个数,column宽度表示词的dimension.<br />因此输入图片是不符合要求的,我们需要将图片处理成<strong>对应的序列</strong>才行.将图片切割成一小块一小块的patch,再将patches延展成一维的(获得patch_num),再将每个patch通过线性变换映射到对应的维度(patch_dim),即完成了patch embedding的过程.最终得到的参数为:[patch_num,patch_dim]<br />其实上述过程,用卷积的思想解释就是<strong>kernel=16x16,stride=16,采用768个卷积核进行卷积计算,即可以将[224,224,3]-&gt;[14,14,768]</strong>,然后再通过torch的flatten处理就可以得到[196,768]</p><div class="note note-info">            <p>注:这里的<strong>768</strong>并非通过如16*16*3计算出来的,而是作者规定的dimension,如ViT-H/16,其patch_dim是1280.</p>          </div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PatchEmbed</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    2D Image to Patch Embedding</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, img_size=<span class="hljs-number">224</span>, patch_size=<span class="hljs-number">16</span>, in_c=<span class="hljs-number">3</span>, embed_dim=<span class="hljs-number">768</span>, norm_layer=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        img_size = (img_size, img_size)<br>        patch_size = (patch_size, patch_size)<br>        self.img_size = img_size<br>        self.patch_size = patch_size<br>        self.grid_size = (img_size[<span class="hljs-number">0</span>] // patch_size[<span class="hljs-number">0</span>], img_size[<span class="hljs-number">1</span>] // patch_size[<span class="hljs-number">1</span>])<br>        self.num_patches = self.grid_size[<span class="hljs-number">0</span>] * self.grid_size[<span class="hljs-number">1</span>]<br><br>        self.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size) <span class="hljs-comment"># 这里所复现的代码用的是卷积的形式,原文的代码不是卷积</span><br>        self.norm = norm_layer(embed_dim) <span class="hljs-keyword">if</span> norm_layer <span class="hljs-keyword">else</span> nn.Identity() <span class="hljs-comment"># 这里的Identity指的是不对输入做任何修改直接输出的意思</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        B, C, H, W = x.shape <span class="hljs-comment"># x.shape = [batch_size,channel,height,width]</span><br>        <span class="hljs-keyword">assert</span> H == self.img_size[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> W == self.img_size[<span class="hljs-number">1</span>], \<br>            <span class="hljs-string">f&quot;Input image size (<span class="hljs-subst">&#123;H&#125;</span>*<span class="hljs-subst">&#123;W&#125;</span>) doesn&#x27;t match model (<span class="hljs-subst">&#123;self.img_size[<span class="hljs-number">0</span>]&#125;</span>*<span class="hljs-subst">&#123;self.img_size[<span class="hljs-number">1</span>]&#125;</span>).&quot;</span><br><br>        <span class="hljs-comment"># flatten: [B, C, H, W] -&gt; [B, C, HW] </span><br>        <span class="hljs-comment"># transpose: [B, C, HW] -&gt; [B, HW, C] 即[B,196,768]</span><br>        x = self.proj(x).flatten(<span class="hljs-number">2</span>).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        x = self.norm(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>注: 代码中的类继承了nn.Module,这里面重写了魔法方法__call__,该方法里面调用了forward方法,因此子类重载forward可使得该方法通过<strong>类实例化对象如普通方法般调用</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">patchEmbed = PatchEmbed(para1,para2,...)<br>x = torch.rand(B,C,H,W)<br>patchEmbed(x) <span class="hljs-comment"># 于此会调用__call__方法,因而调用自己重载后的forward方法</span><br></code></pre></td></tr></table></figure>          </div><h4 id="cls-token"><a class="markdownIt-Anchor" href="#cls-token"></a> CLS token</h4><p>ViT中的分类采用的是Bert中的CLS的思想来进行的,因此我们的patchEmbedding需要变换成**[196+1,768]**,即多出一行用于分类,这个参数由网络学习得到.其与patchEmbedding是concat的关系</p><h4 id="positional-embedding"><a class="markdownIt-Anchor" href="#positional-embedding"></a> positional embedding</h4><p>在transformer里讲过,我们输入的序列缺乏位置信息,因此需要增加positional embedding来使得其位置信息得以保持.在代码中,我们的位置信息是通过模型训练获得的(nn.Parameter()),其与patch embedding是直接add的</p><h3 id="encoder-block"><a class="markdownIt-Anchor" href="#encoder-block"></a> encoder block</h3><p>流程如下图所示:</p><p><img src="https://s2.loli.net/2023/11/05/UVtJnMqul2fjCEO.png" alt="ViT encoder block" /></p><p>关于Multi-Head Attention层相关的部分跟transformer的一样,这里不赘述.以下是Multi-Head Attention的代码解析部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Attention</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 dim,   <span class="hljs-comment"># 输入token的dim(768)</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 num_heads=<span class="hljs-number">8</span>, <span class="hljs-comment"># 有几个头(multi的head)</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 qkv_bias=<span class="hljs-literal">False</span>, <span class="hljs-comment"># 偏移量</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 qk_scale=<span class="hljs-literal">None</span>, <span class="hljs-comment"># 放缩量</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 attn_drop_ratio=<span class="hljs-number">0.</span>, <span class="hljs-comment"># attention公式执行完后的dropout比例</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 proj_drop_ratio=<span class="hljs-number">0.</span></span>):</span> <span class="hljs-comment"># 一个encoder block执行完后的drop比例 </span><br>        <span class="hljs-built_in">super</span>(Attention, self).__init__()<br>        self.num_heads = num_heads<br>        head_dim = dim // num_heads <span class="hljs-comment"># 每个头对应的维度</span><br>        self.scale = qk_scale <span class="hljs-keyword">or</span> head_dim ** -<span class="hljs-number">0.5</span><br>        self.qkv = nn.Linear(dim, dim * <span class="hljs-number">3</span>, bias=qkv_bias) <span class="hljs-comment"># 将QKV三个一次性一起生成</span><br>        self.attn_drop = nn.Dropout(attn_drop_ratio)<br>        self.proj = nn.Linear(dim, dim)<br>        self.proj_drop = nn.Dropout(proj_drop_ratio)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-comment"># [batch_size, num_patches + 1, total_embed_dim]</span><br>        B, N, C = x.shape<br><br>        <span class="hljs-comment"># qkv(): -&gt; [batch_size, num_patches + 1, 3 * total_embed_dim] QKV三个矩阵一起的(相当于沿列方向concat,[B,196,768*3])</span><br>        <span class="hljs-comment"># reshape: -&gt; [batch_size, num_patches + 1, 3, num_heads, embed_dim_per_head] </span><br>        <span class="hljs-comment"># permute: -&gt; [3, batch_size, num_heads, num_patches + 1, embed_dim_per_head] Q,K,V三个矩阵分出来,并且将其各分成num_heads个小矩阵</span><br>        qkv = self.qkv(x).reshape(B, N, <span class="hljs-number">3</span>, self.num_heads, C // self.num_heads).permute(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>        <span class="hljs-comment"># [batch_size, num_heads, num_patches + 1, embed_dim_per_head]</span><br>        q, k, v = qkv[<span class="hljs-number">0</span>], qkv[<span class="hljs-number">1</span>], qkv[<span class="hljs-number">2</span>]  <span class="hljs-comment"># make torchscript happy (cannot use tensor as tuple)</span><br><br>        <span class="hljs-comment"># transpose: -&gt; [batch_size, num_heads, embed_dim_per_head, num_patches + 1]</span><br>        <span class="hljs-comment"># @: multiply -&gt; [batch_size, num_heads, num_patches + 1, num_patches + 1] 集体做矩阵乘</span><br>        attn = (q @ k.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) * self.scale<br>        attn = attn.softmax(dim=-<span class="hljs-number">1</span>) <span class="hljs-comment"># 对行向量做softmax</span><br>        attn = self.attn_drop(attn)<br><br>        <span class="hljs-comment"># @: multiply -&gt; [batch_size, num_heads, num_patches + 1, embed_dim_per_head] </span><br>        <span class="hljs-comment"># transpose: -&gt; [batch_size, num_patches + 1, num_heads, embed_dim_per_head]</span><br>        <span class="hljs-comment"># reshape: -&gt; [batch_size, num_patches + 1, total_embed_dim]</span><br>        x = (attn @ v).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).reshape(B, N, C)<br>        x = self.proj(x) <span class="hljs-comment"># 相当于拼接好后的Z矩阵与W^O矩阵相乘</span><br>        x = self.proj_drop(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>nn.Linear()就是全连接(如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><msup><mi>A</mi><mi>T</mi></msup><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = xA^T + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>是输入参数,可以是多维的,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>是权重矩阵,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>是偏置向量),对x.shape的最后一个维度最连接操作,也可以将其理解为矩阵乘,其参数由训练迭代更新(源码中将其加入了nn.Parameter()中)<br />nn.Droupout()防止过拟合,参数表示不被激活的神经元的占比<br />@-&gt;矩阵乘 *-&gt;矩阵点乘(又或者说逐向量内积)</p>          </div><h4 id="mlp-block"><a class="markdownIt-Anchor" href="#mlp-block"></a> MLP block</h4><p>从上方ViT Encoder Block的图中可以看出,MLP是由两层全连接层和GELU激活函数构成,第一层将其维度变为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>768</mn><mi>x</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">768x4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">6</span><span class="mord">8</span><span class="mord mathnormal">x</span><span class="mord">4</span></span></span></span>,第二层将其维度变回768(<mark>没搞明白为啥这样变</mark>).代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mlp</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_features, hidden_features=<span class="hljs-literal">None</span>, out_features=<span class="hljs-literal">None</span>, act_layer=nn.GELU, drop=<span class="hljs-number">0.</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        out_features = out_features <span class="hljs-keyword">or</span> in_features<br>        hidden_features = hidden_features <span class="hljs-keyword">or</span> in_features<br>        self.fc1 = nn.Linear(in_features, hidden_features) <span class="hljs-comment"># hidden_features == 4*in_features</span><br>        self.act = act_layer()<br>        self.fc2 = nn.Linear(hidden_features, out_features) <span class="hljs-comment"># out_features == in_features</span><br>        self.drop = nn.Dropout(drop)<br><br><span class="hljs-comment"># 按照上述流程图的顺序执行的</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.fc1(x)<br>        x = self.act(x)<br>        x = self.drop(x)<br>        x = self.fc2(x)<br>        x = self.drop(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h3 id="mlp-head"><a class="markdownIt-Anchor" href="#mlp-head"></a> MLP HEAD</h3><p>切片,取第0行的向量(CLS),然后做全连接,流程如下图所示</p><p><img src="https://s2.loli.net/2023/11/03/M4T2mAFqiBhE7JZ.png" alt="MLP-HEAD" /></p><p>关于上面的Pre-Logits,在ImageNet-1K无需用到,直接设置为None;在ImageNet-21K里用到了,就是一个全连接层+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">tanh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal">h</span></span></span></span>激活函数</p><h2 id="vit执行流程"><a class="markdownIt-Anchor" href="#vit执行流程"></a> ViT执行流程</h2><p>详见下图,图片源于B站UP主:霹雳吧啦Wz</p><p><img src="https://s2.loli.net/2023/11/05/QJbGUKgoFZw3kuN.png" alt="ViT Execution Process" /></p><h2 id="vit实验"><a class="markdownIt-Anchor" href="#vit实验"></a> ViT实验</h2><p>拿的别人的模型跑的,但是好像用CUDA的地方出了点问题,在调BUG,跑好了会摆上来</p><h2 id="vit与传统cnn的差异"><a class="markdownIt-Anchor" href="#vit与传统cnn的差异"></a> ViT与传统CNN的差异</h2><p>关于二者的差异在<strong>Do Vision Transformers See Like Convolutional Neural Networks</strong>这篇论文中进行了详细的比对.下面将对其结果和主要使用分析工具进行介绍</p><p>原论文连接:<a href="https://arxiv.org/pdf/2108.08810.pdf">Do Vision Transformers See Like Convolutional Neural Networks?</a><br /><mark>非常粗粒度的看了这篇论文</mark></p><h3 id="主要分析工具"><a class="markdownIt-Anchor" href="#主要分析工具"></a> 主要分析工具</h3><p>CKA(Centered Kernel Alignment),可用于<strong>计算神经网络表征(neural network representation)的相似度</strong>.可以用于计算<strong>同一模型不同层间的表征相似度</strong>,或者是<strong>不同模型间的层的表征相似度</strong>,具体计算公式不细说(<mark>主要是我没弄明白</mark>),知其定义即可理解该论文对ViT和ResNet间的差异性分析.</p><h3 id="vit和resnet的比较"><a class="markdownIt-Anchor" href="#vit和resnet的比较"></a> ViT和ResNet的比较</h3><h4 id="同一模型间的不同层级的表征相似性比较"><a class="markdownIt-Anchor" href="#同一模型间的不同层级的表征相似性比较"></a> 同一模型间的不同层级的表征相似性比较</h4><p><img src="https://s2.loli.net/2023/11/03/jJPaSAEu3WD5Gb8.png" alt="representation structure of ViTs and CNN" /></p><p>从上面这个图可以很清晰的看出来:<strong>ViT模型整体具有高度的表征相似性,而ResNet只是局部具有较高的表征相似性,如低层和高层,且lower layers和higher layers相似性很小</strong></p><h4 id="不同模型间的对应层级的表征相似性比较"><a class="markdownIt-Anchor" href="#不同模型间的对应层级的表征相似性比较"></a> 不同模型间的对应层级的表征相似性比较</h4><p><img src="https://s2.loli.net/2023/11/03/7yHbhG1k2YTDWxM.png" alt="representation structure between ViTs and CNN" /></p><p>从上面这个heatmap图可以看出来:ResNet中较多的较低层与ViT中较少的较低层具有相似性,但是在高层间(最高的那一片区域)二者相似性很低</p><p>以上对模型自身及模型间的层与层的表征相似性的说明了:</p><ul><li><strong>ViT最高层对于ResNet来说,具有相当不同的表示</strong></li><li><strong>ViT在较低层和较高层间的传播表示更为强烈</strong></li><li><strong>ViT计算较低层表征的方式与ResNet较低层的不同</strong></li></ul><h4 id="层表征中的局部和全局信息"><a class="markdownIt-Anchor" href="#层表征中的局部和全局信息"></a> 层表征中的局部和全局信息</h4><p>这个标题主要的意思就是,不同模型中<strong>低层和高层中学习到了的是什么样的信息,局部的或是全局的或是二者皆有</strong><br />因此这里的层表征主要指代的就是<strong>低层</strong>和<strong>高层</strong>的,于ViT而言就是最开始的encoder block和最后一次的encoder block<br />之于CNN而言,我们知道,它卷积其实受限于相邻的区域,即使stride有所调整,也是局部的(于低层而言,<mark>我觉得高层也是,某一块kernel对应的是一只猫的耳朵或是尾巴,其实也是局部信息</mark>)<br />以下是ViT的低层和高层部分的学习到的信息的图(注意,这里的Mean Distance是一种用单个头的注意力权重,就是之前说的Z<sub>i</sub>(i∈[0,15])来加权pixel distance(<mark>我觉得是对应patch的dimension</mark>),然后做平均得到的结果.大距离说明是全局信息,小距离说明是局部信息)</p><p><img src="https://s2.loli.net/2023/11/03/bD5HhY2R1NnCeVE.png" alt="Local and Global information that ViT learned" /></p><p>显而易见,<strong>encoder block在低层时,学到的既有局部信息也有全局信息,而高层的encoder block学习到的都是全局信息</strong>(<mark>个人认为就是自注意力机制脱离了邻域关注的问题,使得低层次也可以学习到全局的信息</mark>)</p><p>当然,这只是说明ViT跟CNN学习方式不同,并非说局部信息不好的意思.论文里作者也用了没有pretrain的ViT,其效果很烂之余,也发现其压根没学到啥局部信息,反而印证了前期学习中局部信息的重要性,效果图如下:</p><p><img src="https://s2.loli.net/2023/11/03/FfwCltvQgaTmysd.png" alt="Local and Global information which no pretrained ViT learned" /></p><p>那么全局信息有啥用呢,作者通过对encoder block 1和2里面各自的16个head划分成多个子集,子集范围对应着[多数含局部信息的heads,多数含全局信息的heads],用这些子集和低层的ResNet计算CKA,得出下图:</p><p><img src="https://s2.loli.net/2023/11/03/2Cmqso1lvcZnSMw.png" alt="Local and Global ViTs Representations compared to ResNets" /></p><p>结果显而易见,随着全局信息增多(即平均距离增大),基本上二者CKA单调递减<br /><mark>作者其实没明确给出ViT中encoder block低层且head较小时学到的全局信息有啥用,但我觉得这个局部信息(基于Mean Distance这种度量方式)可能正是源于我们多头机制想要规避开的<strong>对于自身所在词的过度关注</strong>,而随着后面cocat成一个完整的Z与W<sup>O</sup>做乘积时,其局部性被削弱(这也跟Multi-Head Attention这个机制有关)</mark><br /><mark>而此刻输出值作为下一个encoder block的输入,其包含了较多的全局信息,这使得<strong>我们较低层与较高层构建出一定的相似性</strong>,当然这也与skip connection有关(其实这里说的就是skip connection)</mark></p><p>接着作者还对<strong>有效感受野(ERF)<strong>进行了分析,如下图示:<br /><img src="http://qny.ayyha.store/ViT%20and%20ResNet%20ERF.png" alt="ViT and ResNet ERF" /><br />我们知道,卷积的有效感受野受</strong>kernel大小</strong>以及<strong>下采样层</strong>影响,因此一开始很小;而自注意力机制使得ViT的有效感受野不受局部信息局限,还多了全局信息,因此有效感受野比较大;<br />而之后ResNet的ERF以局部扩增的方式增大(<strong>高度局部化</strong>),而ViT的ERF则是从局部转向全局,且高度依赖于中心的patch,这与skip connection有强烈关系!下图是pre-residual的感受野:</p><p><img src="https://s2.loli.net/2023/11/03/XNuAwY1DVLZMOC9.png" alt="Pre-residual receptive fields of all ViT-B/32 sublayers" /></p><p>可以看出上图(比较Attention12),可以看出残差连接制约着感受野对于中心patch的依赖性</p><h4 id="skip-connection在vit中发挥的作用"><a class="markdownIt-Anchor" href="#skip-connection在vit中发挥的作用"></a> skip connection在ViT中发挥的作用</h4><p>根据先前的ViT不同层级做CKA进行相似性比较的图,我们知道了它的表征具有<strong>高度一致性</strong>,这是由我们这里要讨论的skip connection 发挥的作用<br />我们通过范数比:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∥</mi><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">∥</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\Vert z_i \Vert}{\Vert f(z_i)\Vert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.04398em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∥</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>来进行探讨,其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><msub><mi>z</mi><mi>i</mi></msub><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\Vert z_i \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∥</span></span></span></span>是来自于skip connection的第i个层的hidden representation,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\Vert f(z_i) \Vert</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∥</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">z_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>经过long branch后的值,这里的long branch指的是MLP或是self-attention</p><p>至此,我们知道了,<strong>若是范数比比值大则意味着skip connection起主要作用,若是范数比比值小则意味着long branch起主要作用</strong></p><p>以下是根据范数比所作的heatmap,需注意CLS token和别的spatial token是分开来讨论的:</p><p><img src="https://s2.loli.net/2023/11/03/6XgPrMaVNExsBq7.png" alt="ratio of norms" /></p><p>根据左图,显而易见,CLS token(token[0])和别的spatial token的受影响方式恰好相反<br /><strong>CLS token是网络前期(Block index小的部分)范数比大,即受skip connection影响大,而网络后期则是受long branch影响大,spatial token则相反</strong></p><p>根据右图,除了彰显了上述结论,也可以看出<strong>ViT较ResNet受skip connection影响更大</strong></p><p>作者又做了个干预性实验来证明skip connection对ViT表征结构高度一致性的影响,即移除中间某一个block的skip connection,图示如下:</p><p><img src="https://s2.loli.net/2023/11/05/4FnBmsAk3qGCdiZ.png" alt="ViT remove a block's skip connection" /></p><p>可见,若是移除了某一个block的skip connection,那在该block前后的层的表征相似性则非常低.由此<strong>佐证了skip connection对ViT层间表征相似性的作用</strong>!</p><h4 id="vit在higher-layers的空间位置信息是否仍然保留"><a class="markdownIt-Anchor" href="#vit在higher-layers的空间位置信息是否仍然保留"></a> ViT在higher layers的空间位置信息是否仍然保留</h4><p>知道了前面ViT与ResNet的一些差别后,还想知道它的空间信息在较高的层是否仍然保留,这对transformer是否可以干除了图像分类之外的事很重要,如目标检测</p><p>我们通过对最后一个block的token与最开始输入的patch token进行比较(计算不同位置的CKA值),然后做heatmap,可以看出它们的相似性,即空间位置信息是否被high layers保留.图示如下:</p><p><img src="https://s2.loli.net/2023/11/03/BK32qcVsveSCfu8.png" alt="spatial location of ViT &amp; ResNet" /></p><p>显然,ViT的空间位置信息被保留下来了,而且所选的单个token与最开始的对应的patch相似性最强,而边缘部分的token也是如此,但其与其他边缘位置相似性也很高.可以看出ViT对空间位置信息有保留!相较之下,ResNet则体现不出来,按作者的说法就是significantly weaker的位置信息</p><p>然后作者还对ResNet为啥会位置信息保留得如此薄弱进行了实验,认为是分类所采用的方法导致的,ViT采用的是一个单独的token-&gt;CLS token,对原位置信息本就不影响,而ResNet在训练时分类用的是全局平均池化(GAP),把信息都杂糅在一起了,哪里还有原来规整的位置信息</p><p>因此,就把ViT里面的CLS token去掉,通过GAP来做分类,结果说明了确实是GAP的原因,图示如下:</p><p><img src="https://s2.loli.net/2023/11/05/yIZtpWrUkqmFhPn.png" alt="ViT use GAP to classification" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>transformer理解</title>
    <link href="/2022/10/02/transformer%E7%90%86%E8%A7%A3/"/>
    <url>/2022/10/02/transformer%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是attention注意力机制"><a class="markdownIt-Anchor" href="#什么是attention注意力机制"></a> 什么是Attention(注意力机制)</h2><p>在提起Attention之前,因其涉及到encoder-decoder的设计思想,因此先从RNN-&gt;Seq2Seq做一个简单介绍,以理解Attention为何如此设计</p><h3 id="rnn的一个例子"><a class="markdownIt-Anchor" href="#rnn的一个例子"></a> RNN的一个例子</h3><p>我们知道,RNN(循环神经网络),是可以帮助我们处理序列数据,如文本,语音</p><p>例如,我们需要订票,那么&quot;我去A地&quot;和&quot;我离开A地&quot;,这两个A地分别指代的是不同的信息,一个是目的地,一个是始发地.若是用传统的神经网络难以处理此类问题,而RNN则可以很好的进行分类</p><p>因为RNN对于处理文本信息时,每一个输入的词是<strong>自带了时序信息</strong>在里面的,而当前时刻的词,通过hidden layer,可以与前一时刻的词相关联(类似hidden markov model)</p><p>对输入的词进行编码,构建RNN,因为&quot;去&quot;和&quot;离开&quot;二词的编码信息不同,则最后计算出来的&quot;A地&quot;的得分也不同,因此便可以进行区分</p><p>这是一个<strong>N对N</strong>的例子,即<strong>输入序列的长度==输出序列的长度</strong><br />RNN亦可以实现<strong>1对N</strong> 或是 <strong>N对1</strong></p><p>那如果我们是做文本翻译或是QA系统,那么就会有<strong>N对M</strong>的情况,则需要用到Seq2Seq</p><h3 id="seq2seq的一个例子"><a class="markdownIt-Anchor" href="#seq2seq的一个例子"></a> Seq2Seq的一个例子</h3><p>上面说了,Seq2Seq可以处理<strong>N对M</strong>的情形,其结构又称为<strong>encoder-decoder</strong>模型</p><p>其本质就是利用了<strong>两个RNN</strong>(encoder和decoder都是)来做处理,decoder利用encoder生成的语义编码来做解码,有两种(我所知)使用形式:</p><ul><li>可以将语义编码作为decoder的初始状态</li><li><strong>可以将语义编码作为decoder每一个token的输入</strong></li></ul><p>很明显,若是将语义编码作为decoder每一个token输入的话(较前一个方法好),那么存在一个问题:所有待预测的token它们使用的都是一个语义编码,即没有针对性,没有做到focus each one</p><p>因此就有attention注意力机制的出现</p><h3 id="attention"><a class="markdownIt-Anchor" href="#attention"></a> Attention</h3><p>由上述可知,我们在对不同的词做翻译的时候,如&quot;机器学习&quot;-&gt;“machine learning”,并不是说&quot;机器&quot;,&quot;学习&quot;这两个词语对machine的翻译具有相同的贡献,因此不同贡献可以通过如权重的概念来进行体现</p><p>那么这个&quot;贡献&quot;要怎么获得,即不同词语的权重影响要怎么实现?</p><p>先将这个问题放一边(假设我们有能力做到这一点),那么我们<strong>不同的贡献就可以对应不同语义模型</strong>,那么&quot;注意力&quot;的思想即得到了体现</p><p>回到&quot;贡献&quot;获得的问题,attention中的&quot;贡献&quot;:是输入的时候通过计算encoder和decoder对应token的余弦相似度来获得,然后每一个词有不同的值,通过softmax进行归一化,那么这就是一个语义模型.流程见下图:</p><p><img src="https://s2.loli.net/2023/11/03/Y4GCVzv6H98lARM.png" alt="attention-multi-semantic-model" /></p><h2 id="什么是transformer"><a class="markdownIt-Anchor" href="#什么是transformer"></a> 什么是transformer</h2><p>transformer是一个NLP任务的一个里程碑模型(刷新了多项任务的SOTA),而后被人运用到CV,如DETR(Detection Transformer),ViT(Vision Transformer,做分类的)</p><p>其中ViT在数据量足够大的情况下,可以达到甚至超过当时的SOTA(ViT基本是直接将transformer直接搬到CV上用的,没咋改,除了切图片以使其序列化)</p><p>因此可以看出transformer在CV领域也是大有作为.下面将先以NLP的transformer的释义进行模型解释.</p><p>此外,transformer在NLP机器翻译中的一大特点是它可以并行处理(<mark>存疑:我认为只局限于training阶段</mark>),即对单词的翻译不必由一个去预测下一个</p><p>原论文链接:<a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a></p><h3 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h3><p><img src="https://s2.loli.net/2023/11/03/c6zkRCEOosmIr3q.png" alt="transformerarch" /></p><p>由上图可见,我们的transformer整体也是分为encoder-decoder结构的</p><p>图中所示为encoder,即表明其内部由多个encoder block组成(原论文是6个),decoder也同理<br />(也是6个)</p><h3 id="输入"><a class="markdownIt-Anchor" href="#输入"></a> 输入</h3><p>在transformer中因其采用了注意力机制,因此导致了<strong>位置信息的缺失</strong>,而在机器翻译中,如一个not放置的位置若是不同,语句的意义也可能截然相反.因此我们需要对输入进行编码,以保持位置信息</p><p>我们要对输入进行<strong>词编码</strong>和<strong>位置编码</strong>,以获取输入语句的一个<strong>词的表示向量x</strong>,而后这些词的表示向量堆叠可以获得<strong>词的表示矩阵X</strong>,X∈R<sup>(nxd~model~)</sup></p><p>对于<strong>词编码</strong>,可以通过如Word2Vec等的方式获取<br />对于<strong>位置编码</strong>,transformer采用了正余弦函数来获取(位置编码:偶数位置用正弦,奇数位置用余弦)</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><mi>d</mi></mfrac></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PE_{(pos,2i)} = \sin(\frac{pos}{10000^{\frac{2i}{d}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94467em;vertical-align:-0.8371099999999999em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.16289em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9471099999999999em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8371099999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><mrow><mn>1000</mn><msup><mn>0</mn><mfrac><mrow><mn>2</mn><mi>i</mi></mrow><mi>d</mi></mfrac></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PE_{(pos,2i+1)} = \cos(\frac{pos}{10000^{\frac{2i}{d}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.03853em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">s</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.94467em;vertical-align:-0.8371099999999999em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.16289em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9471099999999999em;"><span style="top:-3.3485500000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8550857142857142em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8371099999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><div class="note note-info">            <p>pos:表示的是词在句子中的位置;<br />d:表示的是词编码后的维度,即词编码后的表示向量的列数;<br />2i:表示的是偶数维度;<br />2i+1:表示的是奇数维度</p>          </div><p>词编码和位置编码均完毕后,我们将其对应相加,即可以得到X的表示矩阵,过程图如下图示:</p><p><img src="https://s2.loli.net/2023/11/03/W9cUZEDxPKHF78f.png" alt="transformer-input-embedding" /></p><h3 id="self-attention"><a class="markdownIt-Anchor" href="#self-attention"></a> self-attention</h3><p>self-attention是attention中的一个特例<br />我们知道attention是找两个句子间的词间关系,而<strong>self-attention找的是一个句子间的词间关系</strong>(也可以理解为两个相同的句子)</p><p>从transformer_arch的图可以看出<strong>Multi-Head Attention</strong>在整个过程中起了极大作用,是核心模型,图中的Multi-Head Attention,其实里面就是由多个self-attention组成(论文里是8个)</p><p>因此我们需要关注self-attention的工作机制</p><p>self-attention的工作过程如下图所示:</p><p><img src="https://s2.loli.net/2023/11/03/hPi9aRNoU7M8evF.png" alt="self-attention-process" /></p><p>可以看出,它有三个输入Q,K,V,分别代表的是Query,Key,Value,然后需要经过MatMul(矩阵相乘),Scale(数值放缩),Mask(掩码,Output时需要),Softmax(归一化)这些个过程.</p><h4 id="获取qkv"><a class="markdownIt-Anchor" href="#获取qkv"></a> 获取Q,K,V</h4><p>首先,输入到encoder里的是我们上面获得的<strong>表示矩阵X</strong></p><p>X通过与对应权重(一开始是随机生成的,后面梯度下降更新的)的矩阵:W<sub>Q</sub>,W<sub>K</sub>,W<sub>V</sub>相乘,获取到对应的Q,K,V三个矩阵,其中它们的维度为:n*d<sub>Q</sub>,n*d<sub>K</sub>,n*d<sub>V</sub>,<strong>n代表着一个句子中词的数目</strong>,<strong>每一个行向量,代表的是某一个词的Q或K或V的维度</strong></p><p>计算的示例图如下图所示:</p><p><img src="https://s2.loli.net/2023/11/03/eh7TqgkBXxdRFrt.png" alt="QKV-compute" /></p><h4 id="self-attention计算公式"><a class="markdownIt-Anchor" href="#self-attention计算公式"></a> self-attention计算公式</h4><p>根据上面的方法获取了Q,K,V三者的矩阵后,可以对其进行self-attention-process图示的计算,公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup></mrow><msqrt><msub><mi>d</mi><mi>k</mi></msub></msqrt></mfrac><mo stretchy="false">)</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.448331em;vertical-align:-0.93em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.25278em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.81722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.18278000000000005em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span></span></p><p>Q与K<sup>T</sup>相乘,得到的是n*n的矩阵(d<sub>K</sub>==d<sub>Q</sub>),那么这个矩阵的<strong>每一行代表的是该词语与别的词语的关注强度(相关性)</strong>,然后为了防止内积过大(不利于梯度更新),则进行放缩,而后通过softmax以使得<strong>词语与词语间的关注强度更为明显</strong>,而后再乘于V,则得到最终的输出Z(n*d<sub>V</sub>)</p><p>从逻辑上思考,Q与K<sup>T</sup>乘积后得到的矩阵,存在着一个问题,即<strong>模型会过度关注自身的位置</strong>,则整体模型的效果会大打折扣,因此作者提出了<strong>Multi-Head Attention</strong>机制来应对这个问题</p><div class="note note-info">            <p>我认为Q,K,V三者的关系可以这么理解(知乎看的):<br />我们要在一个dict上查单词,那么单词肯定是K对应V,若是在dict中刚好有Q==K,则可以立刻找到对应的V;但是现在的情况是,我们的词变成了词向量,则要通过其Q和K相关洗漱,再与V做内积,来找到最有可能的V</p>          </div><h4 id="multi-head-attention"><a class="markdownIt-Anchor" href="#multi-head-attention"></a> Multi-Head Attention</h4><p>self-attention机制存在一个问题,<strong>模型在对当前位置信息进行编码时,会过度的将注意力集中于自身的位置</strong>,那么这样出来的模型就会忽略了其他位置的作用.因此作者提出了Multi-Head Attention机制.<br />在原论文中作者运用了8个头,即h=8.用其去对Q,K,V三者的维度进行划分,即</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>K</mi></msub><mo>=</mo><msub><mi>d</mi><mi>V</mi></msub><mo>=</mo><mfrac><msub><mi>d</mi><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi></mrow></msub><mi>h</mi></mfrac></mrow><annotation encoding="application/x-tex">d_K = d_V = \frac{d_{model}}{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">h</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由上述公式可以看出,我们的d<sub>K</sub>是经过划分的,若不划分,那么即是在h=1的情况下,d<sub>K</sub>= d<sub>V</sub> = d<sub>model</sub>,则经过Scaled Dot-Production Attention后的Z,其主对角线的值总是最大的(就是过于关注自身的问题),因此,通过多头机制,对Q,K,V的列的维度进行划分,以减弱这种影响!公式如下:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>M</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>H</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>Q</mi><mo separator="true">,</mo><mi>K</mi><mo separator="true">,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>h</mi></msub><mo stretchy="false">)</mo><msup><mi>W</mi><mi>O</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mspace width="1em"/><mi>h</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mi>i</mi></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>A</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>Q</mi><msubsup><mi>W</mi><mi>i</mi><mi>Q</mi></msubsup><mo separator="true">,</mo><mi>K</mi><msubsup><mi>W</mi><mi>i</mi><mi>K</mi></msubsup><mo separator="true">,</mo><mi>V</mi><msubsup><mi>W</mi><mi>i</mi><mi>V</mi></msubsup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}MultiHead(Q,K,V) &amp;= Concat(head_1,\cdots,head_h)W^O \\where \quad head_i &amp;= Attention(QW_i^Q,KW_i^K,VW_i^V)\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.17057em;vertical-align:-1.335285em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.835285em;"><span style="top:-3.943954em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span><span style="top:-2.3247150000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.335285em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.835285em;"><span style="top:-3.943954em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span></span></span></span></span></span></span><span style="top:-2.3247150000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">Q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9592389999999998em;"><span style="top:-2.4231360000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.180908em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.22222em;">V</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.335285em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>我们划分将Q,K,V划分成八个(8个h),对它们可以并行做计算,然后最后会得到八个Z<sub>i</sub>(i∈[0,7]),对它们进行concat(合并后的维度与X一致),然后与W<sup>O</sup>矩阵进行相乘即得出对应输出,输出矩阵维度与表示矩阵维度X一致</p><p>具体过程见下图:</p><p><img src="https://s2.loli.net/2023/11/03/CNwkVviS9M3f54b.png" alt="multi-head attention" /></p><p><img src="https://s2.loli.net/2023/11/03/Hg5qPCadnrZtk3x.png" alt="output of multi-head attention" /></p><p>至此,多头注意力机制介绍完毕</p><h3 id="encoder-block"><a class="markdownIt-Anchor" href="#encoder-block"></a> encoder block</h3><p>我们知道,一个encoder block里面,经过了Multi-Head Attention的洗礼后,要经过一个<strong>Add &amp; Norm</strong>的东东,而后再将输出经过Feed Forward NN,便完成了一个encoder的工作</p><h4 id="add-norm"><a class="markdownIt-Anchor" href="#add-norm"></a> Add &amp; Norm</h4><p>其实Add就是ResNet的<strong>shortcut connection</strong>,以防止gradient vanish或者说network degradation;</p><p>然后Norm其实指的就是Layer Normalization,一个归一化的东东(<mark>这是用于RNN里的,与BN不同,是针对每个样本进行的</mark>),用于加快收敛(总之就是加快训练速度)</p><h4 id="feed-forward"><a class="markdownIt-Anchor" href="#feed-forward"></a> Feed Forward</h4><p>是一个两层的全连接层,公式如下(<mark>这个没细看</mark>):</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>X</mi><msub><mi>W</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>W</mi><mn>2</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">max(0,XW_1 + b_1)W_2 + b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>最后输出的维度与X表示矩阵的一致</p><h3 id="encoder"><a class="markdownIt-Anchor" href="#encoder"></a> Encoder</h3><p>Encoder就是将多个encoder block线性连接了起来,前者的输出作为后者的输入,重复六次,则得出最终的输出<strong>编码信息矩阵</strong>,其维度与X的一致<br />过程见图所示:</p><p><img src="https://s2.loli.net/2023/11/03/eLsR5rCEuwxdX9a.png" alt="encoders-process" /></p><h3 id="decoder-block"><a class="markdownIt-Anchor" href="#decoder-block"></a> decoder block</h3><p>decoder block相较于encoder block,它有如下差别:</p><ul><li>首个Multi-Head Attention有Masked掩码操作;</li><li>第二个多头注意力机制,K,V源于encoder的输出的编码信息矩阵,Q则是源于上一个含掩码的输出;</li></ul><h4 id="关于masked-multi-head-attention"><a class="markdownIt-Anchor" href="#关于masked-multi-head-attention"></a> 关于Masked Multi-Head Attention</h4><p>所谓的Masked指的是:翻译的时候是顺推的,即翻译出了第i个单词后,才会进行第i+1个单词的翻译,那么在翻译第i个单词的时候,就需要将第i+1个单词及之后的信息进行遮掩</p><p>需注意:</p><ul><li>在training阶段时,我们采用的是teacher force的策略,就是在每一轮(i)的预测的时候,不采用上一轮(i-1)的输出,而是直接采用正确答案,因为是训练,所以有答案,所以可以做并行;</li><li>在predict阶段,没有答案,需要类似Seq2Seq的方法,即i轮预测需要i-1轮的输出,无法并行.循环往复,直至预测完毕</li></ul><p><strong>Mask操作,是在self-attention里的softmax前执行的</strong></p><h4 id="关于第二个multi-head-attention"><a class="markdownIt-Anchor" href="#关于第二个multi-head-attention"></a> 关于第二个Multi-Head Attention</h4><p>这个其实和普通的差不多,就是K,V来自于encoder的编码信息矩阵</p><h4 id="softmax预测"><a class="markdownIt-Anchor" href="#softmax预测"></a> softmax预测</h4><p>根据最后输出的结果,我们的矩阵是含有掩码的,那么就是说:第0行的输出,只包含词0的信息,第二行,则包括词0,词1的信息.<br />因此softmax是根据输出矩阵的每一行预测下一个单词.</p>]]></content>
    
    
    
    <tags>
      
      <tag>cv</tag>
      
      <tag>transformer</tag>
      
      <tag>attention</tag>
      
      <tag>nlp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NUMA</title>
    <link href="/2022/09/29/NUMA/"/>
    <url>/2022/09/29/NUMA/</url>
    
    <content type="html"><![CDATA[<h2 id="smp和amp对比"><a class="markdownIt-Anchor" href="#smp和amp对比"></a> SMP和AMP对比</h2><p>SMP(Symmetric MultiProcessing):对称多处理器架构<br />AMP(Asymmetric MultiProcessing):非对称处理其架构</p><p>二者区别:</p><ul><li>SMP里的多处理器是<strong>同构</strong>的,使用的是相同架构的CPU;AMP的多个处理器可能是<strong>异构</strong>的;</li><li>SMP多个处理器<strong>共享同一内存地址空间</strong>;AMP则每个处理器有各自<strong>独立的地址空间</strong>;</li><li>SMP多处理器可以通过<strong>共享内存</strong>来<strong>协同通信</strong>;AMP则需要提供一种处理器间通信机制</li></ul><p><strong>现今主流X86架构的多处理器的电脑都是SMP架构,然后AMP架构多是应用于嵌入式系统</strong></p><h2 id="numa和uma对比"><a class="markdownIt-Anchor" href="#numa和uma对比"></a> NUMA和UMA对比</h2><p>NUMA(Non-Uniform Memory Access):非统一内存访问<br />UMA(Uniform Memory Access):统一内存访问</p><p>NUMA和UMA所指代的<strong>统一</strong>是<strong>处理器访问内存的访问时间是否依赖于二者相对位置</strong></p><p><strong>NUMA和UMA是SMP架构的一种设计和实现的不同选择</strong></p><div class="note note-info">            <p>摘自Wiki:<br />NUMA architectures logically follow in scaling from symmetric multiprocessing (SMP) architectures.</p>          </div><p>先说一下UMA架构,就是CPU对内存的访问不依赖于其二者的相对位置关系,因为CPU访存是通过内存控制器(Memory Controller)来的,内存控制器被北桥芯片集成,因此是以<strong>多个CPU-北桥芯片-内存</strong>这样的方式链接的.</p><p>各个CPU是通过FSB(Front Side Bus)前端总线与北桥相连.</p><p><img src="https://s2.loli.net/2023/11/03/Slw8MEfXQqrstT1.png" alt="CPU-North Bridge-Memory" /></p><p>由上图可以看出来,总线模型保证了CPU对所有内存的访问都是一致的,不必考虑相对位置带来时间差异</p><p>这种架构适合用于如服务器(网站,数据库)一类的机子上,因为这类工作都是外部请求访问时,服务器创建线程, 随机访存,然后线程处理的时间很短.</p><p>但随着业务的扩展,会遇到需要很大运算量的应用,那么此刻若是有一个更接近于CPU的本地内存,可以提升速度,而且这样大运算量的应用,或者说线程,不止一个(则需要多个CPU,或者多个核心),那么UMA就不适应于这样的工作,而且FSB会成为其bottleneck(加核心没用),因此有了NUMA的出现</p><p>在NUMA架构中,其将<strong>多个核心作为一个节点(Node)(如一颗多核的CPU)</strong>,<strong>内存控制器芯片(MCH)集成在Node内</strong>,<strong>每一个Node独立连接一部分内存</strong>,此直连的内存称为**“本地内存”**,Node间通过QPI(Quick Path Interconnect)总线连接.因此可以访问&quot;远程内存&quot;.</p><p>由此可以见到内存访问存在本地和远程的区别!</p><p><img src="https://s2.loli.net/2023/11/03/exDGdRYnWiLMpF8.png" alt="NUMA" /></p><p>在Linux机器下,可以通过numactl指令进行查看</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memory Access</tag>
      
      <tag>CPU</tag>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux namespace</title>
    <link href="/2022/09/22/namespace/"/>
    <url>/2022/09/22/namespace/</url>
    
    <content type="html"><![CDATA[<h2 id="namespace常用类型"><a class="markdownIt-Anchor" href="#namespace常用类型"></a> Namespace常用类型</h2><h3 id="pid-namespace"><a class="markdownIt-Anchor" href="#pid-namespace"></a> pid namespace</h3><p>Linux内核维护着一个进程树，Linux中的进程关系通过此树来反映。而在pid namespace引入后，可以认为Linux内依旧是维护着一个进程树，但是其节点既可以是进程也可以是进程树，即此时进程树允许树的嵌套关系。而不同的进程树则使得其内部的进程组互相隔离，它们并不清楚彼此的存在。见下图</p><p><img src="https://s2.loli.net/2023/11/03/eYXaIt2dvu9WMG1.png" alt="nested-process-tree" /></p><p>在不考虑新的pid namespace的情况下，我们所有进程都属于同一个命名空间init_pid_ns，整个进程树都是由作为根的1号进程派生而来的。而当我们创建新的pid namespace时，则会创立出一个新的独立的进程空间。它是我们在创建子进程时可以设置的一个选项，使得新创建出来的子进程在新的pid namespace中，并且成为该命名空间的1号进程。</p><p>显然，利用pid namespace做隔离，子命名空间里的进程认为自己是一棵独立的进程树，完全不知到是父命名空间的存在。但是父命名空间（即init_pid_ns）却拥有着整个进程树的真正完整的视图，因为在引入pid namespace的概念后，pid的含义也变得复杂了，加入了层级level的概念，高层级的进程可以被低层级看见，即init_pid_ns这个进程空间的层级是最低的，为0，而新的进程命名空间随着嵌套情况逐次增加层级。就像图一所示，6号进程的子进程是8号进程（需要被level0的看见），但是由于其派生时设置标志位CLONE_NEWPID，使得8号进程与原先的进程树分离，自己作为新进程命名空间里的1号进程，此时该进程便拥有两个pid，一个是level1的1号进程，而另一个则为level0的8号进程。因此此时的pid结构也发生了相应的变化，见下图</p><p><img src="https://s2.loli.net/2023/11/03/eVCkPrU9KhXzRJ8.png" alt="structure-of-upid-pid" /></p><p>通过引入pid namespace，一个进程现在可以有多个与之关联的pid，每个pid通过level即层级来进行划分，然后利用变长数组numbers可以检索到对应的upid，而upid里的nr即为此命名空间里的pid的值。</p><p>上文中说过，要创建一个新的pid namespace，除了需要利用特殊的标志位注明外，对于pid namespace而言，只能通过clone()这一系统调用进行新的进程命名空间的创建。示例程序如<code>create-new-pidns</code>所示，其输出结果如<code>pid-of-new-pidns</code>所示：</p><p><img src="https://s2.loli.net/2023/11/03/l8ixOqpUKwy5mET.png" alt="create-new-pidns" /></p><p><img src="https://s2.loli.net/2023/11/03/geJ1md4GkvD5W6n.png" alt="pid-of-new-pidns" /></p><p>通过图3图4的示例程序及相应的输出结果，不难看出在clone()后的子进程在新的进程命名空间里，它认为自己是1号进程，打印出其父进程，则为0，即意味着该进程本身是这个进程树的init进程。</p><p>在此时，我们的进程只是隔离了进程空间，即在不同的进程空间下我们所打印出来的进程表都是不同的，但实质上如端口号这一类的资源还是会产生冲突。</p><h3 id="network-namespace"><a class="markdownIt-Anchor" href="#network-namespace"></a> network namespace</h3><p>网络命名空间的作用是隔离网络协议栈，即解决了上述所说的端口号资源冲突问题。除了对端口资源进行隔离外，也对网络设备、ARP表、路由表、iptables以及套接字等资源进行隔离，即构建出一套独立的网络协议栈供新的网络命名空间所用。</p><p>在这一部分就简单的对网络设备的隔离进行讲解，后续一部分会专门对network namespace进行详细的分析。</p><p>若是我们在clone()时增添标志位CLONE_NEWNET，则会使得我们的子进程处于一个新的网络命名空间中，与原命名空间相比，二者的网络设备完全不同，即原来主机上的以太网卡和环回设备在新的命名空间中消失了，取而代之的是一个与原来不同的新的环回设备。也即说明网络命名空间对网络设备一级也做了隔离。示例程序见<code>create-new-netns</code>，其输出结果见<code>difference-of-netns-device</code>：</p><p><img src="https://s2.loli.net/2023/11/03/DL8ZAJS93Xr5dg6.png" alt="create-new-netns" /></p><p><img src="https://s2.loli.net/2023/11/03/SD4eO79lZNojUry.png" alt="difference-of-netns-device" /></p><p>可以看出此主机上的的以太网卡eth0和其环回设备与新的network namespace的并不相同（环回设备状态不同）。因此在网络设备级别做了隔离。</p><p>此时，不同的网络命名空间就相互隔离开来，若是想让多个不同的网络命名空间进行通信，则可以通过虚拟网卡、虚拟网桥来实现，甚至还可以通过主机的以太网卡接受外界的数据包而后通过路由进程路由到对应的子网络命名空间（这里的子对应的是初始的网络命名空间）。见下图：</p><p><img src="https://s2.loli.net/2023/11/03/XKnbAzC7DkGY8US.png" alt="netns-usage" /></p><h3 id="uts-namespace"><a class="markdownIt-Anchor" href="#uts-namespace"></a> uts namespace</h3><p>uts namespace隔离的是utsname这个结构体的domainname和nodename，前者指待的是域名，后者在单服务器上等价于主机名。之所以取名为uts（UNIX Time-Sharing System），是与早期的UNIX分时系统有关，但在现在的namespace中，它只负责隔离主机名和域名。通过标识主机名，有利于我们在一些IP地址动态变化的情况下的操作，即只需要知道IP和这个主机名关联关系即可，无需关心IP的变化。因此uts namespace对于大型容器化的环境非常有帮助。以下是关于uts namespace更改主机名的实验，示例代码如下图<code>modify-new-utsns-hostname</code>所示，结果输出如图<code>hostname-of-diffrent-utsns</code>所示：</p><p><img src="https://s2.loli.net/2023/11/03/LzJpK5UcX6GHNvn.png" alt="modify-new-utsns-hostname" /></p><p><img src="https://s2.loli.net/2023/11/03/LRoMPpmQw9OhxGJ.png" alt="hostname-of-diffrent-utsns" /></p><p>通过上述结果，可以看出uts namespace对主机名的隔离作用，在新的uts namespace中对主机名的修改并不影响另一uts命名空间的主机名。</p><h3 id="mount-namespace"><a class="markdownIt-Anchor" href="#mount-namespace"></a> mount namespace</h3><p>mount namespace用于隔离挂载点，以使得不同的命名空间中的进程不能查看到彼此的文件。</p><p>创建单独的mount namespace效果类似于chroot(改变程序执行时的参考的根目录)，但chroot并不能提供完全的隔离。chroot变更文件的根挂载点示例如下图所示</p><p><img src="https://s2.loli.net/2023/11/03/caMFWXDB6CjKvTP.png" alt="chroot-modify-root-mount-point" /></p><p>在一个新的mount namespace中，子进程会看到和原来的父进程完全相同的挂载点，但此时我们可以在新的挂载命名空间中利用mount或umount来进行挂载或卸下对应的挂载点，这并不会对原来的父进程的挂载点有任何改变，只是对这个命名空间里的挂载点有变化。</p><h3 id="ipc-namespace"><a class="markdownIt-Anchor" href="#ipc-namespace"></a> ipc namespace</h3><p>ipc namespace可以对命名空间内的进程间通信资源进行隔离，这里隔离的是每个命名空间所属的消息队列、信号量以及共享内存，并没有对所有的通信方式都进行隔离。</p><p>以共享内存进行通信为例，我们的同一ipc namespace里的进程组可以通过共享内存来快速知道一些共享的公共参数的变化，而此时若不进行隔离，则会产生安全性问题。</p><h3 id="user-namespace"><a class="markdownIt-Anchor" href="#user-namespace"></a> user namespace</h3><p>user namespace主要是用来隔离用户权限的。它是namespace中最核心也最复杂的，Linux内核对其进行了最长时间的开发。其涉及到权限和安全问题。其包括uid/gid以及capabilities的两大部分的内容。user namespace通过对权限以及uid/gid的控制，使得即使在新的user namespace里是root的用户，当它试图去篡改原来的user namespace里的如主机名一类的别的namespace，它是否具备权限是看它原来在该user namespace是否有相应的修改权限，这也正是为什么每一个非user namespace的命名空间，在它们结构体定义里，都需要指向一个用户命名空间的意义所在。通过user namespace这个命名空间的利用，可以很好的避免了一些越权的行为发生。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>namespace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法分析与设计</title>
    <link href="/2022/08/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/08/31/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="调度问题"><a class="markdownIt-Anchor" href="#调度问题"></a> 调度问题</h2><p>问题:有n项任务,每项任务加工时间已知.从0时刻开始陆续安排到一台机器上加工.每个任务的完成时间是从0时刻到任务加工截止的时间.<br />求:总完成时间最短的方案</p><p>问题建模:</p><ul><li>输入:任务集:S={1,2,…,n} 第j项任务加工时间:tj∈Z+,j=1,2,…,n.</li></ul><p>  贪心算法:<br />设计策略:<strong>加工时间短的先做</strong><br />算法:根据加工时间从小到大排序,依次加工<br />算法正确性:对所有输入实例都得到最优解</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN</title>
    <link href="/2022/08/24/CNN/"/>
    <url>/2022/08/24/CNN/</url>
    
    <content type="html"><![CDATA[<h2 id="cnn模型的理解"><a class="markdownIt-Anchor" href="#cnn模型的理解"></a> CNN模型的理解</h2><p>  CNN全名为Convolutional Neural Network卷积神经网络.它有以下几个部分组成:</p><ul><li><strong>卷积层</strong></li><li><strong>激活函数</strong></li><li><strong>池化层</strong></li><li><strong>全连接</strong></li></ul><h3 id="卷积层"><a class="markdownIt-Anchor" href="#卷积层"></a> 卷积层</h3><p>卷积层是用来识别图像的特征,它是通过卷积核(kernel,filter,neuron)来寻找图像的特征.<br />图片输入进来的时候,机器会将其的分辨率及其通道转换为数组,如32*32*3,然后根据训练好的多个卷积核如5*5*3(Height,Width,Depth)对其进行特征寻找.需要注意的是kernel的depth需要与输入的depth一致.然后便输出一张激活图(此例卷积步长为1,激活图大小为28*28*n(kernel数量)).激活图(activation map/feature map)之后会作为下一层的输入</p><h3 id="激活函数"><a class="markdownIt-Anchor" href="#激活函数"></a> 激活函数</h3><p>激活函数(activation function)是用于<strong>完成数据的非线性变换</strong>,解决线性模型的表达、分类能力不足的问题.根据网上所说,若是在net中全是线性变换,则可以通过矩阵变换将所谓的多层网络转换成一层网络.因此需要通过激活函数使得网络的多层有意义,故需要对数据进行非线性变换<br />常用的激活函数有:</p><ul><li>ReLU</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo separator="true">,</mo><mspace width="1em"/></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">y=\begin{cases}0,\quad &amp;x\lt0 \\ x,\quad &amp;x\ge0 \end{cases} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>Sigmoid</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{ 1 }{ 1+e^{ -x } } </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li>tanh</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">y=\frac{e^x - e^{-x}}{e^x+ e^{-x}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.217661em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.448331em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>根据AlexNet的文章我们可以知道,ReLU相较于传统的激活函数可以提高训练速度,减缓梯度衰减的趋势,同时省去了归一化的开销.</p><h3 id="池化层"><a class="markdownIt-Anchor" href="#池化层"></a> 池化层</h3><p>池化层降低了输入的激活图的维度,对其进行了稀疏处理,减少了数据运算量,也缓解了卷积层对位置的过渡敏感性.池化层也是通过kernel来进行维度处理.<br />池化通常有两种方式:</p><ul><li>最大池化</li><li>平均池化<br />根据名字可以看出,一个是取kernel里最大的值作为输出的激活图的新位置的值,一个是取平均.一般的池化都是stride==kernel的尺寸</li></ul><h3 id="全连接层"><a class="markdownIt-Anchor" href="#全连接层"></a> 全连接层</h3><p>如图像分类,我们最后期望的结果是可能是识别类别的总数的概率,即输出一个N维向量,里面的值代表每一个识别类别的概率,然后进行输出.(此例采用的是softmax此激活函数)</p><h3 id="针对过拟合问题"><a class="markdownIt-Anchor" href="#针对过拟合问题"></a> 针对<strong>过拟合</strong>问题:</h3><p>在网络中,我们若是模型参数多,但是样本又少,那么训练出来的模型就会存在过拟合的问题,即在train的时候模型精确率还可以,但是test和inference就惨不忍睹,那就是因为模型中的参数权重等被量身定做了.<br />对于过拟合问题,可以采用Dropout以使得过拟合问题得到一定解决.<br />Dropout的主要原理就是根据Bernoulli原理生成概率向量[1,0,…,1],然后与输入序列相乘,之后进行forward propagation,backpropagation,这样就相当于集成算法中的Bagging一样,生成了多个子网络,那么多个子网络的平均表达结果就可以规避掉过度耦合的关系.<br />Dropout有两种版本:</p><ul><li>Vanilla Dropout</li><li>Inverted Dropout<br />两者的区别在于<strong>放缩</strong>的顺序,一个是在inference的时候进行放缩,一个是在train的时候放缩.后者相较于前者的优势在于不必在predict的时候频繁调整结果(要放缩).<br />Inverted版本需要在输入序列与概率序列相乘后进行放缩,设p为丢弃概率,则需对相乘后的序列乘上 $ \frac{1}{1-p} $ ,而这个放缩后的序列也会体现在反向传播的梯度中.<br />之所以要进行放缩,是因为此刻我丢弃了p%的数据,那么整体的规模缩小了(1-p)%,则需要放大 $ \frac{1}{1-p} $ 倍.</li></ul><h3 id="一些名词解释"><a class="markdownIt-Anchor" href="#一些名词解释"></a> 一些名词解释</h3><ul><li>SGD stochastic gradient descent 随机梯度下降:GD的话需要计算所有向量以计算梯度值,随机取的话可以减少计算量,但存在陷入局部最优的可能</li><li>top1 error rate:top1错误率,即分类问题中<strong>正确标签</strong>不是<strong>最佳概率</strong>的总数/样本总数</li><li>top5 error rate:top5错误率,即分类问题中<strong>正确标签</strong>不是<strong>前五个较大概率的可能结果</strong>的总数/样本总数</li></ul><p><mark>以下论文还没看完</mark></p><h2 id="pose-guided-feature-disentangling-for-occluded-person-re-identification-based-on-transformer"><a class="markdownIt-Anchor" href="#pose-guided-feature-disentangling-for-occluded-person-re-identification-based-on-transformer"></a> Pose-guided Feature Disentangling for Occluded Person Re-identification Based on Transformer</h2><p>  本文名词解释:</p><ul><li>ViT(Vision Transformer 用于抽取小片特征的视觉Transformer)</li><li>PFD(Pose-guided Feature Disentangling 姿态引导的特征分离)</li><li>Re-ID(Re-identification 再识别)</li><li>PFA(Pose-guided Feature Aggregation 姿态引导的特征聚合[含匹配和分配机制])</li><li>PVM(Pose-View Matching 姿态视图匹配 匹配身体的可见部分,把遮挡的部分分离)</li><li>Post-guided Push Loss 特征值,用于强调身体的可见部分</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer Vision</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringDataJPA学习</title>
    <link href="/2022/03/01/SpringDataJPA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/01/SpringDataJPA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>JPA</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM的理解</title>
    <link href="/2022/02/28/ORM%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/02/28/ORM%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>  ORM -&gt; Object Relational Mapping 对象关系映射。这个技术的出现主要是为了解决：面向对象模型和数据库的关系模型的不匹配问题。<br />  ORM是通过使用描述对象和数据库之间映射的元数据（XML或注解），来将对象持久化到数据库的操作，或是将数据库中某张表的某行数据映射成为我们的一个对象。<strong>本质是数据形式的转化</strong>。<br />  常见的ORM技术的实现有：hibernate、mybatis、JPA</p>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PO、VO、DTO等对象的理解</title>
    <link href="/2022/02/26/PO%E3%80%81VO%E3%80%81DTO%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2022/02/26/PO%E3%80%81VO%E3%80%81DTO%E7%AD%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="po"><a class="markdownIt-Anchor" href="#po"></a> PO</h2><p>  PO -&gt; Persistence Object 持久化对象，即一个持久化对象可以理解为数据库一张表中的记录，即它所包含的<strong>属性对应表中字段</strong></p><h2 id="vo"><a class="markdownIt-Anchor" href="#vo"></a> VO</h2><p>  VO -&gt; Value Object 值对象，一般指一些不会变化的值作为属性来存储；<br />  VO -&gt; View Object 表现层/UI层的对象，即它里面所对应的属性的数据是用于界面展示的数据</p><h2 id="dto"><a class="markdownIt-Anchor" href="#dto"></a> DTO</h2><p>  DTO -&gt; Data Transfer Object 数据传输对象，将客户端请求的数据通过网络传输给它，它相较于PO的区别在于：我们存到数据库的数据的字段可能有20个，但我们客户端需要的只是5个，我们只需要将这5个对象传输给客户端即可，即<strong>不会暴露我们的表结构</strong>，也可以<strong>提高传输效率</strong>。将与客户端进行数据交互的功能交由DTO处理。<br />  当然DTO对象到客户端后，若是用于界面展示，则它转化为VO。</p><h2 id="pojo"><a class="markdownIt-Anchor" href="#pojo"></a> POJO</h2><p>  POJO -&gt; Plain Ordinary Java Object 简单的Java对象，可以根据具体的使用场景转化为PO、VO、DTO</p><h2 id="dao"><a class="markdownIt-Anchor" href="#dao"></a> DAO</h2><p>  DAO -&gt; Data Access Object 数据访问对象。封装了对于数据库的CRUD操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础知识</title>
    <link href="/2022/02/24/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/02/24/Spring%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="resource和autowired"><a class="markdownIt-Anchor" href="#resource和autowired"></a> @Resource和@Autowired</h2><p>  二者都是提供从IOC容器中获取对应的实例进行注入。@Resource是由jdk提供，@Autowired是由Spring提供。其实二者都是通过byName或byType来进行匹配查询的。（@Autowired采用byType策略，@Resource采用byName策略）<br />  @Autowired在匹配到单一实现类时，则会将单一实现类进行注入；当匹配到多个实现类时，无法甄别，则需要用bean的名字进行甄别，就是变量名是否匹配某个实现类的小驼峰，若是符合则将该实现类进行注入，否则抛出错误。<br />  因此，若是在单一实现类时，直接使用@Autowired注入即可；若是有多个实现类时，可结合@Qualifier(“beanName”)注解来搭配使用，即@Qualifier注明某个实现类的小驼峰写法，则可以将对应的实例进行注入。<br />  @Resource则默认靠beanName来进行匹配，当然，若是变量名没匹配到实现类的小驼峰写法，若是只有单一实现类，则可以成功注入，否则会报错；@Resource也可以通过@Resource(name=“beanName”)来指定beanName实现注入，这个注解也可以通过指定type属性来实现注入。<br />  (参考博客)[<a href="https://blog.csdn.net/kevinxxw/article/details/105145397">https://blog.csdn.net/kevinxxw/article/details/105145397</a>]</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea使用遇到的小bug处理及指南</title>
    <link href="/2022/01/29/idea%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8Fbug%E5%A4%84%E7%90%86/"/>
    <url>/2022/01/29/idea%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8Fbug%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="模块创建缺少iml文件"><a class="markdownIt-Anchor" href="#模块创建缺少iml文件"></a> 模块创建缺少iml文件</h2><p>  iml全称为information of module，即模块信息文件。模块必有iml文件，若是没有，可以在terminal下移动到<strong>模块所在的路径</strong>下执行<code>mvn idea:module</code>指令以生成模块对应的iml文件。</p><h2 id="maven使用父模块pom进行依赖管理"><a class="markdownIt-Anchor" href="#maven使用父模块pom进行依赖管理"></a> maven使用父模块pom进行依赖管理</h2><p>  我们先利用Spring Initializer构建一个Spring Boot项目用作父模块来进行<strong>依赖管理</strong>，其中内部不写功能代码。<br />  子模块的pom通过使用以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  来将父模块pom中所含的依赖加入其中（但不包含dependencyManagement其内的内容），而父模块pom需要标明自己的打包方式为pom，且通过modules来管理子模块（如进行clear、package时可以通过父模块完成，而不是一个模块一个模块的去处理）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span> <span class="hljs-comment">&lt;!-- 标明打包方式，默认jar包 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>test1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 标明所含子模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>test2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  上面说的dependencyManagement就是<strong>按需继承</strong>的意思，父模块pom内通过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependcyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  如上方式来添加依赖，并进行<strong>版本管理</strong>，之后子模块只需要自行通过如下方式<strong>按需添加</strong>就行，<strong>不必写版本号</strong>，版本号统一由父模块的pom进行管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  其实上面所说的是parent和modules分别属于maven继承和聚合的特性，更具体的解释可以网上搜索查看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础内容</title>
    <link href="/2022/01/04/JavaScript%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2022/01/04/JavaScript%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="js用途"><a class="markdownIt-Anchor" href="#js用途"></a> JS用途</h2><p>  之前了解的JS，只知道可以实现一些交互和动效，从服务器拿下数据等的作用，但基本上只能局限在浏览器内，除非自己搭个JS引擎在电脑上跑，不然也只能靠浏览器来跑。<br />  但在了解了一些关于Node.js的基础知识后发现，它提供了一个JS的运行环境，使得它可以在本地上跑，不局限于浏览器，可以像Java、python一样，写起后端来。（本文写的只是一些之前忘记了的JS知识，不涉及Node.js部分！！）</p><h2 id="js语法"><a class="markdownIt-Anchor" href="#js语法"></a> JS语法</h2><p>  其实JS大多数语法跟Java很像，语法逻辑上基本上是一样的，以下只对不同的部分进行阐述。</p><h3 id="js数据类型"><a class="markdownIt-Anchor" href="#js数据类型"></a> JS数据类型</h3><p>  JS的数据类型分为：<strong>基本数据类型 + 引用类型</strong><br />  基本数据类型:</p><ul><li>Number<br />就是把整型和浮点数放一起了，还有NaN和Infinity这些特殊值</li><li>String<br />字符串</li><li>Boolean<br />就true|false</li><li>Null<br />指向空指针</li><li>Undefined<br />JS是弱类型语言，就一个var定义所有的变量（ES6可以用let和const定义局部变量），初值都是undefined</li><li>Symbol<br />ES6新加的，用了symbol方法的变量后是此类型，意味unique独一无二</li></ul><p>  引用类型：</p><ul><li>Object<br />就是对象，可以new Object(),一个个加，也可以{}直接写（就是JSON格式里的object）</li><li>Array<br />数组，可以new Array(),里面可以写array‘s length，也可以写数组的内容，当然也可以如[‘a’,123,1.23]这样写，毕竟JSON就是JS的标记法。它这个数组内容是支持任意类型。</li><li>Function<br />函数/方法。通过<code>function funcName(param1,...)&#123;...&#125;</code>这样定义，也可以是匿名函数，然后将函数指针交予一个变量，如<code>var f = function(param1,...)&#123;&#125;;</code>。</li></ul><h3 id="js事件处理"><a class="markdownIt-Anchor" href="#js事件处理"></a> JS事件处理</h3><p>  事件指的是<strong>用户和网页进行某一种交互</strong>，事件处理就是事件发生时该执行的操作。<br />  我们可以使用事件监听器用来处理事件，事件监听器主要的作用就是：<strong>监听事件，当事件发生做出操作。</strong><br />  JS有提供很多的事件，如鼠标、键盘、窗口事件等，我们可以通过JS来将具体的事件（HTML元素属性）和事件发生后的操作（就是自己写函数）进行绑定，从而形成事件监听器。</p><ul><li>在HTML元素里指明attribute<br />如<code>&lt;button id=&quot;myBtn&quot; onclick=&quot;btn()&quot;&gt;&lt;/button&gt;</code>，这里的事件的attribute即使onclick绑定了JS里写的方法btn();</li><li>在JS里绑定<br />如</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascipt">function btn()&#123;<br>alert(&quot;event of click&quot;);<br>&#125;<br>document.getElementById(&quot;myBtn&quot;).onclick=btn;<br></code></pre></td></tr></table></figure><h3 id="js一些别的知识"><a class="markdownIt-Anchor" href="#js一些别的知识"></a> JS一些别的知识</h3><p>  DOM(Document Object Model)文档对象模型，浏览器加载的时候会构建一个DOM，这个东西是树结构。<br />  DOM树的节点分为：</p><ul><li>元素/标签节点（即每一个标签均为一个标签节点/元素节点，是最主要的应用。type为1）；</li><li>属性节点（是<strong>元素节点的内容</strong>，可通过<code>getAttributeNode()</code>获得，也可以在JS自己<code>setAttributeNode()</code>进去，type为2）；</li><li>文本节点（就是不含于标签的文本，type为3）；</li><li>文档节点（是后面所述的document，根节点，type为9）；<br />  在DOM树中，<strong>Document是根节点</strong>（document对象），其余的节点是<strong>标签节点</strong>和<strong>文本节点（不含于标签内）</strong>，这些个节点被称为<strong>Element</strong>对象，可以通过document对象的getElementById()等方法获得（这里及下面谈论的都是元素/标签节点）。<br />  而Element对象可以帮助我们set/get标签的<strong>属性（attributes）<strong>或是</strong>内容(innerHTML/innerText)</strong>;</li></ul><div class="note note-info">            <p>  Element对象带有nodeName、nodeValue、nodeType等属性，可以让我们区分是哪一种类型的节点。<br />  如上述所说的文本节点，一般都是通过Element对象的<code>childNodes()</code>获得。</p>          </div><p>  BOM(Browser Object Model)浏览器对象模型，使得JS和浏览器具有交互能力。BOM核心对象是window，表示当前浏览器的窗口，我们所有的全局对象都是window的属性，document对象也是。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="redis安装"><a class="markdownIt-Anchor" href="#redis安装"></a> redis安装</h2><ol><li>wget URL</li><li>tar xzf packageName</li><li>在有makefile文件下make(可以通过make install prefix=/usr/local/redis自定义安装的位置)</li></ol><h2 id="redis文件含义"><a class="markdownIt-Anchor" href="#redis文件含义"></a> redis文件含义</h2><p>安装完redis后，它会产生一系列文件，对应的文件解释如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">./redis-benchmark //用于进行redis性能测试的工具<br>./redis-check-dump //用于修复出问题的dump.rdb文件<br>./redis-cli //redis的客户端<br>./redis-server //redis的服务端<br>./redis-check-aof //用于修复出问题的AOF文件<br>./redis-sentinel //用于集群管理<br></code></pre></td></tr></table></figure><h2 id="redis服务端"><a class="markdownIt-Anchor" href="#redis服务端"></a> redis服务端</h2><p>redis-server即为redis服务端，可以直接通过./redis-server启动，但这是前台启动。</p><p>后台启动则通过将守护进程daemonize设为yes，然后利用配置文件启动服务端即可。（./redis-server ./redis.conf）</p><p>更多的关于redis.conf的配置可以看：<a href="https://www.runoob.com/redis/redis-conf.html">redis.conf配置</a></p><p>redis服务端<strong>默认端口为6379</strong></p><h2 id="redis客户端"><a class="markdownIt-Anchor" href="#redis客户端"></a> redis客户端</h2><h3 id="redis数据结构"><a class="markdownIt-Anchor" href="#redis数据结构"></a> redis数据结构</h3><p>  redis是key:value存储系统，所谓的redis数据结构其实指的是value的数据结构</p><h4 id="strings-字符串"><a class="markdownIt-Anchor" href="#strings-字符串"></a> strings 字符串</h4><ul><li>set key value</li><li>get key</li></ul><h4 id="lists-字符串列表"><a class="markdownIt-Anchor" href="#lists-字符串列表"></a> lists 字符串列表</h4><p>  redis的list底层实现是链表</p><ul><li>lpush key value</li><li>rpush key value</li><li>lrange key start stop</li></ul><h4 id="sets-字符串集合"><a class="markdownIt-Anchor" href="#sets-字符串集合"></a> sets 字符串集合</h4><p>  redis的set是无序集合，可以做集合能做的事情，如交并差等</p><ul><li>sadd key value</li><li>smembers key</li><li>sismember key value</li><li>sunion key1 key2 […keyn]</li></ul><h4 id="sorted-sets-字符串有序集合"><a class="markdownIt-Anchor" href="#sorted-sets-字符串有序集合"></a> sorted sets 字符串有序集合</h4><p>  redis中的有序集合是通过加入score这一字段来实现有序性的，且因为其命令以z开头，因此redis的有序集合称为zsets</p><ul><li>zadd key score value</li><li>zrange key start stop [rev]</li></ul><h4 id="hashes-哈希"><a class="markdownIt-Anchor" href="#hashes-哈希"></a> hashes 哈希</h4><p>  类似于bean，可以用一个key存储一系列的键值对信息</p><ul><li>hset key filed value […field value]</li><li>hgetall key</li><li>hget key field</li></ul><h2 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> redis持久化</h2><p>   <strong>redis的持久化有两种方式，分别是RDB（redis database）和AOF(append only file)</strong></p><p>  二者可同时使用，若redis重启，则优先采用AOF来进行数据恢复</p><h3 id="持久化之rdb"><a class="markdownIt-Anchor" href="#持久化之rdb"></a> 持久化之RDB</h3><p>  RDB是指在不同时间点将redis存储的数据通过生成快照的方式存储在磁盘上；</p><p>  RDB如何持久化：单独fork一个子进程来完成持久化这项工作，主进程不进行任何IO操作；子进程会先将数据写入到一个临时文件中，待持久化结束，会将这个临时文件替换上次持久化好的文件。</p><p>  若是对数据完整性并不敏感，则可以用RDB来恢复数据。（因为RDB持久化是隔一段时间进行一次的，所以会丢失部分的数据）</p><h3 id="持久化之aof"><a class="markdownIt-Anchor" href="#持久化之aof"></a> 持久化之AOF</h3><p>  AOF（Append Only File 只许追加不许改写）是将redis执行过的所有写指令记录下来</p><p>  利用AOF来恢复数据的话，它会从前往后的将指令执行一遍</p><p>  如何配置：redis.conf里有个appendonly将其改为yes即打开了AOF功能，若有写操作，则会被追加到AOF文件的末尾</p><p>  <strong>插入内容（方便下文理解）：</strong></p><p>Linux的同步IO（sync、fsync、fdatasync）</p><p>  之所以会出现以上那些个同步IO是因为：传统的unix系统的磁盘IO是通过<strong>缓冲</strong>来进行的，是通过在内核中设有对应的<strong>缓冲区高速缓存</strong>或<strong>页高速缓存</strong>来实现的。</p><p>  <strong>当我们将数据写入文件时，内核将数据复制到缓冲区中，只有当缓冲区写满或内核需要重用缓冲区时，才会将里面的数据冲去输出队列，至队首才进行真正的IO，此即为延迟写</u></strong></p><p>  延迟写会带来：数据更新慢以至更新的数据丢失等的情况，因此有上面的同步方法的出现，用于：<strong><u>保证磁盘上的文件与缓冲区高速缓存中内容的一致性</u></strong></p><ul><li>sync</li></ul><p>将缓冲区中的内容冲到输出队列即返回，并不等待实际的写磁盘结束。</p><ul><li>fsync</li></ul><p>将指定的文件描述符中处于缓冲区的内容冲到输出队列，且等待实际的写磁盘结束后才返回。</p><p>既影响文件的数据部分，又影响文件的属性部分(metadata(size、access_time、modify_time…))</p><p>两次IO（数据部分与属性部分置于不同磁盘块）</p><ul><li>fdatasync</li></ul><p>与fsync类似，但只影响文件的数据部分，不影响属性部分</p><p>一次IO</p><p>  <strong>插入完毕</strong></p><p>  <strong>默认的AOF持久化策略为每秒fsync一次</strong>。此时可以让redis保持良好的性能，在丢失数据时，最多也是最近1秒的数据</p><p>  如果遇到一些特殊情况：追加时遇到磁盘满、inode满、断电等情况，<strong>可以通过redis-check-aof工具来进行日志修复</strong></p><p>  <strong><u>因为AOF采用追加方式，所以在不额外做处理的情况下，文件会越来越大，因此，redis提供了AOF文件重写(rewrite)机制</u></strong>，所谓的AOF重写机制指的是：<strong>AOF文件的大小超过阈值，redis会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集（如INCR 100次，不如INCRBY KEY 100）</strong></p><p>  <strong>如何重写呢：</strong></p><pre><code>1. redis fork 重写子进程，读取现有 AOF文件，将其指令进行分析压缩后写入到一个临时文件中；2. 主进程则将新接收的写指令放入缓冲区中，也写入到原AOF文件中（避免重写遇断电，无法恢复）；3. 重写子进程重写完毕后，会给父进程发信号，父进程收到后会将缓冲区的写指令追加到新AOF文件中；4. 追加完毕后，redis用新AOF文件替代旧的AOF文件。</code></pre><h3 id="rdb和aof对比"><a class="markdownIt-Anchor" href="#rdb和aof对比"></a> RDB和AOF对比</h3><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>数据敏感性</td><td>较差</td><td>较好</td></tr><tr><td>数据恢复速度</td><td>较快</td><td>较慢</td></tr><tr><td>文件体积</td><td>较小</td><td>较大</td></tr></tbody></table><h2 id="redis主从"><a class="markdownIt-Anchor" href="#redis主从"></a> redis主从</h2><p>  redis支持主从同步，也有一主多从、多级从结构</p><p>  redis的主从同步是异步进行的</p><ul><li><p><strong>如何进行主从同步的呢：</strong></p><ol><li><p>从服务器发出SYNC给主服务器，主服务器接收后，调用BGSAVE来创建子进程进行数据持久化工作（即将数据写入RDB文件中）；</p></li><li><p>在持久化工作完成前，主服务器的写指令缓存在内存中；</p></li><li><p>BGSAVE完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器会将其存到磁盘上，然后读到内存中。之后主服务器会将期间缓存的写指令以redis协议的格式发给从服务器。</p></li></ol></li><li><p><strong>如果有多个从服务器发送SYNC指令呢？</strong></p><p>那也只会执行一次BGSAVE，只需把持久化好的RDB文件发给多个下游就好</p></li><li><p><strong>主从同步分为：</strong></p><ul><li><p>全量同步（即上面所介绍的“如何进行主从同步的呢”，初次连接都是全量同步）</p><p><img src="https://s2.loli.net/2021/12/21/Ab7wOClYSaFx6ji.png" alt="Redis_主从同步_全量同步.jpg" /></p></li><li><p>增量同步（Redis 2.8 之后有）</p><p>增量同步指的是：主服务器每执行一个写指令时会向从服务器发送相同的写指令，从服务器接收并执行对应的写指令。</p><p><strong>增量同步如何进行？</strong></p><p>  <mark>未写待续…</mark></p></li></ul></li><li><p><strong>Redis主从同步策略</strong></p><p>主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。</p><p>当然，如果有需要，slave 在任何时候都可以发起全量同步。</p><p>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p></li></ul><h2 id="redis事务处理"><a class="markdownIt-Anchor" href="#redis事务处理"></a> redis事务处理</h2><p>  <strong>在redis中，与事务处理相关的指令有以下四个：</strong></p><ul><li><p>multi</p><p>  用于组装事务</p></li><li><p>exec</p><p>  用于执行事务</p></li><li><p>discard</p><p>  用于取消事务</p></li><li><p>watch</p><p>  <strong>用于监视key（可多个），当被监视的key在<u>multi</u>之前有改变时，无论事务的内容是否关于该key，都会返回nil；若是被监视的key没有改变，则正常执行</strong></p></li></ul><p>  <strong>在使用事务时可能遇到的错误：</strong></p><ul><li><p>执行前的错误</p><p>  即语法错误或内存错误导致，在编写事务的某一条指令后会报错(exec前)，之后调用exec指令时，会拒绝执行该事务（2.6.5版本之后）</p></li><li><p>执行后的错误</p><p>  即应用层的错误，如sadd myset “a”;lpush myset “b”;可看出，myset于这两条指令中被使用了不同数据结构的指令。redis在执行此条事务时不会理睬这些错误，而是继续向下执行其他指令（不会影响其他指令的执行，也不会影响该条指令入列），事务最终可以被执行</p></li></ul><h2 id="redis配置"><a class="markdownIt-Anchor" href="#redis配置"></a> redis配置</h2><p>  redis的配置文件为：redis.conf(Linux下)，其支持在主配置文件中引入外部的配置文件，如：</p><p><code>include /home/ayy/...</code></p><p>  redis配置文件被划分为如下几部分：</p><ol><li><p>general</p></li><li><p>snapshotting</p></li><li><p>replication</p></li><li><p>security</p></li><li><p>limits</p></li><li><p>append only mode</p></li><li><p>lua scripting</p></li><li><p>slow log</p></li><li><p>event notification</p></li><li><p>gopher server</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用高级命令</title>
    <link href="/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h2><p>  功能：用于<strong>查找文件</strong><br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find 查找路径 查找条件<br></code></pre></td></tr></table></figure><p>  查找条件：</p><ul><li>-name<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;a.txt&quot;<br>查找当前目录下（含子目录）名称为“a.txt”的文件<br></code></pre></td></tr></table></figure><ul><li>-type<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f <br>查找当前目录下（含子目录）的普通文件<br></code></pre></td></tr></table></figure><p>  linux下文件类型主要有以下几种：</p><table><thead><tr><th style="text-align:center">字母</th><th style="text-align:center">文件类型</th></tr></thead><tbody><tr><td style="text-align:center">f(file)</td><td style="text-align:center">普通文件</td></tr><tr><td style="text-align:center">d(directory)</td><td style="text-align:center">目录</td></tr><tr><td style="text-align:center">b(block)</td><td style="text-align:center">块设备</td></tr><tr><td style="text-align:center">s(socket)</td><td style="text-align:center">套接字</td></tr><tr><td style="text-align:center">c(char)</td><td style="text-align:center">字符设备</td></tr><tr><td style="text-align:center">l(link含硬链接和软链接)</td><td style="text-align:center">链接</td></tr><tr><td style="text-align:center">p(pipe)</td><td style="text-align:center">管道</td></tr></tbody></table><ul><li>-user<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -user &quot;ayyHA&quot;<br>查找当前目录下（含子目录）user为ayyHA的文件<br></code></pre></td></tr></table></figure><ul><li>-group<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -group &quot;test&quot;<br>查找当前目录下（含子目录）group为test的文件<br></code></pre></td></tr></table></figure><ul><li>-not<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -not -type f<br>查找当前目录下（含子目录）文件类型为非普通文件的文件<br></code></pre></td></tr></table></figure><p>  -not也可以用!来替换，二者等价</p><ul><li>-a -o<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -a -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -o -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件或以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>  注：默认情况是-a，即查找条件是合取的关系。</p><ul><li>-maxdepth -mindepth<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -maxdepth 2 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最大深度为2且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mindepth 1 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最小深度为1且以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>  注：当前目录下即为深度为1，往下的每一个子目录深度便加1。</p><ul><li>-size<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -size 10k<br>查找当前目录下（含子目录）大小为10K的文件<br></code></pre></td></tr></table></figure><p>  注：+10K表示比10K大的文件；-10K表示比10K小的文件。</p><ul><li>-perm<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -perm 644<br>查找当前目录下（含子目录）文件权限为644的文件（此为精确匹配）<br></code></pre></td></tr></table></figure><p>  注：权限值若是写成-404则表明只要user权限为r且other权限为r即可，只要满足了这两个条件的文件就都会被筛选出来；权限值若是写成了/404则表明只要user权限为r或other权限为r即可，只要满足了两个条件的其中一个就会被筛选出来。</p><ul><li>-atime -ctime -mtime<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mtime -7 <br>查找当前目录下（含子目录）的文件在7天内有进行过修改的<br></code></pre></td></tr></table></figure><p>  注：其余两个类似，不赘述。（对数字前添加‘+’/‘-’表示‘大于’/‘小于’）</p><ul><li>-exec 命令 {} ;<br />  此查找条件意思为：对<strong>查找到的文件执行(execute)命令</strong>，其中**{}代表的是查找到的文件**。<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;<span class="hljs-emphasis">*md&quot; -exec cat &#123;&#125; \;</span><br><span class="hljs-emphasis">对查找到的以md结尾的文件执行cat命令。</span><br></code></pre></td></tr></table></figure><p>  注：有个<code>-ok 命令 &#123;&#125; \;</code>与该命令相似，但它会询问查找到的文件是否执行该命令(y/n)。</p><h2 id="wc"><a class="markdownIt-Anchor" href="#wc"></a> wc</h2><p>  功能：用于统计行数(line)、单词数(word)、字节数(char,内存占1byte)<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc 统计条件 文件名<br></code></pre></td></tr></table></figure><p>  统计条件：</p><ul><li>-l<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -l ./text.txt<br>用于统计text.txt文件的行数<br></code></pre></td></tr></table></figure><ul><li>-w<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -w ./text.txt<br>用于统计text.txt文件的单词数<br></code></pre></td></tr></table></figure><ul><li>-c<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -c ./text.txt<br>用于统计text.txt文件的字节数<br></code></pre></td></tr></table></figure><ul><li>-m<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -m ./text.txt<br>用于统计text.txt文件的字符数（一个汉字在utf8编码里是3个字节，利用-c不方便统计字符数）<br></code></pre></td></tr></table></figure><ul><li>-L<br />  e.g.:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -L ./text.txt<br>用于统计text.txt文件最长行的长度<br></code></pre></td></tr></table></figure><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h2><p>  功能：依据条件进行过滤，找到满足条件的行<br />  基本格式；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">grep [option] pattern file<br></code></pre></td></tr></table></figure><p>  option：<br />以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/22/1HB2myCgfSLURvZ.png" alt="grep option test file.png" /></p><ul><li>-E<br />  作用：pattern匹配转为扩展正则表达式，等价于egrep命令。</li><li>-i<br />  作用：忽略大小写，ignore。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/MNxbnQC4cFoI3yt.png" alt="grep -i.png" /></p><ul><li>-v<br />  作用：反向查询，类似取反，invert。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/xgBqR1JAsXLakEF.png" alt="grep -v.png" /></p><ul><li>-n<br />  作用：输出行号，number。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/4fEnBglMyROKLIa.png" alt="grep -n.png" /></p><ul><li>-w<br />  作用：匹配整个单词，字符串内出现的不匹配，word。<br />  在原来的文本上补加了一些内容用以演示，演示文本如下图所示：</li></ul><p><img src="https://s2.loli.net/2021/12/22/z8CVugykKlm3jDW.png" alt="grep option test file2.png" /></p><p>  演示如下：</p><p><img src="https://s2.loli.net/2021/12/22/MVeg9XinhKbmp8H.png" alt="grep -w.png" /></p><ul><li>-c<br />  作用：统计匹配到的行数，count。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/BivsRuxHTD4Fc75.png" alt="grep -c.png" /></p><ul><li>-o<br />  作用：只显示匹配到的字符串，不显示其所在行的内容。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/2G1ietD6KTlsEfw.png" alt="grep -o.png" /></p><ul><li>-Ax<br />  作用：输出匹配到内容所在行的后x行的内容，after x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/aP2fjGeyrdRHVt7.png" alt="grep -Ax.png" /></p><ul><li>-Bx<br />  作用：输出匹配到内容所在行的前x行的内容，before x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/3SR7Fq9IuaXrt81.png" alt="grep -Bx.png" /></p><ul><li>-Cx<br />  作用：输出匹配到内容所在行的前后x行的内容，context x。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/VQLbpYTBtfgrXw7.png" alt="grep -Cx.png" /></p><ul><li>-e<br />  作用：实现多个匹配，相当于or。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/2QNHo4A6UgLjZdP.png" alt="grep -e.png" /></p><ul><li>-q<br />  作用：安静模式，只关心结果，即有没有匹配到。匹配到为0，匹配不到为1，文件有误为2，quiet。<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/22/bF7aTqXPDpZiU45.png" alt="grep -q.png" /></p><div class="note note-info">            <p>  注：如果在使用grep匹配关键字时，匹配到的关键字没高亮，可以通过在命令<code>grep --color=auto &quot;word&quot; file</code>中添加<code>--color=auto</code>来开启；也可以通过alias命令重申一下grep命令<code>alias &quot;grep=grep --color=auto&quot;</code>来达到效果。</p>          </div><h3 id="pattern均为扩展正则表达式"><a class="markdownIt-Anchor" href="#pattern均为扩展正则表达式"></a> pattern（均为扩展正则表达式）:</h3><p>以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/23/xZlKf47MLJDVo2j.png" alt="re test file.png" /></p><h4 id="单个字符匹配相关"><a class="markdownIt-Anchor" href="#单个字符匹配相关"></a> 单个字符匹配相关</h4><ul><li>.<br />  作用：匹配<strong>任意</strong>的单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/NMRckIXrfUnspwl.jpg" alt="re ..jpg" /></p><ul><li>[  ]<br />  作用：匹配<strong>指定范围内</strong>的任意单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/dMiYpb48Q9DtzCX.jpg" alt="re   .jpg" /></p><ul><li>[^  ]<br />  作用：匹配<strong>指定范围外</strong>的任意单个字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/fKPtF1Y7C4VH6AJ.jpg" alt="re ^ .jpg" /></p><ul><li>[0-9] / [[:digit:]]<br />  作用：[0-9]和[[:digit:]]功能一样，匹配[0,9]间任意的单个数字<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/q24p6arlHcwPbVZ.jpg" alt="re 0-9.jpg" /></p><ul><li>[a-zA-z] / [[:alpha:]]<br />  作用：[a-zA-z]和[[:alpha:]]功能一样，匹配单个任意的大小写字母<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/8R3hXU5GMNJqVel.jpg" alt="re a-z.jpg" /></p><ul><li>[^0-9] / [^[:digit:]]<br />  作用：[^0-9]和[^[:digit:]]功能一样，匹配单个非数字字符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/oi6j8pNmBXruqVz.png" alt="re  ^0-9.png" /></p><h4 id="次数匹配相关"><a class="markdownIt-Anchor" href="#次数匹配相关"></a> 次数匹配相关</h4><ul><li>?<br />  作用：<strong>匹配其前面的字符0次或1次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/XoTC6RLYDwqcHh1.jpg" alt="re ?.jpg" /></p><ul><li><ul><li></li></ul></li></ul><p>  作用：<strong>匹配其前面的字符至少1次</strong><br />  演示如下：</p><p><img src="https://s2.loli.net/2021/12/23/XWNkxrpv6AGcqE8.png" alt="re +.png" /></p><ul><li>*<br />  作用：<strong>匹配其前面的字符至少0次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/wVLJ8mpWM1v7RFP.jpg" alt="re .jpg" /></p><ul><li>{n}<br />  作用：<strong>匹配其前面的字符n次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/oxlNqW4nOITgGcw.png" alt="re {n}.png" /></p><ul><li>{n,}<br />  作用：<strong>匹配其前面的字符至少n次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/Tz6QYKoABqPRLkh.png" alt="re {n,}.png" /></p><ul><li>{,m}<br />在原来的文本上新增一行内容以体现演示效果，文本内容如下：</li></ul><p><img src="https://s2.loli.net/2021/12/23/gMywnzfhaqULSPD.png" alt="re test file2.png" /></p><p>  作用：<strong>匹配其前面的字符至多m次，最少可以是0次</strong><br />  演示如下：</p><p><img src="https://s2.loli.net/2021/12/24/mcgXYvMiGquxR2o.png" alt="re {,m}.png" /></p><ul><li>{n,m}<br />  作用：<strong>匹配其前面的字符至少n次，至多m次</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/4bJSjCD9xcA3BsN.png" alt="re {n,m}.png" /></p><h4 id="位置匹配相关"><a class="markdownIt-Anchor" href="#位置匹配相关"></a> 位置匹配相关</h4><ul><li>^<br />  作用：其后跟着的内容需位于<strong>行首</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/YnKjS8vP1mMouyU.png" alt="re ^.png" /></p><ul><li>$<br />  作用：其前跟着的内容需位于<strong>行尾</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/pcQOKedIY2b8JgR.png" alt="re $.png" /></p><ul><li>\&lt; / \b<br />  作用：其后跟着的内容需位于<strong>词首</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/GJUe9Cb4Qz5EOvj.png" alt="re .png" /></p><ul><li>\&gt; / \b<br />  作用：其前跟着的内容需位于<strong>词尾</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/QgniJvzjoVLt6Ou.png" alt="re .png" /></p><p>  若是将<code>\&lt;</code>和<code>\&gt;</code>同时作用于一单词上，表明它既是词首又是词尾，那其实它就是个独立的单词，示例如下；</p><p><img src="https://s2.loli.net/2021/12/24/QTtz8hOxbeNp6Pj.png" alt="re   .png" /></p><ul><li>\B<br />  作用：匹配非词首或非词尾的内容（具体看它放在单词前还是后）<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/uPWpweh5NlyCQ7D.png" alt="re .png" /></p><h4 id="分组和后向引用"><a class="markdownIt-Anchor" href="#分组和后向引用"></a> 分组和后向引用</h4><p>  修改了演示文件以便于展示效果，新的演示文件如下：</p><p><img src="https://s2.loli.net/2021/12/24/o35kyPu19tXMnxf.png" alt="re test file3.png" /></p><ul><li>()<br />  作用：分组内部的内容为一个<strong>整体</strong>，<strong>可嵌套</strong>使用<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/gZmKzu1A87Jw2NG.png" alt="re ().png" /></p><ul><li>\x<br />  作用：后向引用分组，<strong>匹配分组x相同的内容</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/g7usQXN2tjC1c4W.png" alt="re .png" /></p><h4 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h4><ul><li>\<br />  作用：转义符<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/4viCzfdm3DpGEwQ.png" alt="re png" /></p><div class="note note-info">            <p>  注:对需要转义的字符进行转义时，加上<code>\</code>即可，但若是对<code>\</code>本身进行转义，则需要使用<code>''</code>单引号而非双引号。</p>          </div><ul><li>|<br />  作用：表示<strong>或</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/JEubgS23M96yzod.png" alt="re |.png" /></p><ul><li>.*<br />  作用：类似<strong>通配符</strong>，可<strong>匹配任意字符的任意内容</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/w4pKLBOCUhEs2zk.png" alt="re ..png" /></p><ul><li>^$<br />  作用：<strong>表示空行</strong><br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/dgZPsM1vzIaRp28.png" alt="re ^$.png" /></p><h2 id="du"><a class="markdownIt-Anchor" href="#du"></a> du</h2><p>  功能：查询磁盘目录下文件的大小 disk usage<br />  常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -h<br>查询当前目录下（递归查询）文件的大小，最后输出目录总大小，会以K，M，G的格式写明文件大小。<br>human readable<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -s<br>查询当前目录下文件的总计大小，只输出总文件大小。 summarize<br></code></pre></td></tr></table></figure><h2 id="df"><a class="markdownIt-Anchor" href="#df"></a> df</h2><p>  功能：查询文件系统的使用情况 disk file system<br />  常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">df -h<br>查询当前盘符的使用情况，以人类可读的方式输出。human readable<br></code></pre></td></tr></table></figure><h2 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h2><p>  功能：排序（一行一行排，默认按字典序排）<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sort [option] file<br>默认升序<br></code></pre></td></tr></table></figure><p>  option：<br />以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/24/O1rGviUWcuIhCzT.png" alt="sort test file.png" /></p><ul><li>-r<br />  作用：逆序输出 reverse<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/bWrDHNRcu4SG8zv.png" alt="sort -r.png" /></p><ul><li>-t组合-k<br />  作用：-t后跟着分隔符，用以将内容划分成列；-k后跟着数字，用以指明第几列<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/nWiAF65eNqTg7yb.png" alt="sort -t -k.png" /></p><p>  我们用空格作为分隔符，将其划分成三列，且取第二列作为排序的依据，当结果看起来好像排错了，其实没错，因为sort默认按照<strong>字典序</strong>排序，10&lt;4是因为利用ASCII码比较完首个字符后，就认为4&gt;10。可以通过后面的-n选项来用<strong>数值</strong>比较。<br />-t(field separator) -k(key)</p><ul><li>-n<br />  作用：按数值大小排序，默认是字典序，会出现10&lt;2的情况 numeric sort<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/WPR2SwnajvdDu6y.png" alt="sort -n.png" /></p><p>  我们可以看到，此可第二列是按照正常的升序进行的排序。</p><ul><li>-u<br />  作用：去除重复的行（不要求重复行相邻） unique<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/lCtq8doRTQE9k1r.png" alt="sort -u.png" /></p><h2 id="uniq"><a class="markdownIt-Anchor" href="#uniq"></a> uniq</h2><p>  功能：去重（去掉<strong>连续</strong>的<strong>重复行</strong>），重复行需要相邻。<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">uniq [option]<br></code></pre></td></tr></table></figure><p>  此处的演示文本依旧使用sort的文本。</p><p>  option:</p><ul><li>不带option时<br />  作用：去除重复的行（需要借助sort来将重复文本弄成相邻的行）<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/7EVMi3va9GbDkpc.png" alt="uniq default.png" /></p><ul><li>-c<br />  作用：统计行数，置于行首 count<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/El2Jq9pPCvB8V76.png" alt="uniq -c.png" /></p><ul><li>-u<br />  作用：不打印重复的行 unique(only print unique lines)<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/Mk6S9rJUYcqFl53.png" alt="uniq -u.png" /></p><h2 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> cut</h2><p>  功能：打印列<br />  基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">cut option file<br></code></pre></td></tr></table></figure><p>  此处的演示文本依旧使用sort的文本。</p><p>  option:</p><ul><li>-d -f<br />  作用：-d(delimiter)后跟着分隔符，-f后跟着数字用以选择是哪个域(field)<br />  演示如下：</li></ul><p><img src="https://s2.loli.net/2021/12/24/DjTCRkboBSQJty1.png" alt="cut -d -f.png" /></p><h2 id="perl"><a class="markdownIt-Anchor" href="#perl"></a> perl</h2><h2 id="lsmod"><a class="markdownIt-Anchor" href="#lsmod"></a> lsmod</h2><p>查看已加载在内核中的LKM（loadable kernel module）</p><h2 id="lshw"><a class="markdownIt-Anchor" href="#lshw"></a> lshw</h2><h2 id="lspci"><a class="markdownIt-Anchor" href="#lspci"></a> lspci</h2>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim的基础使用</title>
    <link href="/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vim的几种模式"><a class="markdownIt-Anchor" href="#vim的几种模式"></a> Vim的几种模式</h2><ul><li><strong>normal模式</strong><br />  默认模式，此模式下你可以输入命令，如利用<code>/ + 单词</code>来进行搜索，又或者利用yp进行cv操作；</li><li><strong>编辑模式</strong><br />  通过输入i(insert)/a(append)/o(open a line)进入编辑模式，可以进行文本的编辑操作；</li><li><strong>命令模式</strong><br />  就是在normal模式下输命令，比如分屏：<code>:vs</code>竖分屏； <code>:sp</code>横分屏</li><li><strong>可视化模式</strong><br />  所谓的可视化模式用于选择文本，在normal模式下使用<code>v</code>可以进入visual模式，可选择的最小单位是每一个字符；使用<code>V</code>可以进入visual line模式，顾名思义，可选择的最小单位是每一行；使用<code>ctrl + v</code>可以进入visual block模式，可以以矩阵的方式进行文本选择。</li></ul><h2 id="编辑模式下的小技巧"><a class="markdownIt-Anchor" href="#编辑模式下的小技巧"></a> 编辑模式下的小技巧</h2><ul><li><code>ctrl + h</code> 删除上一个编辑的字符</li><li><code>ctrl + w</code> 删除上一个编辑的单词</li><li><code>ctrl + u</code> 删除当前行<br />上述的快捷键也可以用于终端；</li><li><code>ctrl + [</code> insert模式切换到normal模式</li><li><code>gi</code>快速跳转到最后一次编辑的地方并进入插入模式</li></ul><h2 id="vim移动"><a class="markdownIt-Anchor" href="#vim移动"></a> Vim移动</h2><ul><li><code>hjkl</code>即是vim normal模式下的左下上右键；</li><li>w/W移到下一个单词开头</li><li>e/E移到下一个单词结尾</li><li>b/B移到上一个单词开头 back word</li></ul><div class="note note-info">            <p>  上面移动的小写和大写的区别在于：<br />小写指的是以非空白符分割的单词；<br />大写指的是以空白符分割的单词；</p>          </div><ul><li><code>f + &lt;char&gt;</code>可以移动到<strong>行内</strong>第一个符合的字符上，若不符合，可以通过<code>;</code>或<code>,</code>进行搜索下一个或上一个；大写的F则表示反向搜索，而非正向搜索；</li></ul><div class="note note-info">            <p>  上面的f可以理解为find,使用<code>f + &lt;char&gt;</code>可以到达寻找的字符；<br />  而若是用<code>t + &lt;char&gt;</code>则可以寻找到要找的字符前一位，此处的t可以理解为to；</p>          </div><ul><li><code>0</code>可以移动到当前行的行首；</li><li><code>$</code>可以移动到当前行的行尾；</li><li><code>^</code>可以移动到当前行的首个非空字符；</li><li><code>g_</code>可以移动到当前行的最后一个非空字符；</li><li><code>gg/G</code>移动到文件开头或结尾；</li><li><code>H/M/L</code>可以跳转到屏幕的开头(Head)/中间(Middle)/结尾(Lower)；</li><li><code>ctrl + f/ctrl + u</code>向下分页(forward)/向上分页(upward)</li><li><code>zz</code>把屏幕设置为中间</li></ul><h2 id="vim增删改查"><a class="markdownIt-Anchor" href="#vim增删改查"></a> Vim增删改查</h2><h3 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h3><ul><li>i(insert): 在字符前插入</li><li>a(append): 在字符后插入</li><li>o(open a new line): 下启一行插入</li><li>I: 在行首插入</li><li>A: 在行末插入</li><li>O: 上启一行插入</li></ul><h3 id="删"><a class="markdownIt-Anchor" href="#删"></a> 删</h3><ul><li>x: 删除单个字符</li><li>d(delete): 此为删除命令，可结合文本对象具体使用，如diw(delete inner word)</li></ul><div class="note note-info">            <p>  d和x可以搭配数字使用，以达到同一命令重复执行多次的效果。</p>          </div><h3 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h3><ul><li>r(replace): <code>r &lt;char&gt;</code>用以替换当前光标所在处的字符；</li><li>c(change):  可以搭配文本对象具体使用，如<code>&quot;just try try&quot;</code>中使用<code>ci&quot;</code>则会删除掉引号内的内容(引号不会去掉，若是<code>ca&quot;</code>则会)，并且进入到编辑模式</li><li>s(substitute): 删除并进入编辑模式</li></ul><div class="note note-info">            <p>  <code>s</code>可以搭配数字使用；<br />  上述的三个命令若是大写（即R/C/S）会有不同的作用：</p><ul><li>R进入replace模式，从当前字符起可以一直替换，直到退出该模式；</li><li>C/S二者差不多，删掉整行进入编辑模式；</li></ul>          </div><h3 id="查"><a class="markdownIt-Anchor" href="#查"></a> 查</h3><ul><li><code>/ + &lt;word&gt;</code>: 前向搜索</li><li><code>? + &lt;word&gt;</code>: 反向搜索</li><li><code>n/N</code>: 跳到下一匹配项/跳到上一匹配项</li><li><code>*/#</code>: 当前光标处单词的下一项/上一项匹配</li></ul><h2 id="vim搜索替换"><a class="markdownIt-Anchor" href="#vim搜索替换"></a> Vim搜索替换</h2><p>  格式: <code>:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]</code><br />  range表示范围(不写则默认当前行)：</p><ul><li><code>%</code>表示全选；</li><li><code>m,n</code>表示第m-第n行；</li><li><code>n,$</code>表示第n行到末尾；</li></ul><p>  s表示替换<br />  pattern表示替换前的单词，可以用正则<br />  string表示替换后的单词<br />  flags表示替换方式(不写则默认替换第一个(当前行/范围内的行)出现的pattern)：</p><ul><li>g(global): 全局执行（即所有出现的，不局限在第一个）</li><li>n(number): 报告匹配的次数而不替换</li></ul><h2 id="个人小结"><a class="markdownIt-Anchor" href="#个人小结"></a> 个人小结</h2><p>  对于可以结合文本对象进行操作的命令：如y(yank)/d(delete)/c(change)等，可以结合以下的范围词来使用：a(around,含该字符)/f(find,含该字符)/i(inner,不含该字符)/t(to,不含该字符)来结合特定的字符使用。<br />  如：<code>yf;</code>表示由当前字符开始复制至<code>;</code>处，且含<code>;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础应用</title>
    <link href="/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <url>/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="git是什么"><a class="markdownIt-Anchor" href="#git是什么"></a> Git是什么</h2><p>  Git是分布式版本管理系统<br />  它可以帮助你：</p><ul><li><strong>构造本地仓库</strong></li><li><strong>管理本地仓库内的文件版本（可以回滚，可以往前）</strong></li><li><strong>与远程仓库建立连接（通过SSH）</strong></li><li><strong>远程仓库存储副本</strong></li><li><strong>多人协作开发</strong></li><li>…</li></ul><h2 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> Git安装</h2><ul><li>windows系统<br />下个Git Bash</li><li>Linux系统<br /><code>yum install git -y</code></li></ul><p>  安装完成后我们需要在Git Bash内或是Linux的终端中(下文统一称为<strong>terminal</strong>)设置全局属性name和email。用以标识用户。<br />  <code>git config --global user.name &quot;ayyHA&quot;</code><br />  <code>git config --global user.email &quot;email@qq.com&quot;</code><br />  还可以启用Git的一些额外颜色<br />  <code>git config --global color.ui true</code></p><h2 id="git本地仓库的操作"><a class="markdownIt-Anchor" href="#git本地仓库的操作"></a> Git本地仓库的操作</h2><p>  我们可以新建一个目录，用以作为被Git管理的本地仓库，<strong>放置于其内的任意文件都会被Git进行版本管理</strong>。</p><h3 id="本地仓库初始化"><a class="markdownIt-Anchor" href="#本地仓库初始化"></a> 本地仓库初始化</h3><p>  通过<code>git init</code>命令即可以将该目录设置为<strong>本地仓库</strong>，且该目录内会多出一个**.git**文件夹，其内是Git用于版本管理的东西，<strong>没事别乱动！！</strong></p><h3 id="提交文件"><a class="markdownIt-Anchor" href="#提交文件"></a> 提交文件</h3><p>  之后你可以往这个文件夹里建文件，写东西。但是这并没有使用到我们Git的版本管理。如何使用到呢？<br />  我们可以打开terminal输入<code>git status</code>这条命令进行查看。<br />  你会发现上面写着Untracked files,即意味着你的文件只是放在这个目录下，还没有被Git进行跟踪管理。</p><p>  我们可以通过<code>git add &lt;file&gt;</code>来将文件放置到一个叫<strong>暂存区</strong>的地方（即index或stage，存放于.git下）</p><p>  我们可以一次性将许多文件放在暂存区内，然后提交到<strong>本地仓库:</strong><code>git commit -m &quot;这里写此次提交的注释&quot;</code></p><p>  之后当你修改这些被跟踪的文件时，都可以通过<code>git status</code>来查看有谁被modified，有谁需要committed。</p>  <div class="note note-info">            <p>  你可能会想到一种情况：<br />  我在本地仓库里新建了a文件，修改了其内容，然后通过<code>git add a.txt</code>将其提交到暂存区，之后忽然发现有个地方写错了，然后直接先去修改a文件了，此时Git会将你放入暂存区的文件和再次修改的文件分隔来看，即放入暂存区的文件可以通过<code>git commit</code>将内容上交，而新加的内容则是被认为是modified，需要重新<code>git add</code>。</p>          </div><h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3><p>  当我们对文件一股脑的进行修改后发现，修改的部分极大可能出错了，且修改的地方比较多，若是一点一点回去改，会很耗时。而Git给我们提供了一剂后悔药<code>git checkout -- &lt;file&gt;</code>即可以将修改撤销，变回修改前的模样。</p>  <div class="note note-info">            <p>  ①若是未将文件<code>git add</code>到暂存区，则文件会回滚文修改前的版本；<br />  ②若是将文件放到了暂存区，又进行了修改，则checkout后得到的是暂存区的版本；（现在Git）</p>          </div><p>  除了上面所说的<code>git checkout -- &lt;file&gt;</code>来对文件进行撤销修改外，Git也提供了<code>git restore &lt;file&gt;</code>来撤销修改（因为<code>git checkout</code>也与后面的分支切换有关）,还提供了<code>git restore --staged &lt;file&gt;</code>来<strong>撤销放置于暂存区的文件</strong></p><h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3><p>  撤销修改中的①其实就是回退到最新的版本，也可以通过版本回退来实现:<code>git reset --hard HEAD^</code>此即为回退到上一个版本，若是想回退到上上一个版本，加多个<sup>即可。但若是我们需要回退的版本很前很前，写那么多个</sup>并不现实，可以通过：<code>git --reset HEAD~100</code>即可以回退到前100个版本去；<br />  那我们如果想回退到某一个版本，我们不知道它跟我们现在的版本差距为多少，我们可以通过<strong>版本号</strong>来进行回退。版本号可以通过<code>git log</code>来得到（commit后面那一串就是版本号）,如果版本太多，可以通过<code>git log --pretty=oneline</code>来较为清晰地输出版本信息。<br />  回退的时候我们不需要把版本号全部写上去，写前几个字母就好了，如：<code>git reset --hard 95a9b</code>。<br />  那当我们知道了版本号，其实不只可以进行版本回退，也可以将版本向前移动。若是不知道版本号，我们可以通过<code>git reflog</code>来进行查询。</p><div class="note note-info">            <p>  上面指令中的<strong>HEAD其实就是指向当前分支（如master）</strong>, 而<strong>当前的分支才是指向提交</strong>的，也即是说我们<strong>commit到本地仓库的内容是提交在当前分支上</strong>的，这个在后面的分支管理部分可以更好的理解。</p>          </div><h2 id="git远程仓库的操作"><a class="markdownIt-Anchor" href="#git远程仓库的操作"></a> Git远程仓库的操作</h2><h3 id="github设置及远程推送"><a class="markdownIt-Anchor" href="#github设置及远程推送"></a> Github设置及远程推送</h3><p>  要知道，我们GitHub和Git的数据传输是通过SSH加密的，需要进行如下的设置：</p><ol><li>在terminal中通过<code>ssh-keygen -t rsa -C &quot;email&quot; </code>来生成，它利用RSA加密算法生成一个公钥和密钥，放在你当前用户的HOME目录下（windows在C:/User/UserName/.ssh下，Linux在~/.ssh下）;</li><li>将在.ssh目录下的id_rsa放置到你的Github的Settings下的SSH and GPG keys中（通过点击New SSH key放置其中）；其中id_rsa是公钥，带pub后缀的是密钥;<br />至此，你的电脑利用Git去远程访问你的Github下的信息已经可以进行权限认证了（就是可以分辨出有没资格去拿信息）。</li><li>我们需要在Github上建一个仓库，并将本地仓库和远程仓库通过<code>git remote add origin git@github.com:github_name/repo_name.git </code>关联起来(注意github_name需替换成你的GitHub账号,repo_name需替换成你的仓库名);<br />  以上，你便将你的本地仓库和远程仓库建立了连接。我们可以将<strong>本地文件push到repo</strong>了。<code>git push -u origin master</code>首次push需要加-u，以使得你的本地分支master和远程仓库分支master相关联。之后就<code>git push origin master</code>就行。<br />  我们也可以<strong>拉取到该repo的文件</strong><code>git pull origin master</code>。</li></ol><h3 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h3><p>  通过上面的描述我们知道，我们的本地仓库在创建之时给我们自带了一个master分支，我们也可以自创分支<code>git branch branchName</code>，也可以切换分支<code>git checkout branchName</code>，可以通过<code>git branch来查看当前有多少分支</code>，还可以通过<code>git branch -d branchName</code>来删除分支。<br />  上面的分支切换和分支创建也可以通过如下指令完成<code>git checkout -b branchName</code>。<br />  我们一般都是用一个分支（如dev）进行修改提交（就是dev改了内容之后要add、commit），然后再合并到主分支master上，即是：<code>git merge dev</code>(master合并掉dev,通过fast-forward策略)。</p><div class="note note-info">            <p>  分支就像是一个线程一样，共享仓库里的文件，但是对文件的修改提交只对该分支可见。</p>          </div><p>  我们前面曾说过，我们的分支是面向提交的，那么也就是说如果我有master分支和dev分支，我们即对dev做了修改提交，又对master做了修改提交，那么在合并的时候就会产生<strong>冲突</strong>，我们可以通过查看产生了冲突的文件，上面会有&lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt;的信息来指示这个部分是哪个分支进行的修改，手动解决冲突后，即可合并。</p><div class="note note-info">            <p>  fast forward策略合并分支后，我们若是删除了分支，会丢失掉分支的信息。因此可以通过禁用fast forward的方式来避免丢失信息：<code>git merge -no-ff -m &quot;注释&quot; branchName</code>，之后还可以通过<code>git log</code>来找到它。<br />  若是在遇到某些bug的情况下需要另建分支，解决bug，而此时工作现场又无法commit的话，我们可以通过<code>git stash</code>来隐藏工作现场，后期可以通过<code>git stash list</code>来查看现场，然后可以通过<code>git stash apply</code>和<code>git stash drop</code>来应用和删除现场，也可以通过<code>git stash pop</code>来恢复现场和删除现场。</p>          </div><h3 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h3><p>  在前面push内容到GitHub时，我们用到了<code>git push origin master</code>其实这个origin就是远程仓库默认的名字。我们可以通过<code>git remote</code>和<code>git remote -v</code>来查看远程仓库的信息。而这里的master则是指的本地分支，意为：将本地的master分支push到origin上去。<br />  那么我们若是要push本地的dev分支到origin去的话，我们的远程仓库会自动set up一个叫dev的分支，并与我们本地的dev分支建立关联。<br />  若是我们需要将origin上的dev分支弄到本地来，可以通过<code>git checkout -b dev origin/dev</code>实现；<br />  若是当我们要提交的dev分支产生冲突，我们需要拉取最新的下来，我们需要先指定本地dev分支与远程origin/dev分支的关联关系：<code>git branch --set-upstream dev origin/dev</code>，再pull即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo之方便文创的代码</title>
    <link href="/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="tag插件"><a class="markdownIt-Anchor" href="#tag插件"></a> Tag插件</h2><h3 id="便签"><a class="markdownIt-Anchor" href="#便签"></a> 便签</h3><p>  便签，就是贴在文章中的彩色标签，用于展示作者的一些提示信息。便签是通过便签类型来进行划分的。<br /><a href="https://hexo.fluid-dev.com/docs/guide/">fluid配置指南</a></p><p><strong>用法</strong></p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>这里写便签里的内容<br>&#123;% endnote %&#125;<br>需注意：上面的success是便签类型的指代，此为绿色的便签。<br></code></pre></td></tr></table></figure><p><strong>便签类型和颜色的对应关系</strong></p><table><thead><tr><th style="text-align:center">便签类型</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center">primary</td><td style="text-align:center">紫色</td></tr><tr><td style="text-align:center">secondary</td><td style="text-align:center">灰色</td></tr><tr><td style="text-align:center">success</td><td style="text-align:center">绿色</td></tr><tr><td style="text-align:center">danger</td><td style="text-align:center">红色</td></tr><tr><td style="text-align:center">warning</td><td style="text-align:center">黄色</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">蓝色</td></tr><tr><td style="text-align:center">light</td><td style="text-align:center">白色</td></tr></tbody></table><p><strong>效果演示</strong></p>  <div class="note note-primary">            <p>我是primary，我是紫色</p>          </div>  <div class="note note-secondary">            <p>我是secondary，我是灰色</p>          </div>  <div class="note note-success">            <p>我是success，我是绿色</p>          </div>  <div class="note note-danger">            <p>我是danger，我是红色</p>          </div>  <div class="note note-warning">            <p>我是warning，我是黄色</p>          </div>  <div class="note note-info">            <p>我是info，我是蓝色</p>          </div>  <div class="note note-light">            <p>我是light，我是白色</p>          </div><h3 id="行内标签"><a class="markdownIt-Anchor" href="#行内标签"></a> 行内标签</h3><p>  行内标签类似于一个按钮（就是不可以按），用于标识信息。</p><p><strong>用法：</strong><br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% label primary @text%&#125;<br></code></pre></td></tr></table></figure><br /><div class="note note-info">            <p>text即为标签的文本，primary这些与便签类似，但多了个default，没有secondary和 light，且text开头不能是@。</p>          </div></p><p><strong>效果演示：</strong><br /><span class="label label-primary">我是primary</span><br /><span class="label label-default">我是default</span><br /><span class="label label-success">我是success</span><br /><span class="label label-warning">我是warning</span><br /><span class="label label-danger">我是danger</span></p><h3 id="按钮"><a class="markdownIt-Anchor" href="#按钮"></a> 按钮</h3><p>  按钮就是加了底色的外链跳转</p><p><strong>用法：</strong><br /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% btn url,text,title %&#125;<br></code></pre></td></tr></table></figure></p>  <div class="note note-info">            <p>btn标识其为一个按钮，url是点击后跳转的外链，text是按钮显示的文本，title是鼠标悬停的文字，是个可选项。</p>          </div><p><strong>效果演示：</strong></p>  <a class="btn" href="http://baidu.com"  title="百度" target="_blank">我是一个可以跳到百度的按钮</a><h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2><p>  脚注可以使得我们很方便地标出文章中一些引用部分的出处或是相关的解释。脚注在生成的文章中被放置于文末，类似于参考文献，且带有锚点，我们点击即可到达标注处。</p><p><strong>用法</strong>：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br>这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br>这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup><br><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">第一处的脚注</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">第二处的脚注</span><br>[<span class="hljs-symbol">^3</span>]: <span class="hljs-link">第三处的脚注</span><br></code></pre></td></tr></table></figure><p>把上面代码段的内容贴到MD文档里是以下的<strong>效果</strong>：</p><p>这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br />这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br />这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>第一处的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>第二处的脚注<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>第三处的脚注<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud自学</title>
    <link href="/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>  由于Netfilx提供的服务组件停止维护了，因此选择了Alibaba提供的服务组件，本文会围绕着Nacos,Sentinel等组件来讲解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloudAlibaba</tag>
      
      <tag>Nacos</tag>
      
      <tag>Ribbon</tag>
      
      <tag>Hystrix</tag>
      
      <tag>Feign</tag>
      
      <tag>Zuul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自学</title>
    <link href="/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot的大时代"><a class="markdownIt-Anchor" href="#springboot的大时代"></a> SpringBoot的大时代</h1><hr /><h2 id="1-微服务"><a class="markdownIt-Anchor" href="#1-微服务"></a> 1. 微服务</h2><ul><li>微服务是一种架构风格</li><li>一个应用拆分为一组小型服务</li><li>每一个服务可以部署在自己的服务器上，运行在自己的进程内，也就是可以独立部署和升级，与单个应用无差</li><li>服务之间的交互使用轻量级的HTTP交互</li><li>服务围绕业务功能进行拆分</li><li>服务可以由全自动部署机制独立部署</li><li>去中心化（每一个服务可以用不同的语言来进行开发，也可以使用不同的存储技术）、服务自治</li></ul><p>而<strong>微服务的出现，将大应用拆分成多个小服务进行独立部署，会导致分布式的产生</strong></p><hr /><h2 id="2-分布式"><a class="markdownIt-Anchor" href="#2-分布式"></a> 2. 分布式</h2><p>问题：</p><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>…</li></ul><p>分布式的解决：SpringBoot + SpringCloud</p><h2 id="3-云原生"><a class="markdownIt-Anchor" href="#3-云原生"></a> 3. 云原生</h2><p>原生应用如何上云：Cloud Native</p><p>上云的困难：</p><ul><li>服务的自愈</li><li>弹性伸缩（拥塞）</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>…</li></ul><h1 id="springboot官方文档架构"><a class="markdownIt-Anchor" href="#springboot官方文档架构"></a> SpringBoot官方文档架构</h1><hr /><p><a href="Spring.io">Spring官方网址</a></p><p>可以通过官方网址的Projects&gt;SpringBoot进行SpringBoot的学习</p><p>其中OVERVIEW部分可以看到发布版本的更新情况以及更新的内容；LEARN则可以选择版本来进行对应的学习</p><p>本次学习所采用的是2.3.4版本的SpringBoot</p><h1 id="springboot2之helloworld"><a class="markdownIt-Anchor" href="#springboot2之helloworld"></a> SpringBoot2之HelloWorld</h1><p>系统要求：</p><ul><li>Java8及以上</li><li>Maven3.3+</li></ul><ol><li>配置Maven</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>HelloWorld</li></ol><p>需求：浏览发送/hello请求，响应Hello,SpringBoot2</p><p>①创建一个普通的Maven项目，编写POM</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ayy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot-01-helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 导入SpringBoot父工程，版本是2.3.4 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SpringBoot web开发启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②编写主程序类，在main&gt;java下创建com.ayy.boot.MainApplication Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类；主配置类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③编写controller类，并运行main方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">//@ResponseBody  //此注解用于表示此类的返回值均是写给浏览器的，而不是跳转某个页面等；</span><br><span class="hljs-comment">//@Controller</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>简化配置</li></ol><p>在resources下创建一个application.properties的配置文件，所有的配置如端口号等，都可以写此处，当运行时，SpringBoot会读取里面的配置,若是无更改的则按照SpringBoot默认的配置行事。</p><p>当不知道什么配置可以写于其中时，可参照官方文档中的Application Properties的内容来进行设置。</p><ol start="4"><li>简化部署</li></ol><p>maven项目默认是打包为jar包</p><p>SpringBoot所打包是一个<strong>可执行的jar包</strong>，通过以下插件配置即可实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过maven自带的lifestyle的clean和package进行打包操作</p><p>对打好的包通过cmd命令行执行 <code>java -jar 包名</code>即可执行之！！</p><p>注意：</p><ul><li>需要取消cmd的快速编辑模式</li></ul><p>最后展示一下此模块的目录结构：</p><p><img src="https://s2.loli.net/2021/12/13/sfYOvp6CVNwumB4.png" alt="目录结构" /></p><hr /><h1 id="springboot依赖管理特性"><a class="markdownIt-Anchor" href="#springboot依赖管理特性"></a> SpringBoot依赖管理特性</h1><ul><li>父项目做依赖管理(<strong>自动版本仲裁机制</strong>)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>//starter-parent里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>在spring-boot-dependencies这一项目里面，几乎声明了所有开发中常用的依赖的版本号,此即为自动版本仲裁机制<br></code></pre></td></tr></table></figure><ul><li>开发导入starter场景启动器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. spring-boot-starter-* : 此即代表某种场景<br>2. 只要引入starter，这个场景的所有常规需要的依赖我们都会自动导入<br>3. SpringBoot所有支持的场景：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter<br>4. 见到的 *-spring-boot-starter : 是第三方为我们提供的简化开发的场景启动器<br>5. 所有场景启动器最底层的依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">引入依赖默认都可以不写版本号，除非引入的依赖是非版本仲裁的jar，则一定要写版本号<br></code></pre></td></tr></table></figure><ul><li>可以修改版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 查看spring-boot-dependencies里面规定的当前依赖的版本所用的关键字<br>2. 在当前项目里面重写配置<br><br>注：利用的时MAVEN提供的特性：就近优先原则<br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.43<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="springboot自动配置特性"><a class="markdownIt-Anchor" href="#springboot自动配置特性"></a> SpringBoot自动配置特性</h1><ul><li><p>自动配置tomcat（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入tomcat依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置tomcat</li></ol></blockquote></li><li><p>自动配置SpringMVC（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入了SpringMVC全套组件</li><li>自动配好SpringMVC常用组件(功能)</li></ol></blockquote></li><li><p>自动配好Web常见功能，如：字符编码问题</p><blockquote><p>SpringBoot帮我们配置好了所有web开发时的常见场景</p></blockquote></li><li><p>默认的包结构</p><blockquote><ul><li>主程序所在的包及其下边的所有的子包都能被扫描（即无需配置包扫描，此为默认的包扫描规则）</li><li><strong>如果想要改变包扫描路径，可以通过在@SpringBootApplication(scanBasePackages=“com.ayy”)来改变</strong></li><li>或者通过一个@ComponentScan来指定扫描的路径，但此时因SpringBootApplication已经使用了其，故暂时不能将其与之写于一起来进行包扫描路径的替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>等同于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.ayy&quot;)</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>各种配置都拥有默认值</strong></p></li></ul><blockquote><p>默认配置最终都是映射到某一个类上的</p><p>配置文件的值会绑定到某一个类上，这个类会在容器中创建对象</p></blockquote><ul><li><strong>按需加载所有自动配置项</strong></li></ul><blockquote><p>引入了哪些场景，这个场景的自动配置才会开启</p><p>SpringBoot的所有自动配置功能都在spring-boot-autoconfigure包里面</p></blockquote><hr /><h1 id="底层注解-configuration组件添加解析"><a class="markdownIt-Anchor" href="#底层注解-configuration组件添加解析"></a> 底层注解-@Configuration(组件添加)解析</h1><hr /><p>在之前，我们对Spring进行一个组件的注册是通过在spring.xml配置文件里增添如下内容实现，在表示配置spring.xml之前，先进行两个类的构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*User类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*Pet类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pet&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过spring.xml对其中的bean进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Pet&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上便是<strong>Spring通过配置文件的方式，来实现组件的注册，经注册的组件可以在容器中找到</strong></p><p>而<strong>在SpringBoot中，可以通过@Configuration这个注解来替代spring.xml配置文件，即用一个含有@Configuration注解的类来进行组件的注册，而在需要注册的组件上，只需要通过@Bean注解来声明即可</strong>，如下类MyConfig所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.config;<br><br><span class="hljs-keyword">import</span> com.ayy.boot.bean.Pet;<br><span class="hljs-keyword">import</span> com.ayy.boot.bean.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 告诉SpringBoot这是一个配置类（配置类就等于配置文件）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 给容器中添加组件，以方法名作为组件的id,返回类型就是组件类型。返回的值就是组件在容器中的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*被@Bean注解所注的方法的返回值即是注册在容器中的组件的实例对象，方法名即为实例对象的id，若是不满方法名作为对象id,可以在@Bean(&quot;myName&quot;)中进行组件id的重写</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>需要特别注意的是：<strong>此时我们所注册在容器中的组件都是单例的</strong>，无论你通过容器如何getBean或多次getBean，甚至直接获取MyConfig组件（<strong>因其也是在配置文件下的类，故其也被注册在容器里</strong>）直接进行方法的调用，也依旧是单例！！</p><p>​这个单例的构成，与**@Configuration注解下的proxyBeanMethods的默认值为true有直接关系**，proxyBeanMethods即意为<strong>代理Bean方法</strong>，在其为true的情况下，我们通过getBean获得的MyConfig类的实例对象其实是<strong>代理对象</strong>，也即通过这个代理对象，我们无论怎么去调用对象里的方法，也只是从容器里面获取对应的组件而已；当<strong>代理Bean方法</strong>值为false时，才会是个普通的对象，通过调用其中方法，获得的实例则不相同。</p><p>​以下部分是体现代理对象调用方法后所得组件为容器中组件且为单例的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>        <span class="hljs-comment">// 查看容器里的组件</span><br>        String[] names = run.getBeanDefinitionNames();<span class="hljs-comment">// 获取容器中组件的实例对象的名字</span><br>        <span class="hljs-keyword">for</span>(String name:names)<br>            System.out.println(<span class="hljs-string">&quot;NANE: &quot;</span>+name);<br>   <span class="hljs-comment">// 从容器中获取组件</span><br>        MyConfig myConfig = run.getBean(MyConfig.class);<br>        Pet jerry = run.getBean(<span class="hljs-string">&quot;jerry&quot;</span>, Pet.class);<br>        System.out.println(jerry==myConfig.tom());<br>        System.out.println(myConfig);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注：当我们打出myconfig的内容时，会发现其打印的内容为：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig$$EnhancerBySpringCGLIB$$8a7037ca@7ea4d397</span><br><span class="hljs-comment">并非一个单纯的类，而在其中还夹杂了EnhancerBySpringCGLIB,即其被SpringCGLIB所提升，而很自然联想到是被提升为代理对象</span><br><span class="hljs-comment">小贴士：在Spring中一般这种事是jdk干的，但在SpringBoot中，这种事交由CGLIB干</span><br><span class="hljs-comment">而当我们修改MyConfig的注解为@Configuration(proxyBeanMethods=false)时，再运行程序，可以发现：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig@62d0ac62</span><br><span class="hljs-comment">此时则为一个普通的容器中的组件</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>proxyBeanMethods:代理bean的方法根据true/false，有以下两种模式：</p><ul><li>Full(proxyBeanMethods=true) 全模式</li><li>Lite(proxyBeanMethods=false) 轻量级模式，因为不像全模式，在<strong>构建</strong>时需要查询容器中是否存在该实例，加快了运行速度，故为轻量级</li></ul><p>在此处举一个单例的实例：比如我们的User里有一个成员变量是Pet，它们两个都是在容器中获得的组件，且此为<strong>User依赖Pet</strong>，那么通过单例，可以很好地体现这么一个<strong>依赖关系</strong>，因为User所占有的Pet，也是容器里面所独有的Pet，不存在这些个Pet相异的情况。</p><p><strong>因此：当没有依赖组件时则用Lite轻量级模式；当需要依赖时，则需要使用Full全模式。</strong></p><p><strong>注：根据后面的学习来看，轻量级模式下的自动类配置，它的参数的获取，有大概率的可能是通过容器中获取。若是自己写的配置类（如笔者自己的MyCofig），使这个代理bean方法失效后，因笔者没有传入参数，故没有进行进一步的测试。<em>因此笔者猜测：SpringBoot在处理配置类的参数时，直接获取的是容器中已有的组件，若是构建当前组件的实例，则对Full会进行单例查询，而对Lite则不查询，直接放入容器中。但随之而来的问题是：自动获取的传入参数如何保证是我们所想要的哪个呢？而框架本身的因为是与配置文件相绑定，所以只要是获取到的实参，都是所需的。</em></strong></p><p>2021.9.7看，不懂上面的注说的啥</p><h1 id="底层注解-import导入组件解析"><a class="markdownIt-Anchor" href="#底层注解-import导入组件解析"></a> 底层注解-@Import(导入组件)解析</h1><hr /><p>除了上面所说的@Configuration加上@Bean可以给容器注册组件外，还有之前的@Component（表示为一个组件）、@Controller（表示为一个控制器）、@Service（表示为一个业务逻辑组件）、@Repository(代表它是一个数据库层组件)都能用。</p><p>@ComponentScan就是通过指定包扫描路径来实现组件导入，因为告知了Spring该去哪里扫描即哪里找可能是组件的类</p><p><strong>@Import是给容器导入组件，可以写在配置类中或组件类中</strong></p><p><strong>它的参数是一个数组，这个数组里面写的是想要导入到容器中的组件的类型，它会<u>调用该类的无参构造器来构造出该类的对象加入到容器中，所默认使用的id，即BeanName是全类名</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先在配置类MyConfig里写下以下内容，以在容器中导入对应的类实例对象</span><br><br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean(&quot;jerry&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-comment">// 之后我们通过MainApplication来打印导入的类，查看其打印情况</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 查看Import注解导入的组件的名字</span><br>        String[] beanNames = run.getBeanNamesForType(User.class);<br>        System.out.println(<span class="hljs-string">&quot;&lt;====================================&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(String bean:beanNames)<br>            System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + bean);<br>        DBHelper dbHelper = run.getBean(DBHelper.class);<br>        System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + dbHelper);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 打印结果如下：</span><br>&lt;====================================&gt;<br>bean:com.ayy.boot.bean.User<br>bean:user01<br>bean:ch.qos.logback.core.db.DBHelper@1d81e101<br>不难看出，我们通过导入进去的默认BeanName即我们在Spring.xml注册的id即为全类名，且其为无参构造得到的。<br><br></code></pre></td></tr></table></figure><h1 id="底层注解-conditional条件装配"><a class="markdownIt-Anchor" href="#底层注解-conditional条件装配"></a> 底层注解-@Conditional条件装配</h1><hr /><p><strong>条件装配：满足Conditional指定的条件，则进行组件注入</strong>！！！</p><img src="https://s2.loli.net/2021/12/13/SG6y5Umhs1oxv3p.png" alt="Conditional相关注解.png" style="zoom:67%;" /><p>Conditional是个根注解，其下的许多注解可以按照名字的意思来进行对应的测试，下面的例子用@ConditionalOnBean来实现，其意为，当某个Bean存在时，则执行下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>通过对<span class="hljs-meta">@Bean</span>注解注释，使之不会注册到容器中，以下为此例的验证<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用注册到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 通过输出结果即证明了没有加上注解@Bean的Javabean不会注册到容器中。则根据这一规则我们可以进行下面的测试</span><br>    <br>    <br><span class="hljs-number">2.</span> 当tom存在时，才注册user01到容器中，否则不注册<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@ConditionalOnBean(name=&#123;&quot;tom&quot;&#125;)</span><span class="hljs-comment">// 当容器中有个名为tom的组件时，才执行user01组件注册到容器中，否则不注册到容器中</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用，注入到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;    <br>   <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">false</span><br><span class="hljs-comment">// 通过结果可以得出，当名为tom的组件在容器中找不到时，user01也不会注册到容器中，此注解也可以放置到类上，以期满足某种条件，才执行类中的组件的注册。</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-importresource导入spring配置文件"><a class="markdownIt-Anchor" href="#底层注解-importresource导入spring配置文件"></a> 底层注解-@ImportResource导入Spring配置文件</h1><hr /><p>@ImportResource用于向SpringBoot中导入Spring的配置文件：spring.xml，即通过此注解可以将无法被SpringBoot所理解的组件注册到容器中。<strong>此注解写于配置类上即可</strong></p><p>以下为一实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>当在配置类MyConfig中没有加上此注解时：<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLUser&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.User&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&quot;</span>&gt;&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;18&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLPet&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.Pet&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&#x27;s pet&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br><span class="hljs-comment">// 上述为spring.xml中的注册组件</span><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>    <span class="hljs-comment">// 对IOC容器进行查询，根据BeanName查询</span><br>        <span class="hljs-keyword">boolean</span> springXMLUser = run.containsBean(<span class="hljs-string">&quot;springXMLUser&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLUser:&quot;</span> + springXMLUser);<br>        <span class="hljs-keyword">boolean</span> springXMLPet = run.containsBean(<span class="hljs-string">&quot;springXMLPet&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLPet:&quot;</span> + springXMLPet);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 输出结果为：</span><br>springXMLUser:<span class="hljs-keyword">false</span><br>springXMLPet:<span class="hljs-keyword">false</span><br>    <br><span class="hljs-comment">// 我们对配置类MyConfig进行@ImportResource(&quot;classpath:spring.xml&quot;)注解标识后，再运行，可得如下输出结果</span><br>springXMLUser:<span class="hljs-keyword">true</span><br>springXMLPet:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 此时即实现了对spring中的组件进行了注册</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-configurationproperties配置绑定"><a class="markdownIt-Anchor" href="#底层注解-configurationproperties配置绑定"></a> 底层注解-@ConfigurationProperties配置绑定</h1><p>在以前，我们对一些常规配置的内容是写在my.properties中然后通过绑定的机制来将之内容写入Javabean中，这个过程较为繁琐，而<strong>在SpringBoot中，我们可以通过将配置信息写在application.properties，然后通过注解@ConfigurationProperties来实现绑定</strong>，且绑定的形式有两种！下图是之前绑定的方法的一个流程显示：</p><p><img src="https://s2.loli.net/2021/12/13/AK9Fbc8GnCDaBLJ.png" alt="ConfigurationProperties.png" /></p><p>法①</p><p>通过在Javabean类Car中进行注解：@Component 和 @ConfigurationProperties(prefix = “mycar”) 来实现配置文件中的内容与该Javabean的绑定，并注册为容器中的一个组件。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*   只有在容器中的组件，才能使用SpringBoot提供的强大功能，因此需要通过@Component注解来将这个组件加入到容器中，</span><br><span class="hljs-comment">*   然后对prefix为mycar的配置内容进行获取</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&#x27;&quot;</span> + price + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String brand, String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 以下内容是application.properties的配置内容：</span><br>server.port=<span class="hljs-number">8888</span><br><br>mycar.brand=TESLA<br>mycar.price=<span class="hljs-number">280000</span><br>    <br><span class="hljs-comment">// 接着我们在HelloController类中通过映射请求来实现这个绑定的体现：</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Car car;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/car&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">myCar</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> car;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 紧接着我们访问 localhost:8888/car 即可获得输出于浏览器上的结果</span><br>&#123;<span class="hljs-string">&quot;brand&quot;</span>:<span class="hljs-string">&quot;TESLA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-string">&quot;280000&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>法②</p><p><strong>删去Car类中的@Component组件并通过在MyConfig这个配置类中增加注解@EnableConfigurationProperties(Car.class)来开启Car类的属性配置功能</strong></p><p>其中@EnableConfigurationProperties的作用有如下两点：</p><blockquote><ol><li><strong>开启Car组件的配置绑定功能</strong></li><li><strong>把Car这个组件自动地注册到容器中</strong></li></ol></blockquote><p><strong>此类用法多用于我们使用第三方的jar包中的类的时候，我们不能轻易地去修改别人的源代码，因此可以通过这样的方式来实现组件的配置绑定及加载到容器中。</strong></p><hr /><h1 id="自动配置-自动包规则原理"><a class="markdownIt-Anchor" href="#自动配置-自动包规则原理"></a> 自动配置-自动包规则原理</h1><hr /><p>自动包配置原理，是在SpringBoot应用下才生效的，即在SpringBoot应用下，可以自动加载配置类，即会自动往容器中导入组件，那么这个实现得从注解@SpringBootApplication先看起；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>&lt;=====&gt;等价于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br>接下来我们对它们逐个解析<br></code></pre></td></tr></table></figure><ol><li>@SpringBootConfiguration</li></ol><p><strong>往此注解内部点去，可以发现其内部的核心是@Configuration，即注明此类是配置类</strong>，也就是说，我们的<strong>MainApplication类也是配置类</strong></p><ol start="2"><li>@ComponentScan</li></ol><p>此即为自动包扫描的配置，配置其下的目录及其子包都会被扫描</p><ol start="3"><li><strong>@EnableAutoConfiguration</strong></li></ol><p>我们通过Ctrl+左键点击进去后发现，@EnableAutoConfiguration注解由如下注解组成：</p><ul><li><p><strong>@AutoConfigurationPackage</strong></p></li><li><p><strong>@Import({AutoConfigurationImportSelector.class})</strong></p></li></ul><p>我们先着重说一下，@AutoConfiguraionPackage这个注解！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们点进去@AutoConfigurationPackage这个注解有以下内容</span><br><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br><span class="hljs-comment">// 我们发现，@AutoConfiguraionPackge里的注解是导入了Registrar组件，那么导入组件则是一个一个导入，我们先继续点进去该类看下</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>        Registrar() &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>            AutoConfigurationPackages.register(registry, (String[])(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//上面是这个类的方法，我们看第一个方法registerBeanDefinitions()，传入的第一个参数metadata是一个注解元数据类型，所获取到的其实质是这个注解所注的类的元数据信息，而这个注解是合成注解，因此所获取到的是MainApplication这个标注了@SpringBootApplication注解的类，再看该方法里面的内容，它通过metadata获取到了我们主类的包名，然后还给它弄成了一个数组，对这个包名下的组件进行了注册！！</span><br></code></pre></td></tr></table></figure><p>由此可见，我们自动包规则原理，便是基于这个<strong>Registrar</strong>这个类，利用这个类，给容器导入一系列的组件。将指定的标注了这个注解（@AutoConfiguraionPackage）或利用之合成的注解(@EnableAutoConfiguraion或@SpringBootApplication)的类<strong>所在的包进行了组件注册</strong>！！</p><h1 id="自动配置-初始加载自动配置类"><a class="markdownIt-Anchor" href="#自动配置-初始加载自动配置类"></a> 自动配置-初始加载自动配置类</h1><hr /><p>上面我们解释了@EnableAutoConfiguraion中的@AutoConfiguraionPackage，紧接着我们讲一下另一个注解@Import({AutoConfigurationImportSelector.class})，我们来详细谈一下这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>在进入AutoConfigurationImportSelector类后，我们看到一个方法：<br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata)&#123;...&#125;，其中该方法有一行代码是：getAutoConfigurationEntry(annotationMetadata);<span class="hljs-comment">// 此方法用于给容器批量导入一批组件</span><br><span class="hljs-number">2.</span>上面所说的那个给容器批量导入一批组件的方法，其内调用了：<br>    List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<span class="hljs-comment">// 通过调用此方法获取到所有需要导入到容器中的配置类</span><br><span class="hljs-number">3.</span>上述的那个方法是怎么知道导入这些需要导入的配置类的呢？往里面点，我们发现：<br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br><span class="hljs-comment">// 它利用工厂加载来加载内容，那么所加载的内容是什么呢？</span><br><span class="hljs-number">4.</span>再往下点击，可以发现其所加载的内容是：<br>    Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)&#123;...&#125;;<span class="hljs-comment">// 即通过一个Map来获取到所有的组件</span><br><span class="hljs-number">5.</span>那么这些组件是从哪里得到并加载的呢？通过以下对loadSpringFactories的debug过程便可略知一二：<br>     Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<span class="hljs-comment">// 不难看出，它是从一个META-INF/spring.factories的位置来加载文件。Spring会默认扫描我们当前系统里面所有的META-INF/spring.factories位置的文件！！</span><br><span class="hljs-number">6.</span>我们可以通过External Libraries来找对应的存在META-INF/spring.factories位置的jar包，查看其中内容。而最核心的包便是spring-boot-autoconfigure这个包。通过对这个包的内容进行查看，看到其下META-INF/spring.factories中有一行注为Auto Configure的内容，其后紧跟着<span class="hljs-number">127</span>个自动配置类！！也就是说，文件里面写死了spring-boot一启动就要加载到容器中的所有配置类。<br><span class="hljs-number">7.</span>我们可以通过getBeanDefinitionCount()来查看的确是有这<span class="hljs-number">127</span>个组件的存在，那么此时又存在另一个问题：它那么大，不应该会导致系统很卡嘛？<br>    虽然我们<span class="hljs-number">127</span>个场景的所有自动配置启动的时候默认全部加载，但最终会按需配置！！！<br>    这个按需配置就是利用了之前所学的条件装配规则！！！（<span class="hljs-meta">@ConditionnalOnClass(使用者所需要导入的类.class)</span>）<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/13/O3bjzpPL7FcgJBf.png" alt="AutoConfigurationImportSelector.png" /></p><center>上图不难看出，默认导入的组件有127个之多。</center><h1 id="自动配置中一些有趣的东西"><a class="markdownIt-Anchor" href="#自动配置中一些有趣的东西"></a> 自动配置中一些有趣的东西</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">            name = &#123;&quot;multipartResolver&quot;&#125;</span><br><span class="hljs-meta">        )</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> resolver;<br>        &#125;<br><span class="hljs-comment">// 上面这就是MultipartResolver文件上传解析器,当容器中有该类并且找不到该类名为multipartResolver的组件时，则通过下面的函数，利用参数由容器中获取，然后将之返回，并将其名字改为函数名即multipartResolver，然后重新放回到容器中！</span><br><span class="hljs-comment">// 此例用于将不规范的文件上传解析器名字进行更改，以规范化！</span><br></code></pre></td></tr></table></figure><p><strong>SpringBoot默认会在底层配好所有的组件，但是如果用户自己配置了的话，则就以用户的优先</strong><br />下面以字符配置(HttpEncodingAutoConfiguration)为例，并先对默认配置进行解释，再展示自我配置的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix=&quot;server.servlet.encoding&quot;,value = &#123;&quot;enabled&quot;&#125;,matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(ServerProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getServlet().getEncoding();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br><span class="hljs-comment">/*...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​从上面的源码中我们可以得知HttpEncodingAutoConfiguration是一个配置类，且其开启了类ServerProperties的配置绑定，并将之加入于容器中，然后我们的是Web项目，且是类型为Servlet的，又因为自动导入了SpringMVC,因此对应的CharacterEncodingFilter类也存在，最后的注解标识是实不实现都可以，因此满足自动配置此类的条件，则可以继续往下执行！<br />​它的构造函数会从刚刚加入到容器中的ServerProperties组件获取，然后把一些内容交予本类的成员properties，之后的characterEncodingFilter()这个函数，则利用该成员进行字符编码的设置！！<strong>由此可见，若想通过DIY方式配置SpringBoot的环境，可以通过修改配置文件（即application.properties）来实现；</strong></p><p>​当然也可以通过接下来的手段实现，<strong>因为在进行组件的注册时，其有条件装配规定的约束，当容器中无该类才执行，即若是使用者自行注册，则不会再次于其中注册</strong>，此即满足了<strong>用户优先原则，且也为我们DIY配置环境提供了一个方法，就是自己定义配置类进行注册</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以下以字符编码CharacterEncodingFilter类为例，先展示无修改任何配置的情况下的正常输出：</span><br><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span> + name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 当我们在浏览器中键入：&#x27;localhost:8888/hello?name=张三&#x27; 则在浏览器中会显示&#x27;Hello,SpringBoot2!张三&#x27;，由此可见SpringBoot默认在底层的确给我们配置好了所有组件！</span><br><br><span class="hljs-comment">// 接下来，通过修改配置文件application.properties来进行乱码操作！</span><br>我们通过查找HttpEncodingAutoConfiguration类发现其prefix为server.servlet.encoding，然后在application.properties中进行修改，将之修改为server.servlet.encoding.charset=ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span><br>则通过浏览器进行输入测试，会发现，已乱码为：Hello,SpringBoot2!??<br>    由此可见，配置文件DIY便利着实有效！<br><br><span class="hljs-comment">// 接下来，通过自定义配置类，然后注册组件实现字符编码DIY</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br><span class="hljs-comment">//上述代码实则在运行的时候会报错，因为该组件在底层其他部分也有重要的应用，但可以通过这种方法注册组件，而不是使用系统默认的组件配置。</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>SpringBoot先加载所有的自动配置类（xxxAutoConfiguration）</p></li><li><p>每个自动配置类按照条件装配进行生效，默认都会“绑定”配置文件指定的值，这个绑定是通过利用参数xxxProperties(这是个类，用于配置属性绑定的)获得的。xxxProperties和它对应的配置文件进行了配置绑定！</p></li><li><p>生效的配置类就会给容器中装配组件</p></li><li><p>只要容器中有这些组件，相当于拥有了这些功能</p></li><li><p>只要用户有自己配置的，就以用户的优先</p></li><li><p>定制化配置（DIY配置）</p><blockquote><p>用户通过自定义配置类再通过@Bean注解来使用自己想配置的组件</p><p>用户通过看底层源码对应的xxxProperties中的prefix来获取前缀，通过application.properties来进行修改（结合tab提示）</p></blockquote></li></ul><p>xxxAutoConfiguration(自动配置类) —&gt; 导入了一大堆组件 —&gt; 通过xxxProperties去获取值 —&gt; 通过application.properties去重设置值</p><hr /><h1 id="springboot编写逻辑"><a class="markdownIt-Anchor" href="#springboot编写逻辑"></a> SpringBoot编写逻辑</h1><ol><li>引入对应的场景依赖<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">spring-boot-starter-xxx</a></li></ul></li><li>查看自动配置了哪些组件<ul><li>自行分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true<strong>开启自动配置报告</strong> Negative(不生效) / Positive(生效)</li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/appendix-application-properties.html#common-application-properties">文档地址</a></li></ul></li><li>自行分析，xxxProperties绑定的配置文件的前缀，然后找到注入的部分</li><li>自定义加入或者替换组件<ul><li>@Bean@Component</li></ul></li><li>自定义器xxxCustomizer(目前IDon’tKnow)</li><li>…</li></ul></li></ol><hr /><h1 id="开发小技巧-lombok"><a class="markdownIt-Anchor" href="#开发小技巧-lombok"></a> 开发小技巧-Lombok</h1><p>Lombok这个东西可用于简化JavaBean的开发</p><p>安装依赖及插件的过程如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">1.依赖安装<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.插件安装，通过Settings&gt;Plugins下搜索lombok进行安装即可！</p><p>lombok的几个重要注解：</p><ul><li>@Getter/@Setter:作用于类上，生成所有成员变量的get/set方法；作用于成员变量上，则只对该变量生成get/set方法。可以设置访问权限（@Getter(value=“AccessLevel.PUBLIC”)）和是否懒加载。</li><li>@ToString:会自动给Javabean的成员变量们构造toString函数，可以通过of/exclude来指定/排除某些成员变量生成于toString方法中。</li><li>@EqualsAndHashCode:生成equals和hashcode方法。</li><li>@NoArgsConstructor:自动给Javabean创造无参构造器</li><li>@AllArgsConstructor:自动给Javabean创造全参构造器</li><li>@RequiredArgsConstructor:生成包含final和@NonNull注解的成员变量构造器</li><li>@Data:@Getter+@Setter+@ToString+@EqualsAndHashCode+@RequiredArgsConstructor</li><li>@Builder:作用于类上，快速地为类实现建造者模式。可以链式赋值（初始化的时候），若是需要修改要么通过set，要么在实体类的@Builder(toBuilder=true)，但它会返回一个全新的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user = User.builder().id(<span class="hljs-number">1</span>).username(<span class="hljs-string">&quot;ayy&quot;</span>).build();<br></code></pre></td></tr></table></figure><ul><li>@Slf4j:给类注入日志类，<a href="http://xn--log-u68dx6aq0u2xfq43ed1nol0brja.info">以后在该类中调用log.info</a>()便可将内容通过日志输出，而不用sout输出于控制台下</li></ul><p>注：若需部分成员构造器，则可以自行编写或利用IDEA的自动编写功能</p><hr /><h1 id="开发小技巧-dev-tools"><a class="markdownIt-Anchor" href="#开发小技巧-dev-tools"></a> 开发小技巧-dev-tools</h1><p>此物需要增加依赖于pom.xml中，用于制造伪热更新（实质通过restart形式实现，而热更新是通过reload形式实现），以下是其依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们修改我们的代码文件后，不需要通过关闭再打开项目来实现刷新，而直接通过Ctrl + F9重新编译项目即可，然后就实现了刷新！</p><p>如果想要使用真正的热更新，可以付费购买插件JRebel。</p><hr /><h1 id="开发小技巧-spring-initializer"><a class="markdownIt-Anchor" href="#开发小技巧-spring-initializer"></a> 开发小技巧-Spring Initializer</h1><p>创建SpringBoot项目通过File&gt;New&gt;Project&gt;Spring Initializer以GUI界面创建SpringBoot，其中要啥starter就自行勾选啥，然后创建的时候要联网，会自动帮你导jar包（就是自动添加依赖啦）。</p><p>不过一开始关于mvn和.gitignore不会用到，删去即可。</p><p>而在src下，我们可以看到src&gt;main&gt;java + resources。在resources目录下，可以看到application.properties + static(包)  + templates(包)</p><p>static包用于存储静态资源，如css 、js；templates包用于存放页面</p><hr /><h1 id="配置文件-yaml用法"><a class="markdownIt-Anchor" href="#配置文件-yaml用法"></a> 配置文件-yaml用法</h1><hr /><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><ul><li>key: value #k，v之间有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li><li>‘’ 与 “” 表示字符串内容，会比如 转义/不转义</li></ul><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li>字面量：单个的、不可再分的值 Date、Boolean、String、number、null</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">k: v<br></code></pre></td></tr></table></figure><ul><li>对象：键值对的集合。 map、hash、set、object</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;<br>或<br>k:<br> k1: v1<br> k2: v2<br> k3: v3<br></code></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: [v1,v2,v3]<br>或<br>k:<br> - v1<br> - v2<br> - v3<br></code></pre></td></tr></table></figure><h1 id="配置文件-自定义类绑定的配置提示"><a class="markdownIt-Anchor" href="#配置文件-自定义类绑定的配置提示"></a> 配置文件-自定义类绑定的配置提示</h1><hr /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加如下依赖:<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>在build&gt;plugins下的spring-boot-maven-plugin插件内添加如下配置，以在打包时舍弃之，减少包的大小<br><span class="hljs-tag">&lt;<span class="hljs-name">configuraion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuraion-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuraion</span>&gt;</span><br></code></pre></td></tr></table></figure><hr /><h1 id="web-静态资源规则与定制化"><a class="markdownIt-Anchor" href="#web-静态资源规则与定制化"></a> Web-静态资源规则与定制化</h1><h2 id="1-静态资源目录"><a class="markdownIt-Anchor" href="#1-静态资源目录"></a> 1. <strong>静态资源目录</strong></h2><p>只要静态资源放在类路径下：</p><p><code>/static</code>(or<code>/public</code>or<code>/resources</code>or<code>/META-INF/resources</code>)</p><p>则可以直接通过：当前项目根路径/ + 静态资源名 <strong>进行访问</strong></p><p><strong>原理：静态映射/**，即拦截所有的请求，而controller也是如此。</strong></p><p><strong>在运行的时候，请求进来，先去找controller看能不能处理，不能处理的所有请求则交给静态资源处理器，若是静态资源处理器也无法处理则报告404</strong></p><p><strong>改变默认的静态资源路径：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">static-locations:</span> [<span class="hljs-string">classpath:/xxx/</span>]<br></code></pre></td></tr></table></figure><h2 id="2-静态资源访问前缀"><a class="markdownIt-Anchor" href="#2-静态资源访问前缀"></a> 2. <strong>静态资源访问前缀</strong></h2><p>默认无前缀。</p><p>之所以要使用这个东西是因为，如果是一个web项目，需要登录后才可以执行某一些操作，若是拦截器拦截/**，则静态资源也会被拦截。为了拦截器可以放行静态资源，因此可以通过静态资源加上访问前缀来过滤掉它们。</p><p>可以通过如下方式在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/res/**</span><br></code></pre></td></tr></table></figure><h2 id="3-支持webjar静态资源访问"><a class="markdownIt-Anchor" href="#3-支持webjar静态资源访问"></a> 3. <strong>支持webjar静态资源访问</strong></h2><p>webjar即是将如css、js等文件通过jar包的形式给出，可通过依赖获得</p><p><a href="https://www.webjars.org/">获取webjar</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以下是一个jQuery的webjar的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>访问形式：localhost:8080/webjars/…(资源详细路径)</p><hr /><h1 id="web-welcome与favicon功能"><a class="markdownIt-Anchor" href="#web-welcome与favicon功能"></a> Web-welcome与favicon功能</h1><h2 id="1-欢迎页支持"><a class="markdownIt-Anchor" href="#1-欢迎页支持"></a> 1. 欢迎页支持</h2><p>用于直接ip:port访问项目，会显示index.html欢迎页</p><ul><li>静态资源路径下放置index.html<ul><li><strong>可以配置静态资源路径</strong></li><li><strong>不可以配置静态资源访问前缀，否则会导致index.html不能默认访问</strong></li></ul></li></ul><h2 id="2-自定义favicon"><a class="markdownIt-Anchor" href="#2-自定义favicon"></a> 2. 自定义Favicon</h2><p>用于更改web项目的小图标，这个在静态资源路径下放置favicon.ico即可，需注意浏览器缓存可能导致的无法显示。同样的也<strong>不可以配置静态资源的访问前缀</strong>，否则会导致其失效</p><hr /><h1 id="静态资源配置原理"><a class="markdownIt-Anchor" href="#静态资源配置原理"></a> 静态资源配置原理</h1><ul><li><p>SpringBoot启动默认加载 xxxAutoConfiguration类(自动配置类)</p></li><li><p>SpringMVC功能的自动配置类 WebMvcAutoConfiguration生效</p><ul><li>那么它给容器中配了些什么呢？</li></ul><p>比如：OrderedHiddenHttpMethodFilter(用来兼容rest风格，表单可以提交PUT、DELETE等)、OrderedFormContentFilter(表单内容过滤器)，然后有一个叫做WebMvcAutoConfigurationAdapter这么一个配置类（那么它肯定也在容器中）。接下来研究一下它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>先看到配置文件，它让WebMvcProperties和ResourceProperties跟对应的配置文件绑定。<strong>spring.mvc==WebMvcProperties 、spring.resources==ResourceProperties</strong></li></ul></li></ul><p>​1. <strong>配置类只有一个有参构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有参构造器所有参数的值都会从容器中确定</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* resourceProperties 获取和spring.resources绑定的所有值的对象</span><br><span class="hljs-comment">* mvcProperties 获取和spring.mvc绑定的所有值的对象</span><br><span class="hljs-comment">* beanFactory Spring的bean工厂</span><br><span class="hljs-comment">* HttpMessageConverters 找到所有的HttpMessageConverters</span><br><span class="hljs-comment">* ResourceHandlerRegistrationCustomizer 找到资源处理器的自定义器</span><br><span class="hljs-comment">* DispatcherServletPath</span><br><span class="hljs-comment">* ServletRegistrationBean 注册servlet、filter...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span><span class="hljs-params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.resourceProperties = resourceProperties;<br>            <span class="hljs-keyword">this</span>.mvcProperties = mvcProperties;<br>            <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>            <span class="hljs-keyword">this</span>.messageConvertersProvider = messageConvertersProvider;<br>            <span class="hljs-keyword">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();<br>            <span class="hljs-keyword">this</span>.dispatcherServletPath = dispatcherServletPath;<br>            <span class="hljs-keyword">this</span>.servletRegistrations = servletRegistrations;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>资源处理的默认规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>       <span class="hljs-comment">// isAddMapping这个玩意是看你要不要使用静态资源的默认规则，可以通过spring.resources.add-mappings来选择使用或关闭，默认使用</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这个是用来设置静态资源的缓存的存活时间，可以通过spring.resources.cache.period设置</span><br>                Duration cachePeriod = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getPeriod();<br>                CacheControl cacheControl = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();<br>                <span class="hljs-comment">// 注册/webjars/**静态资源，且说明其资源路径是META-INF/resources/webjars下，那么之后访问webjars资源则通过访问/webjars/所需访问的资源的层级目录即可！所以这里是webjars的规则（/webjars/**的所有请求，通过类路径下的/META-INF/resources/webjars下拿）</span><br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">&quot;/webjars/**&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br>   <span class="hljs-comment">// 这一段是对静态资源默认路径的配置，先通过mvcProperties获取/**下的所有请求，通过getStaticLocations获取的区域下面拿取静态资源。静态资源都有缓存策略</span><br>                String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();<br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>欢迎页的处理规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HandlerMapping:处理器映射，保存了每一个handler能处理哪些的请求 </span><br><span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title">welcomePageHandlerMapping</span><span class="hljs-params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;<br>            WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="hljs-keyword">new</span> WelcomePageHandlerMapping(<span class="hljs-keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="hljs-keyword">this</span>.getWelcomePage(), <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern());<br>            welcomePageHandlerMapping.setInterceptors(<span class="hljs-keyword">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));<br>            welcomePageHandlerMapping.setCorsConfigurations(<span class="hljs-keyword">this</span>.getCorsConfigurations());<br>            <span class="hljs-keyword">return</span> welcomePageHandlerMapping;<br>        &#125;<br><br><span class="hljs-comment">// 以下是欢迎页处理器映射的构造函数，不难看出，它写死了欢迎页只能在/**下</span><br>WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;<br>    <span class="hljs-comment">// 欢迎页存在且/**等于静态资源路径才可以使用之，否则不行</span><br>        <span class="hljs-keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="hljs-string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;forward:index.html&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page template: index&quot;</span>);<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="请求参数处理"><a class="markdownIt-Anchor" href="#请求参数处理"></a> 请求参数处理</h1><h2 id="请求映射这里说的不是requestmapping而是rest风格的请求映射注解"><a class="markdownIt-Anchor" href="#请求映射这里说的不是requestmapping而是rest风格的请求映射注解"></a> 请求映射(这里说的不是RequestMapping,而是Rest风格的请求映射注解)</h2><ul><li>@xxxMapping</li><li>Rest风格支持*(使用<strong>HTTP请求方式动词</strong>来表示对资源的操作)*<ul><li>以前是通过：/getUser获取用户 /deleteUser删除用户 /editUser修改用户 /saveUser保存用户</li><li>现在是通过： /user （就只这一个访问路径）<ul><li>GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户</li></ul></li><li>核心Filter：HiddenHttpMethodFilter<ul><li><strong>用法： 表单method=post , 隐藏域type=hidden,_method=PUT</strong></li><li><strong>需注意还需要手动开启：spring.mvc.hiddenmethod.filter.enable=true；</strong></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br><br><br>源码部分：<br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span><br>   <span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">       prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span><br><span class="hljs-meta">       name = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">       matchIfMissing = false</span><br><span class="hljs-meta">   )</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> OrderedHiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrderedHiddenHttpMethodFilter();<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>Rest原理(表单提交，且需要使用REST时)</strong></p><ul><li>表单提交会带上_method=PUT</li><li>请求过来的时候会被HiddenHttpMethodFilter拦截<ul><li>请求是否是POST，且是否正常<ul><li>获取到_method的值</li><li>原生request(post)，包装模式requestWrapper重写了getMethod方法，返回的是传入的值(_method=XXX)</li><li>兼容以下请求：<strong>PUT DELETE PATCH等</strong></li><li>过滤链放行的时候使用的是wrapper。以后调用的getMethod方法是调用requestWrapper的。</li></ul></li></ul></li></ul><p><strong>Rest使用客户端工具：</strong></p><ul><li>如postman直接发生put、delete等方式请求，无需filter重新包装</li></ul><p><strong>上述的@RequestMapping(value=“/user”,method=“RequestMethod.POST”)这些注解，可以更改为以下的注解(由上述注解合成而来)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@PutMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>**如何更改默认的_method为我们想要的名字呢？**请看以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>    <span class="hljs-comment">// 组件无依赖故Lite型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span></span>&#123;<br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        hiddenHttpMethodFilter.setMethodParam(<span class="hljs-string">&quot;_m&quot;</span>);<br>        <span class="hljs-keyword">return</span> hiddenHttpMethodFilter;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过使用“用户优先原则”来进行HiddenHttpMethodFilter组件的注册，并设定MethodParam的值，重而实现更改默认的_method！</span><br><br></code></pre></td></tr></table></figure><hr /><h2 id="请求映射原理"><a class="markdownIt-Anchor" href="#请求映射原理"></a> 请求映射原理</h2><hr /><h2 id="普通参数与基本注解"><a class="markdownIt-Anchor" href="#普通参数与基本注解"></a> 普通参数与基本注解</h2><ul><li>注解：</li></ul><p><mark>@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestAttribute、@RequestBody、@MatrixVariable</mark></p><ul><li>Servlet API</li></ul><p><mark>WebRequest、ServletRequest、MultipartRequest、HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、Zoneld</mark></p><ul><li>复杂参数</li></ul><p><mark>Map、Model(<strong>map,model里面的数据会被放在request请求域中</strong>即req.setAttribute(xxx))、Errors/BindingResult、RedirectAttributes(<strong>重定向携带数据</strong>)、ServletResponse(<strong>Response</strong>)、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</mark></p><ul><li>自定义对象参数</li></ul><p><mark>可以自动类型转换和格式化，可以级联封装</mark></p><h3 id="1-注解"><a class="markdownIt-Anchor" href="#1-注解"></a> 1. <strong>注解：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @PathVariable一般接收的是Rest风格的请求，即表单请求，因此使用GetMapping,然后里面的value/path用希望使用者访问的路径和传入的数据，而数据通过&#123;数据名&#125;的形式括起来，在函数的参数部分通过@PathVariable(数据名)来获取数据，并且给到参数；当然也可以通过Map&lt;String,String&gt;的方式来进行直接获取全部的参数，此时在@PathVariable里不需写任何参数。</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;id&quot;</span>,id);<br>       map.put(<span class="hljs-string">&quot;username&quot;</span>,userName);<br>       map.put(<span class="hljs-string">&quot;pv&quot;</span>,pv);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br><span class="hljs-comment">// @RequestHeader获取的是浏览器页面的请求头的kv值，可以通过@RequestHeader(数据名)来获取数据；也可以通过@RequestHeader Map&lt;String,String&gt; rh来获取所有的请求头的内容，此时再@RequestHeader内不需写任何内容。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,<span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;userAgent&quot;</span>,userAgent);<br>       map.put(<span class="hljs-string">&quot;rh&quot;</span>,rh);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br>  <span class="hljs-comment">// @RequestParam获取的请求参数，可以通过@RequestParam(数据名)来获取数据的值；也可以通过@RequestParam Map&lt;String,String&gt;来获取所有的请求参数的信息，这时不需要写数据名，默认全部访问</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;age&quot;</span>,age);<br>       map.put(<span class="hljs-string">&quot;interests&quot;</span>,interests);<br>       map.put(<span class="hljs-string">&quot;rp&quot;</span>,rp);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @CookieValue注解用于获取当前访问内容的cookie值。可通过以下来种方式进行访问：①@CookieValue(cookie的名称) 基本数据类型，则这样获取到的是这个cookie对应的value值；②@CookieValue(cookie的名称) Cookie cookie,则这样获取到的是cookie的对象，里面有其name和value和供我们获得</span><br>   <span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span>Cookie cookie)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;_ga&quot;</span>,_ga);<br>       System.out.println(cookie.getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + cookie.getValue());<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @RequestBody获取请求体，这个只有post请求才有请求体。可以通过这样来获取表单的kv数据。@RequestBody String content</span><br><span class="hljs-meta">@PostMapping(&quot;/save&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String content)</span></span>&#123;<br>       Map map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;内容&quot;</span>,content);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 搭配上述内容使用的HTML文件 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>com.ayy.test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HelloIndexHtml<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;POST-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;car/3/owner/zhangsan?age=18&amp;interest=basketball&amp;interest=tennis&quot;</span>&gt;</span>car/&#123;id&#125;/owner/&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@PathVariable 路径变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestHeader 获取请求头<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestParam 获取请求参数<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@CookieValue 获取Cookie值<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestAttribute 获取request域属性<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestBody 获取请求体<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@MatrixVariable 矩阵变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/save&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Pwd&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;passwd&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Usr&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usrName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/sell;price=300000;brand=BYD,AUTO,TESLA&quot;</span>&gt;</span>MatrixVariable111 /cars/sell;price=300000;brand=BYD,AUTO,TESLA<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/boss;id=666/emp;id=888&quot;</span>&gt;</span>MatrixVariable222 /cars/boss;id=666/emp;id=888<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @RequestAttribute获取request域的属性。request可以通过setAttribute方法来设置属性，而request是在一次请求中生效。这就要说下forward和redirect两个的区别先。</span><br><span class="hljs-comment">// forward是直接转发，它只需要客户端发起一次的请求即可；而redirect(重定向/间接转发)是客户端发起两次请求。服务器端在响应第一次请求的时候，让浏览器再向另一个URL发出请求，从而达到转发的目的。</span><br><span class="hljs-comment">// 因此本次测试，需要采用forward直接转发的方式</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此例子用于显示HttpServletRequest 和 <span class="hljs-doctag">@RequestAttribute</span>注解提取request的域属性，需用forward进行直接请求转发，redirect这个是间接转发要进行</span><br><span class="hljs-comment">     * 两次请求，不符要求</span><br><span class="hljs-comment">     * 在默认情况下，无<span class="hljs-doctag">@ReponseBody</span>默认进行页面跳转</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/goto&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">gotoNextPage</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        request.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        request.setAttribute(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(&quot;user&quot;)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-meta">@RequestAttribute(&quot;status&quot;)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                           HttpServletRequest request)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>        map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MatrixVariable是矩阵变量，需要与PathVariable路径变量结合起来使用。且一般存放的是cookie的kv</span><br><span class="hljs-comment">// 我们通过PathVariable设置访问路径，而MatrixVariable是在路径变量;后的那一大串，当然也可以通过另一个路径变量相隔开。</span><br><span class="hljs-comment">// 矩阵变量的例子： localhost://car/sell;price=200000;brand=BYD,AUTO,TESLA</span><br><span class="hljs-comment">// 其中同一个k的多个v也可以用分号拆开(brand=BYD;brand=AUTO;brand=TESLA)，这里的sell就是PathVariable，后面的;到结尾都是MatrixVariable。</span><br><span class="hljs-comment">// 那么通过路径来显示就是/car/&#123;path;price=xxx;brand=xxx,yyy,zzz&#125; ，这里可以看出MatrixVariable必须依靠PathVariable而存在</span><br><span class="hljs-comment">// 需要跟RequestParam进行区分/car/&#123;path&#125;?price=xxx&amp;brand=xxx，这里可以看出PathVariable和RequestParam是独立的两个个体</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarSell</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;path&quot;)</span> String path,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;price&quot;)</span> Integer price,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;path&quot;</span>,path);<br>        map.put(<span class="hljs-string">&quot;price&quot;</span>,price);<br>        map.put(<span class="hljs-string">&quot;brand&quot;</span>,brand);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 需注意，以下此物默认关闭，需自定义组件UrlPathHelper来开启</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">webMvcConfigurer</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;<br>                UrlPathHelper urlPathHelper=<span class="hljs-keyword">new</span> UrlPathHelper();<br>                <span class="hljs-comment">// 开启不移除分号功能，这样才可以使MatrixVariable生效</span><br>                urlPathHelper.setRemoveSemicolonContent(<span class="hljs-keyword">false</span>);<br>                configurer.setUrlPathHelper(urlPathHelper);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-comment">// 若是存在/car/1;age=20/2;age=30这种情况，则可以利用MatrixVariable的参数pathVar来设定区域，否则若是直接根据k取age会都取到第一个。</span><br><span class="hljs-comment">//    /cars/boss;id=666/emp;id=888</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path1&#125;/&#123;path2&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarDetail</span><span class="hljs-params">(<span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path1&quot;)</span> Integer bid,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path2&quot;)</span> Integer eid)</span></span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;bid&quot;</span>,bid);<br>        map.put(<span class="hljs-string">&quot;eid&quot;</span>,eid);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 小拓展：一般来说我们若是将cookie功能禁掉，是无法访问到session的，因为session-&gt;jsessionId相关联-&gt;而jsessionId是存放在cookie-&gt;cookie在每一次的请求中都会被带上，但若是禁掉，就无法获得jessionId，就无法获得session。但现在可以通过矩阵变量的方式去获得(具体不清晰！！！)</span><br></code></pre></td></tr></table></figure><h3 id="2-servlet-api"><a class="markdownIt-Anchor" href="#2-servlet-api"></a> 2. Servlet API</h3><p>就如上面所说的那么多的Servlet API，是怎么通过Resolver（即参数解析器）来实现对应参数获取的？此外，注解获得的参数，也是通过参数解析器实现参数的获取。</p><p>以下以HttpServletRequest这个ServletAPI来展示如何通过参数解析器来获取之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ServletRequestMethodArgumentResolver</span><br>WebRequest.class.isAssignableFrom(paramType) || <br>ServletRequest.class.isAssignableFrom(paramType) || <br>MultipartRequest.class.isAssignableFrom(paramType) || <br>HttpSession.class.isAssignableFrom(paramType) || <br>pushBuilder != <span class="hljs-keyword">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType) ||<br>Principal.class.isAssignableFrom(paramType) || <br>InputStream.class.isAssignableFrom(paramType) || <br>Reader.class.isAssignableFrom(paramType) || <br>HttpMethod.class == paramType || <br>Locale.class == paramType || <br>TimeZone.class == paramType || <br>ZoneId.class == paramType;<br><span class="hljs-comment">// WebRequest == Request + Response + ...</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">resolveNativeRequest</span><span class="hljs-params">(NativeWebRequest webRequest, Class&lt;T&gt; requiredType)</span> </span>&#123;<br>        T nativeRequest = webRequest.getNativeRequest(requiredType);<br>        <span class="hljs-keyword">if</span> (nativeRequest == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Current request is not of type [&quot;</span> + requiredType.getName() + <span class="hljs-string">&quot;]: &quot;</span> + webRequest);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> nativeRequest;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 此时即返回原生的request。因此这是通过resolver实现ServletAPI参数获取的一个展示。可通过debug逐步寻找</span><br></code></pre></td></tr></table></figure><h3 id="3-复杂参数"><a class="markdownIt-Anchor" href="#3-复杂参数"></a> 3. 复杂参数</h3><p>对于复杂参数：<strong>Model、Map它俩存放的区域是request的请求域(渲染时存放的)，即request attribute那个东西。以下例子通过直接转发来体现之：访问localhost:8080/params -&gt; localhost:8080/success</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/params&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(Map&lt;String,Object&gt; map,</span></span><br><span class="hljs-params"><span class="hljs-function">                        Model model,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletRequest req,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletResponse resp)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,<span class="hljs-string">&quot;map content&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;md&quot;</span>,<span class="hljs-string">&quot;model content&quot;</span>);<br>    req.setAttribute(<span class="hljs-string">&quot;req&quot;</span>,<span class="hljs-string">&quot;request content&quot;</span>);<br><br>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>);<br>    resp.addCookie(cookie);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(value =&quot;user&quot;,required = false)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-meta">@RequestAttribute(value = &quot;status&quot;,required = false)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                       HttpServletRequest request)</span></span>&#123;<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>    map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;map1&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;md&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;md&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;req&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;req&quot;</span>));<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-自定义对象的参数"><a class="markdownIt-Anchor" href="#4-自定义对象的参数"></a> 4. 自定义对象的参数</h3><p>它是通过一个叫“数据绑定”的东西：当页面提交的请求数据(GET、POST)都可以和对象属性进行绑定，包括级联绑定。以下是数据绑定的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/saveUser&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">saveUser</span><span class="hljs-params">(Person person)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> person;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/saveUser&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;birth&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000/1/5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="响应处理"><a class="markdownIt-Anchor" href="#响应处理"></a> 响应处理</h1><hr /><h2 id="响应json"><a class="markdownIt-Anchor" href="#响应json"></a> 响应JSON</h2><h3 id="jacksonjar-responsebody"><a class="markdownIt-Anchor" href="#jacksonjar-responsebody"></a> jackson.jar +  ResponseBody</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>web场景自动引入了Json场景<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以通过jackson.jar包和@ResponseBody注解返回给前端json数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Person person;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/response/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.person;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个返回值是如何变成了json数据的格式呢？</p><p>先前说过ArgumentResolver参数解析器，在确定方法的参数值的时候，会用各种参数解析器来确定；</p><p>而现在有ReturnValueHandler，故可知springmvc对返回值的所有解析也是采取了返回值解析器的方法。</p><hr /><h2 id="returnvaluehandler原理"><a class="markdownIt-Anchor" href="#returnvaluehandler原理"></a> ReturnValueHandler原理</h2><hr /><h2 id="httpmessageconverter原理"><a class="markdownIt-Anchor" href="#httpmessageconverter原理"></a> HTTPMessageConverter原理</h2><hr /><h2 id="内容协商原理"><a class="markdownIt-Anchor" href="#内容协商原理"></a> 内容协商原理</h2><hr /><h2 id="基于请求参数的内容协商原理"><a class="markdownIt-Anchor" href="#基于请求参数的内容协商原理"></a> 基于请求参数的内容协商原理</h2><hr /><h2 id="自定义messageconverter"><a class="markdownIt-Anchor" href="#自定义messageconverter"></a> 自定义MessageConverter</h2><hr /><h2 id="浏览器与postman内容协商完全适配"><a class="markdownIt-Anchor" href="#浏览器与postman内容协商完全适配"></a> 浏览器与PostMan内容协商完全适配</h2><hr /><h1 id="视图解析与模板引擎"><a class="markdownIt-Anchor" href="#视图解析与模板引擎"></a> 视图解析与模板引擎</h1>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
