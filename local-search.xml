<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/12/21/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><ol><li>wget URL</li><li>tar xzf packageName</li><li>在有makefile文件下make(可以通过make install prefix=/usr/local/redis自定义安装的位置)</li></ol><h2 id="redis文件含义"><a href="#redis文件含义" class="headerlink" title="redis文件含义"></a>redis文件含义</h2><p>安装完redis后，它会产生一系列文件，对应的文件解释如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">./redis-benchmark //用于进行redis性能测试的工具<br>./redis-check-dump //用于修复出问题的dump.rdb文件<br>./redis-cli //redis的客户端<br>./redis-server //redis的服务端<br>./redis-check-aof //用于修复出问题的AOF文件<br>./redis-sentinel //用于集群管理<br></code></pre></td></tr></table></figure><h2 id="redis服务端"><a href="#redis服务端" class="headerlink" title="redis服务端"></a>redis服务端</h2><p>redis-server即为redis服务端，可以直接通过./redis-server启动，但这是前台启动。</p><p>后台启动则通过将守护进程daemonize设为yes，然后利用配置文件启动服务端即可。（./redis-server ./redis.conf）</p><p>更多的关于redis.conf的配置可以看：<a href="https://www.runoob.com/redis/redis-conf.html">redis.conf配置</a></p><p>redis服务端<strong>默认端口为6379</strong></p><h2 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h2><h3 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h3><p>&nbsp;&nbsp;redis是key:value存储系统，所谓的redis数据结构其实指的是value的数据结构</p><h4 id="strings-字符串"><a href="#strings-字符串" class="headerlink" title="strings 字符串"></a>strings 字符串</h4><ul><li>set key value </li><li>get key</li></ul><h4 id="lists-字符串列表"><a href="#lists-字符串列表" class="headerlink" title="lists 字符串列表"></a>lists 字符串列表</h4><p>&nbsp;&nbsp;redis的list底层实现是链表</p><ul><li>lpush key value</li><li>rpush key value</li><li>lrange key start stop</li></ul><h4 id="sets-字符串集合"><a href="#sets-字符串集合" class="headerlink" title="sets 字符串集合"></a>sets 字符串集合</h4><p>&nbsp;&nbsp;redis的set是无序集合，可以做集合能做的事情，如交并差等</p><ul><li>sadd key value </li><li>smembers key</li><li>sismember key value</li><li>sunion key1 key2 […keyn] </li></ul><h4 id="sorted-sets-字符串有序集合"><a href="#sorted-sets-字符串有序集合" class="headerlink" title="sorted sets 字符串有序集合"></a>sorted sets 字符串有序集合</h4><p>&nbsp;&nbsp;redis中的有序集合是通过加入score这一字段来实现有序性的，且因为其命令以z开头，因此redis的有序集合称为zsets</p><ul><li>zadd key score value </li><li>zrange key start stop [rev]</li></ul><h4 id="hashes-哈希"><a href="#hashes-哈希" class="headerlink" title="hashes 哈希"></a>hashes 哈希</h4><p>&nbsp;&nbsp;类似于bean，可以用一个key存储一系列的键值对信息</p><ul><li>hset key filed value […field value]</li><li>hgetall key</li><li>hget key field</li></ul><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>&nbsp;&nbsp; <strong>redis的持久化有两种方式，分别是RDB（redis database）和AOF(append only file)</strong></p><p>&nbsp;&nbsp;二者可同时使用，若redis重启，则优先采用AOF来进行数据恢复</p><h3 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h3><p>&nbsp;&nbsp;RDB是指在不同时间点将redis存储的数据通过生成快照的方式存储在磁盘上；</p><p>&nbsp;&nbsp;RDB如何持久化：单独fork一个子进程来完成持久化这项工作，主进程不进行任何IO操作；子进程会先将数据写入到一个临时文件中，待持久化结束，会将这个临时文件替换上次持久化好的文件。</p><p>&nbsp;&nbsp;若是对数据完整性并不敏感，则可以用RDB来恢复数据。（因为RDB持久化是隔一段时间进行一次的，所以会丢失部分的数据）</p><h3 id="持久化之AOF"><a href="#持久化之AOF" class="headerlink" title="持久化之AOF"></a>持久化之AOF</h3><p>&nbsp;&nbsp;AOF（Append Only File 只许追加不许改写）是将redis执行过的所有写指令记录下来</p><p>&nbsp;&nbsp;利用AOF来恢复数据的话，它会从前往后的将指令执行一遍</p><p>&nbsp;&nbsp;如何配置：redis.conf里有个appendonly将其改为yes即打开了AOF功能，若有写操作，则会被追加到AOF文件的末尾</p><p>&nbsp;&nbsp;<strong>插入内容（方便下文理解）：</strong></p><p>Linux的同步IO（sync、fsync、fdatasync）</p><p>&nbsp;&nbsp;之所以会出现以上那些个同步IO是因为：传统的unix系统的磁盘IO是通过<strong>缓冲</strong>来进行的，是通过在内核中设有对应的<strong>缓冲区高速缓存</strong>或<strong>页高速缓存</strong>来实现的。</p><p>&nbsp;&nbsp;<strong>当我们将数据写入文件时，内核将数据复制到缓冲区中，只有当缓冲区写满或内核需要重用缓冲区时，才会将里面的数据冲去输出队列，至队首才进行真正的IO，此即为延迟写</u></strong></p><p>&nbsp;&nbsp;延迟写会带来：数据更新慢以至更新的数据丢失等的情况，因此有上面的同步方法的出现，用于：**<u>保证磁盘上的文件与缓冲区高速缓存中内容的一致性</u>**</p><ul><li>sync</li></ul><p>将缓冲区中的内容冲到输出队列即返回，并不等待实际的写磁盘结束。</p><ul><li>fsync</li></ul><p>将指定的文件描述符中处于缓冲区的内容冲到输出队列，且等待实际的写磁盘结束后才返回。</p><p>既影响文件的数据部分，又影响文件的属性部分(metadata(size、access_time、modify_time…))</p><p>两次IO（数据部分与属性部分置于不同磁盘块）</p><ul><li>fdatasync</li></ul><p>与fsync类似，但只影响文件的数据部分，不影响属性部分</p><p>一次IO</p><p>&nbsp;&nbsp;<strong>插入完毕</strong></p><p>&nbsp;&nbsp;<strong>默认的AOF持久化策略为每秒fsync一次</strong>。此时可以让redis保持良好的性能，在丢失数据时，最多也是最近1秒的数据</p><p>&nbsp;&nbsp;如果遇到一些特殊情况：追加时遇到磁盘满、inode满、断电等情况，<strong>可以通过redis-check-aof工具来进行日志修复</strong></p><p>&nbsp;&nbsp;<strong><u>因为AOF采用追加方式，所以在不额外做处理的情况下，文件会越来越大，因此，redis提供了AOF文件重写(rewrite)机制</u><strong>，所谓的AOF重写机制指的是：</strong>AOF文件的大小超过阈值，redis会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集（如INCR 100次，不如INCRBY KEY 100）</strong></p><p>&nbsp;&nbsp;<strong>如何重写呢：</strong></p><pre><code>      1. redis fork 重写子进程，读取现有 AOF文件，将其指令进行分析压缩后写入到一个临时文件中；      2. 主进程则将新接收的写指令放入缓冲区中，也写入到原AOF文件中（避免重写遇断电，无法恢复）；      3. 重写子进程重写完毕后，会给父进程发信号，父进程收到后会将缓冲区的写指令追加到新AOF文件中；      4. 追加完毕后，redis用新AOF文件替代旧的AOF文件。</code></pre><h3 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h3><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>数据敏感性</td><td>较差</td><td>较好</td></tr><tr><td>数据恢复速度</td><td>较快</td><td>较慢</td></tr><tr><td>文件体积</td><td>较小</td><td>较大</td></tr></tbody></table><h2 id="redis主从"><a href="#redis主从" class="headerlink" title="redis主从"></a>redis主从</h2><p>&nbsp;&nbsp;redis支持主从同步，也有一主多从、多级从结构</p><p>&nbsp;&nbsp;redis的主从同步是异步进行的</p><ul><li><p><strong>如何进行主从同步的呢：</strong></p><ol><li><p>从服务器发出SYNC给主服务器，主服务器接收后，调用BGSAVE来创建子进程进行数据持久化工作（即将数据写入RDB文件中）；</p></li><li><p>在持久化工作完成前，主服务器的写指令缓存在内存中；</p></li><li><p>BGSAVE完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器会将其存到磁盘上，然后读到内存中。之后主服务器会将期间缓存的写指令以redis协议的格式发给从服务器。</p></li></ol></li><li><p><strong>如果有多个从服务器发送SYNC指令呢？</strong></p><p>那也只会执行一次BGSAVE，只需把持久化好的RDB文件发给多个下游就好</p></li><li><p><strong>主从同步分为：</strong></p><ul><li><p>全量同步（即上面所介绍的“如何进行主从同步的呢”，初次连接都是全量同步）</p><p> <img src="https://s2.loli.net/2021/12/21/Ab7wOClYSaFx6ji.png" alt="Redis_主从同步_全量同步.jpg"></p></li><li><p>增量同步（Redis 2.8 之后有）</p><p>增量同步指的是：主服务器每执行一个写指令时会向从服务器发送相同的写指令，从服务器接收并执行对应的写指令。</p><p><strong>增量同步如何进行？</strong></p><p>&nbsp;&nbsp;==未写待续…==</p></li></ul></li><li><p><strong>Redis主从同步策略</strong></p><p>主从刚刚连接的时候，进行全量同步；全量同步结束后，进行增量同步。</p><p>当然，如果有需要，slave 在任何时候都可以发起全量同步。</p><p>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p></li></ul><h2 id="redis事务处理"><a href="#redis事务处理" class="headerlink" title="redis事务处理"></a>redis事务处理</h2><p>&nbsp;&nbsp;<strong>在redis中，与事务处理相关的指令有以下四个：</strong></p><ul><li><p>multi</p><p>&nbsp;&nbsp;用于组装事务</p></li><li><p>exec</p><p>&nbsp;&nbsp;用于执行事务</p></li><li><p>discard</p><p>&nbsp;&nbsp;用于取消事务</p></li><li><p>watch</p><p>&nbsp;&nbsp;<strong>用于监视key（可多个），当被监视的key在<u>multi</u>之前有改变时，无论事务的内容是否关于该key，都会返回nil；若是被监视的key没有改变，则正常执行</strong></p></li></ul><p>&nbsp;&nbsp;<strong>在使用事务时可能遇到的错误：</strong></p><ul><li><p>执行前的错误</p><p>&nbsp;&nbsp;即语法错误或内存错误导致，在编写事务的某一条指令后会报错(exec前)，之后调用exec指令时，会拒绝执行该事务（2.6.5版本之后）</p></li><li><p>执行后的错误</p><p>&nbsp;&nbsp;即应用层的错误，如sadd myset “a”;lpush myset “b”;可看出，myset于这两条指令中被使用了不同数据结构的指令。redis在执行此条事务时不会理睬这些错误，而是继续向下执行其他指令（不会影响其他指令的执行，也不会影响该条指令入列），事务最终可以被执行</p></li></ul><h2 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h2><p>&nbsp;&nbsp;redis的配置文件为：redis.conf(Linux下)，其支持在主配置文件中引入外部的配置文件，如：</p><p><code>include /home/ayy/...</code></p><p>&nbsp;&nbsp;redis配置文件被划分为如下几部分：</p><ol><li><p>general</p></li><li><p>snapshotting</p></li><li><p>replication</p></li><li><p>security</p></li><li><p>limits</p></li><li><p>append only mode</p></li><li><p>lua scripting</p></li><li><p>slow log</p></li><li><p>event notification</p></li><li><p>gopher server</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用高级命令</title>
    <link href="/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/21/linux%E5%B8%B8%E7%94%A8%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>&nbsp;&nbsp;功能：用于<strong>查找文件</strong><br>&nbsp;&nbsp;基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find 查找路径 查找条件<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;查找条件：</p><ul><li><p>-name<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;a.txt&quot;<br>查找当前目录下（含子目录）名称为“a.txt”的文件<br></code></pre></td></tr></table></figure></li><li><p>-type<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f <br>查找当前目录下（含子目录）的普通文件<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;linux下文件类型主要有以下几种：</p></li></ul><table><thead><tr><th align="center">字母</th><th align="center">文件类型</th></tr></thead><tbody><tr><td align="center">f(file)</td><td align="center">普通文件</td></tr><tr><td align="center">d(directory)</td><td align="center">目录</td></tr><tr><td align="center">b(block)</td><td align="center">块设备</td></tr><tr><td align="center">s(socket)</td><td align="center">套接字</td></tr><tr><td align="center">c(char)</td><td align="center">字符设备</td></tr><tr><td align="center">l(link含硬链接和软链接)</td><td align="center">链接</td></tr><tr><td align="center">p(pipe)</td><td align="center">管道</td></tr></tbody></table><ul><li><p>-user<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -user &quot;ayyHA&quot;<br>查找当前目录下（含子目录）user为ayyHA的文件<br></code></pre></td></tr></table></figure></li><li><p>-group<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -group &quot;test&quot;<br>查找当前目录下（含子目录）group为test的文件<br></code></pre></td></tr></table></figure></li><li><p>-not<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -not -type f<br>查找当前目录下（含子目录）文件类型为非普通文件的文件<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;-not也可以用!来替换，二者等价</p></li><li><p>-a -o<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -a -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -type f -o -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）文件类型为普通文件或以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：默认情况是-a，即查找条件是合取的关系。</p></li><li><p>-maxdepth -mindepth<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -maxdepth 2 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最大深度为2且以md结尾的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mindepth 1 -name &quot;<span class="hljs-emphasis">*md&quot;</span><br><span class="hljs-emphasis">查找当前目录下（含子目录）最小深度为1且以md结尾的文件</span><br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：当前目录下即为深度为1，往下的每一个子目录深度便加1。</p></li><li><p>-size<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -size 10k<br>查找当前目录下（含子目录）大小为10K的文件<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：+10K表示比10K大的文件；-10K表示比10K小的文件。</p></li><li><p>-perm<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -perm 644<br>查找当前目录下（含子目录）文件权限为644的文件（此为精确匹配）<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：权限值若是写成-404则表明只要user权限为r且other权限为r即可，只要满足了这两个条件的文件就都会被筛选出来；权限值若是写成了/404则表明只要user权限为r或other权限为r即可，只要满足了两个条件的其中一个就会被筛选出来。</p></li><li><p>-atime -ctime -mtime<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -mtime -7 <br>查找当前目录下（含子目录）的文件在7天内有进行过修改的<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：其余两个类似，不赘述。（对数字前添加‘+’/‘-’表示‘大于’/‘小于’）</p></li><li><p>-exec 命令 {} ;<br>&nbsp;&nbsp;此查找条件意思为：对<strong>查找到的文件执行(execute)命令</strong>，其中<strong>{}代表的是查找到的文件</strong>。<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">find ./ -name &quot;<span class="hljs-emphasis">*md&quot; -exec cat &#123;&#125; \;</span><br><span class="hljs-emphasis">对查找到的以md结尾的文件执行cat命令。</span><br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;注：有个<code>-ok 命令 &#123;&#125; \;</code>与该命令相似，但它会询问查找到的文件是否执行该命令(y/n)。</p></li></ul><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>&nbsp;&nbsp;功能：用于统计行数(line)、单词数(word)、字节数(char,内存占1byte)<br>&nbsp;&nbsp;基本格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc 统计条件 文件名<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;统计条件：</p><ul><li><p>-l<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -l ./text.txt<br>用于统计text.txt文件的行数<br></code></pre></td></tr></table></figure></li><li><p>-w<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -w ./text.txt<br>用于统计text.txt文件的单词数<br></code></pre></td></tr></table></figure></li><li><p>-c<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -c ./text.txt<br>用于统计text.txt文件的字节数<br></code></pre></td></tr></table></figure></li><li><p>-m<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -m ./text.txt<br>用于统计text.txt文件的字符数（一个汉字在utf8编码里是3个字节，利用-c不方便统计字符数）<br></code></pre></td></tr></table></figure></li><li><p>-L<br>&nbsp;&nbsp;e.g.:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">wc -L ./text.txt<br>用于统计text.txt文件最长行的长度<br></code></pre></td></tr></table></figure></li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>&nbsp;&nbsp;功能：依据条件进行过滤，找到满足条件的行<br>&nbsp;&nbsp;基本格式；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">grep [option] pattern file<br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;option：<br>以下示例所用文本均为下图所示：</p><p><img src="https://s2.loli.net/2021/12/22/1HB2myCgfSLURvZ.png" alt="grep option test file.png"></p><ul><li><p>-E<br>&nbsp;&nbsp;作用：pattern匹配转为扩展正则表达式，等价于egrep命令。</p></li><li><p>-i<br>&nbsp;&nbsp;作用：忽略大小写，ignore。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/MNxbnQC4cFoI3yt.png" alt="grep -i.png"></p></li><li><p>-v<br>&nbsp;&nbsp;作用：反向查询，类似取反，invert。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/xgBqR1JAsXLakEF.png" alt="grep -v.png"></p></li><li><p>-n<br>&nbsp;&nbsp;作用：输出行号，number。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/4fEnBglMyROKLIa.png" alt="grep -n.png"></p></li><li><p>-w<br>&nbsp;&nbsp;作用：匹配整个单词，字符串内出现的不匹配，word。<br>&nbsp;&nbsp;在原来的文本上补加了一些内容用以演示，演示文本如下图所示：<br><img src="https://s2.loli.net/2021/12/22/z8CVugykKlm3jDW.png" alt="grep option test file2.png"><br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/MVeg9XinhKbmp8H.png" alt="grep -w.png"></p></li><li><p>-c<br>&nbsp;&nbsp;作用：统计匹配到的行数，count。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/BivsRuxHTD4Fc75.png" alt="grep -c.png"></p></li><li><p>-o<br>&nbsp;&nbsp;作用：只显示匹配到的字符串，不显示其所在行的内容。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/2G1ietD6KTlsEfw.png" alt="grep -o.png"></p></li><li><p>-Ax<br>&nbsp;&nbsp;作用：输出匹配到内容所在行的后x行的内容，after x。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/aP2fjGeyrdRHVt7.png" alt="grep -Ax.png"></p></li><li><p>-Bx<br>&nbsp;&nbsp;作用：输出匹配到内容所在行的前x行的内容，before x。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/3SR7Fq9IuaXrt81.png" alt="grep -Bx.png"></p></li><li><p>-Cx<br>&nbsp;&nbsp;作用：输出匹配到内容所在行的前后x行的内容，context x。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/VQLbpYTBtfgrXw7.png" alt="grep -Cx.png"></p></li><li><p>-e<br>&nbsp;&nbsp;作用：实现多个匹配，相当于or。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/2QNHo4A6UgLjZdP.png" alt="grep -e.png"></p></li><li><p>-q<br>&nbsp;&nbsp;作用：安静模式，只关心结果，即有没有匹配到。匹配到为0，匹配不到为1，文件有误为2，quiet。<br>&nbsp;&nbsp;演示如下：<br><img src="https://s2.loli.net/2021/12/22/bF7aTqXPDpZiU45.png" alt="grep -q.png"></p></li></ul><div class="note note-info">            <p>&nbsp;&nbsp;注：如果在使用grep匹配关键字时，匹配到的关键字没高亮，可以通过在命令<code>grep --color=auto &quot;word&quot; file</code>中添加<code>--color=auto</code>来开启；也可以通过alias命令重申一下grep命令<code>alias &quot;grep=grep --color=auto&quot;</code>来达到效果。</p>          </div><h3 id="pattern（均为扩展正则表达式）"><a href="#pattern（均为扩展正则表达式）" class="headerlink" title="pattern（均为扩展正则表达式）:"></a>pattern（均为扩展正则表达式）:</h3><h4 id="单个字符匹配相关"><a href="#单个字符匹配相关" class="headerlink" title="单个字符匹配相关"></a>单个字符匹配相关</h4><ul><li>.<br>&nbsp;&nbsp;作用：匹配<strong>任意</strong>的单个字符<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>[  ]<br>&nbsp;&nbsp;作用：匹配<strong>指定范围内</strong>的任意单个字符<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>[^  ]<br>&nbsp;&nbsp;作用：匹配<strong>指定范围外</strong>的任意单个字符<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>[0-9] / [[:digit:]]<br>&nbsp;&nbsp;作用：[0-9]和[[:digit:]]功能一样，匹配[0,9]间任意的单个数字<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>[a-zA-z] / [[:alpha:]]<br>&nbsp;&nbsp;作用：[a-zA-z]和[[:alpha:]]功能一样，匹配单个任意的大小写字母<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>[^0-9] / [^[:digit:]]<br>&nbsp;&nbsp;作用：[^0-9]和[^[:digit:]]功能一样，匹配单个非数字字符<br>&nbsp;&nbsp;演示如下：</li></ul><h4 id="次数匹配相关"><a href="#次数匹配相关" class="headerlink" title="次数匹配相关"></a>次数匹配相关</h4><ul><li>?<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符0次或1次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>+<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符至少1次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>*<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符至少0次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>{n}<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符n次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>{n,}<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符至少n次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>{,m}<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符至多m次，最少可以是0次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>{n,m}<br>&nbsp;&nbsp;作用：<strong>匹配其前面的字符至少n次，至多m次</strong><br>&nbsp;&nbsp;演示如下：</li></ul><h4 id="位置匹配相关"><a href="#位置匹配相关" class="headerlink" title="位置匹配相关"></a>位置匹配相关</h4><ul><li>^<br>&nbsp;&nbsp;作用：其后跟着的内容需位于<strong>行首</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>$<br>&nbsp;&nbsp;作用：其前跟着的内容需位于<strong>行尾</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>\&lt; / \b<br>&nbsp;&nbsp;作用：其后跟着的内容需位于<strong>词首</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>\&gt; / \b<br>&nbsp;&nbsp;作用：其前跟着的内容需位于<strong>词尾</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>\B<br>&nbsp;&nbsp;作用：匹配非词首或非词尾的内容（具体看它放在单词前还是后）<br>&nbsp;&nbsp;演示如下：</li></ul><h4 id="分组和后向引用"><a href="#分组和后向引用" class="headerlink" title="分组和后向引用"></a>分组和后向引用</h4><ul><li>()<br>&nbsp;&nbsp;作用：分组内部的内容为一个<strong>整体</strong>，<strong>可嵌套</strong>使用<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>\x<br>&nbsp;&nbsp;作用：后向引用分组，<strong>匹配分组x相同的内容</strong><br>&nbsp;&nbsp;演示如下：</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><br>&nbsp;&nbsp;作用：转义符<br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>|<br>&nbsp;&nbsp;作用：表示<strong>或</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>.*<br>&nbsp;&nbsp;作用：类似<strong>通配符</strong>，可<strong>匹配任意字符的任意内容</strong><br>&nbsp;&nbsp;演示如下：</li></ul><ul><li>^$<br>&nbsp;&nbsp;作用：<strong>表示空行</strong><br>&nbsp;&nbsp;演示如下：</li></ul><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>&nbsp;&nbsp;功能：查询磁盘目录下文件的大小 disk usage<br>&nbsp;&nbsp;常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -h<br>查询当前目录下（递归查询）文件的大小，最后输出目录总大小，会以K，M，G的格式写明文件大小。human readable<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">du -s<br>查询当前目录下文件的总计大小，只输出总文件大小。 summarize<br></code></pre></td></tr></table></figure><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>&nbsp;&nbsp;功能：查询文件系统的使用情况 disk file system<br>&nbsp;&nbsp;常用方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">df -h<br>查询当前盘符的使用情况，以人类可读的方式输出。human readable<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim的基础使用</title>
    <link href="/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/17/Vim%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Vim的几种模式"><a href="#Vim的几种模式" class="headerlink" title="Vim的几种模式"></a>Vim的几种模式</h2><ul><li><strong>normal模式</strong><br>&nbsp;&nbsp;默认模式，此模式下你可以输入命令，如利用<code>/ + 单词</code>来进行搜索，又或者利用yp进行cv操作；</li><li><strong>编辑模式</strong><br>&nbsp;&nbsp;通过输入i(insert)/a(append)/o(open a line)进入编辑模式，可以进行文本的编辑操作；</li><li><strong>命令模式</strong><br>&nbsp;&nbsp;就是在normal模式下输命令，比如分屏：<code>:vs</code>竖分屏； <code>:sp</code>横分屏</li><li><strong>可视化模式</strong><br>&nbsp;&nbsp;所谓的可视化模式用于选择文本，在normal模式下使用<code>v</code>可以进入visual模式，可选择的最小单位是每一个字符；使用<code>V</code>可以进入visual line模式，顾名思义，可选择的最小单位是每一行；使用<code>ctrl + v</code>可以进入visual block模式，可以以矩阵的方式进行文本选择。</li></ul><h2 id="编辑模式下的小技巧"><a href="#编辑模式下的小技巧" class="headerlink" title="编辑模式下的小技巧"></a>编辑模式下的小技巧</h2><ul><li><code>ctrl + h</code> 删除上一个编辑的字符</li><li><code>ctrl + w</code> 删除上一个编辑的单词</li><li><code>ctrl + u</code> 删除当前行<br>上述的快捷键也可以用于终端；</li><li><code>ctrl + [</code> insert模式切换到normal模式</li><li><code>gi</code>快速跳转到最后一次编辑的地方并进入插入模式</li></ul><h2 id="Vim移动"><a href="#Vim移动" class="headerlink" title="Vim移动"></a>Vim移动</h2><ul><li><code>hjkl</code>即是vim normal模式下的左下上右键；</li><li>w/W移到下一个单词开头</li><li>e/E移到下一个单词结尾</li><li>b/B移到上一个单词开头 back word<div class="note note-info">            <p>&nbsp;&nbsp;上面移动的小写和大写的区别在于：<br>小写指的是以非空白符分割的单词；<br>大写指的是以空白符分割的单词；</p>          </div></li><li><code>f + &lt;char&gt;</code>可以移动到<strong>行内</strong>第一个符合的字符上，若不符合，可以通过<code>;</code>或<code>,</code>进行搜索下一个或上一个；大写的F则表示反向搜索，而非正向搜索；<div class="note note-info">            <p>&nbsp;&nbsp;上面的f可以理解为find,使用<code>f + &lt;char&gt;</code>可以到达寻找的字符；<br>&nbsp;&nbsp;而若是用<code>t + &lt;char&gt;</code>则可以寻找到要找的字符前一位，此处的t可以理解为to；</p>          </div></li><li><code>0</code>可以移动到当前行的行首；</li><li><code>$</code>可以移动到当前行的行尾；</li><li><code>^</code>可以移动到当前行的首个非空字符；</li><li><code>g_</code>可以移动到当前行的最后一个非空字符；</li><li><code>gg/G</code>移动到文件开头或结尾；</li><li><code>H/M/L</code>可以跳转到屏幕的开头(Head)/中间(Middle)/结尾(Lower)；</li><li><code>ctrl + f/ctrl + u</code>向下分页(forward)/向上分页(upward)</li><li><code>zz</code>把屏幕设置为中间</li></ul><h2 id="Vim增删改查"><a href="#Vim增删改查" class="headerlink" title="Vim增删改查"></a>Vim增删改查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li>i(insert): 在字符前插入</li><li>a(append): 在字符后插入</li><li>o(open a new line): 下启一行插入</li><li>I: 在行首插入</li><li>A: 在行末插入</li><li>O: 上启一行插入<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3></li><li>x: 删除单个字符</li><li>d(delete): 此为删除命令，可结合文本对象具体使用，如diw(delete inner word) <div class="note note-info">            <p>&nbsp;&nbsp;d和x可以搭配数字使用，以达到同一命令重复执行多次的效果。</p>          </div><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3></li><li>r(replace): <code>r &lt;char&gt;</code>用以替换当前光标所在处的字符；</li><li>c(change):  可以搭配文本对象具体使用，如<code>&quot;just try try&quot;</code>中使用<code>ci&quot;</code>则会删除掉引号内的内容(引号不会去掉，若是<code>ca&quot;</code>则会)，并且进入到编辑模式</li><li>s(substitute): 删除并进入编辑模式 <div class="note note-info">            <p>&nbsp;&nbsp;<code>s</code>可以搭配数字使用；<br>&nbsp;&nbsp;上述的三个命令若是大写（即R/C/S）会有不同的作用：</p><ul><li>R进入replace模式，从当前字符起可以一直替换，直到退出该模式；</li><li>C/S二者差不多，删掉整行进入编辑模式；</li></ul>          </div><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3></li><li><code>/ + &lt;word&gt;</code>: 前向搜索</li><li><code>? + &lt;word&gt;</code>: 反向搜索</li><li><code>n/N</code>: 跳到下一匹配项/跳到上一匹配项</li><li><code>*/#</code>: 当前光标处单词的下一项/上一项匹配</li></ul><h2 id="Vim搜索替换"><a href="#Vim搜索替换" class="headerlink" title="Vim搜索替换"></a>Vim搜索替换</h2><p>&nbsp;&nbsp;格式: <code>:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]</code><br>&nbsp;&nbsp;range表示范围(不写则默认当前行)：</p><ul><li><code>%</code>表示全选；</li><li><code>m,n</code>表示第m-第n行；</li><li><code>n,$</code>表示第n行到末尾；</li></ul><p>&nbsp;&nbsp;s表示替换<br>&nbsp;&nbsp;pattern表示替换前的单词，可以用正则<br>&nbsp;&nbsp;string表示替换后的单词<br>&nbsp;&nbsp;flags表示替换方式(不写则默认替换第一个(当前行/范围内的行)出现的pattern)：</p><ul><li>g(global): 全局执行（即所有出现的，不局限在第一个）</li><li>n(number): 报告匹配的次数而不替换</li></ul><h2 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h2><p>&nbsp;&nbsp;对于可以结合文本对象进行操作的命令：如y(yank)/d(delete)/c(change)等，可以结合以下的范围词来使用：a(around,含该字符)/f(find,含该字符)/i(inner,不含该字符)/t(to,不含该字符)来结合特定的字符使用。<br>&nbsp;&nbsp;如：<code>yf;</code>表示由当前字符开始复制至<code>;</code>处，且含<code>;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础应用</title>
    <link href="/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/"/>
    <url>/2021/12/15/Git%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h2><p>&nbsp;&nbsp;Git是分布式版本管理系统<br>&nbsp;&nbsp;它可以帮助你：</p><ul><li><strong>构造本地仓库</strong></li><li><strong>管理本地仓库内的文件版本（可以回滚，可以往前）</strong></li><li><strong>与远程仓库建立连接（通过SSH）</strong></li><li><strong>远程仓库存储副本</strong></li><li><strong>多人协作开发</strong></li><li>…</li></ul><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ul><li>windows系统<br>  下个Git Bash</li><li>Linux系统<br><code>yum install git -y</code></li></ul><p>&nbsp;&nbsp;安装完成后我们需要在Git Bash内或是Linux的终端中(下文统一称为<strong>terminal</strong>)设置全局属性name和email。用以标识用户。<br>&nbsp;&nbsp;<code>git config --global user.name &quot;ayyHA&quot;</code><br>&nbsp;&nbsp;<code>git config --global user.email &quot;email@qq.com&quot;</code><br>&nbsp;&nbsp;还可以启用Git的一些额外颜色<br>&nbsp;&nbsp;<code>git config --global color.ui true</code></p><h2 id="Git本地仓库的操作"><a href="#Git本地仓库的操作" class="headerlink" title="Git本地仓库的操作"></a>Git本地仓库的操作</h2><p>&nbsp;&nbsp;我们可以新建一个目录，用以作为被Git管理的本地仓库，<strong>放置于其内的任意文件都会被Git进行版本管理</strong>。</p><h3 id="本地仓库初始化"><a href="#本地仓库初始化" class="headerlink" title="本地仓库初始化"></a>本地仓库初始化</h3><p>&nbsp;&nbsp;通过<code>git init</code>命令即可以将该目录设置为<strong>本地仓库</strong>，且该目录内会多出一个<strong>.git</strong>文件夹，其内是Git用于版本管理的东西，<strong>没事别乱动！！</strong></p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><p>&nbsp;&nbsp;之后你可以往这个文件夹里建文件，写东西。但是这并没有使用到我们Git的版本管理。如何使用到呢？<br>&nbsp;&nbsp;我们可以打开terminal输入<code>git status</code>这条命令进行查看。<br>&nbsp;&nbsp;你会发现上面写着Untracked files,即意味着你的文件只是放在这个目录下，还没有被Git进行跟踪管理。</p><p>&nbsp;&nbsp;我们可以通过<code>git add &lt;file&gt;</code>来将文件放置到一个叫<strong>暂存区</strong>的地方（即index或stage，存放于.git下）</p><p>&nbsp;&nbsp;我们可以一次性将许多文件放在暂存区内，然后提交到<strong>本地仓库:</strong><code>git commit -m &quot;这里写此次提交的注释&quot;</code> </p><p>&nbsp;&nbsp;之后当你修改这些被跟踪的文件时，都可以通过<code>git status</code>来查看有谁被modified，有谁需要committed。</p>  <div class="note note-info">            <p>&nbsp;&nbsp;你可能会想到一种情况：<br>&nbsp;&nbsp;我在本地仓库里新建了a文件，修改了其内容，然后通过<code>git add a.txt</code>将其提交到暂存区，之后忽然发现有个地方写错了，然后直接先去修改a文件了，此时Git会将你放入暂存区的文件和再次修改的文件分隔来看，即放入暂存区的文件可以通过<code>git commit</code>将内容上交，而新加的内容则是被认为是modified，需要重新<code>git add</code>。    </p>          </div><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>&nbsp;&nbsp;当我们对文件一股脑的进行修改后发现，修改的部分极大可能出错了，且修改的地方比较多，若是一点一点回去改，会很耗时。而Git给我们提供了一剂后悔药<code>git checkout -- &lt;file&gt;</code>即可以将修改撤销，变回修改前的模样。<br>  <div class="note note-info">            <p>&nbsp;&nbsp;①若是未将文件<code>git add</code>到暂存区，则文件会回滚文修改前的版本；<br>&nbsp;&nbsp;②若是将文件放到了暂存区，又进行了修改，则checkout后得到的是暂存区的版本；（现在Git）    </p>          </div><br>&nbsp;&nbsp;除了上面所说的<code>git checkout -- &lt;file&gt;</code>来对文件进行撤销修改外，Git也提供了<code>git restore &lt;file&gt;</code>来撤销修改（因为<code>git checkout</code>也与后面的分支切换有关）,还提供了<code>git restore --staged &lt;file&gt;</code>来<strong>撤销放置于暂存区的文件</strong></p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>&nbsp;&nbsp;撤销修改中的①其实就是回退到最新的版本，也可以通过版本回退来实现:<code>git reset --hard HEAD^</code>此即为回退到上一个版本，若是想回退到上上一个版本，加多个^即可。但若是我们需要回退的版本很前很前，写那么多个^并不现实，可以通过：<code>git --reset HEAD~100</code>即可以回退到前100个版本去；<br>&nbsp;&nbsp;那我们如果想回退到某一个版本，我们不知道它跟我们现在的版本差距为多少，我们可以通过<strong>版本号</strong>来进行回退。版本号可以通过<code>git log</code>来得到（commit后面那一串就是版本号）,如果版本太多，可以通过<code>git log --pretty=oneline</code>来较为清晰地输出版本信息。<br>&nbsp;&nbsp;回退的时候我们不需要把版本号全部写上去，写前几个字母就好了，如：<code>git reset --hard 95a9b</code>。<br>&nbsp;&nbsp;那当我们知道了版本号，其实不只可以进行版本回退，也可以将版本向前移动。若是不知道版本号，我们可以通过<code>git reflog</code>来进行查询。</p><div class="note note-info">            <p>&nbsp;&nbsp;上面指令中的<strong>HEAD其实就是指向当前分支（如master）</strong>, 而<strong>当前的分支才是指向提交</strong>的，也即是说我们<strong>commit到本地仓库的内容是提交在当前分支上</strong>的，这个在后面的分支管理部分可以更好的理解。</p>          </div><h2 id="Git远程仓库的操作"><a href="#Git远程仓库的操作" class="headerlink" title="Git远程仓库的操作"></a>Git远程仓库的操作</h2><h3 id="Github设置及远程推送"><a href="#Github设置及远程推送" class="headerlink" title="Github设置及远程推送"></a>Github设置及远程推送</h3><p>&nbsp;&nbsp;要知道，我们GitHub和Git的数据传输是通过SSH加密的，需要进行如下的设置：</p><ol><li>在terminal中通过<code>ssh-keygen -t rsa -C &quot;email&quot; </code>来生成，它利用RSA加密算法生成一个公钥和密钥，放在你当前用户的HOME目录下（windows在C:/User/UserName/.ssh下，Linux在~/.ssh下）;</li><li>将在.ssh目录下的id_rsa放置到你的Github的Settings下的SSH and GPG keys中（通过点击New SSH key放置其中）；其中id_rsa是公钥，带pub后缀的是密钥;<br>至此，你的电脑利用Git去远程访问你的Github下的信息已经可以进行权限认证了（就是可以分辨出有没资格去拿信息）。</li><li>我们需要在Github上建一个仓库，并将本地仓库和远程仓库通过<code>git remote add origin git@github.com:github_name/repo_name.git </code>关联起来(注意github_name需替换成你的GitHub账号,repo_name需替换成你的仓库名);<br>&nbsp;&nbsp;以上，你便将你的本地仓库和远程仓库建立了连接。我们可以将<strong>本地文件push到repo</strong>了。<code>git push -u origin master</code>首次push需要加-u，以使得你的本地分支master和远程仓库分支master相关联。之后就<code>git push origin master</code>就行。<br>&nbsp;&nbsp;我们也可以<strong>拉取到该repo的文件</strong><code>git pull origin master</code>。</li></ol><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>&nbsp;&nbsp;通过上面的描述我们知道，我们的本地仓库在创建之时给我们自带了一个master分支，我们也可以自创分支<code>git branch branchName</code>，也可以切换分支<code>git checkout branchName</code>，可以通过<code>git branch来查看当前有多少分支</code>，还可以通过<code>git branch -d branchName</code>来删除分支。<br>&nbsp;&nbsp;上面的分支切换和分支创建也可以通过如下指令完成<code>git checkout -b branchName</code>。<br>&nbsp;&nbsp;我们一般都是用一个分支（如dev）进行修改提交（就是dev改了内容之后要add、commit），然后再合并到主分支master上，即是：<code>git merge dev</code>(master合并掉dev,通过fast-forward策略)。</p><div class="note note-info">            <p>&nbsp;&nbsp;分支就像是一个线程一样，共享仓库里的文件，但是对文件的修改提交只对该分支可见。</p>          </div><p>&nbsp;&nbsp;我们前面曾说过，我们的分支是面向提交的，那么也就是说如果我有master分支和dev分支，我们即对dev做了修改提交，又对master做了修改提交，那么在合并的时候就会产生<strong>冲突</strong>，我们可以通过查看产生了冲突的文件，上面会有&lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt;的信息来指示这个部分是哪个分支进行的修改，手动解决冲突后，即可合并。</p><div class="note note-info">            <p>&nbsp;&nbsp;fast forward策略合并分支后，我们若是删除了分支，会丢失掉分支的信息。因此可以通过禁用fast forward的方式来避免丢失信息：<code>git merge -no-ff -m &quot;注释&quot; branchName</code>，之后还可以通过<code>git log</code>来找到它。<br>&nbsp;&nbsp;若是在遇到某些bug的情况下需要另建分支，解决bug，而此时工作现场又无法commit的话，我们可以通过<code>git stash</code>来隐藏工作现场，后期可以通过<code>git stash list</code>来查看现场，然后可以通过<code>git stash apply</code>和<code>git stash drop</code>来应用和删除现场，也可以通过<code>git stash pop</code>来恢复现场和删除现场。</p>          </div><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>&nbsp;&nbsp;在前面push内容到GitHub时，我们用到了<code>git push origin master</code>其实这个origin就是远程仓库默认的名字。我们可以通过<code>git remote</code>和<code>git remote -v</code>来查看远程仓库的信息。而这里的master则是指的本地分支，意为：将本地的master分支push到origin上去。<br>&nbsp;&nbsp;那么我们若是要push本地的dev分支到origin去的话，我们的远程仓库会自动set up一个叫dev的分支，并与我们本地的dev分支建立关联。<br>&nbsp;&nbsp;若是我们需要将origin上的dev分支弄到本地来，可以通过<code>git checkout -b dev origin/dev</code>实现；<br>&nbsp;&nbsp;若是当我们要提交的dev分支产生冲突，我们需要拉取最新的下来，我们需要先指定本地dev分支与远程origin/dev分支的关联关系：<code>git branch --set-upstream dev origin/dev</code>，再pull即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo之方便文创的代码</title>
    <link href="/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2021/12/14/hexo%E4%B9%8B%E6%96%B9%E4%BE%BF%E6%96%87%E5%88%9B%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Tag插件"><a href="#Tag插件" class="headerlink" title="Tag插件"></a>Tag插件</h2><h3 id="便签"><a href="#便签" class="headerlink" title="便签"></a>便签</h3><p>&nbsp;&nbsp;便签，就是贴在文章中的彩色标签，用于展示作者的一些提示信息。便签是通过便签类型来进行划分的。<br>  <a href="https://hexo.fluid-dev.com/docs/guide/">fluid配置指南</a></p><p>  <strong>用法</strong><br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>这里写便签里的内容<br>&#123;% endnote %&#125;<br>需注意：上面的success是便签类型的指代，此为绿色的便签。<br></code></pre></td></tr></table></figure></p><p>  <strong>便签类型和颜色的对应关系</strong></p><table><thead><tr><th align="center">便签类型</th><th align="center">颜色</th></tr></thead><tbody><tr><td align="center">primary</td><td align="center">紫色</td></tr><tr><td align="center">secondary</td><td align="center">灰色</td></tr><tr><td align="center">success</td><td align="center">绿色</td></tr><tr><td align="center">danger</td><td align="center">红色</td></tr><tr><td align="center">warning</td><td align="center">黄色</td></tr><tr><td align="center">info</td><td align="center">蓝色</td></tr><tr><td align="center">light</td><td align="center">白色</td></tr></tbody></table><p>  <strong>效果演示</strong><br>  <div class="note note-primary">            <p>我是primary，我是紫色</p>          </div></p>  <div class="note note-secondary">            <p>我是secondary，我是灰色</p>          </div>  <div class="note note-success">            <p>我是success，我是绿色</p>          </div>  <div class="note note-danger">            <p>我是danger，我是红色</p>          </div>  <div class="note note-warning">            <p>我是warning，我是黄色</p>          </div>  <div class="note note-info">            <p>我是info，我是蓝色</p>          </div>  <div class="note note-light">            <p>我是light，我是白色</p>          </div><h3 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h3><p>&nbsp;&nbsp;行内标签类似于一个按钮（就是不可以按），用于标识信息。</p><p>  <strong>用法：</strong><br>    <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% label primary @text%&#125;<br></code></pre></td></tr></table></figure><br>    <div class="note note-info">            <p>text即为标签的文本，primary这些与便签类似，但多了个default，没有secondary和 light，且text开头不能是@。</p>          </div></p><p>  <strong>效果演示：</strong><br>    <span class="label label-primary">我是primary</span><br>    <span class="label label-default">我是default</span><br>    <span class="label label-success">我是success</span><br>    <span class="label label-warning">我是warning</span><br>    <span class="label label-danger">我是danger</span></p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>&nbsp;&nbsp;按钮就是加了底色的外链跳转</p><p>  <strong>用法：</strong><br>    <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% btn url,text,title %&#125;<br></code></pre></td></tr></table></figure><br>  <div class="note note-info">            <p>btn标识其为一个按钮，url是点击后跳转的外链，text是按钮显示的文本，title是鼠标悬停的文字，是个可选项。</p>          </div></p><p>  <strong>效果演示：</strong><br>  <a class="btn" href="http://baidu.com"  title="百度" target="_blank">我是一个可以跳到百度的按钮</a></p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>&nbsp;&nbsp;脚注可以使得我们很方便地标出文章中一些引用部分的出处或是相关的解释。脚注在生成的文章中被放置于文末，类似于参考文献，且带有锚点，我们点击即可到达标注处。</p><p>  <strong>用法</strong>：<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br>这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br>这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup><br><br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">第一处的脚注</span><br>[<span class="hljs-symbol">^2</span>]: <span class="hljs-link">第二处的脚注</span><br>[<span class="hljs-symbol">^3</span>]: <span class="hljs-link">第三处的脚注</span><br></code></pre></td></tr></table></figure></p><p>  把上面代码段的内容贴到MD文档里是以下的<strong>效果</strong>：</p><p>  这里写的是我们第一处引用内容<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="第一处的脚注">[1]</span></a></sup><br>  这里写的是我们第二处引用内容<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="第二处的脚注">[2]</span></a></sup><br>  这里写的是我们第三处引用内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="第三处的脚注">[3]</span></a></sup></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>第一处的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>第二处的脚注<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>第三处的脚注<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud自学</title>
    <link href="/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/13/SpringCloud%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Eureka</tag>
      
      <tag>Ribbon</tag>
      
      <tag>Hystrix</tag>
      
      <tag>Config</tag>
      
      <tag>Feign</tag>
      
      <tag>Zuul</tag>
      
      <tag>Bus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot自学</title>
    <link href="/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/"/>
    <url>/2021/12/10/SpringBoot%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot的大时代"><a href="#SpringBoot的大时代" class="headerlink" title="SpringBoot的大时代"></a>SpringBoot的大时代</h1><hr><h2 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1. 微服务"></a>1. 微服务</h2><ul><li>微服务是一种架构风格</li><li>一个应用拆分为一组小型服务</li><li>每一个服务可以部署在自己的服务器上，运行在自己的进程内，也就是可以独立部署和升级，与单个应用无差</li><li>服务之间的交互使用轻量级的HTTP交互</li><li>服务围绕业务功能进行拆分</li><li>服务可以由全自动部署机制独立部署</li><li>去中心化（每一个服务可以用不同的语言来进行开发，也可以使用不同的存储技术）、服务自治</li></ul><p>而<strong>微服务的出现，将大应用拆分成多个小服务进行独立部署，会导致分布式的产生</strong></p><hr><h2 id="2-分布式"><a href="#2-分布式" class="headerlink" title="2. 分布式"></a>2. 分布式</h2><p>问题：</p><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>…</li></ul><p>分布式的解决：SpringBoot + SpringCloud</p><h2 id="3-云原生"><a href="#3-云原生" class="headerlink" title="3. 云原生"></a>3. 云原生</h2><p>原生应用如何上云：Cloud Native</p><p>上云的困难：</p><ul><li>服务的自愈</li><li>弹性伸缩（拥塞）</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>…</li></ul><h1 id="SpringBoot官方文档架构"><a href="#SpringBoot官方文档架构" class="headerlink" title="SpringBoot官方文档架构"></a>SpringBoot官方文档架构</h1><hr><p> <a href="Spring.io">Spring官方网址</a></p><p>可以通过官方网址的Projects&gt;SpringBoot进行SpringBoot的学习</p><p>其中OVERVIEW部分可以看到发布版本的更新情况以及更新的内容；LEARN则可以选择版本来进行对应的学习</p><p>本次学习所采用的是2.3.4版本的SpringBoot</p><h1 id="SpringBoot2之HelloWorld"><a href="#SpringBoot2之HelloWorld" class="headerlink" title="SpringBoot2之HelloWorld"></a>SpringBoot2之HelloWorld</h1><p>系统要求：</p><ul><li>Java8及以上</li><li>Maven3.3+</li></ul><ol><li>配置Maven</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>HelloWorld</li></ol><p>需求：浏览发送/hello请求，响应Hello,SpringBoot2</p><p>①创建一个普通的Maven项目，编写POM</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.ayy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>boot-01-helloworld<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 导入SpringBoot父工程，版本是2.3.4 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SpringBoot web开发启动器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>②编写主程序类，在main&gt;java下创建com.ayy.boot.MainApplication Java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类；主配置类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③编写controller类，并运行main方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">//@ResponseBody  //此注解用于表示此类的返回值均是写给浏览器的，而不是跳转某个页面等；</span><br><span class="hljs-comment">//@Controller</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>简化配置</li></ol><p>在resources下创建一个application.properties的配置文件，所有的配置如端口号等，都可以写此处，当运行时，SpringBoot会读取里面的配置,若是无更改的则按照SpringBoot默认的配置行事。</p><p>当不知道什么配置可以写于其中时，可参照官方文档中的Application Properties的内容来进行设置。</p><ol start="4"><li>简化部署</li></ol><p>maven项目默认是打包为jar包</p><p>SpringBoot所打包是一个<strong>可执行的jar包</strong>，通过以下插件配置即可实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过maven自带的lifestyle的clean和package进行打包操作</p><p>对打好的包通过cmd命令行执行 <code>java -jar 包名</code>即可执行之！！</p><p>注意：</p><ul><li>需要取消cmd的快速编辑模式</li></ul><p>最后展示一下此模块的目录结构：</p><p><img src="https://s2.loli.net/2021/12/13/sfYOvp6CVNwumB4.png" alt="目录结构"></p><hr><h1 id="SpringBoot依赖管理特性"><a href="#SpringBoot依赖管理特性" class="headerlink" title="SpringBoot依赖管理特性"></a>SpringBoot依赖管理特性</h1><ul><li>父项目做依赖管理(<strong>自动版本仲裁机制</strong>)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">//pom.xml里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>//starter-parent里面的父项目<br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>在spring-boot-dependencies这一项目里面，几乎声明了所有开发中常用的依赖的版本号,此即为自动版本仲裁机制<br></code></pre></td></tr></table></figure><ul><li>开发导入starter场景启动器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. spring-boot-starter-* : 此即代表某种场景<br>2. 只要引入starter，这个场景的所有常规需要的依赖我们都会自动导入<br>3. SpringBoot所有支持的场景：https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter<br>4. 见到的 *-spring-boot-starter : 是第三方为我们提供的简化开发的场景启动器<br>5. 所有场景启动器最底层的依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>无需关注版本号，自动版本仲裁</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">引入依赖默认都可以不写版本号，除非引入的依赖是非版本仲裁的jar，则一定要写版本号<br></code></pre></td></tr></table></figure><ul><li>可以修改版本号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">1. 查看spring-boot-dependencies里面规定的当前依赖的版本所用的关键字<br>2. 在当前项目里面重写配置<br><br>注：利用的时MAVEN提供的特性：就近优先原则<br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.43<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="SpringBoot自动配置特性"><a href="#SpringBoot自动配置特性" class="headerlink" title="SpringBoot自动配置特性"></a>SpringBoot自动配置特性</h1><ul><li><p>自动配置tomcat（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入tomcat依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置tomcat</li></ol></blockquote></li><li><p>自动配置SpringMVC（如在spring-boot-starter-web依赖下便带有）</p><blockquote><ol><li>引入了SpringMVC全套组件</li><li>自动配好SpringMVC常用组件(功能)</li></ol></blockquote></li><li><p>自动配好Web常见功能，如：字符编码问题</p><blockquote><p>SpringBoot帮我们配置好了所有web开发时的常见场景</p></blockquote></li><li><p>默认的包结构</p><blockquote><ul><li>主程序所在的包及其下边的所有的子包都能被扫描（即无需配置包扫描，此为默认的包扫描规则）</li><li><strong>如果想要改变包扫描路径，可以通过在@SpringBootApplication(scanBasePackages=”com.ayy”)来改变</strong></li><li>或者通过一个@ComponentScan来指定扫描的路径，但此时因SpringBootApplication已经使用了其，故暂时不能将其与之写于一起来进行包扫描路径的替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>等同于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.ayy&quot;)</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>各种配置都拥有默认值</strong></p></li></ul><blockquote><p>默认配置最终都是映射到某一个类上的</p><p>配置文件的值会绑定到某一个类上，这个类会在容器中创建对象</p></blockquote><ul><li><strong>按需加载所有自动配置项</strong></li></ul><blockquote><p>引入了哪些场景，这个场景的自动配置才会开启</p><p>SpringBoot的所有自动配置功能都在spring-boot-autoconfigure包里面</p></blockquote><hr><h1 id="底层注解-Configuration-组件添加-解析"><a href="#底层注解-Configuration-组件添加-解析" class="headerlink" title="底层注解-@Configuration(组件添加)解析"></a>底层注解-@Configuration(组件添加)解析</h1><hr><p>在之前，我们对Spring进行一个组件的注册是通过在spring.xml配置文件里增添如下内容实现，在表示配置spring.xml之前，先进行两个类的构建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*User类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&#x27;&quot;</span> + age + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(String age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*Pet类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pet&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pet</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过spring.xml对其中的bean进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user01&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tomcat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Pet&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上便是<strong>Spring通过配置文件的方式，来实现组件的注册，经注册的组件可以在容器中找到</strong></p><p>而<strong>在SpringBoot中，可以通过@Configuration这个注解来替代spring.xml配置文件，即用一个含有@Configuration注解的类来进行组件的注册，而在需要注册的组件上，只需要通过@Bean注解来声明即可</strong>，如下类MyConfig所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ayy.boot.config;<br><br><span class="hljs-keyword">import</span> com.ayy.boot.bean.Pet;<br><span class="hljs-keyword">import</span> com.ayy.boot.bean.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// 告诉SpringBoot这是一个配置类（配置类就等于配置文件）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span>  <span class="hljs-comment">// 给容器中添加组件，以方法名作为组件的id,返回类型就是组件类型。返回的值就是组件在容器中的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*被@Bean注解所注的方法的返回值即是注册在容器中的组件的实例对象，方法名即为实例对象的id，若是不满方法名作为对象id,可以在@Bean(&quot;myName&quot;)中进行组件id的重写</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>需要特别注意的是：<strong>此时我们所注册在容器中的组件都是单例的</strong>，无论你通过容器如何getBean或多次getBean，甚至直接获取MyConfig组件（<strong>因其也是在配置文件下的类，故其也被注册在容器里</strong>）直接进行方法的调用，也依旧是单例！！</p><p>​    这个单例的构成，与**@Configuration注解下的proxyBeanMethods的默认值为true有直接关系<strong>，proxyBeanMethods即意为</strong>代理Bean方法<strong>，在其为true的情况下，我们通过getBean获得的MyConfig类的实例对象其实是</strong>代理对象<strong>，也即通过这个代理对象，我们无论怎么去调用对象里的方法，也只是从容器里面获取对应的组件而已；当</strong>代理Bean方法**值为false时，才会是个普通的对象，通过调用其中方法，获得的实例则不相同。</p><p>​    以下部分是体现代理对象调用方法后所得组件为容器中组件且为单例的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @SpringBootApplication: 告知此为一个SpringBoot应用,带有此注解的也称之为主程序类</span><br><span class="hljs-comment">* 在main方法里调用SpringApplication.run(主类.class，args);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>        <span class="hljs-comment">// 查看容器里的组件</span><br>        String[] names = run.getBeanDefinitionNames();<span class="hljs-comment">// 获取容器中组件的实例对象的名字</span><br>        <span class="hljs-keyword">for</span>(String name:names)<br>            System.out.println(<span class="hljs-string">&quot;NANE: &quot;</span>+name);<br>   <span class="hljs-comment">// 从容器中获取组件</span><br>        MyConfig myConfig = run.getBean(MyConfig.class);<br>        Pet jerry = run.getBean(<span class="hljs-string">&quot;jerry&quot;</span>, Pet.class);<br>        System.out.println(jerry==myConfig.tom());<br>        System.out.println(myConfig);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注：当我们打出myconfig的内容时，会发现其打印的内容为：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig$$EnhancerBySpringCGLIB$$8a7037ca@7ea4d397</span><br><span class="hljs-comment">并非一个单纯的类，而在其中还夹杂了EnhancerBySpringCGLIB,即其被SpringCGLIB所提升，而很自然联想到是被提升为代理对象</span><br><span class="hljs-comment">小贴士：在Spring中一般这种事是jdk干的，但在SpringBoot中，这种事交由CGLIB干</span><br><span class="hljs-comment">而当我们修改MyConfig的注解为@Configuration(proxyBeanMethods=false)时，再运行程序，可以发现：</span><br><span class="hljs-comment">com.ayy.boot.config.MyConfig@62d0ac62</span><br><span class="hljs-comment">此时则为一个普通的容器中的组件</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>proxyBeanMethods:代理bean的方法根据true/false，有以下两种模式：</p><ul><li>Full(proxyBeanMethods=true) 全模式</li><li>Lite(proxyBeanMethods=false) 轻量级模式，因为不像全模式，在<strong>构建</strong>时需要查询容器中是否存在该实例，加快了运行速度，故为轻量级</li></ul><p>在此处举一个单例的实例：比如我们的User里有一个成员变量是Pet，它们两个都是在容器中获得的组件，且此为<strong>User依赖Pet</strong>，那么通过单例，可以很好地体现这么一个<strong>依赖关系</strong>，因为User所占有的Pet，也是容器里面所独有的Pet，不存在这些个Pet相异的情况。</p><p><strong>因此：当没有依赖组件时则用Lite轻量级模式；当需要依赖时，则需要使用Full全模式。</strong></p><p><strong>注：根据后面的学习来看，轻量级模式下的自动类配置，它的参数的获取，有大概率的可能是通过容器中获取。若是自己写的配置类（如笔者自己的MyCofig），使这个代理bean方法失效后，因笔者没有传入参数，故没有进行进一步的测试。<em>因此笔者猜测：SpringBoot在处理配置类的参数时，直接获取的是容器中已有的组件，若是构建当前组件的实例，则对Full会进行单例查询，而对Lite则不查询，直接放入容器中。但随之而来的问题是：自动获取的传入参数如何保证是我们所想要的哪个呢？而框架本身的因为是与配置文件相绑定，所以只要是获取到的实参，都是所需的。</em></strong></p><p>2021.9.7看，不懂上面的注说的啥</p><h1 id="底层注解-Import-导入组件-解析"><a href="#底层注解-Import-导入组件-解析" class="headerlink" title="底层注解-@Import(导入组件)解析"></a>底层注解-@Import(导入组件)解析</h1><hr><p>除了上面所说的@Configuration加上@Bean可以给容器注册组件外，还有之前的@Component（表示为一个组件）、@Controller（表示为一个控制器）、@Service（表示为一个业务逻辑组件）、@Repository(代表它是一个数据库层组件)都能用。</p><p>@ComponentScan就是通过指定包扫描路径来实现组件导入，因为告知了Spring该去哪里扫描即哪里找可能是组件的类</p><p><strong>@Import是给容器导入组件，可以写在配置类中或组件类中</strong></p><p><strong>它的参数是一个数组，这个数组里面写的是想要导入到容器中的组件的类型，它会<u>调用该类的无参构造器来构造出该类的对象加入到容器中，所默认使用的id，即BeanName是全类名</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先在配置类MyConfig里写下以下内容，以在容器中导入对应的类实例对象</span><br><br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br>    <span class="hljs-meta">@Bean(&quot;jerry&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-comment">// 之后我们通过MainApplication来打印导入的类，查看其打印情况</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 查看Import注解导入的组件的名字</span><br>        String[] beanNames = run.getBeanNamesForType(User.class);<br>        System.out.println(<span class="hljs-string">&quot;&lt;====================================&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(String bean:beanNames)<br>            System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + bean);<br>        DBHelper dbHelper = run.getBean(DBHelper.class);<br>        System.out.println(<span class="hljs-string">&quot;bean:&quot;</span> + dbHelper);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 打印结果如下：</span><br>&lt;====================================&gt;<br>bean:com.ayy.boot.bean.User<br>bean:user01<br>bean:ch.qos.logback.core.db.DBHelper@1d81e101<br>不难看出，我们通过导入进去的默认BeanName即我们在Spring.xml注册的id即为全类名，且其为无参构造得到的。<br><br></code></pre></td></tr></table></figure><h1 id="底层注解-Conditional条件装配"><a href="#底层注解-Conditional条件装配" class="headerlink" title="底层注解-@Conditional条件装配"></a>底层注解-@Conditional条件装配</h1><hr><p><strong>条件装配：满足Conditional指定的条件，则进行组件注入</strong>！！！</p><img src="https://s2.loli.net/2021/12/13/SG6y5Umhs1oxv3p.png" alt="Conditional相关注解.png" style="zoom:67%;" /><p>Conditional是个根注解，其下的许多注解可以按照名字的意思来进行对应的测试，下面的例子用@ConditionalOnBean来实现，其意为，当某个Bean存在时，则执行下面的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>通过对<span class="hljs-meta">@Bean</span>注解注释，使之不会注册到容器中，以下为此例的验证<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用注册到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;<br><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 通过输出结果即证明了没有加上注解@Bean的Javabean不会注册到容器中。则根据这一规则我们可以进行下面的测试</span><br>    <br>    <br><span class="hljs-number">2.</span> 当tom存在时，才注册user01到容器中，否则不注册<br><span class="hljs-meta">@Import(&#123;User.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@ConditionalOnBean(name=&#123;&quot;tom&quot;&#125;)</span><span class="hljs-comment">// 当容器中有个名为tom的组件时，才执行user01组件注册到容器中，否则不注册到容器中</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user01</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;18&quot;</span>);&#125;<br><br><span class="hljs-comment">//  @Bean(&quot;jerry&quot;)  注解后，此为一个普通的方法，不具备成为组件的条件，则其不会在配置时被调用，注入到容器中</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pet <span class="hljs-title">tom</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pet(<span class="hljs-string">&quot;tomcat&quot;</span>);&#125;<br>&#125;    <br>   <br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br><br>        <span class="hljs-comment">// 对注释了@Bean的组件进行测试，查看是否存在在容器中</span><br>        <span class="hljs-keyword">boolean</span> tom = run.containsBean(<span class="hljs-string">&quot;tom&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;tom:&quot;</span> + tom);<br><br>        <span class="hljs-keyword">boolean</span> user01 = run.containsBean(<span class="hljs-string">&quot;user01&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;user01:&quot;</span> + user01);<br>    &#125;<br>&#125;<br><br>输出结果为：<br>tom:<span class="hljs-keyword">false</span><br>user01:<span class="hljs-keyword">false</span><br><span class="hljs-comment">// 通过结果可以得出，当名为tom的组件在容器中找不到时，user01也不会注册到容器中，此注解也可以放置到类上，以期满足某种条件，才执行类中的组件的注册。</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-ImportResource导入Spring配置文件"><a href="#底层注解-ImportResource导入Spring配置文件" class="headerlink" title="底层注解-@ImportResource导入Spring配置文件"></a>底层注解-@ImportResource导入Spring配置文件</h1><hr><p>@ImportResource用于向SpringBoot中导入Spring的配置文件：spring.xml，即通过此注解可以将无法被SpringBoot所理解的组件注册到容器中。<strong>此注解写于配置类上即可</strong></p><p>以下为一实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>当在配置类MyConfig中没有加上此注解时：<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLUser&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.User&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&quot;</span>&gt;&lt;/property&gt;<br>        &lt;property name=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;18&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;springXMLPet&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.ayy.boot.bean.Pet&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;lisi&#x27;s pet&quot;</span>&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br><span class="hljs-comment">// 上述为spring.xml中的注册组件</span><br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回IOC容器</span><br>        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);<br>    <span class="hljs-comment">// 对IOC容器进行查询，根据BeanName查询</span><br>        <span class="hljs-keyword">boolean</span> springXMLUser = run.containsBean(<span class="hljs-string">&quot;springXMLUser&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLUser:&quot;</span> + springXMLUser);<br>        <span class="hljs-keyword">boolean</span> springXMLPet = run.containsBean(<span class="hljs-string">&quot;springXMLPet&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;springXMLPet:&quot;</span> + springXMLPet);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 输出结果为：</span><br>springXMLUser:<span class="hljs-keyword">false</span><br>springXMLPet:<span class="hljs-keyword">false</span><br>    <br><span class="hljs-comment">// 我们对配置类MyConfig进行@ImportResource(&quot;classpath:spring.xml&quot;)注解标识后，再运行，可得如下输出结果</span><br>springXMLUser:<span class="hljs-keyword">true</span><br>springXMLPet:<span class="hljs-keyword">true</span><br><span class="hljs-comment">// 此时即实现了对spring中的组件进行了注册</span><br></code></pre></td></tr></table></figure><h1 id="底层注解-ConfigurationProperties配置绑定"><a href="#底层注解-ConfigurationProperties配置绑定" class="headerlink" title="底层注解-@ConfigurationProperties配置绑定"></a>底层注解-@ConfigurationProperties配置绑定</h1><p>在以前，我们对一些常规配置的内容是写在my.properties中然后通过绑定的机制来将之内容写入Javabean中，这个过程较为繁琐，而<strong>在SpringBoot中，我们可以通过将配置信息写在application.properties，然后通过注解@ConfigurationProperties来实现绑定</strong>，且绑定的形式有两种！下图是之前绑定的方法的一个流程显示：</p><p><img src="https://s2.loli.net/2021/12/13/AK9Fbc8GnCDaBLJ.png" alt="ConfigurationProperties.png"></p><p>法①</p><p>通过在Javabean类Car中进行注解：@Component 和 @ConfigurationProperties(prefix = “mycar”) 来实现配置文件中的内容与该Javabean的绑定，并注册为容器中的一个组件。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*   只有在容器中的组件，才能使用SpringBoot提供的强大功能，因此需要通过@Component注解来将这个组件加入到容器中，</span><br><span class="hljs-comment">*   然后对prefix为mycar的配置内容进行获取</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String brand;<br>    <span class="hljs-keyword">private</span> String price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBrand</span><span class="hljs-params">(String brand)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;brand=&#x27;&quot;</span> + brand + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, price=&#x27;&quot;</span> + price + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String brand, String price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.brand = brand;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 以下内容是application.properties的配置内容：</span><br>server.port=<span class="hljs-number">8888</span><br><br>mycar.brand=TESLA<br>mycar.price=<span class="hljs-number">280000</span><br>    <br><span class="hljs-comment">// 接着我们在HelloController类中通过映射请求来实现这个绑定的体现：</span><br><span class="hljs-meta">@RestController</span> <span class="hljs-comment">//上面二者合成了RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Car car;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/car&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">myCar</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> car;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 紧接着我们访问 localhost:8888/car 即可获得输出于浏览器上的结果</span><br>&#123;<span class="hljs-string">&quot;brand&quot;</span>:<span class="hljs-string">&quot;TESLA&quot;</span>,<span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-string">&quot;280000&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>法②</p><p><strong>删去Car类中的@Component组件并通过在MyConfig这个配置类中增加注解@EnableConfigurationProperties(Car.class)来开启Car类的属性配置功能</strong></p><p>其中@EnableConfigurationProperties的作用有如下两点：</p><blockquote><ol><li><strong>开启Car组件的配置绑定功能</strong></li><li><strong>把Car这个组件自动地注册到容器中</strong></li></ol></blockquote><p><strong>此类用法多用于我们使用第三方的jar包中的类的时候，我们不能轻易地去修改别人的源代码，因此可以通过这样的方式来实现组件的配置绑定及加载到容器中。</strong></p><hr><h1 id="自动配置-自动包规则原理"><a href="#自动配置-自动包规则原理" class="headerlink" title="自动配置-自动包规则原理"></a>自动配置-自动包规则原理</h1><hr><p>自动包配置原理，是在SpringBoot应用下才生效的，即在SpringBoot应用下，可以自动加载配置类，即会自动往容器中导入组件，那么这个实现得从注解@SpringBootApplication先看起；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br>&lt;=====&gt;等价于<br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br>接下来我们对它们逐个解析<br></code></pre></td></tr></table></figure><ol><li>@SpringBootConfiguration</li></ol><p><strong>往此注解内部点去，可以发现其内部的核心是@Configuration，即注明此类是配置类</strong>，也就是说，我们的<strong>MainApplication类也是配置类</strong></p><ol start="2"><li>@ComponentScan</li></ol><p>此即为自动包扫描的配置，配置其下的目录及其子包都会被扫描</p><ol start="3"><li><strong>@EnableAutoConfiguration</strong></li></ol><p>我们通过Ctrl+左键点击进去后发现，@EnableAutoConfiguration注解由如下注解组成：</p><ul><li><p><strong>@AutoConfigurationPackage</strong></p></li><li><p><strong>@Import({AutoConfigurationImportSelector.class})</strong></p></li></ul><p>我们先着重说一下，@AutoConfiguraionPackage这个注解！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们点进去@AutoConfigurationPackage这个注解有以下内容</span><br><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br><span class="hljs-comment">// 我们发现，@AutoConfiguraionPackge里的注解是导入了Registrar组件，那么导入组件则是一个一个导入，我们先继续点进去该类看下</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>        Registrar() &#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>            AutoConfigurationPackages.register(registry, (String[])(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//上面是这个类的方法，我们看第一个方法registerBeanDefinitions()，传入的第一个参数metadata是一个注解元数据类型，所获取到的其实质是这个注解所注的类的元数据信息，而这个注解是合成注解，因此所获取到的是MainApplication这个标注了@SpringBootApplication注解的类，再看该方法里面的内容，它通过metadata获取到了我们主类的包名，然后还给它弄成了一个数组，对这个包名下的组件进行了注册！！</span><br></code></pre></td></tr></table></figure><p>由此可见，我们自动包规则原理，便是基于这个<strong>Registrar</strong>这个类，利用这个类，给容器导入一系列的组件。将指定的标注了这个注解（@AutoConfiguraionPackage）或利用之合成的注解(@EnableAutoConfiguraion或@SpringBootApplication)的类<strong>所在的包进行了组件注册</strong>！！</p><h1 id="自动配置-初始加载自动配置类"><a href="#自动配置-初始加载自动配置类" class="headerlink" title="自动配置-初始加载自动配置类"></a>自动配置-初始加载自动配置类</h1><hr><p>上面我们解释了@EnableAutoConfiguraion中的@AutoConfiguraionPackage，紧接着我们讲一下另一个注解@Import({AutoConfigurationImportSelector.class})，我们来详细谈一下这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>在进入AutoConfigurationImportSelector类后，我们看到一个方法：<br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata)&#123;...&#125;，其中该方法有一行代码是：getAutoConfigurationEntry(annotationMetadata);<span class="hljs-comment">// 此方法用于给容器批量导入一批组件</span><br><span class="hljs-number">2.</span>上面所说的那个给容器批量导入一批组件的方法，其内调用了：<br>    List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<span class="hljs-comment">// 通过调用此方法获取到所有需要导入到容器中的配置类</span><br><span class="hljs-number">3.</span>上述的那个方法是怎么知道导入这些需要导入的配置类的呢？往里面点，我们发现：<br>    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br><span class="hljs-comment">// 它利用工厂加载来加载内容，那么所加载的内容是什么呢？</span><br><span class="hljs-number">4.</span>再往下点击，可以发现其所加载的内容是：<br>    Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)&#123;...&#125;;<span class="hljs-comment">// 即通过一个Map来获取到所有的组件</span><br><span class="hljs-number">5.</span>那么这些组件是从哪里得到并加载的呢？通过以下对loadSpringFactories的debug过程便可略知一二：<br>     Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<span class="hljs-comment">// 不难看出，它是从一个META-INF/spring.factories的位置来加载文件。Spring会默认扫描我们当前系统里面所有的META-INF/spring.factories位置的文件！！</span><br><span class="hljs-number">6.</span>我们可以通过External Libraries来找对应的存在META-INF/spring.factories位置的jar包，查看其中内容。而最核心的包便是spring-boot-autoconfigure这个包。通过对这个包的内容进行查看，看到其下META-INF/spring.factories中有一行注为Auto Configure的内容，其后紧跟着<span class="hljs-number">127</span>个自动配置类！！也就是说，文件里面写死了spring-boot一启动就要加载到容器中的所有配置类。<br><span class="hljs-number">7.</span>我们可以通过getBeanDefinitionCount()来查看的确是有这<span class="hljs-number">127</span>个组件的存在，那么此时又存在另一个问题：它那么大，不应该会导致系统很卡嘛？<br>    虽然我们<span class="hljs-number">127</span>个场景的所有自动配置启动的时候默认全部加载，但最终会按需配置！！！<br>    这个按需配置就是利用了之前所学的条件装配规则！！！（<span class="hljs-meta">@ConditionnalOnClass(使用者所需要导入的类.class)</span>）<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2021/12/13/O3bjzpPL7FcgJBf.png" alt="AutoConfigurationImportSelector.png"></p><center>上图不难看出，默认导入的组件有127个之多。</center><h1 id="自动配置中一些有趣的东西"><a href="#自动配置中一些有趣的东西" class="headerlink" title="自动配置中一些有趣的东西"></a>自动配置中一些有趣的东西</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnBean(&#123;MultipartResolver.class&#125;)</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean(</span><br><span class="hljs-meta">            name = &#123;&quot;multipartResolver&quot;&#125;</span><br><span class="hljs-meta">        )</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">(MultipartResolver resolver)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> resolver;<br>        &#125;<br><span class="hljs-comment">// 上面这就是MultipartResolver文件上传解析器,当容器中有该类并且找不到该类名为multipartResolver的组件时，则通过下面的函数，利用参数由容器中获取，然后将之返回，并将其名字改为函数名即multipartResolver，然后重新放回到容器中！</span><br><span class="hljs-comment">// 此例用于将不规范的文件上传解析器名字进行更改，以规范化！</span><br></code></pre></td></tr></table></figure><p><strong>SpringBoot默认会在底层配好所有的组件，但是如果用户自己配置了的话，则就以用户的优先</strong><br>下面以字符配置(HttpEncodingAutoConfiguration)为例，并先对默认配置进行解释，再展示自我配置的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix=&quot;server.servlet.encoding&quot;,value = &#123;&quot;enabled&quot;&#125;,matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Encoding properties;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpEncodingAutoConfiguration</span><span class="hljs-params">(ServerProperties properties)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.properties = properties.getServlet().getEncoding();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        CharacterEncodingFilter filter = <span class="hljs-keyword">new</span> OrderedCharacterEncodingFilter();<br>        filter.setEncoding(<span class="hljs-keyword">this</span>.properties.getCharset().name());<br>        filter.setForceRequestEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));<br>        filter.setForceResponseEncoding(<span class="hljs-keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));<br>        <span class="hljs-keyword">return</span> filter;<br>    &#125;<br><span class="hljs-comment">/*...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">  ...</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    从上面的源码中我们可以得知HttpEncodingAutoConfiguration是一个配置类，且其开启了类ServerProperties的配置绑定，并将之加入于容器中，然后我们的是Web项目，且是类型为Servlet的，又因为自动导入了SpringMVC,因此对应的CharacterEncodingFilter类也存在，最后的注解标识是实不实现都可以，因此满足自动配置此类的条件，则可以继续往下执行！<br>​    它的构造函数会从刚刚加入到容器中的ServerProperties组件获取，然后把一些内容交予本类的成员properties，之后的characterEncodingFilter()这个函数，则利用该成员进行字符编码的设置！！<strong>由此可见，若想通过DIY方式配置SpringBoot的环境，可以通过修改配置文件（即application.properties）来实现；</strong></p><p>​    当然也可以通过接下来的手段实现，<strong>因为在进行组件的注册时，其有条件装配规定的约束，当容器中无该类才执行，即若是使用者自行注册，则不会再次于其中注册</strong>，此即满足了<strong>用户优先原则，且也为我们DIY配置环境提供了一个方法，就是自己定义配置类进行注册</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以下以字符编码CharacterEncodingFilter类为例，先展示无修改任何配置的情况下的正常输出：</span><br><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>  <span class="hljs-comment">// 映射请求，表示希望浏览器发送hello请求</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handle01</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,SpringBoot2!&quot;</span> + name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 当我们在浏览器中键入：&#x27;localhost:8888/hello?name=张三&#x27; 则在浏览器中会显示&#x27;Hello,SpringBoot2!张三&#x27;，由此可见SpringBoot默认在底层的确给我们配置好了所有组件！</span><br><br><span class="hljs-comment">// 接下来，通过修改配置文件application.properties来进行乱码操作！</span><br>我们通过查找HttpEncodingAutoConfiguration类发现其prefix为server.servlet.encoding，然后在application.properties中进行修改，将之修改为server.servlet.encoding.charset=ISO-<span class="hljs-number">8859</span>-<span class="hljs-number">1</span><br>则通过浏览器进行输入测试，会发现，已乱码为：Hello,SpringBoot2!??<br>    由此可见，配置文件DIY便利着实有效！<br><br><span class="hljs-comment">// 接下来，通过自定义配置类，然后注册组件实现字符编码DIY</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> CharacterEncodingFilter <span class="hljs-title">characterEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br><span class="hljs-comment">//上述代码实则在运行的时候会报错，因为该组件在底层其他部分也有重要的应用，但可以通过这种方法注册组件，而不是使用系统默认的组件配置。</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><p>SpringBoot先加载所有的自动配置类（xxxAutoConfiguration）</p></li><li><p>每个自动配置类按照条件装配进行生效，默认都会“绑定”配置文件指定的值，这个绑定是通过利用参数xxxProperties(这是个类，用于配置属性绑定的)获得的。xxxProperties和它对应的配置文件进行了配置绑定！</p></li><li><p>生效的配置类就会给容器中装配组件</p></li><li><p>只要容器中有这些组件，相当于拥有了这些功能</p></li><li><p>只要用户有自己配置的，就以用户的优先</p></li><li><p>定制化配置（DIY配置）</p><blockquote><p>用户通过自定义配置类再通过@Bean注解来使用自己想配置的组件</p><p>用户通过看底层源码对应的xxxProperties中的prefix来获取前缀，通过application.properties来进行修改（结合tab提示）</p></blockquote></li></ul><p>xxxAutoConfiguration(自动配置类) —&gt; 导入了一大堆组件 —&gt; 通过xxxProperties去获取值 —&gt; 通过application.properties去重设置值</p><hr><h1 id="SpringBoot编写逻辑"><a href="#SpringBoot编写逻辑" class="headerlink" title="SpringBoot编写逻辑"></a>SpringBoot编写逻辑</h1><ol><li>引入对应的场景依赖<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/using-spring-boot.html#using-boot-starter">spring-boot-starter-xxx</a></li></ul></li><li>查看自动配置了哪些组件<ul><li>自行分析，引入场景对应的自动配置一般都生效了</li><li>配置文件中debug=true<strong>开启自动配置报告</strong> Negative(不生效) / Positive(生效)</li></ul></li><li>是否需要修改<ul><li>参照文档修改配置项<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/html/appendix-application-properties.html#common-application-properties">文档地址</a></li></ul></li><li>自行分析，xxxProperties绑定的配置文件的前缀，然后找到注入的部分</li><li>自定义加入或者替换组件<ul><li>@Bean@Component</li></ul></li><li>自定义器xxxCustomizer(目前IDon’tKnow)</li><li>…</li></ul></li></ol><hr><h1 id="开发小技巧-Lombok"><a href="#开发小技巧-Lombok" class="headerlink" title="开发小技巧-Lombok"></a>开发小技巧-Lombok</h1><p>Lombok这个东西可用于简化JavaBean的开发</p><p>安装依赖及插件的过程如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">1.依赖安装<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.插件安装，通过Settings&gt;Plugins下搜索lombok进行安装即可！</p><p>lombok的几个重要注解：</p><ul><li>@Data:会自动给Javabean的成员变量创造get、set方法，在程序编译时生效</li><li>@ToString:会自动给Javabean的成员变量们构造toString函数</li><li>@NoArgsConstructor:自动给Javabean创造无参构造器</li><li>@AllArgsConstructor:自动给Javabean创造全成员的构造器</li><li>@Slf4j:给类注入日志类，以后在该类中调用log.info()便可将内容通过日志输出，而不用sout输出于控制台下 </li></ul><p>注：若需部分成员构造器，则可以自行编写或利用IDEA的自动编写功能</p><hr><h1 id="开发小技巧-dev-tools"><a href="#开发小技巧-dev-tools" class="headerlink" title="开发小技巧-dev-tools"></a>开发小技巧-dev-tools</h1><p>此物需要增加依赖于pom.xml中，用于制造伪热更新（实质通过restart形式实现，而热更新是通过reload形式实现），以下是其依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们修改我们的代码文件后，不需要通过关闭再打开项目来实现刷新，而直接通过Ctrl + F9重新编译项目即可，然后就实现了刷新！</p><p>如果想要使用真正的热更新，可以付费购买插件JRebel。</p><hr><h1 id="开发小技巧-Spring-Initializer"><a href="#开发小技巧-Spring-Initializer" class="headerlink" title="开发小技巧-Spring Initializer"></a>开发小技巧-Spring Initializer</h1><p>创建SpringBoot项目通过File&gt;New&gt;Project&gt;Spring Initializer以GUI界面创建SpringBoot，其中要啥starter就自行勾选啥，然后创建的时候要联网，会自动帮你导jar包（就是自动添加依赖啦）。</p><p>不过一开始关于mvn和.gitignore不会用到，删去即可。</p><p>而在src下，我们可以看到src&gt;main&gt;java + resources。在resources目录下，可以看到application.properties + static(包)  + templates(包)</p><p>static包用于存储静态资源，如css 、js；templates包用于存放页面</p><hr><h1 id="配置文件-yaml用法"><a href="#配置文件-yaml用法" class="headerlink" title="配置文件-yaml用法"></a>配置文件-yaml用法</h1><hr><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>key: value #k，v之间有空格</li><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li><li>‘’ 与 “” 表示字符串内容，会比如 转义/不转义</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>字面量：单个的、不可再分的值 Date、Boolean、String、number、null</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">k: v<br></code></pre></td></tr></table></figure><ul><li>对象：键值对的集合。 map、hash、set、object</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: &#123;k1:v1,k2:v2,k3:v3&#125;<br>或<br>k:<br> k1: v1<br> k2: v2<br> k3: v3<br></code></pre></td></tr></table></figure><ul><li>数组：一组按次序排列的值。array、list、queue</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">行内写法： k: [v1,v2,v3]<br>或<br>k:<br> - v1<br> - v2<br> - v3<br></code></pre></td></tr></table></figure><h1 id="配置文件-自定义类绑定的配置提示"><a href="#配置文件-自定义类绑定的配置提示" class="headerlink" title="配置文件-自定义类绑定的配置提示"></a>配置文件-自定义类绑定的配置提示</h1><hr><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加如下依赖:<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>在build&gt;plugins下的spring-boot-maven-plugin插件内添加如下配置，以在打包时舍弃之，减少包的大小<br><span class="hljs-tag">&lt;<span class="hljs-name">configuraion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuraion-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuraion</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h1 id="Web-静态资源规则与定制化"><a href="#Web-静态资源规则与定制化" class="headerlink" title="Web-静态资源规则与定制化"></a>Web-静态资源规则与定制化</h1><h2 id="1-静态资源目录"><a href="#1-静态资源目录" class="headerlink" title="1. 静态资源目录"></a>1. <strong>静态资源目录</strong></h2><p>只要静态资源放在类路径下：</p><p><code>/static</code>(or<code>/public</code>or<code>/resources</code>or<code>/META-INF/resources</code>)</p><p>则可以直接通过：当前项目根路径/ + 静态资源名 <strong>进行访问</strong></p><p><strong>原理：静态映射/**，即拦截所有的请求，而controller也是如此。</strong></p><p><strong>在运行的时候，请求进来，先去找controller看能不能处理，不能处理的所有请求则交给静态资源处理器，若是静态资源处理器也无法处理则报告404</strong></p><p><strong>改变默认的静态资源路径：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">static-locations:</span> [<span class="hljs-string">classpath:/xxx/</span>]<br></code></pre></td></tr></table></figure><h2 id="2-静态资源访问前缀"><a href="#2-静态资源访问前缀" class="headerlink" title="2. 静态资源访问前缀"></a>2. <strong>静态资源访问前缀</strong></h2><p>默认无前缀。</p><p>之所以要使用这个东西是因为，如果是一个web项目，需要登录后才可以执行某一些操作，若是拦截器拦截/**，则静态资源也会被拦截。为了拦截器可以放行静态资源，因此可以通过静态资源加上访问前缀来过滤掉它们。</p><p>可以通过如下方式在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/res/**</span><br></code></pre></td></tr></table></figure><h2 id="3-支持webjar静态资源访问"><a href="#3-支持webjar静态资源访问" class="headerlink" title="3. 支持webjar静态资源访问"></a>3. <strong>支持webjar静态资源访问</strong></h2><p>webjar即是将如css、js等文件通过jar包的形式给出，可通过依赖获得</p><p><a href="https://www.webjars.org/">获取webjar</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 以下是一个jQuery的webjar的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>访问形式：localhost:8080/webjars/…(资源详细路径)</p><hr><h1 id="Web-welcome与favicon功能"><a href="#Web-welcome与favicon功能" class="headerlink" title="Web-welcome与favicon功能"></a>Web-welcome与favicon功能</h1><h2 id="1-欢迎页支持"><a href="#1-欢迎页支持" class="headerlink" title="1. 欢迎页支持"></a>1. 欢迎页支持</h2><p>用于直接ip:port访问项目，会显示index.html欢迎页</p><ul><li>静态资源路径下放置index.html<ul><li><strong>可以配置静态资源路径</strong></li><li><strong>不可以配置静态资源访问前缀，否则会导致index.html不能默认访问</strong></li></ul></li></ul><h2 id="2-自定义Favicon"><a href="#2-自定义Favicon" class="headerlink" title="2. 自定义Favicon"></a>2. 自定义Favicon</h2><p>用于更改web项目的小图标，这个在静态资源路径下放置favicon.ico即可，需注意浏览器缓存可能导致的无法显示。同样的也<strong>不可以配置静态资源的访问前缀</strong>，否则会导致其失效</p><hr><h1 id="静态资源配置原理"><a href="#静态资源配置原理" class="headerlink" title="静态资源配置原理"></a>静态资源配置原理</h1><ul><li><p>SpringBoot启动默认加载 xxxAutoConfiguration类(自动配置类)</p></li><li><p>SpringMVC功能的自动配置类 WebMvcAutoConfiguration生效</p><ul><li>那么它给容器中配了些什么呢？</li></ul><p>比如：OrderedHiddenHttpMethodFilter(用来兼容rest风格，表单可以提交PUT、DELETE等)、OrderedFormContentFilter(表单内容过滤器)，然后有一个叫做WebMvcAutoConfigurationAdapter这么一个配置类（那么它肯定也在容器中）。接下来研究一下它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>先看到配置文件，它让WebMvcProperties和ResourceProperties跟对应的配置文件绑定。<strong>spring.mvc==WebMvcProperties 、spring.resources==ResourceProperties</strong></li></ul></li></ul><p>​    1. <strong>配置类只有一个有参构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有参构造器所有参数的值都会从容器中确定</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* resourceProperties 获取和spring.resources绑定的所有值的对象</span><br><span class="hljs-comment">* mvcProperties 获取和spring.mvc绑定的所有值的对象</span><br><span class="hljs-comment">* beanFactory Spring的bean工厂</span><br><span class="hljs-comment">* HttpMessageConverters 找到所有的HttpMessageConverters</span><br><span class="hljs-comment">* ResourceHandlerRegistrationCustomizer 找到资源处理器的自定义器</span><br><span class="hljs-comment">* DispatcherServletPath</span><br><span class="hljs-comment">* ServletRegistrationBean 注册servlet、filter...</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span><span class="hljs-params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties, ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider, ObjectProvider&lt;WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider, ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath, ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.resourceProperties = resourceProperties;<br>            <span class="hljs-keyword">this</span>.mvcProperties = mvcProperties;<br>            <span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>            <span class="hljs-keyword">this</span>.messageConvertersProvider = messageConvertersProvider;<br>            <span class="hljs-keyword">this</span>.resourceHandlerRegistrationCustomizer = (WebMvcAutoConfiguration.ResourceHandlerRegistrationCustomizer)resourceHandlerRegistrationCustomizerProvider.getIfAvailable();<br>            <span class="hljs-keyword">this</span>.dispatcherServletPath = dispatcherServletPath;<br>            <span class="hljs-keyword">this</span>.servletRegistrations = servletRegistrations;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>资源处理的默认规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>       <span class="hljs-comment">// isAddMapping这个玩意是看你要不要使用静态资源的默认规则，可以通过spring.resources.add-mappings来选择使用或关闭，默认使用</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这个是用来设置静态资源的缓存的存活时间，可以通过spring.resources.cache.period设置</span><br>                Duration cachePeriod = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getPeriod();<br>                CacheControl cacheControl = <span class="hljs-keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();<br>                <span class="hljs-comment">// 注册/webjars/**静态资源，且说明其资源路径是META-INF/resources/webjars下，那么之后访问webjars资源则通过访问/webjars/所需访问的资源的层级目录即可！所以这里是webjars的规则（/webjars/**的所有请求，通过类路径下的/META-INF/resources/webjars下拿）</span><br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(<span class="hljs-string">&quot;/webjars/**&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/webjars/**&quot;</span>&#125;).addResourceLocations(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>&#125;).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br>   <span class="hljs-comment">// 这一段是对静态资源默认路径的配置，先通过mvcProperties获取/**下的所有请求，通过getStaticLocations获取的区域下面拿取静态资源。静态资源都有缓存策略</span><br>                String staticPathPattern = <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern();<br>                <span class="hljs-keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;<br>                    <span class="hljs-keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="hljs-keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="hljs-keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));<br>                &#125;<br><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>欢迎页的处理规则</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HandlerMapping:处理器映射，保存了每一个handler能处理哪些的请求 </span><br><span class="hljs-meta">@Bean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> WelcomePageHandlerMapping <span class="hljs-title">welcomePageHandlerMapping</span><span class="hljs-params">(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;<br>            WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="hljs-keyword">new</span> WelcomePageHandlerMapping(<span class="hljs-keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, <span class="hljs-keyword">this</span>.getWelcomePage(), <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern());<br>            welcomePageHandlerMapping.setInterceptors(<span class="hljs-keyword">this</span>.getInterceptors(mvcConversionService, mvcResourceUrlProvider));<br>            welcomePageHandlerMapping.setCorsConfigurations(<span class="hljs-keyword">this</span>.getCorsConfigurations());<br>            <span class="hljs-keyword">return</span> welcomePageHandlerMapping;<br>        &#125;<br><br><span class="hljs-comment">// 以下是欢迎页处理器映射的构造函数，不难看出，它写死了欢迎页只能在/**下</span><br>WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123;<br>    <span class="hljs-comment">// 欢迎页存在且/**等于静态资源路径才可以使用之，否则不行</span><br>        <span class="hljs-keyword">if</span> (welcomePage.isPresent() &amp;&amp; <span class="hljs-string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page: &quot;</span> + welcomePage.get());<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;forward:index.html&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;<br>            logger.info(<span class="hljs-string">&quot;Adding welcome page template: index&quot;</span>);<br>            <span class="hljs-keyword">this</span>.setRootViewName(<span class="hljs-string">&quot;index&quot;</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="请求参数处理"><a href="#请求参数处理" class="headerlink" title="请求参数处理"></a>请求参数处理</h1><h2 id="请求映射-这里说的不是RequestMapping-而是Rest风格的请求映射注解"><a href="#请求映射-这里说的不是RequestMapping-而是Rest风格的请求映射注解" class="headerlink" title="请求映射(这里说的不是RequestMapping,而是Rest风格的请求映射注解)"></a>请求映射(这里说的不是RequestMapping,而是Rest风格的请求映射注解)</h2><ul><li>@xxxMapping</li><li>Rest风格支持*(使用<strong>HTTP请求方式动词</strong>来表示对资源的操作)*<ul><li>以前是通过：/getUser获取用户 /deleteUser删除用户 /editUser修改用户 /saveUser保存用户</li><li>现在是通过： /user （就只这一个访问路径）<ul><li>GET-获取用户 DELETE-删除用户 PUT-修改用户 POST-保存用户</li></ul></li><li>核心Filter：HiddenHttpMethodFilter<ul><li><strong>用法： 表单method=post , 隐藏域type=hidden,_method=PUT</strong></li><li><strong>需注意还需要手动开启：spring.mvc.hiddenmethod.filter.enable=true；</strong></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br><br><br>源码部分：<br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span><br>   <span class="hljs-meta">@ConditionalOnProperty(</span><br><span class="hljs-meta">       prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span><br><span class="hljs-meta">       name = &#123;&quot;enabled&quot;&#125;,</span><br><span class="hljs-meta">       matchIfMissing = false</span><br><span class="hljs-meta">   )</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> OrderedHiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OrderedHiddenHttpMethodFilter();<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>Rest原理(表单提交，且需要使用REST时)</strong></p><ul><li>表单提交会带上_method=PUT</li><li>请求过来的时候会被HiddenHttpMethodFilter拦截<ul><li>请求是否是POST，且是否正常<ul><li>获取到_method的值</li><li>原生request(post)，包装模式requestWrapper重写了getMethod方法，返回的是传入的值(_method=XXX)</li><li>兼容以下请求：<strong>PUT DELETE PATCH等</strong></li><li>过滤链放行的时候使用的是wrapper。以后调用的getMethod方法是调用requestWrapper的。</li></ul></li></ul></li></ul><p><strong>Rest使用客户端工具：</strong></p><ul><li>如postman直接发生put、delete等方式请求，无需filter重新包装</li></ul><p><strong>上述的@RequestMapping(value=”/user”,method=”RequestMethod.POST”)这些注解，可以更改为以下的注解(由上述注解合成而来)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@PostMapping(&quot;/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PostUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Post User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">DeleteUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Delete User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@PutMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PutUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Put User&quot;</span>;<br>   &#125;<br><span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get User&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>如何更改默认的_method为我们想要的名字呢？</strong>请看以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>    <span class="hljs-comment">// 组件无依赖故Lite型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HiddenHttpMethodFilter <span class="hljs-title">hiddenHttpMethodFilter</span><span class="hljs-params">()</span></span>&#123;<br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        hiddenHttpMethodFilter.setMethodParam(<span class="hljs-string">&quot;_m&quot;</span>);<br>        <span class="hljs-keyword">return</span> hiddenHttpMethodFilter;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过使用“用户优先原则”来进行HiddenHttpMethodFilter组件的注册，并设定MethodParam的值，重而实现更改默认的_method！</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="请求映射原理"><a href="#请求映射原理" class="headerlink" title="请求映射原理"></a>请求映射原理</h2><hr><h2 id="普通参数与基本注解"><a href="#普通参数与基本注解" class="headerlink" title="普通参数与基本注解"></a>普通参数与基本注解</h2><ul><li>注解：</li></ul><p>==@PathVariable、@RequestHeader、@RequestParam、@CookieValue、@RequestAttribute、@RequestBody、@MatrixVariable==</p><ul><li>Servlet API</li></ul><p>==WebRequest、ServletRequest、MultipartRequest、HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、Zoneld==</p><ul><li>复杂参数</li></ul><p>==Map、Model(<strong>map,model里面的数据会被放在request请求域中</strong>即req.setAttribute(xxx))、Errors/BindingResult、RedirectAttributes(<strong>重定向携带数据</strong>)、ServletResponse(<strong>Response</strong>)、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder==</p><ul><li>自定义对象参数</li></ul><p>==可以自动类型转换和格式化，可以级联封装==</p><h3 id="1-注解："><a href="#1-注解：" class="headerlink" title="1. 注解："></a>1. <strong>注解：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @PathVariable一般接收的是Rest风格的请求，即表单请求，因此使用GetMapping,然后里面的value/path用希望使用者访问的路径和传入的数据，而数据通过&#123;数据名&#125;的形式括起来，在函数的参数部分通过@PathVariable(数据名)来获取数据，并且给到参数；当然也可以通过Map&lt;String,String&gt;的方式来进行直接获取全部的参数，此时在@PathVariable里不需写任何参数。</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;id&quot;</span>,id);<br>       map.put(<span class="hljs-string">&quot;username&quot;</span>,userName);<br>       map.put(<span class="hljs-string">&quot;pv&quot;</span>,pv);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br><span class="hljs-comment">// @RequestHeader获取的是浏览器页面的请求头的kv值，可以通过@RequestHeader(数据名)来获取数据；也可以通过@RequestHeader Map&lt;String,String&gt; rh来获取所有的请求头的内容，此时再@RequestHeader内不需写任何内容。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,<span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh)</span></span>&#123;<br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;userAgent&quot;</span>,userAgent);<br>       map.put(<span class="hljs-string">&quot;rh&quot;</span>,rh);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br><br>  <span class="hljs-comment">// @RequestParam获取的请求参数，可以通过@RequestParam(数据名)来获取数据的值；也可以通过@RequestParam Map&lt;String,String&gt;来获取所有的请求参数的信息，这时不需要写数据名，默认全部访问</span><br><span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;age&quot;</span>,age);<br>       map.put(<span class="hljs-string">&quot;interests&quot;</span>,interests);<br>       map.put(<span class="hljs-string">&quot;rp&quot;</span>,rp);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @CookieValue注解用于获取当前访问内容的cookie值。可通过以下来种方式进行访问：①@CookieValue(cookie的名称) 基本数据类型，则这样获取到的是这个cookie对应的value值；②@CookieValue(cookie的名称) Cookie cookie,则这样获取到的是cookie的对象，里面有其name和value和供我们获得</span><br>   <span class="hljs-meta">@GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getCar</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String userName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@PathVariable</span> Map&lt;String,String&gt; pv,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestHeader</span> Map&lt;String,String&gt; rh,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam(&quot;interest&quot;)</span> List&lt;String&gt; interests,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@RequestParam</span> Map&lt;String,String&gt; rp,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span> String _ga,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-meta">@CookieValue(&quot;_ga&quot;)</span>Cookie cookie)</span></span>&#123;<br><br>       Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       <span class="hljs-comment">//=======</span><br>       map.put(<span class="hljs-string">&quot;_ga&quot;</span>,_ga);<br>       System.out.println(cookie.getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + cookie.getValue());<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br><br>   <span class="hljs-comment">// @RequestBody获取请求体，这个只有post请求才有请求体。可以通过这样来获取表单的kv数据。@RequestBody String content</span><br><span class="hljs-meta">@PostMapping(&quot;/save&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String content)</span></span>&#123;<br>       Map map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;内容&quot;</span>,content);<br>       <span class="hljs-keyword">return</span> map;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 搭配上述内容使用的HTML文件 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>com.ayy.test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>HelloIndexHtml<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GET-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;POST-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;DELETE-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/user&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PUT-TYPE&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;car/3/owner/zhangsan?age=18&amp;interest=basketball&amp;interest=tennis&quot;</span>&gt;</span>car/&#123;id&#125;/owner/&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@PathVariable 路径变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestHeader 获取请求头<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestParam 获取请求参数<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@CookieValue 获取Cookie值<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestAttribute 获取request域属性<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@RequestBody 获取请求体<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>@MatrixVariable 矩阵变量<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/save&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Pwd&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;passwd&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Usr&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usrName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/sell;price=300000;brand=BYD,AUTO,TESLA&quot;</span>&gt;</span>MatrixVariable111 /cars/sell;price=300000;brand=BYD,AUTO,TESLA<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/cars/boss;id=666/emp;id=888&quot;</span>&gt;</span>MatrixVariable222 /cars/boss;id=666/emp;id=888<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @RequestAttribute获取request域的属性。request可以通过setAttribute方法来设置属性，而request是在一次请求中生效。这就要说下forward和redirect两个的区别先。</span><br><span class="hljs-comment">// forward是直接转发，它只需要客户端发起一次的请求即可；而redirect(重定向/间接转发)是客户端发起两次请求。服务器端在响应第一次请求的时候，让浏览器再向另一个URL发出请求，从而达到转发的目的。</span><br><span class="hljs-comment">// 因此本次测试，需要采用forward直接转发的方式</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此例子用于显示HttpServletRequest 和 <span class="hljs-doctag">@RequestAttribute</span>注解提取request的域属性，需用forward进行直接请求转发，redirect这个是间接转发要进行</span><br><span class="hljs-comment">     * 两次请求，不符要求</span><br><span class="hljs-comment">     * 在默认情况下，无<span class="hljs-doctag">@ReponseBody</span>默认进行页面跳转</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@GetMapping(&quot;/goto&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">gotoNextPage</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>        request.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        request.setAttribute(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(&quot;user&quot;)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-meta">@RequestAttribute(&quot;status&quot;)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                           HttpServletRequest request)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>        map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MatrixVariable是矩阵变量，需要与PathVariable路径变量结合起来使用。且一般存放的是cookie的kv</span><br><span class="hljs-comment">// 我们通过PathVariable设置访问路径，而MatrixVariable是在路径变量;后的那一大串，当然也可以通过另一个路径变量相隔开。</span><br><span class="hljs-comment">// 矩阵变量的例子： localhost://car/sell;price=200000;brand=BYD,AUTO,TESLA</span><br><span class="hljs-comment">// 其中同一个k的多个v也可以用分号拆开(brand=BYD;brand=AUTO;brand=TESLA)，这里的sell就是PathVariable，后面的;到结尾都是MatrixVariable。</span><br><span class="hljs-comment">// 那么通过路径来显示就是/car/&#123;path;price=xxx;brand=xxx,yyy,zzz&#125; ，这里可以看出MatrixVariable必须依靠PathVariable而存在</span><br><span class="hljs-comment">// 需要跟RequestParam进行区分/car/&#123;path&#125;?price=xxx&amp;brand=xxx，这里可以看出PathVariable和RequestParam是独立的两个个体</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarSell</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;path&quot;)</span> String path,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;price&quot;)</span> Integer price,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-meta">@MatrixVariable(&quot;brand&quot;)</span> List&lt;String&gt; brand)</span></span>&#123;<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;path&quot;</span>,path);<br>        map.put(<span class="hljs-string">&quot;price&quot;</span>,price);<br>        map.put(<span class="hljs-string">&quot;brand&quot;</span>,brand);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 需注意，以下此物默认关闭，需自定义组件UrlPathHelper来开启</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">webMvcConfigurer</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;<br>                UrlPathHelper urlPathHelper=<span class="hljs-keyword">new</span> UrlPathHelper();<br>                <span class="hljs-comment">// 开启不移除分号功能，这样才可以使MatrixVariable生效</span><br>                urlPathHelper.setRemoveSemicolonContent(<span class="hljs-keyword">false</span>);<br>                configurer.setUrlPathHelper(urlPathHelper);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br><span class="hljs-comment">// 若是存在/car/1;age=20/2;age=30这种情况，则可以利用MatrixVariable的参数pathVar来设定区域，否则若是直接根据k取age会都取到第一个。</span><br><span class="hljs-comment">//    /cars/boss;id=666/emp;id=888</span><br>    <span class="hljs-meta">@GetMapping(&quot;/cars/&#123;path1&#125;/&#123;path2&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">getCarDetail</span><span class="hljs-params">(<span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path1&quot;)</span> Integer bid,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-meta">@MatrixVariable(value = &quot;id&quot;,pathVar = &quot;path2&quot;)</span> Integer eid)</span></span>&#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;bid&quot;</span>,bid);<br>        map.put(<span class="hljs-string">&quot;eid&quot;</span>,eid);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br><span class="hljs-comment">// 小拓展：一般来说我们若是将cookie功能禁掉，是无法访问到session的，因为session-&gt;jsessionId相关联-&gt;而jsessionId是存放在cookie-&gt;cookie在每一次的请求中都会被带上，但若是禁掉，就无法获得jessionId，就无法获得session。但现在可以通过矩阵变量的方式去获得(具体不清晰！！！)</span><br></code></pre></td></tr></table></figure><h3 id="2-Servlet-API"><a href="#2-Servlet-API" class="headerlink" title="2. Servlet API"></a>2. Servlet API</h3><p>就如上面所说的那么多的Servlet API，是怎么通过Resolver（即参数解析器）来实现对应参数获取的？此外，注解获得的参数，也是通过参数解析器实现参数的获取。</p><p>以下以HttpServletRequest这个ServletAPI来展示如何通过参数解析器来获取之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ServletRequestMethodArgumentResolver</span><br>WebRequest.class.isAssignableFrom(paramType) || <br>ServletRequest.class.isAssignableFrom(paramType) || <br>MultipartRequest.class.isAssignableFrom(paramType) || <br>HttpSession.class.isAssignableFrom(paramType) || <br>pushBuilder != <span class="hljs-keyword">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType) ||<br>Principal.class.isAssignableFrom(paramType) || <br>InputStream.class.isAssignableFrom(paramType) || <br>Reader.class.isAssignableFrom(paramType) || <br>HttpMethod.class == paramType || <br>Locale.class == paramType || <br>TimeZone.class == paramType || <br>ZoneId.class == paramType;<br><span class="hljs-comment">// WebRequest == Request + Response + ...</span><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">resolveNativeRequest</span><span class="hljs-params">(NativeWebRequest webRequest, Class&lt;T&gt; requiredType)</span> </span>&#123;<br>        T nativeRequest = webRequest.getNativeRequest(requiredType);<br>        <span class="hljs-keyword">if</span> (nativeRequest == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Current request is not of type [&quot;</span> + requiredType.getName() + <span class="hljs-string">&quot;]: &quot;</span> + webRequest);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> nativeRequest;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 此时即返回原生的request。因此这是通过resolver实现ServletAPI参数获取的一个展示。可通过debug逐步寻找</span><br></code></pre></td></tr></table></figure><h3 id="3-复杂参数"><a href="#3-复杂参数" class="headerlink" title="3. 复杂参数"></a>3. 复杂参数</h3><p>对于复杂参数：<strong>Model、Map它俩存放的区域是request的请求域(渲染时存放的)，即request attribute那个东西。以下例子通过直接转发来体现之：访问localhost:8080/params -&gt; localhost:8080/success</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/params&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(Map&lt;String,Object&gt; map,</span></span><br><span class="hljs-params"><span class="hljs-function">                        Model model,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletRequest req,</span></span><br><span class="hljs-params"><span class="hljs-function">                        HttpServletResponse resp)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,<span class="hljs-string">&quot;map content&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;md&quot;</span>,<span class="hljs-string">&quot;model content&quot;</span>);<br>    req.setAttribute(<span class="hljs-string">&quot;req&quot;</span>,<span class="hljs-string">&quot;request content&quot;</span>);<br><br>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;c1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>);<br>    resp.addCookie(cookie);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/success&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/success&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">successPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestAttribute(value =&quot;user&quot;,required = false)</span> String user,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-meta">@RequestAttribute(value = &quot;status&quot;,required = false)</span> Integer status,</span></span><br><span class="hljs-params"><span class="hljs-function">                       HttpServletRequest request)</span></span>&#123;<br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;r_attribute:&quot;</span>,user);<br>    map.put(<span class="hljs-string">&quot;r_servletRequset&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;map1&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;map1&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;md&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;md&quot;</span>));<br>    map.put(<span class="hljs-string">&quot;req&quot;</span>,request.getAttribute(<span class="hljs-string">&quot;req&quot;</span>));<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-自定义对象的参数"><a href="#4-自定义对象的参数" class="headerlink" title="4. 自定义对象的参数"></a>4. 自定义对象的参数</h3><p>它是通过一个叫“数据绑定”的东西：当页面提交的请求数据(GET、POST)都可以和对象属性进行绑定，包括级联绑定。以下是数据绑定的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/saveUser&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">saveUser</span><span class="hljs-params">(Person person)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> person;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/saveUser&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zhangsan&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    生日：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;birth&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2000/1/5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    宠物年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pet.age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h1><hr><h2 id="响应JSON"><a href="#响应JSON" class="headerlink" title="响应JSON"></a>响应JSON</h2><h3 id="jackson-jar-ResponseBody"><a href="#jackson-jar-ResponseBody" class="headerlink" title="jackson.jar +  ResponseBody"></a>jackson.jar +  ResponseBody</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>web场景自动引入了Json场景<br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以通过jackson.jar包和@ResponseBody注解返回给前端json数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Person person;<br><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/response/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.person;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个返回值是如何变成了json数据的格式呢？</p><p>先前说过ArgumentResolver参数解析器，在确定方法的参数值的时候，会用各种参数解析器来确定；</p><p>而现在有ReturnValueHandler，故可知springmvc对返回值的所有解析也是采取了返回值解析器的方法。</p><hr><h2 id="ReturnValueHandler原理"><a href="#ReturnValueHandler原理" class="headerlink" title="ReturnValueHandler原理"></a>ReturnValueHandler原理</h2><hr><h2 id="HTTPMessageConverter原理"><a href="#HTTPMessageConverter原理" class="headerlink" title="HTTPMessageConverter原理"></a>HTTPMessageConverter原理</h2><hr><h2 id="内容协商原理"><a href="#内容协商原理" class="headerlink" title="内容协商原理"></a>内容协商原理</h2><hr><h2 id="基于请求参数的内容协商原理"><a href="#基于请求参数的内容协商原理" class="headerlink" title="基于请求参数的内容协商原理"></a>基于请求参数的内容协商原理</h2><hr><h2 id="自定义MessageConverter"><a href="#自定义MessageConverter" class="headerlink" title="自定义MessageConverter"></a>自定义MessageConverter</h2><hr><h2 id="浏览器与PostMan内容协商完全适配"><a href="#浏览器与PostMan内容协商完全适配" class="headerlink" title="浏览器与PostMan内容协商完全适配"></a>浏览器与PostMan内容协商完全适配</h2><hr><h1 id="视图解析与模板引擎"><a href="#视图解析与模板引擎" class="headerlink" title="视图解析与模板引擎"></a>视图解析与模板引擎</h1>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
