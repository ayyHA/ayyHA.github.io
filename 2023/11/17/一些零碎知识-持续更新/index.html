

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一些零碎的知识,主要起概念理解作用">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="一些零碎的知识,主要起概念理解作用">
<meta property="og:type" content="article">
<meta property="og:title" content="一些零碎知识(持续更新)">
<meta property="og:url" content="http://example.com/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="一些零碎的知识,主要起概念理解作用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png">
<meta property="og:image" content="https://s2.loli.net/2024/08/15/mIl78OekFQasEx1.png">
<meta property="article:published_time" content="2023-11-17T02:56:43.000Z">
<meta property="article:modified_time" content="2024-10-19T12:23:16.451Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg">
  
  <title>一些零碎知识(持续更新) - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="一些零碎知识(持续更新)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-11-17 10:56" pubdate>
        2023年11月17日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      34 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">一些零碎知识(持续更新)</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：7 天前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="python-u是啥"><a class="markdownIt-Anchor" href="#python-u是啥"></a> python -u是啥</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.stdout.write(<span class="hljs-string">&quot;correct1&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error1&quot;</span>)<br>sys.stdout.write(<span class="hljs-string">&quot;correct2&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error2&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>stdout是标准输入,stderr是标准错误,一般来说,标准错误没有缓存区,会直接输出到屏幕上;而stdout会有缓存区,即当出现换行符或者到达一定长度才会输出到屏幕,而增加**-u<strong>这个短指令即是使得stdout变为</strong>unbuffered**,使得我们的代码顺序即为输出顺序</p>
<p><mark>在python3.6.8的解释器下执行,感觉好像默认了unbuffered</mark>😕</p>
<h2 id="pty何物是也为啥一些指令都有它"><a class="markdownIt-Anchor" href="#pty何物是也为啥一些指令都有它"></a> pty何物是也,为啥一些指令都有它</h2>
<p>关于tty(终端，是一种字符型设备，名字源于teletypewriter，电传打字机)：</p>
<p>pty:pseudo terminal伪终端</p>
<h2 id="串口并口"><a class="markdownIt-Anchor" href="#串口并口"></a> 串口并口</h2>
<p>串口（串行接口）：一次传输一位数据，较为稳定，可进行长距离通信（串行口COM1,COM2）<br />
并口（并行接口）：一次传输八位数据，但受长度限制，因为长度越长会增加干扰，数据容易出错</p>
<p>详情可见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622677267">硬件基础：硬件通信常见的串口介绍</a></p>
<h2 id="什么是异构"><a class="markdownIt-Anchor" href="#什么是异构"></a> 什么是异构</h2>
<p>异构计算（Heterogeneous Computing）是一种特殊的并行分布式计算系统。它能够经济有效地实现高计算能力，可扩展性强，能够非常高效地利用计算资源。与之相对的概念就是同构计算（Homogeneous Computing），也就是为大家熟知的多核理念。为了突破计算算力受制于功耗的瓶颈，多核CPU技术得到越来越多的应用。强大的CPU采用越来越多的CPU内核这就是传统同构计算系统。很快人们就发现在AI人工智能和自动驾驶爆炸式增长的计算需求下，传统同构计算系统已经无法满足要求，GPU、DSP、FPGA和ASIC由于特定需求下高效性越来越多的被应用。而异构计算技术应运而生，像一个大厨将CPU、GPU、DSP、FPGA和ASIC(Application Specific Integrated Circuit，应用专用集成电路，主流有TPU、NPU、VPU、BPU芯片等)这些优良食材制成一道融合各方口味特点的佳肴<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.zhihu.com/question/63207620/answer/1707221853
">[1]</span></a></sup>。</p>
<ol>
<li>
<p>计算场景异构（通俗意义上的异构计算）<br />
CPU+GPU/DPU<br />
DPU：是对网卡和存储等数据的高效处理<br />
何为计算场景的异构呢，就是本来应该是CPU处理的场景，现在解耦出来由专门的芯片进行处理。</p>
</li>
<li>
<p>计算性能的异构<br />
相比于传统的X86芯片的同构多核，ARM在芯片架构上进行创新，采用了异构多核的芯片架构，芯片里面的核心分了大小核</p>
</li>
<li>
<p>CPU架构的异构<br />
应该就是采用X86，ARM，RISC-V，Alpha，LoongArch等不同的CPU架构</p>
</li>
</ol>
<h2 id="进制单位转换"><a class="markdownIt-Anchor" href="#进制单位转换"></a> 进制单位转换</h2>
<p><img src="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg" srcset="/img/loading.gif" lazyload alt="multiple-byte units" /></p>
<p>左侧代表的是十进制前缀，右侧表示的是二进制前缀</p>
<p>一般是制造商采用十进制，对于我们来说<strong>存储一般指的是二进制</strong>的，而在说到<strong>带宽一类的速率时，指的是十进制的</strong></p>
<h2 id="local目录"><a class="markdownIt-Anchor" href="#local目录"></a> ./local目录</h2>
<p>.local相当于跟全局的python环境进行了一层的隔离，在这里我们可以安装自己需要的库（在本地范围内），而无需提权<br />
类似的安装方式大致如下：<br />
<code>pip install target=~/.local/lib/python3.8/site-packages &lt;package-name&gt;</code><br />
参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67402026/article/details/125241407">https://blog.csdn.net/m0_67402026/article/details/125241407</a></p>
<p>当然，如果知道有多个解释器，也可以安装到对应的解释器的位置，如：<br />
<code>D:\path\to\python.exe -m pip install --user &lt;package-name&gt;</code><br />
参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ThsPool/article/details/132809683">https://blog.csdn.net/ThsPool/article/details/132809683</a></p>
<p>参考:<a target="_blank" rel="noopener" href="https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html">https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html</a></p>
<h2 id="linux软硬链接"><a class="markdownIt-Anchor" href="#linux软硬链接"></a> linux软硬链接</h2>
<p>关于linux软链接的创建删除更新，可以这么理解，Linux的软链接相当于快捷方式 ，硬链接好像会共享原来的inode<br />
以下是参考文章：<a target="_blank" rel="noopener" href="http://www.mobiletrain.org/about/BBS/151003.html">http://www.mobiletrain.org/about/BBS/151003.html</a></p>
<h2 id="site-packages和distpages区别"><a class="markdownIt-Anchor" href="#site-packages和distpages区别"></a> site-packages和distpages区别:</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40614261/article/details/90023807">https://blog.csdn.net/weixin_40614261/article/details/90023807</a></p>
<h2 id="vimrc配置"><a class="markdownIt-Anchor" href="#vimrc配置"></a> vimrc配置</h2>
<p>注意,要查看vimrc在哪可以在一个利用vim打开的文件内通过:version查看,往下滑动可以看到vimrc文件一般配置在:<br />
/etc/vimrc<br />
~/.vimrc</p>
<h2 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h2>
<p>module全称:<strong>module-environment</strong>是一个用于<strong>管理环境变量的工具</strong></p>
<h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3>
<ul>
<li><code>module avail</code>查看所有的模块</li>
<li><code>module load/add 需要加载的模块</code>加载需要加载的模块</li>
<li><code>module unload/rm 需要卸载的模块</code> 卸载需要卸载的模块</li>
<li><code>module list</code> 列出已加载的模块</li>
<li><code>module show 模块</code> 查看指定的模块信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.fasteda.cn/post/22.html0">Linux 下 Module 工具的介绍与使用</a></p>
<h2 id="iterableiteratorgenerator"><a class="markdownIt-Anchor" href="#iterableiteratorgenerator"></a> iterable,iterator,generator</h2>
<p>关于python中iterable,iterator,generator:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/131501576">https://blog.csdn.net/weixin_44966641/article/details/131501576</a></p>
<h2 id="不同操作系统的多线程"><a class="markdownIt-Anchor" href="#不同操作系统的多线程"></a> 不同操作系统的多线程</h2>
<p>Windows用spawn,Unix用fork,主要区别见下文:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CJTARRR/p/17742597.html">fork和spawn区别</a></p>
<h2 id="__getattr__-__getattribute_"><a class="markdownIt-Anchor" href="#__getattr__-__getattribute_"></a> __getattr__ __getattribute_</h2>
<h2 id="descriptor描述器之__get__-__set__-__delete__"><a class="markdownIt-Anchor" href="#descriptor描述器之__get__-__set__-__delete__"></a> descriptor(描述器)之__get__ __set__ __delete__</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/andy1031/p/10923834.html">一些魔法方法</a></p>
<h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tobyqin/p/python-decorator.html">python装饰器1</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/640193185">python装饰器2</a></p>
<h3 id="常用装饰器"><a class="markdownIt-Anchor" href="#常用装饰器"></a> 常用装饰器</h3>
<p>这里介绍三个常用的装饰器语法糖,需注意函数指的是非类方法,方法指的是类内的方法,分为实例方法,类方法,静态方法</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/544021480">方法分类及三个常用装饰器语法糖</a></p>
<ul>
<li>@property</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yingxuanzhang/article/details/125071269">property装饰器详解</a></p>
<ul>
<li>@classmethod</li>
<li>@staticmethod</li>
</ul>
<h2 id="类属性和实例属性"><a class="markdownIt-Anchor" href="#类属性和实例属性"></a> 类属性和实例属性</h2>
<h2 id="一般属性和私有属性"><a class="markdownIt-Anchor" href="#一般属性和私有属性"></a> 一般属性和私有属性</h2>
<p>参考文章：</p>
<h2 id="常量表达式constexpr"><a class="markdownIt-Anchor" href="#常量表达式constexpr"></a> 常量表达式constexpr</h2>
<h2 id="c的lambda表达式"><a class="markdownIt-Anchor" href="#c的lambda表达式"></a> c++的lambda表达式</h2>
<p>c++11引入的,主要的写作构造如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) specifiers exception -&gt; type &#123; function body &#125; <br></code></pre></td></tr></table></figure>
<ul>
<li><code>capture list</code>,捕获列表,捕获我们作用域中的变量,有值捕获(=),引用捕获(&amp;),混合捕获:
<ul>
<li>如[a,b]表示值捕获a,b变量,以const方式;</li>
<li>如[&amp;a]表示引用捕获a变量,可修改值;</li>
<li>如[=]/[&amp;]表示值/引用捕获作用域的所有变量</li>
</ul>
</li>
<li><code>parameter list</code>,参数列表,传参嘛</li>
<li><code>specifiers</code>,限定符,少用,可忽视</li>
<li><code>exception</code>,异常说明符,少用,可忽视</li>
<li><code>-&gt; type</code>,返回值</li>
<li><code>function body</code>,函数体</li>
</ul>
<p>使用如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-keyword">int</span> i) -&gt; pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || i == n)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,nums&#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">get(i) 返回一个二元组/键值对,用来处理数组边界,比如nums[-1]/nums[n] (注:n == nums.size())</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="fma和mac"><a class="markdownIt-Anchor" href="#fma和mac"></a> FMA和MAC</h2>
<p>MAC(Multiply-Accumulation):乘积累加运算</p>
<p>FMA(fused-multiply-add):融合乘加运算</p>
<p>它俩实现的都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>←</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leftarrow a+b*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>这么一个操作,只用一条指令就可以完成(否则要用两条嘛),当然有相搭配的硬件(如乘数累加器)</p>
<p>不同之处在于MAC要规约2次,FMA规约1次即可(更精准,更快速,但也有一些问题)</p>
<p>参考文件:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39444290/article/details/124939546">FMA和MAC区别</a></p>
<h2 id="ldd"><a class="markdownIt-Anchor" href="#ldd"></a> ldd</h2>
<p>这是一条神奇的指令,可以查看可执行文件所需要的动态库(<code>.dll</code>,<code>.so</code>)</p>
<p><code>ldd file</code></p>
<img src="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png" srcset="/img/loading.gif" lazyload alt="ldd file" style="zoom:67%;" />
<h2 id="神奇的环境变量名"><a class="markdownIt-Anchor" href="#神奇的环境变量名"></a> 神奇的环境变量名</h2>
<h3 id="ld_library_path"><a class="markdownIt-Anchor" href="#ld_library_path"></a> LD_LIBRARY_PATH</h3>
<p>在终端通过<code>echo $LD_LIBRARY_PATH</code>可以看到一些路径,这些路径是<strong>用于指定共享库/动态链接库的搜索路径</strong>.因此如果在运行可执行文件时报有<code>.so</code>或<code>.dll</code>库找不到的错误,可以通过ldd指令查看是否有库没有被找到</p>
<p>如果想添加一些别的动态库搜索路径,可以通过在<code>~/.bashrc</code>文件中导出环境变量,并用<code>source ~/.bashrc</code>刷新一下bashrc文件,即可实现</p>
<p>导出环境变量可以加在bashrc文件末尾,如:</p>
<p><code>export LD_LIBRARY_PATH=/lib:$LD_LIBRARY_PATH</code></p>
<p>其中:是路径的分隔符</p>
<p>参考文件:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44534541/article/details/135500799">Linux环境变量LD_LIBRARY_PATH配置</a></p>
<h2 id="gdb小工具使用方法"><a class="markdownIt-Anchor" href="#gdb小工具使用方法"></a> GDB小工具使用方法</h2>
<p><strong>要使用GDB来进行代码调试以完成错误定位，在进行编译的时候要加上<code>-g</code>的选项</strong></p>
<p>生成可执行文件后，<strong>通过<code>gdb filename</code>的方式进行gdb调试程序</strong></p>
<p>首先<strong>通过<code>l</code>(list缩写)来查看当前程序的代码</strong></p>
<div class="note note-info">
            <p>一般终端无输入即按回车是重复上一条指令</p>
          </div>
<p><strong>通过<code>break funcName</code>来设置断点，也可以通过<code>break lineNum</code>行数来设置断点。可以通过<code>info break</code>来查看断点设置情况</strong></p>
<p><strong>执行<code>r</code>(run缩写)执行程序，程序会执行到端点处暂停，然后通过<code>n</code>(next缩写)单步越过执行/<code>s</code>(step缩写)单步步入执行，可以通过<code>c</code>(continue缩写)来直接执行到下一个断点处,又或者通过<code>u lineNum</code>(until缩写)来移动到执行的行数</strong></p>
<p><strong>通过<code>q</code>(quit退出调试程序)</strong></p>
<p>若是在执行到某一个函数内部,排查好了问题,想回到原函数,可以<strong>通过<code>finish</code>完成函数剩下的指令返回</strong>,也可以通过<code>return</code>立刻返回,不执行后面的指令</p>
<p>**如何调试内联汇编?**这是gdb对于算子开发的一个最重要的作用,因为别的错误我们好排查,而一旦牵扯到内联汇编,可能涉及到内存,寄存器的问题:</p>
<p>我们可以<strong>通过<code>layout asm</code>显示汇编代码的窗口</strong>,我们只需要打断点到指定的内联汇编开头,然后开启这个窗口,<strong>通过<code>si</code>(step instruction),单步执行指令</strong>,然后可以通过<code>p</code>(print)或display(更推荐)来指定一些想要观察的变量或寄存器(寄存器需要<code>display $v0</code>加个<code>$</code>),通过display的话每次执行一条指令都会打印我们跟踪的变量和寄存器的结果,这对于调试内联汇编代码非常有用,可以帮助我们观察一些寄存器和变量的实时变化情况</p>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvdongjie/p/8994092.html">GDB调试程序参考</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/litanglian9839/article/details/84966811">GDB-layout-1</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjs0322/article/details/10152279">GDB-layout-2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/125083029">GDB一些参考</a></li>
</ul>
<h2 id="c之const的位置"><a class="markdownIt-Anchor" href="#c之const的位置"></a> c++之const的位置</h2>
<p><strong>const默认作用于其左边的东西,否则作用于其右边的东西</strong></p>
<blockquote>
<p>const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.</p>
</blockquote>
<p>例子:</p>
<ul>
<li>
<p><code>const int *</code>是一个指针指向一个常量整型 a pointer to a constant integer</p>
</li>
<li>
<p><code>int* const</code> 是一个常量指针指向一个整型 a constant pointer to an integer</p>
</li>
<li>
<p><code>int const * const</code> 是一个常量指针指向一个常量整型 a contanst pointer to a constant integer</p>
</li>
<li>
<p><code>...</code></p>
</li>
</ul>
<p>可以通过<strong>从右往左读</strong>的方式来理解,然后一般写的时候也建议按照<strong>eastern const style</strong>(把const放东边/右边)来写</p>
<div class="note note-info">
            <p>注:看的时候脑子冒出来左结合右结合,搜了一下,<strong>结合性是为了处理具有相同优先级的运算符时,确定他们在表达式中结合的顺序</strong></p><p>左结合即是指在一个表达式中有多个具有相同优先级的运算符,它们在表达式中从左到右依次结合,如:<code>a + b + c</code> -&gt; <code>(a + b) + c</code></p><p>右结合即是指具有相同优先级的多个运算符在表达式中从右到左依次结合,如:<code>a = b = c</code> -&gt; <code>a = ( b = c)</code></p><p>参考文件:</p><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47441055/article/details/131384865">结合性,左结合,右结合</a></li></ul>
          </div>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/443195492/answer/1723886545">const位置摆放</a></li>
</ul>
<h2 id="c之namespace"><a class="markdownIt-Anchor" href="#c之namespace"></a> C++之namespace</h2>
<ol>
<li><strong>全局范围内定义</strong>,通过<code>namespace ns_name&#123;...&#125;</code>这样定义,不可以局部范围内定义;</li>
<li><strong>namespace可嵌套</strong>;</li>
<li><strong>namespace目的:避免命名冲突</strong>;</li>
<li>我们要使用某一命名空间内的变量/函数时:
<ul>
<li><strong>用::(作用域限定符)来获得,如std::cin</strong>;</li>
<li><strong>命名空间全部展开</strong><mark>不推荐</mark><code>using namespace std;</code>;</li>
<li><strong>命名空间部分展开</strong><code>using std::endl;</code></li>
</ul>
</li>
</ol>
<div class="note note-info">
            <p>其中作用域限定符有:全局范围的,类范围的,也有namespace范围的,使用如下:</p><ul><li>global scope: <code>::var</code></li><li>class scope: <code>class::var</code></li><li>namespace scope: <code>namespace::var</code></li></ul><p>通过访问左侧的scope来知道想要访问的var是哪里的</p>
          </div>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2202_75303754/article/details/131782875">c++ namespace</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/holm/articles/13715169.html">作用域限定符</a></li>
</ul>
<h2 id="c之左值纯右值将亡值"><a class="markdownIt-Anchor" href="#c之左值纯右值将亡值"></a> C++之左值,纯右值,将亡值</h2>
<ul>
<li><strong>左值(left-hand-side value)简称lvalue</strong></li>
<li><strong>纯右值(pure right-hand-side value)简称prvalue</strong></li>
<li><strong>将亡值(expiring value)简称xvalue</strong></li>
</ul>
<p>三者的由来与函数返回值相关:</p>
<ul>
<li><strong>直接存在寄存器里返回</strong></li>
<li><strong>直接操作用于接收返回值的变量(函数返回值转换为出参,由函数内部直接操作外部的栈空间)</strong></li>
<li><strong>使用匿名空间接收函数返回值,这是一个临时的内存空间,用完即析构</strong></li>
</ul>
<p>prvalue,lvalue,xvalue对应上述三种情况.</p>
<p>这三种值的出现与C<ins>是C的extension有关,C</ins>的结构体乃至类增加了构造函数和析构函数,并将之与变量的生命周期进行绑定有关</p>
<p>详细情况参看参考文件中腾讯技术工程对这一块的讲解</p>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C++要分左右值</a></li>
</ul>
<h2 id="c平凡类型与非平凡类型"><a class="markdownIt-Anchor" href="#c平凡类型与非平凡类型"></a> c++平凡类型与非平凡类型</h2>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vviccc/article/details/138089766">C++11 内存布局术语解读（平凡类型、平凡可复制类型、标准布局类型）</a></li>
</ul>
<h2 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h2>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">C++11新特性</a></li>
</ul>
<h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/670068158">智能指针</a></li>
</ul>
<h2 id="elf文件格式了解"><a class="markdownIt-Anchor" href="#elf文件格式了解"></a> ELF文件格式了解</h2>
<p>ELF(Excutable Linkable Format)是linux下可执行文件的存储格式,是COFF(Comman File Format)的一种变体</p>
<p>目标文件,动态库,静态库以及可执行文件都用ELF文件格式来进行存储</p>
<p>一般二进制文件的存储格式中都有文件头,是通过读文件头来确认如何解析文件(个人感觉文件头存储了许多的元数据)</p>
<p>补Elf64_Ehdr和Elf64_Shdr,前者是ELF文件头,里面有比如段表(节头表Section Header Table)的信息,比如有多少个段,段大小,段偏移;后者则是记录每个段表的元信息</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/544198038">从零解析ELF目标文件(附源码)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42570601/article/details/124695589">链接装载与库：第三章——ELF文件结构</a></li>
</ul>
<h2 id="decltype和auto"><a class="markdownIt-Anchor" href="#decltype和auto"></a> decltype和auto</h2>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/17503803561e">深入解析decltype和decltype(auto)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linxmouse/p/17567763.html">C++11容易遗忘的特性整理与理解</a></li>
</ul>
<h2 id="name-mangling的解释工具"><a class="markdownIt-Anchor" href="#name-mangling的解释工具"></a> name mangling的解释工具</h2>
<p>反汇编出的汇编代码,它会有一坨怪怪的东西,比如<code>_Z3addPiPb</code>之类的,这个东西又大概知道它应该是个函数名,这玩意可以通过<code>c++filt</code>或是<code>cu++filt</code>来给它还原,比如:</p>
<img src="https://s2.loli.net/2024/08/15/mIl78OekFQasEx1.png" srcset="/img/loading.gif" lazyload alt="read-name-mangling-tool" style="zoom:67%;" />
<h2 id="神奇的宏定义"><a class="markdownIt-Anchor" href="#神奇的宏定义"></a> 神奇的宏定义</h2>
<p>在看别人代码的时候,不难会发现,有些人的宏定义会出现<code>#</code>,主要用两个用途:</p>
<ul>
<li><code>#</code>单个井号的使用,使得值变成字串,如<code>#define val2str(val) (#val) </code></li>
<li><code>##</code>两个井号的使用,使得两个值进行拼接,如<code>#define nameJoin(x,y) x##y</code></li>
</ul>
<p>可以通过<code>gcc -E ...</code>使得文件经过预处理,看看宏替换后的效果~</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/program/2847248sa.htm">浅析C++宏定义里#和##的使用</a></li>
</ul>
<h2 id="c-tmp"><a class="markdownIt-Anchor" href="#c-tmp"></a> C++ TMP</h2>
<p>TMP即templace metaprogramming<strong>模板元编程</strong>，这里小小的记录一下，更多的细节需要在实践中不断认知</p>
<p>元编程(metaprogramming)是编写元程序(metaprogram)的一种编程技巧</p>
<p>元程序的输入是其他程序乃至自己(metaprogram is a program about a program)</p>
<h3 id="元编程两种类型"><a class="markdownIt-Anchor" href="#元编程两种类型"></a> 元编程两种类型：</h3>
<ul>
<li>一种是对domain language翻译成host language，<strong>逻辑代码与元程序是分离的</strong></li>
<li>一种是用同一种语言将逻辑代码和元程序写在一起，元程序通过编译得到逻辑代码，并与别的逻辑代码混合，自己manipulate自己，<strong>逻辑代码与元程序是混合的</strong>，<strong><u>元程序看起来自己在编写自己</u></strong></li>
</ul>
<p><strong>C<ins>TMP是后者，元程序的代码和c</ins>逻辑代码写一起，元程序的逻辑在编译期执行，c++逻辑代码在运行期执行</strong></p>
<h3 id="可声明的模板类型"><a class="markdownIt-Anchor" href="#可声明的模板类型"></a> 可声明的模板类型</h3>
<ul>
<li>
<p><strong>类模板</strong>(class template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTemplate</span>;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>函数模板</strong>(function template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTemplate</span><span class="hljs-params">(T)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>变量模板</strong>(variable template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T varTemplate;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>别名模板(alias template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> aliasTemplate = T;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>concept</p>
</li>
</ul>
<p>前三种可以有<strong>定义</strong>，后两种不需定义(不产生运行时的实体)</p>
<p>模板的产生是为了泛型编程(generic programming)，因此<strong>类型是被参数化</strong>(即类型可做参数)了的。模板由关键字<code>template</code>表明,然后<code>&lt;&gt;</code>内放置的是模板的参数</p>
<p><strong>类模板，函数模板是模板而非类或函数，它们是对类和函数的描述，<u>模板是对代码的描述</u></strong></p>
<h3 id="模板之形参形参-parameter实参-argument"><a class="markdownIt-Anchor" href="#模板之形参形参-parameter实参-argument"></a> 模板之形参(形参-parameter,实参-argument)：</h3>
<ul>
<li>
<p><strong>Non-type Template Parameters</strong>,接受一个<strong>确定类型</strong>(与模型形参的那个确定类型匹配)<strong>的常量作为实参,之所以需要常量,是因为模板是在编译期展开的,这个时候只有常量,没有变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> n&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcPrint</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br>    funcPrint&lt;b&gt;(); <span class="hljs-comment">// output 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Type Template Parameters</strong>,用**<code>typename</code><strong>这个关键字来</strong>声明<strong>这个形参的</strong>类型**(datatype)是T</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">whichType</span><span class="hljs-params">()</span></span>&#123;<br>    T val;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(val).<span class="hljs-built_in">name</span>() &lt;&lt; endl;	<span class="hljs-comment">// 头文件#include&lt;typeinfo&gt;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    whichType&lt;<span class="hljs-keyword">int</span>&gt;();	<span class="hljs-comment">// output i</span><br>    whichType&lt;<span class="hljs-keyword">float</span>&gt;(); <span class="hljs-comment">// output f</span><br>    whichType&lt;<span class="hljs-keyword">uint32_t</span>&gt;(); <span class="hljs-comment">// output j</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Template Template Parameters</strong>,<strong>只接受类模板和类的别名模板作为实参，且实参模板参数列表要和形参模板的参数列表match</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTemp</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>      T val;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;From clsTemp,datatype:&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(val).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">typename</span> tmplClass&gt;	<span class="hljs-comment">//  template&lt;typename T&gt;指明了所接受的类模板的形参列表.本类接受的类模板形参经由typename声明为tmplClass这么一个类型</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTempTempPara</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>      tmplClass&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;From clsTempTempPara&quot;</span> &lt;&lt; endl;<br>          tmp.<span class="hljs-built_in">display</span>();<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      clsTempTempPara&lt;clsTemp&gt; classTempTempPara;	<span class="hljs-comment">// 类模板作为实参,clsTemp这个类模板的参数列表只有一位,且是type template parameter</span><br>      classTempTempPara.<span class="hljs-built_in">print</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="模板形参之可变长形参列表"><a class="markdownIt-Anchor" href="#模板形参之可变长形参列表"></a> 模板形参之可变长形参列表</h4>
<p>模板的形参也可以是可变长形参列表的,这个列表呢称作<strong>template parameter pack</strong>,这个可变长的pack要给它放最后(定长前面,变长后面),它可以接受:</p>
<ul>
<li>
<p><strong>nontype的constant</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl1</span>&#123;</span>&#125;; <br>packtmpl1&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&gt; pinst;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl2</span>&#123;</span>&#125;;<br>packtmpl2&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>,string&gt; pinst2;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">typename</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl3</span>&#123;</span>&#125;;<br>packtmpl3&lt;clsTemp&gt; pinst3;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模板实例化"><a class="markdownIt-Anchor" href="#模板实例化"></a> 模板实例化</h3>
<p><strong>模板的实例化也分显式和隐式(按需)</strong>,实际上我们<strong>一般常用的都是隐式</strong>,比如<code>vector&lt;int&gt; vec;</code>,从这里可以看出,<strong>所谓的模板实例化的显式隐式不是以你是否隐式传参来区分的</strong></p>
<ul>
<li>
<p>隐式/按需实例化,需要具体的对象再实例化</p>
</li>
<li>
<p>显式实例化,先不创建对象,但是先实例化模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span></span>&#123;cout &lt;&lt; t &lt;&lt; endl;&#125;<br><span class="hljs-comment">// 显式实例化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="包含模型"><a class="markdownIt-Anchor" href="#包含模型"></a> 包含模型</h3>
<p><strong>模板编程的包含模型(inclusion model):将模板定义放在头文件,源文件包含这个头文件</strong></p>
<p>模板实例化所产生的symbol是<strong>weak symbol</strong>,不然会有重定义的问题,说是不同的翻译单元,传入的实参相同,则会实例化多次,产生的类/函数/变量都是相同的;同一个翻译单元则会复用而不是实例化多次,只会实例化一次</p>
<h3 id="模板特化"><a class="markdownIt-Anchor" href="#模板特化"></a> 模板特化</h3>
<p><strong>模板特化(Template Specialization)指的是对模板的形参进行部分替换或全部替换,并重新定义这种替换了的模板</strong></p>
<ul>
<li>
<p><strong>全特化(full specialization),指对原模版的形参全部替换</strong> <mark>函数模板只有全特化</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTmpl</span><span class="hljs-params">(T t,U u)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;primary template&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; u &lt;&lt;endl;    <br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTmpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">float</span> u)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;full specialization&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; u &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">float</span> u = <span class="hljs-number">2.0</span>;<br><span class="hljs-built_in">funcTmpl</span>(t,u);		<span class="hljs-comment">// output: full specialization1 2</span><br><span class="hljs-built_in">funcTmpl</span>(t,<span class="hljs-string">&quot;123&quot;</span>);   <span class="hljs-comment">// output: primary template1 123</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>偏特化(partial specialization),指对原模版的形参部分替换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;primary template &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&lt;</span><span class="hljs-keyword">int</span>,U&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;partial specialization &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&lt;</span><span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;full specialization &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br>clsTmpl&lt;string,<span class="hljs-keyword">int</span>&gt;ctm1; ctm1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// primary template </span><br>clsTmpl&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;ctm2; ctm2.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// partial specialization</span><br>clsTmpl&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>&gt;ctm3; ctm3.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// full specialization</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主模板(primary template),无特化的原始模板</strong></p>
</li>
</ul>
<p>从上面的输出结果可以看出,<strong>在实例化模板的时候,编译器会挑最匹配的实现来进行替换,如果找不到才用primary template进行替换</strong></p>
<p><strong>注意区分模板特化和显示实例化</strong>,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>)</span></span>; <span class="hljs-comment">// 模板特化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>)</span></span>;	<span class="hljs-comment">// 显式实例化</span><br></code></pre></td></tr></table></figure>
<p>参考文件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378360055">C++模板元编程（二）：模板基础</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384826036">C++模板元编程（三）：从简单案例中学习</a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63207620/answer/1707221853">https://www.zhihu.com/question/63207620/answer/1707221853</a><br />
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">重庆高性能会议记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/15/little-knowledge-of-loadable-kernel-module/">
                        <span class="hidden-mobile">little-knowledge-of-loadable-kernel-module</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'c26778f9dcc30274cc0603f5d9511f91'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
