

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一些零碎的知识,主要起概念理解作用">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="一些零碎的知识,主要起概念理解作用">
<meta property="og:type" content="article">
<meta property="og:title" content="一些零碎知识(持续更新)">
<meta property="og:url" content="http://example.com/2023/11/17/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="一些零碎的知识,主要起概念理解作用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png">
<meta property="og:image" content="https://s2.loli.net/2024/08/15/mIl78OekFQasEx1.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/17/iwedH3ScrB2LU8Q.png">
<meta property="og:image" content="https://s2.loli.net/2024/12/17/d2jGafA4K9hHqRS.jpg">
<meta property="article:published_time" content="2023-11-17T02:56:43.000Z">
<meta property="article:modified_time" content="2025-02-23T08:14:58.478Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg">
  
  <title>一些零碎知识(持续更新) - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="一些零碎知识(持续更新)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-11-17 10:56" pubdate>
        2023年11月17日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      22k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      68 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">一些零碎知识(持续更新)</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：1 天前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="python-u是啥"><a class="markdownIt-Anchor" href="#python-u是啥"></a> python -u是啥</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.stdout.write(<span class="hljs-string">&quot;correct1&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error1&quot;</span>)<br>sys.stdout.write(<span class="hljs-string">&quot;correct2&quot;</span>)<br>sys.stderr.write(<span class="hljs-string">&quot;error2&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>stdout是标准输入,stderr是标准错误,一般来说,标准错误没有缓存区,会直接输出到屏幕上;而stdout会有缓存区,即当出现换行符或者到达一定长度才会输出到屏幕,而增加**-u<strong>这个短指令即是使得stdout变为</strong>unbuffered**,使得我们的代码顺序即为输出顺序</p>
<p><mark>在python3.6.8的解释器下执行,感觉好像默认了unbuffered</mark>😕</p>
<h2 id="pty何物是也为啥一些指令都有它"><a class="markdownIt-Anchor" href="#pty何物是也为啥一些指令都有它"></a> pty何物是也,为啥一些指令都有它</h2>
<p>关于tty(终端，是一种字符型设备，名字源于teletypewriter，电传打字机)：</p>
<p>pty:pseudo terminal伪终端</p>
<h2 id="串口并口"><a class="markdownIt-Anchor" href="#串口并口"></a> 串口并口</h2>
<p>串口（串行接口）：一次传输一位数据，较为稳定，可进行长距离通信（串行口COM1,COM2）<br />
并口（并行接口）：一次传输八位数据，但受长度限制，因为长度越长会增加干扰，数据容易出错</p>
<p>详情可见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622677267">硬件基础：硬件通信常见的串口介绍</a></p>
<h2 id="什么是异构"><a class="markdownIt-Anchor" href="#什么是异构"></a> 什么是异构</h2>
<p>异构计算（Heterogeneous Computing）是一种特殊的并行分布式计算系统。它能够经济有效地实现高计算能力，可扩展性强，能够非常高效地利用计算资源。与之相对的概念就是同构计算（Homogeneous Computing），也就是为大家熟知的多核理念。为了突破计算算力受制于功耗的瓶颈，多核CPU技术得到越来越多的应用。强大的CPU采用越来越多的CPU内核这就是传统同构计算系统。很快人们就发现在AI人工智能和自动驾驶爆炸式增长的计算需求下，传统同构计算系统已经无法满足要求，GPU、DSP、FPGA和ASIC由于特定需求下高效性越来越多的被应用。而异构计算技术应运而生，像一个大厨将CPU、GPU、DSP、FPGA和ASIC(Application Specific Integrated Circuit，应用专用集成电路，主流有TPU、NPU、VPU、BPU芯片等)这些优良食材制成一道融合各方口味特点的佳肴[^1]。</p>
<ol>
<li>
<p>计算场景异构（通俗意义上的异构计算）<br />
CPU+GPU/DPU<br />
DPU：是对网卡和存储等数据的高效处理<br />
何为计算场景的异构呢，就是本来应该是CPU处理的场景，现在解耦出来由专门的芯片进行处理。</p>
</li>
<li>
<p>计算性能的异构<br />
相比于传统的X86芯片的同构多核，ARM在芯片架构上进行创新，采用了异构多核的芯片架构，芯片里面的核心分了大小核</p>
</li>
<li>
<p>CPU架构的异构<br />
应该就是采用X86，ARM，RISC-V，Alpha，LoongArch等不同的CPU架构</p>
</li>
</ol>
<h2 id="进制单位转换"><a class="markdownIt-Anchor" href="#进制单位转换"></a> 进制单位转换</h2>
<p><img src="https://s2.loli.net/2023/11/27/YIu4h7HD8L3fMSe.jpg" srcset="/img/loading.gif" lazyload alt="multiple-byte units" /></p>
<p>左侧代表的是十进制前缀，右侧表示的是二进制前缀</p>
<p>一般是制造商采用十进制，对于我们来说<strong>存储一般指的是二进制</strong>的，而在说到<strong>带宽一类的速率时，指的是十进制的</strong></p>
<h2 id="local目录"><a class="markdownIt-Anchor" href="#local目录"></a> ./local目录</h2>
<p>.local相当于跟全局的python环境进行了一层的隔离，在这里我们可以安装自己需要的库（在本地范围内），而无需提权<br />
类似的安装方式大致如下：<br />
<code>pip install target=~/.local/lib/python3.8/site-packages &lt;package-name&gt;</code><br />
参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67402026/article/details/125241407">https://blog.csdn.net/m0_67402026/article/details/125241407</a></p>
<p>当然，如果知道有多个解释器，也可以安装到对应的解释器的位置，如：<br />
<code>D:\path\to\python.exe -m pip install --user &lt;package-name&gt;</code><br />
参考自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ThsPool/article/details/132809683">https://blog.csdn.net/ThsPool/article/details/132809683</a></p>
<p>参考:<a target="_blank" rel="noopener" href="https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html">https://geek-docs.com/python/python-ask-answer/603_python_what_is_the_purpose_of_homelocal.html</a></p>
<h2 id="linux软硬链接"><a class="markdownIt-Anchor" href="#linux软硬链接"></a> linux软硬链接</h2>
<p>关于linux软链接的创建删除更新，可以这么理解，Linux的软链接相当于快捷方式 ，硬链接好像会共享原来的inode<br />
以下是参考文章：<a target="_blank" rel="noopener" href="http://www.mobiletrain.org/about/BBS/151003.html">http://www.mobiletrain.org/about/BBS/151003.html</a></p>
<h2 id="site-packages和distpages区别"><a class="markdownIt-Anchor" href="#site-packages和distpages区别"></a> site-packages和distpages区别:</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40614261/article/details/90023807">https://blog.csdn.net/weixin_40614261/article/details/90023807</a></p>
<h2 id="vimrc配置"><a class="markdownIt-Anchor" href="#vimrc配置"></a> vimrc配置</h2>
<p>注意,要查看vimrc在哪可以在一个利用vim打开的文件内通过:version查看,往下滑动可以看到vimrc文件一般配置在:<br />
/etc/vimrc<br />
~/.vimrc</p>
<h2 id="module"><a class="markdownIt-Anchor" href="#module"></a> module</h2>
<p>module全称:<strong>module-environment</strong>是一个用于<strong>管理环境变量的工具</strong></p>
<h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3>
<ul>
<li><code>module avail</code>查看所有的模块</li>
<li><code>module load/add 需要加载的模块</code>加载需要加载的模块</li>
<li><code>module unload/rm 需要卸载的模块</code> 卸载需要卸载的模块</li>
<li><code>module list</code> 列出已加载的模块</li>
<li><code>module show 模块</code> 查看指定的模块信息</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.fasteda.cn/post/22.html0">Linux 下 Module 工具的介绍与使用</a></p>
<h2 id="iterableiteratorgenerator"><a class="markdownIt-Anchor" href="#iterableiteratorgenerator"></a> iterable,iterator,generator</h2>
<p>关于python中iterable,iterator,generator:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/131501576">https://blog.csdn.net/weixin_44966641/article/details/131501576</a></p>
<h2 id="不同操作系统的多线程"><a class="markdownIt-Anchor" href="#不同操作系统的多线程"></a> 不同操作系统的多线程</h2>
<p>Windows用spawn,Unix用fork,主要区别见下文:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CJTARRR/p/17742597.html">fork和spawn区别</a></p>
<h2 id="__getattr__-__getattribute_"><a class="markdownIt-Anchor" href="#__getattr__-__getattribute_"></a> __getattr__ __getattribute_</h2>
<h2 id="descriptor描述器之__get__-__set__-__delete__"><a class="markdownIt-Anchor" href="#descriptor描述器之__get__-__set__-__delete__"></a> descriptor(描述器)之__get__ __set__ __delete__</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/andy1031/p/10923834.html">一些魔法方法</a></p>
<h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tobyqin/p/python-decorator.html">python装饰器1</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/640193185">python装饰器2</a></p>
<h3 id="常用装饰器"><a class="markdownIt-Anchor" href="#常用装饰器"></a> 常用装饰器</h3>
<p>这里介绍三个常用的装饰器语法糖,需注意函数指的是非类方法,方法指的是类内的方法,分为实例方法,类方法,静态方法</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/544021480">方法分类及三个常用装饰器语法糖</a></p>
<ul>
<li>@property</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yingxuanzhang/article/details/125071269">property装饰器详解</a></p>
<ul>
<li>@classmethod</li>
<li>@staticmethod</li>
</ul>
<h2 id="类属性和实例属性"><a class="markdownIt-Anchor" href="#类属性和实例属性"></a> 类属性和实例属性</h2>
<h2 id="一般属性和私有属性"><a class="markdownIt-Anchor" href="#一般属性和私有属性"></a> 一般属性和私有属性</h2>
<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/63207620/answer/1707221853">异构计算</a></li>
</ul>
<h2 id="常量表达式constexpr"><a class="markdownIt-Anchor" href="#常量表达式constexpr"></a> 常量表达式constexpr</h2>
<h2 id="c的lambda表达式"><a class="markdownIt-Anchor" href="#c的lambda表达式"></a> c++的lambda表达式</h2>
<p>c++11引入的,主要的写作构造如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) specifiers exception -&gt; type &#123; function body &#125; <br></code></pre></td></tr></table></figure>
<ul>
<li><code>capture list</code>,捕获列表,捕获我们作用域中的变量,有值捕获(=),引用捕获(&amp;),混合捕获:
<ul>
<li>如[a,b]表示值捕获a,b变量,以const方式;</li>
<li>如[&amp;a]表示引用捕获a变量,可修改值;</li>
<li>如[=]/[&amp;]表示值/引用捕获作用域的所有变量</li>
</ul>
</li>
<li><code>parameter list</code>,参数列表,传参嘛</li>
<li><code>specifiers</code>,限定符,少用,可忽视</li>
<li><code>exception</code>,异常说明符,少用,可忽视</li>
<li><code>-&gt; type</code>,返回值</li>
<li><code>function body</code>,函数体</li>
</ul>
<p>使用如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-keyword">int</span> i) -&gt; pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || i == n)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>,nums&#125;;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">get(i) 返回一个二元组/键值对,用来处理数组边界,比如nums[-1]/nums[n] (注:n == nums.size())</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="fma和mac"><a class="markdownIt-Anchor" href="#fma和mac"></a> FMA和MAC</h2>
<p>MAC(Multiply-Accumulation):乘积累加运算</p>
<p>FMA(fused-multiply-add):融合乘加运算</p>
<p>它俩实现的都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>←</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leftarrow a+b*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>这么一个操作,只用一条指令就可以完成(否则要用两条嘛),当然有相搭配的硬件(如乘数累加器)</p>
<p>不同之处在于MAC要规约2次,FMA规约1次即可(更精准,更快速,但也有一些问题)</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39444290/article/details/124939546">FMA和MAC区别</a></li>
</ul>
<h2 id="ldd"><a class="markdownIt-Anchor" href="#ldd"></a> ldd</h2>
<p>这是一条神奇的指令,可以查看可执行文件所需要的动态库(<code>.dll</code>,<code>.so</code>)</p>
<p><code>ldd file</code></p>
<img src="https://s2.loli.net/2024/04/30/gVWkNmHxF156Csv.png" srcset="/img/loading.gif" lazyload alt="ldd file" style="zoom:67%;" />
<h2 id="神奇的环境变量名"><a class="markdownIt-Anchor" href="#神奇的环境变量名"></a> 神奇的环境变量名</h2>
<h3 id="ld_library_path"><a class="markdownIt-Anchor" href="#ld_library_path"></a> LD_LIBRARY_PATH</h3>
<p>在终端通过<code>echo $LD_LIBRARY_PATH</code>可以看到一些路径,这些路径是<strong>用于指定共享库/动态链接库的搜索路径</strong>.因此如果在运行可执行文件时报有<code>.so</code>或<code>.dll</code>库找不到的错误,可以通过ldd指令查看是否有库没有被找到</p>
<p>如果想添加一些别的动态库搜索路径,可以通过在<code>~/.bashrc</code>文件中导出环境变量,并用<code>source ~/.bashrc</code>刷新一下bashrc文件,即可实现</p>
<p>导出环境变量可以加在bashrc文件末尾,如:</p>
<p><code>export LD_LIBRARY_PATH=/lib:$LD_LIBRARY_PATH</code></p>
<p>其中:是路径的分隔符</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44534541/article/details/135500799">Linux环境变量LD_LIBRARY_PATH配置</a></li>
</ul>
<h2 id="gdb小工具使用方法"><a class="markdownIt-Anchor" href="#gdb小工具使用方法"></a> GDB小工具使用方法</h2>
<p><strong>要使用GDB来进行代码调试以完成错误定位，在进行编译的时候要加上<code>-g</code>的选项</strong></p>
<p>生成可执行文件后，<strong>通过<code>gdb filename</code>的方式进行gdb调试程序</strong></p>
<p>首先<strong>通过<code>l</code>(list缩写)来查看当前程序的代码</strong></p>
<div class="note note-info">
            <p>一般终端无输入即按回车是重复上一条指令</p>
          </div>
<p><strong>通过<code>break funcName</code>来设置断点，也可以通过<code>break lineNum</code>行数来设置断点。可以通过<code>info break</code>来查看断点设置情况</strong></p>
<p><strong>执行<code>r</code>(run缩写)执行程序，程序会执行到端点处暂停，然后通过<code>n</code>(next缩写)单步越过执行/<code>s</code>(step缩写)单步步入执行，可以通过<code>c</code>(continue缩写)来直接执行到下一个断点处,又或者通过<code>u lineNum</code>(until缩写)来移动到执行的行数</strong></p>
<p><strong>通过<code>q</code>(quit退出调试程序)</strong></p>
<p>若是在执行到某一个函数内部,排查好了问题,想回到原函数,可以<strong>通过<code>finish</code>完成函数剩下的指令返回</strong>,也可以通过<code>return</code>立刻返回,不执行后面的指令</p>
<p>**如何调试内联汇编?**这是gdb对于算子开发的一个最重要的作用,因为别的错误我们好排查,而一旦牵扯到内联汇编,可能涉及到内存,寄存器的问题:</p>
<p>我们可以<strong>通过<code>layout asm</code>显示汇编代码的窗口</strong>,我们只需要打断点到指定的内联汇编开头,然后开启这个窗口,<strong>通过<code>si</code>(step instruction),单步执行指令</strong>,然后可以通过<code>p</code>(print)或display(更推荐)来指定一些想要观察的变量或寄存器(寄存器需要<code>display $v0</code>加个<code>$</code>),通过display的话每次执行一条指令都会打印我们跟踪的变量和寄存器的结果,这对于调试内联汇编代码非常有用,可以帮助我们观察一些寄存器和变量的实时变化情况</p>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvdongjie/p/8994092.html">GDB调试程序参考</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/litanglian9839/article/details/84966811">GDB-layout-1</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjs0322/article/details/10152279">GDB-layout-2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/125083029">GDB一些参考</a></li>
</ul>
<h2 id="c之const的位置"><a class="markdownIt-Anchor" href="#c之const的位置"></a> c++之const的位置</h2>
<p><strong>const默认作用于其左边的东西,否则作用于其右边的东西</strong></p>
<blockquote>
<p>const applies to the thing left of it. If there is nothing on the left then it applies to the thing right of it.</p>
</blockquote>
<p>例子:</p>
<ul>
<li>
<p><code>const int *</code>是一个指针指向一个常量整型 a pointer to a constant integer</p>
</li>
<li>
<p><code>int* const</code> 是一个常量指针指向一个整型 a constant pointer to an integer</p>
</li>
<li>
<p><code>int const * const</code> 是一个常量指针指向一个常量整型 a contanst pointer to a constant integer</p>
</li>
<li>
<p><code>...</code></p>
</li>
</ul>
<p>可以通过<strong>从右往左读</strong>的方式来理解,然后一般写的时候也建议按照<strong>eastern const style</strong>(把const放东边/右边)来写</p>
<div class="note note-info">
            <p>注:看的时候脑子冒出来左结合右结合,搜了一下,<strong>结合性是为了处理具有相同优先级的运算符时,确定他们在表达式中结合的顺序</strong></p><p>左结合即是指在一个表达式中有多个具有相同优先级的运算符,它们在表达式中从左到右依次结合,如:<code>a + b + c</code> -&gt; <code>(a + b) + c</code></p><p>右结合即是指具有相同优先级的多个运算符在表达式中从右到左依次结合,如:<code>a = b = c</code> -&gt; <code>a = ( b = c)</code></p><p>参考文件:</p><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47441055/article/details/131384865">结合性,左结合,右结合</a></li></ul>
          </div>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/443195492/answer/1723886545">const位置摆放</a></li>
</ul>
<h2 id="c之namespace"><a class="markdownIt-Anchor" href="#c之namespace"></a> C++之namespace</h2>
<ol>
<li><strong>全局范围内定义</strong>,通过<code>namespace ns_name&#123;...&#125;</code>这样定义,不可以局部范围内定义;</li>
<li><strong>namespace可嵌套</strong>;</li>
<li><strong>namespace目的:避免命名冲突</strong>;</li>
<li>我们要使用某一命名空间内的变量/函数时:
<ul>
<li><strong>用::(作用域限定符)来获得,如std::cin</strong>;</li>
<li><strong>命名空间全部展开</strong><mark>不推荐</mark><code>using namespace std;</code>;</li>
<li><strong>命名空间部分展开</strong><code>using std::endl;</code></li>
</ul>
</li>
</ol>
<div class="note note-info">
            <p>其中作用域限定符有:全局范围的,类范围的,也有namespace范围的,使用如下:</p><ul><li>global scope: <code>::var</code></li><li>class scope: <code>class::var</code></li><li>namespace scope: <code>namespace::var</code></li></ul><p>通过访问左侧的scope来知道想要访问的var是哪里的</p>
          </div>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2202_75303754/article/details/131782875">c++ namespace</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/holm/articles/13715169.html">作用域限定符</a></li>
</ul>
<h2 id="c之左值纯右值将亡值"><a class="markdownIt-Anchor" href="#c之左值纯右值将亡值"></a> C++之左值,纯右值,将亡值</h2>
<ul>
<li><strong>左值(left-hand-side value)简称lvalue</strong></li>
<li><strong>纯右值(pure right-hand-side value)简称prvalue</strong></li>
<li><strong>将亡值(expiring value)简称xvalue</strong></li>
</ul>
<p>三者的由来与函数返回值相关:</p>
<ul>
<li><strong>直接存在寄存器里返回</strong></li>
<li><strong>直接操作用于接收返回值的变量(函数返回值转换为出参,由函数内部直接操作外部的栈空间)</strong></li>
<li><strong>使用匿名空间接收函数返回值,这是一个临时的内存空间,用完即析构</strong></li>
</ul>
<p>prvalue,lvalue,xvalue对应上述三种情况.</p>
<p>这三种值的出现与C<ins>是C的extension有关,C</ins>的结构体乃至类增加了构造函数和析构函数,并将之与变量的生命周期进行绑定有关</p>
<p>详细情况参看参考文件中腾讯技术工程对这一块的讲解</p>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/428340896/answer/2913419725">为什么C++要分左右值</a></li>
</ul>
<h2 id="c平凡类型与非平凡类型"><a class="markdownIt-Anchor" href="#c平凡类型与非平凡类型"></a> c++平凡类型与非平凡类型</h2>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/vviccc/article/details/138089766">C++11 内存布局术语解读（平凡类型、平凡可复制类型、标准布局类型）</a></li>
</ul>
<h2 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h2>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/650986900">C++11新特性</a></li>
</ul>
<h2 id="c智能指针"><a class="markdownIt-Anchor" href="#c智能指针"></a> C++智能指针</h2>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/670068158">智能指针</a></li>
</ul>
<h2 id="elf文件格式了解"><a class="markdownIt-Anchor" href="#elf文件格式了解"></a> ELF文件格式了解</h2>
<p>ELF(Excutable Linkable Format)是linux下可执行文件的存储格式,是COFF(Comman File Format)的一种变体</p>
<p>目标文件,动态库,静态库以及可执行文件都用ELF文件格式来进行存储</p>
<p>一般二进制文件的存储格式中都有文件头,是通过读文件头来确认如何解析文件(个人感觉文件头存储了许多的元数据)</p>
<p>补Elf64_Ehdr和Elf64_Shdr,前者是ELF文件头,里面有比如段表(节头表Section Header Table)的信息,比如有多少个段,段大小,段偏移;后者则是记录每个段表的元信息</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/544198038">从零解析ELF目标文件(附源码)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42570601/article/details/124695589">链接装载与库：第三章——ELF文件结构</a></li>
</ul>
<h2 id="decltype和auto"><a class="markdownIt-Anchor" href="#decltype和auto"></a> decltype和auto</h2>
<p>两者都用于<strong>自动类型推导</strong>,都是在<strong>编译期完成</strong>的</p>
<p><strong>auto定义变量必须提供初值表达式</strong>,形如:<code>auto v = expr</code>;</p>
<p><strong>decltype则和表达式结合在一起</strong>,如:<code>decltype(expr) v;</code>同时<strong>它可以保留变量的引用属性和cv修饰词(const,volatile)信息</strong></p>
<p>对于decltype使用时,可以根据expr有无带括号分类:</p>
<ul>
<li>
<p><strong>expr无括号</strong>:</p>
<ul>
<li>若expr是<strong>单变量</strong>标识符,类的数据成员,函数名称,数组名称,则<strong>推导出来的类型和expr的类型是一致的</strong>;</li>
<li>若expr是一条<strong>表达式</strong>,则<strong>视表达式运算后的结果而定</strong>:
<ul>
<li><strong>右值,推导类型和运算结果类型一致;</strong></li>
<li><strong>左值,推导结果是个引用</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>expr带括号:</strong></p>
<p><code>(expr)</code>表示的是执行表达式,并<strong>根据返回结果推导类型</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> x2 = <span class="hljs-number">2.0</span>;<br><span class="hljs-comment">// 下面的if都是true</span><br><span class="hljs-keyword">if</span>(is_same&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">decltype</span>(x1)&gt;::value)<br>	cout &lt;&lt; <span class="hljs-string">&quot;decltype(x1) datatype is int;&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(is_same&lt;<span class="hljs-keyword">int</span>&amp;,<span class="hljs-keyword">decltype</span>((x1))&gt;::value)	<span class="hljs-comment">// (x1)返回x1,是个左值</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;decltype((x1)) datatype is int&amp;;&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(is_same&lt;<span class="hljs-keyword">double</span>,<span class="hljs-keyword">decltype</span>(x1+x2)&gt;::value)<br>    cout &lt;&lt; <span class="hljs-string">&quot;decltype(x1+x2) datatype is double;&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(is_same&lt;<span class="hljs-keyword">double</span>,<span class="hljs-keyword">decltype</span>((x1+x2))&gt;::value)<br>    cout &lt;&lt; <span class="hljs-string">&quot;decltype((x1+x2)) datatype is double;&quot;</span>&lt;&lt;endl;<br></code></pre></td></tr></table></figure>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/17503803561e">深入解析decltype和decltype(auto)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linxmouse/p/17567763.html">C++11容易遗忘的特性整理与理解</a></li>
</ul>
<h2 id="name-mangling的解释工具"><a class="markdownIt-Anchor" href="#name-mangling的解释工具"></a> name mangling的解释工具</h2>
<p>反汇编出的汇编代码,它会有一坨怪怪的东西,比如<code>_Z3addPiPb</code>之类的,这个东西又大概知道它应该是个函数名,这玩意可以通过<code>c++filt</code>或是<code>cu++filt</code>来给它还原,比如:</p>
<img src="https://s2.loli.net/2024/08/15/mIl78OekFQasEx1.png" srcset="/img/loading.gif" lazyload alt="read-name-mangling-tool" style="zoom:67%;" />
<h2 id="神奇的宏定义"><a class="markdownIt-Anchor" href="#神奇的宏定义"></a> 神奇的宏定义</h2>
<p>在看别人代码的时候,不难会发现,有些人的宏定义会出现<code>#</code>,主要用两个用途:</p>
<ul>
<li><code>#</code>单个井号的使用,使得值变成字串,如<code>#define val2str(val) (#val) </code></li>
<li><code>##</code>两个井号的使用,使得两个值进行拼接,如<code>#define nameJoin(x,y) x##y</code></li>
</ul>
<p>可以通过<code>gcc -E ...</code>使得文件经过预处理,看看宏替换后的效果~</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/program/2847248sa.htm">浅析C++宏定义里#和##的使用</a></li>
</ul>
<h2 id="c-tmp"><a class="markdownIt-Anchor" href="#c-tmp"></a> C++ TMP</h2>
<p>TMP即templace metaprogramming<strong>模板元编程</strong>，这里小小的记录一下，更多的细节需要在实践中不断认知</p>
<p>元编程(metaprogramming)是编写元程序(metaprogram)的一种编程技巧</p>
<p>元程序的输入是其他程序乃至自己(metaprogram is a program about a program)</p>
<h3 id="元编程两种类型"><a class="markdownIt-Anchor" href="#元编程两种类型"></a> 元编程两种类型：</h3>
<ul>
<li>一种是对domain language翻译成host language，<strong>逻辑代码与元程序是分离的</strong></li>
<li>一种是用同一种语言将逻辑代码和元程序写在一起，元程序通过编译得到逻辑代码，并与别的逻辑代码混合，自己manipulate自己，<strong>逻辑代码与元程序是混合的</strong>，<strong><u>元程序看起来自己在编写自己</u></strong></li>
</ul>
<p><strong>C<ins>TMP是后者，元程序的代码和c</ins>逻辑代码写一起，元程序的逻辑在编译期执行，c++逻辑代码在运行期执行</strong></p>
<h3 id="可声明的模板类型"><a class="markdownIt-Anchor" href="#可声明的模板类型"></a> 可声明的模板类型</h3>
<ul>
<li>
<p><strong>类模板</strong>(class template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTemplate</span>;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>函数模板</strong>(function template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTemplate</span><span class="hljs-params">(T)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>变量模板</strong>(variable template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T varTemplate;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>别名模板</strong>(alias template)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> aliasTemplate = T;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>concept</p>
</li>
</ul>
<p>前三种可以有<strong>定义</strong>，后两种不需定义(不产生运行时的实体)</p>
<p>模板的产生是为了泛型编程(generic programming)，因此<strong>类型是被参数化</strong>(即类型可做参数)了的。模板由关键字<code>template</code>表明,然后<code>&lt;&gt;</code>内放置的是模板的参数</p>
<p><strong>类模板，函数模板是模板而非类或函数，它们是对类和函数的描述，<u>模板是对代码的描述</u></strong></p>
<h3 id="模板之形参形参-parameter实参-argument"><a class="markdownIt-Anchor" href="#模板之形参形参-parameter实参-argument"></a> 模板之形参(形参-parameter,实参-argument)：</h3>
<ul>
<li>
<p><strong>Non-type Template Parameters</strong>,接受一个<strong>确定类型</strong>(与模型形参的那个确定类型匹配)<strong>的常量作为实参,之所以需要常量,是因为模板是在编译期展开的,这个时候只有常量,没有变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> n&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcPrint</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;<br>    funcPrint&lt;b&gt;(); <span class="hljs-comment">// output 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Type Template Parameters</strong>,用**<code>typename</code><strong>这个关键字来</strong>声明**T是一个类型名称</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">whichType</span><span class="hljs-params">()</span></span>&#123;<br>    T val;<br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(val).<span class="hljs-built_in">name</span>() &lt;&lt; endl;	<span class="hljs-comment">// 头文件#include&lt;typeinfo&gt;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    whichType&lt;<span class="hljs-keyword">int</span>&gt;();	<span class="hljs-comment">// output i</span><br>    whichType&lt;<span class="hljs-keyword">float</span>&gt;(); <span class="hljs-comment">// output f</span><br>    whichType&lt;<span class="hljs-keyword">uint32_t</span>&gt;(); <span class="hljs-comment">// output j</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Template Template Parameters</strong>,<strong>只接受类模板和类的别名模板作为实参，且实参模板参数列表要和形参模板的参数列表match</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTemp</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>      T val;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;From clsTemp,datatype:&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(val).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">typename</span> tmplClass&gt;	<span class="hljs-comment">//  template&lt;typename T&gt;指明了所接受的类模板的形参列表.本类接受的类模板形参经由typename声明为tmplClass这么一个类型</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clsTempTempPara</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>      tmplClass&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;From clsTempTempPara&quot;</span> &lt;&lt; endl;<br>          tmp.<span class="hljs-built_in">display</span>();<br>      &#125;<br>  &#125;;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>      clsTempTempPara&lt;clsTemp&gt; classTempTempPara;	<span class="hljs-comment">// 类模板作为实参,clsTemp这个类模板的参数列表只有一位,且是type template parameter</span><br>      classTempTempPara.<span class="hljs-built_in">print</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="模板形参之可变长形参列表"><a class="markdownIt-Anchor" href="#模板形参之可变长形参列表"></a> 模板形参之可变长形参列表</h4>
<p>模板的形参也可以是可变长形参列表的,这个列表呢称作<strong>template parameter pack</strong>,这个可变长的pack要给它放最后(定长前面,变长后面),它可以接受:</p>
<ul>
<li>
<p><strong>nontype的constant</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl1</span>&#123;</span>&#125;; <br>packtmpl1&lt;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&gt; pinst;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl2</span>&#123;</span>&#125;;<br>packtmpl2&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>,string&gt; pinst2;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">typename</span>...args&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">packtmpl3</span>&#123;</span>&#125;;<br>packtmpl3&lt;clsTemp&gt; pinst3;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模板实例化"><a class="markdownIt-Anchor" href="#模板实例化"></a> 模板实例化</h3>
<p><strong>模板的实例化也分显式和隐式(按需)</strong>,实际上我们<strong>一般常用的都是隐式</strong>,比如<code>vector&lt;int&gt; vec;</code>,从这里可以看出,<strong>所谓的模板实例化的显式隐式不是以你是否隐式传参来区分的</strong></p>
<ul>
<li>
<p>隐式/按需实例化,需要具体的对象再实例化</p>
</li>
<li>
<p>显式实例化,先不创建对象,但是先实例化模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span></span>&#123;cout &lt;&lt; t &lt;&lt; endl;&#125;<br><span class="hljs-comment">// 显式实例化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="包含模型"><a class="markdownIt-Anchor" href="#包含模型"></a> 包含模型</h3>
<p><strong>模板编程的包含模型(inclusion model):将模板定义放在头文件,源文件包含这个头文件</strong></p>
<p>模板实例化所产生的symbol是<strong>weak symbol</strong>,不然会有重定义的问题,说是不同的翻译单元,传入的实参相同,则会实例化多次,产生的类/函数/变量都是相同的;同一个翻译单元则会复用而不是实例化多次,只会实例化一次</p>
<h3 id="模板特化"><a class="markdownIt-Anchor" href="#模板特化"></a> 模板特化</h3>
<p><strong>模板特化(Template Specialization)指的是对模板的形参进行部分替换或全部替换(替换是指具体化,即无泛型特征),并重新定义这种替换了的模板</strong></p>
<ul>
<li>
<p><strong>全特化(full specialization),指对原模版的形参全部替换</strong> <mark>函数模板只有全特化</mark></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTmpl</span><span class="hljs-params">(T t,U u)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;primary template&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; u &lt;&lt;endl;    <br>&#125;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funcTmpl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">float</span> u)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;full specialization&quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; u &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">float</span> u = <span class="hljs-number">2.0</span>;<br><span class="hljs-built_in">funcTmpl</span>(t,u);		<span class="hljs-comment">// output: full specialization1 2</span><br><span class="hljs-built_in">funcTmpl</span>(t,<span class="hljs-string">&quot;123&quot;</span>);   <span class="hljs-comment">// output: primary template1 123</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>偏特化(partial specialization),指对原模版的形参部分替换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;primary template &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&lt;</span><span class="hljs-keyword">int</span>,U&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;partial specialization &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clsTmpl</span>&lt;</span><span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>&gt;&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;full specialization &quot;</span> &lt;&lt; endl;&#125;<br>&#125;;<br>clsTmpl&lt;string,<span class="hljs-keyword">int</span>&gt;ctm1; ctm1.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// primary template </span><br>clsTmpl&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;ctm2; ctm2.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// partial specialization</span><br>clsTmpl&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>&gt;ctm3; ctm3.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// full specialization</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>主模板(primary template),无特化的原始模板</strong></p>
</li>
</ul>
<p>从上面的输出结果可以看出,<strong>在实例化模板的时候,编译器会挑最匹配的实现来进行替换,如果找不到才用primary template进行替换</strong></p>
<p><strong>注意区分模板特化和显示实例化</strong>,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>)</span></span>; <span class="hljs-comment">// 模板特化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>)</span></span>;	<span class="hljs-comment">// 显式实例化</span><br></code></pre></td></tr></table></figure>
<h3 id="metafuncion-convention"><a class="markdownIt-Anchor" href="#metafuncion-convention"></a> Metafuncion Convention</h3>
<p><strong>编译期只有常量和类型</strong>,我们管他们统一称为Metadata,其中<strong>常量是non-type metadata</strong>,而<strong>类型是type metadata</strong>.对于一个程序,除了数据,还有逻辑,<strong>逻辑部分则称为Metafunction,是在编译期会被调用的&quot;函数&quot;</strong></p>
<p>这类&quot;函数&quot;会返回<code>type</code>,即某一种特定的类型,也会返回<code>value</code>,这个<code>value</code>按照上面metadata的分类来说,即是常量.它们会通过别名模板或者是变量模板加以后缀<code>_v</code>或是<code>_t</code>用以定义或声明</p>
<p>而一个metafunction如果使用了另一个metafuncion的东西,可以通过继承来实现拥有其所依赖类的全部内容,相较于通过定义<code>using type = xxx&lt;xx&gt;::type</code>一类的方式更加简洁,同时采用struct关键字可以少写公有继承和类模板内的共两个public</p>
<div class="note note-info">
            <p>根据参考文件说是只返回<code>type</code>(这里的返回其实跟函数返回值不一样,可以通过如<code>xxx&lt;T&gt;::type</code>的方式获取到这个类型)作为唯一的返回值,而已经通过<code>value</code>表示的常量则通过类模板封装,metafuncion返回这个类模板实例,但感觉把继承用上,其实就直接<code>xxx::value</code>和<code>xxx::type</code>去获取这俩了,不用通过<code>xxx::type::value</code>去获取这个value</p>
          </div>
<p>根据参考文件(三)中编写程序时遇到了<strong>待决名</strong>,即语法分析阶段无法获知它是啥,例如<code>remove_reference&lt;T&gt;::type</code>依赖于T,这是语义分析才会实例化之,才可以对type进行名字查找,但在语法分析要判定语句是否合法,<strong>要通过typename显式指定它是一个类型或者通过template显式指定这是一个成员模板</strong></p>
<p><strong>在对类模板实例化时,如何匹配特化的模板?<strong>会通过</strong>确认实参-&gt;代入特化-&gt;反向推导对应特化的形参</strong>来确认是否匹配,如果失败则会依次fallback至主模板</p>
<p>关于参考文件三的实现:<a target="_blank" rel="noopener" href="https://github.com/ayyHA/cpp_grammar_test/blob/main/template_meta_programming/tmpv2.cpp">cpp_grammar_tmp</a></p>
<p>其中关于TMP处理数组,个人理解如<code>int[4][5][6]</code>进行匹配会倒过来匹配:<code>int[6][5][4]</code>,先从<code>[4]</code>开始匹配,此时<code>T</code>是<code>int[6][5]</code></p>
<h3 id="模板实参推导"><a class="markdownIt-Anchor" href="#模板实参推导"></a> 模板实参推导</h3>
<p>模板实参推导分为<strong>函数模板实参推导</strong>和<strong>类模板实参推导</strong>(c++17引入,通过构造函数进行模板实参推导),<strong>模板实参无需全部显式传入,可通过函数调用的实参或是构造函数的实参来进行推导,模板实参都能被推导且推导结果无冲突(即不存在T=int又T=float这种情况),则推导成功</strong></p>
<h3 id="sfinae"><a class="markdownIt-Anchor" href="#sfinae"></a> SFINAE</h3>
<p><strong>SFINAE(Substitution Failure Is Not An Error)即替换失败不是一个错误</strong>,说句人话就是<strong>实例化失败不会报错,不会产生error</strong></p>
<p>SFINAE这个东西的作用很大,比如可以让我们<u>基于逻辑控制重载集</u>/可以在c<ins>11/c</ins>14模拟c++17的if constexpr等,但需要先说说<strong>模板实例化流程</strong>,因为SFINAE作用于其中</p>
<ul>
<li>
<p><strong>函数模板的实例化流程</strong></p>
<p><strong>名字查找</strong>(找重载)-&gt;<strong>函数模板实参推导</strong>(推导失败的不会报错而是在重载集中删去)-&gt;<strong>重载决议</strong>(偏序规则排序和SFINAE于重载集删去非良构的)-&gt;<strong>有特化选特化,没特化选主模板</strong>-&gt;<strong>替换生成代码</strong></p>
</li>
<li>
<p><strong>类模板的实例化流程</strong></p>
<p><strong>名字查找</strong>(找类模板,多了就re-identification了)-&gt;<strong>根据主模板的构造函数进行实参推导</strong>(出错直接error)-&gt;<strong>根据主模板和特化选择最匹配的</strong>(估计这里冒出来了特化集,这里匹配特化就是metafunction那里的内容),通过将类模板的特化转为函数模板,使用函数模板的偏序规则排序,以及SFINAE对非良构的特化移出特化集-&gt;<strong>有特选最特,最特挑不出报错,无特选主模板</strong>-&gt;<strong>替换生成代码</strong></p>
</li>
</ul>
<div class="note note-info">
            <ul><li><p><strong>对于类模板而言,特化并不会带来新的名字;</strong></p></li><li><p><strong>对于函数模板而言,重载则是一个新的名字,特化(对函数就是全特化)也不会带来新的名字</strong></p></li></ul><p>这里的新的名字就是重定义指的那个名字</p><p>同时需要注意,<strong>实例化中并不一定都要通过推导得到模板实参,这个模板实参可以是默认值,可以是显式传入,也可以是推导得来的</strong></p>
          </div>
<p>上面我们提及了一个偏序规则,同时也提及了类模板的特化转成函数模板的形式采用函数模板的偏序规则进行排序,这个排序的目的是选出最匹配的特化/重载</p>
<p>那么类模板特化如何转换成函数模板呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span>&lt;</span>T,<span class="hljs-keyword">int</span>&gt; S&#123;&#125;;	   <span class="hljs-comment">// #a</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">struct</span>&lt;</span>T,<span class="hljs-keyword">float</span>&gt; S&#123;&#125;;  <span class="hljs-comment">// #b</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fa</span><span class="hljs-params">(S&lt;T,<span class="hljs-keyword">int</span>&gt;)</span></span>;		<span class="hljs-comment">// fa</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fb</span><span class="hljs-params">(S&lt;T,<span class="hljs-keyword">float</span>&gt;)</span></span>;	<span class="hljs-comment">// fb</span><br></code></pre></td></tr></table></figure>
<p>根据上述示例代码可以看出,<strong>转换的关键就是将模板特化的形参转换为函数的形参</strong></p>
<p>而后便使用偏序规则对特化进行优先级比较</p>
<p><strong>偏序规则</strong>可以这么描述:<code>fa&lt;U&gt;(A)</code>,其中U表示模板实参,A是实参列表中的类型,它是用U来表示的,即<code>A=op(U)</code>,将A代入<code>fb</code>的函数形参列表P,据此推导出T,即用U表示T</p>
<p>当<code>fa&lt;U&gt;(A) =&gt; fb&lt;T&gt;(P) &amp;&amp; fb&lt;U&gt;(A) ≠&gt;fa&lt;T&gt;(P)</code>时,说明<code>fa</code>比<code>fb</code>偏序更高.而<strong>不存在上述关系的二者无法推出谁比谁高,即认为相等</strong></p>
<p>最后来说一下这一部分的重点SFINAE:</p>
<p><strong>替换失败(Subtitution Failure)是指:在进行替换时,模板的立即上下文(immediate context,指声明处)中的类型或表达式非良构(ill-formed,指语法错误),这&quot;不是一个错误&quot;(INAE),只会在重载集/特化集中移除它,不会报错!</strong></p>
<p>关于参考文件五的实现:<a target="_blank" rel="noopener" href="https://github.com/ayyHA/cpp_grammar_test/blob/main/template_meta_programming/tmpv3.cpp">cpp_grammar_tmp</a></p>
<p>以下对一些SFINAE实现的模板进行描述:</p>
<ul>
<li><code>enable_if&lt;bool,T&gt;</code>类模板,根据bool的true/false触发SFINAE(非良构),实现基于逻辑控制重载集,可用其&quot;类型&quot;(<code>enable_if_t&lt;bool,T&gt;</code>)用于如<strong>函数的返回值</strong>,这样如果<code>enable_if&lt;false,T&gt;</code>就会非良构从重载集删去,因不会继承<code>type_identity&lt;T&gt;</code>;而传入的为<code>true</code>,则会以<code>T</code>作为返回值</li>
<li><code>void_t&lt;Args...&gt;</code>别名模板,可以基于此实现如python的hasattr功能,实现为<code>has_member_type</code>这个类模板,通过<code>template&lt;class T,class U=void&gt; has_member_type : false_type&#123;&#125;;</code>来实现一个主模板,特化模板的形参的<code>void</code>通过<code>void_t</code>传入,会根据SFINAE进行判断</li>
<li><code>declval&lt;T&gt;()</code>函数模板,可以实现编译期的fake variable,作用于不求值运算符内,这个函数模板的实现是<strong>只声明不定义</strong>,<code>template&lt;T&gt; add_rvalue_reference_t&lt;T&gt; declval();</code>通过<code>decltype(declval&lt;T&gt;())</code>获取伪变量的类型</li>
<li><code>add_lvalue_reference&lt;T&gt;</code>类模板通过一些函数模板实现继承的选择,所谓继承的选择是通过SFINAE实现的,因为如<code>void</code>是没有引用或右值引用类型的,所以要通过SFINAE匹配到对应的函数模板,如果是<code>void</code>返回<code>void</code>,是<code>int</code>返回<code>int&amp;</code>,这个返回的是<code>type_identity&lt;T&gt;</code>或者<code>type_identity&lt;T&amp;&gt;</code>一类的,而对于int而言这两种返回值都可以被匹配到,都在重载集里,这时候就要用偏序规则挑,那就要从函数的形参列表做文章,如<code>func(...)</code>或者<code>func(int)</code>后者显然偏序更高,当传入是int类型的单个参数.所以<strong>偏序规则和SFINAE两者要一起结合着用</strong></li>
<li><code>is_copy_assignable&lt;T,U=void&gt;</code>类模板,本质上跟利用<code>void_t</code>实现的<code>has_member_type</code>类模板一样的实现方式,都是应试尽试的想法,先通过declval搞俩假变量,然后赋值,然后通过decltype取类型,通过别名模板换个名字,而后利用<code>void_t</code>进行替换测试,如果无错则说明替换成功,支持拷贝赋值运算符,否则选到主模板</li>
<li><code>tuple</code>
<ul>
<li>通过template parameter pack定义一个构造函数,作为递归边界;而另一个特化则把这个pack拆成<code>T</code>和另一个<code>Args...</code>,继承于类模板实参为<code>Args...</code>的类,在当前情况下,T所对应的值,存储于<code>T value_;</code>这么个成员变量,显然对于不同的<code>Args...</code>,拆成某一情况下的<code>T</code>和<code>Args...</code>对应的<code>value_</code>是不同的,是属于该类的成员变量.从可变长参数拆到没参数匹配到递归边界</li>
<li>原生tuple中的<code>auto t = std::tuple('1',2.2f,std::string(&quot;three&quot;)); auto value = get&lt;idx&gt;(t);</code>显然传入的<code>idx</code>是类似于前期解构<code>extent</code>这么个获知某一个维度的数组的N的类模板,那么idx也可以通过类似的方式传入,而括号中的<code>t</code>通过模板实参推导得到,我们知道传入的一定是tuple,那么可以推导得到的<code>Args...</code>就会被作为模板形参,由此我们知道了get的大致写法,同时由于我们要获取某一个idx的<code>value_</code>,本质上是一个upcast的过程(找父类),因此可以通过<code>static_cast&lt;&gt;()</code>进行转换,与之而来的是转换得到的类型应该是什么?</li>
<li>显然转换的类型是某一个父类,即<code>tuple&lt;...&gt;</code>,这与输入的idx有关,递归至idx为0,则可以取此时的一整个tuple,这里的递归是<code>tuple_element&lt;N,tuple&lt;T,Args...&gt;&gt;:tuple_element&lt;N-1,tuple&lt;Args...&gt;&gt;</code>,等到N(即是上面的idx)变为0,则对此特化取<code>using __tuple_type = tuple&lt;T,Args...&gt;</code>,由此上述的upcast的问题便可以通过此metafunction获得,而获得的返回值是此时对应的T,则在这个<code>tuple_element&lt;0,tuple&lt;T,Args...&gt;&gt; : type_identity&lt;T&gt;</code>得到,而原生的tuple是可以修改值的,因此upcast包括get的返回值应该都是含有引用</li>
</ul>
</li>
</ul>
<div class="note note-info">
            <p><strong>不求值(Unevaluated)运算符有<code>sizeof</code>,<code>decltype</code>,<code>typeid</code></strong>(这玩意不是RTTI的东西吗,怎么跑编译期来了),<strong><code>noexcept</code>,这些运算符的操作数在编译期后就消失了,不求值,<u>只访问操作数的编译期属性</u>.对应的有<u>不求值表达式,不求值上下文</u></strong></p>
          </div>
<h3 id="concept和requires"><a class="markdownIt-Anchor" href="#concept和requires"></a> concept和requires</h3>
<p><mark>注意此部分没有写测试代码</mark></p>
<p>我们前面对传入的模板实参的筛选,目的是挑选对应的函数或类,以使用特定的具体实现,是通过模板实例化中的特化集和重载集,利用偏序规则和SFINAE去做筛选,有一种反着写代码的感觉,且<strong>报错非常冗长</strong>.而<u>c++20引入的concept</u>则解决了这个问题,且<strong>语法简单清晰</strong>.</p>
<p><strong>concept是对于模板实参的一系列constraints的集合</strong>,<strong>对它的检查先于模板实例化</strong>(所以报错少).它的声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> conceptName = constraint1 &amp;&amp; constraint2 || constraint3; <span class="hljs-comment">// constraint_expression </span><br></code></pre></td></tr></table></figure>
<p><strong>通过约束表达式来声明具体的concept</strong>,其中<strong>约束表达式支持短路求值</strong>,跟之前模板实例化中的逻辑运算表达式不同.具体使用如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Numeric = std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;Numeric T&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T)</span></span>;<br></code></pre></td></tr></table></figure>
<p><code>requires</code>关键字引入<u>requires从句</u>,放置于函数模板的声明中:</p>
<ul>
<li>可以接在函数模板形参列表<code>&gt;</code>的后面;</li>
<li>也可以放在函数形参列表和函数体之间<code>funcName() here &#123;&#125;</code></li>
</ul>
<p><strong><u>requires从句</u>必须是一个常量表达式</strong>,可以是:</p>
<ul>
<li>
<p>concept表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">requires</span> Numeric&lt;T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>true/false</p>
</li>
<li>
<p>约束表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T)</span> <span class="hljs-keyword">requires</span> std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt; </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>requires表达式</p>
<p>这个表达式声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in"><span class="hljs-keyword">requires</span></span>(parameter)&#123;...&#125;<br></code></pre></td></tr></table></figure>
<p><strong>它本质是一个bool类型的纯右值,也是描述约束,良构为true,否则为false</strong>.可以用于声明concept,也可以用于requires从句</p>
</li>
</ul>
<p><strong>约束出现的顺序决定了编译器检查的顺序,逻辑相同,但约束的位置不同,不会被认为是重定义</strong></p>
<p><strong>泛型编程并非完全泛型,而是约束下的泛型编程,这里的约束即是concept和requires的体现</strong></p>
<p>参考文件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378360055">C++模板元编程（二）：模板基础</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384826036">C++模板元编程（三）：从简单案例中学习</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/390783543">C++模板元编程（四）：深入模板</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/395165250">C++模板元编程（五）：从进阶的案例中学习</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413297399">C++模板元编程（六）：约束和概念</a></li>
</ul>
<h2 id="c特征萃取"><a class="markdownIt-Anchor" href="#c特征萃取"></a> C++特征萃取</h2>
<p>详见<code>type_traits</code>库,也可以看模板元编程中的部分手动实现</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_68194402/article/details/142148126">C++ 萃取技术——固定萃取技术</a></li>
</ul>
<h2 id="常量折叠"><a class="markdownIt-Anchor" href="#常量折叠"></a> 常量折叠</h2>
<p>在传统编译器中,常量折叠指的就是编译期算好的常量,它们是放在常量表中的,然后用到的时候直接取值,如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &gt;= <span class="hljs-number">1</span>; i--)<br>        val *= i;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> b = <span class="hljs-built_in">mul</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-keyword">int</span> *c = (<span class="hljs-keyword">int</span> *)(&amp;b);<br>    *c = <span class="hljs-number">12345</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d, c = %d\n&quot;</span>, b, *c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b addr = %p, c addr = %p\n&quot;</span>, &amp;b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 输出结果:</span><br><span class="hljs-comment">a = 5, b = 120</span><br><span class="hljs-comment">b = 120, c = 12345</span><br><span class="hljs-comment">b addr = 000000000061fe0c, c addr = 000000000061fe0c</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>g++ -S</code>编译看到汇编文件中b的值就是<code>$120</code></p>
<p><img src="https://s2.loli.net/2024/12/17/iwedH3ScrB2LU8Q.png" srcset="/img/loading.gif" lazyload alt="test constant fold" /></p>
<p>而常量折叠这个次也出现在了AI编译器中,指的是计算图优化中对一些输入均为常量值的op提前计算,以消除冗余的计算,下面是知乎ZOMI酱的图(编译器相关的代码我不懂,但是理解理解概念总是需要的)</p>
<img src="https://s2.loli.net/2024/12/17/d2jGafA4K9hHqRS.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
<h2 id="__attribute__"><a class="markdownIt-Anchor" href="#__attribute__"></a> __attribute__()</h2>
<p><strong>为函数,变量,类型提供优化和检查的编译属性</strong>,详见参考文件中的内容,可以去到gnu的网站看一些详情和例子,见得比较多的是声明一些类型的最小对齐大小,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span> <span class="hljs-keyword">short</span> var[<span class="hljs-number">3</span>];&#125; __attribute__((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">8</span>)));<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    S sss;<br>    <span class="hljs-keyword">size_t</span> size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sss);<br>    cout &lt;&lt; size &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">// 增加了__attribute__((aligned(8)))</span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">// 注掉它</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>也可以用来标识一个函数过期了,如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">__attribute__((<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;old function call&quot;</span>))) <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fff&quot;</span>);&#125;<br><span class="hljs-comment">/* compile output</span><br><span class="hljs-comment">xxx.cpp:13:8: warning: &#x27;void f()&#x27; is deprecated: old function call [-Wdeprecated-declarations]</span><br><span class="hljs-comment">     f();</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29350001/article/details/129390465">__attribute__详解</a></li>
</ul>
<h2 id="虚表指针"><a class="markdownIt-Anchor" href="#虚表指针"></a> 虚表指针</h2>
<p><strong>在函数前有个<code>virtual</code>关键字的就是虚函数,有虚函数的类的实例们就有一个大家统一用的虚函数表,有个虚表指针会指向这个虚表,用以实现多态,通过运行时指向具体子类指针/引用的基类指针/引用来调用对应虚表的函数实现,从而实现多态.</strong></p>
<div class="note note-info">
            <p><strong><code>virtual void func() = 0;</code>纯虚函数,拥有它的类是抽象类,无法实例化</strong>,但是可以声明之用以指向实现了纯虚函数的派生类</p>
          </div>
<p><strong>虚表指针是在类内成员变量的最前面</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSizeA</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSizeB</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;TestSizeB func&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// main:</span><br>TestSizeA a;<br>TestSizeB b;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(b) &lt;&lt; endl;<br>cout &lt;&lt; &amp;a.x &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(&amp;a) &lt;&lt; endl;<br>cout &lt;&lt; &amp;b.x &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> *&gt;(&amp;b) &lt;&lt; endl;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">16				// 还给它对齐了</span><br><span class="hljs-comment">0x7ffc98f10e2c	 // TestSizeA的x是首地址</span><br><span class="hljs-comment">0x7ffc98f10e2c	 </span><br><span class="hljs-comment">0x7ffc98f10e68	 // TestSizeB的x和首地址隔了8个字节</span><br><span class="hljs-comment">0x7ffc98f10e60	 // 虚表指针</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>根据上面的测试,既然可以得到虚表指针,也即可以通过虚表指针调用对应的内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> voidFunc = <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;constructor Father&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Father</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;deconstructor Father&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Father::printf&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print2</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Father::print2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son2</span> :</span> <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son2</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;constructor Son2&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Son2</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;deconstructor Son2&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Son2::print&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print2</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Son2:print2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-comment">// main:</span><br>Father *fptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Son2</span>();<br><span class="hljs-keyword">uintptr_t</span> *func = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span> *&gt;(fptr);<br><span class="hljs-keyword">uintptr_t</span> *funcc = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span> *&gt;(*func);<br>voidFunc func1 = <span class="hljs-keyword">reinterpret_cast</span>&lt;voidFunc&gt;(funcc[<span class="hljs-number">3</span>]);<br><span class="hljs-built_in">func1</span>();<br><span class="hljs-keyword">delete</span> fptr;<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">constructor Father</span><br><span class="hljs-comment">constructor Son2</span><br><span class="hljs-comment">Son2:print2</span><br><span class="hljs-comment">deconstructor Son2</span><br><span class="hljs-comment">deconstructor Father</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>上述是使用虚表指针进行内容调用的一个例子,需要注意<strong>虚表指针是二级指针</strong>,同时运用多态的时候,<strong>析构函数也要是虚函数(基类的析构函数要是虚函数)</strong>,不然你delete的时候就调用的是基类指针的析构函数,会造成内存泄漏,而给析构函数加个virtual,那delete的时候通过虚表找到对应的析构函数,即可把子类给析构了再析构父类</p>
<p>虚表指针是在内存分配-&gt;初始化列表-&gt;构造函数内部的内存分配和初始化列表之间完成初始化的</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/682680244">深入理解C++虚函数表</a></li>
</ul>
<h2 id="四种cast使用场景"><a class="markdownIt-Anchor" href="#四种cast使用场景"></a> 四种cast使用场景</h2>
<p>四种cast:<code>static_cast&lt;newType&gt;(expr)</code>,<code>dynamic_cast&lt;newType&gt;(expr)</code>,<code>const_cast&lt;newType&gt;(expr)</code>,<code>reinterpret_cast&lt;newType&gt;(expr)</code></p>
<ul>
<li>涉及到底层指针的转换采用<code>reinterpret_cast</code></li>
<li>涉及到cv属性变化的采用<code>const_cast</code></li>
<li>在单元测试中涉及到downcast的对象指针或对象引用则用(RTTI(runtime type identification)影响性能)</li>
<li>平常则用<code>static_cast</code></li>
</ul>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/578828427">现代C++中的四种CAST</a></li>
</ul>
<h2 id="default-delete"><a class="markdownIt-Anchor" href="#default-delete"></a> =default / =delete</h2>
<p>c++11 <code>=default</code>可以在类中让编译器生成默认构造函数,拷贝构造函数,移动构造函数,以及对应的赋值运算符,反之可以通过<code>=delete</code>禁用</p>
<h2 id="函数调用约定"><a class="markdownIt-Anchor" href="#函数调用约定"></a> 函数调用约定</h2>
<p><code>__stdcall</code>和<code>__cdecl</code>是两个函数调用约定的关键字,都是从右到左入栈,前者是被调函数清理栈,后者是调用函数清理栈</p>
<h2 id="几个继承"><a class="markdownIt-Anchor" href="#几个继承"></a> 几个继承</h2>
<p>公有继承于派生类就是基类的成员访问权限保持原样;<br />
protected和private则是把基类成员的访问权限全变成protected或是private</p>
<p>非公有继承会影响到后续派生类对象对基类方法的调用,可以通过using来重新定义一下访问权限</p>
<p>参考文章:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43441284/article/details/140251777">C++：using重新定义继承时访问权限</a></li>
</ul>
<h2 id="友元"><a class="markdownIt-Anchor" href="#友元"></a> 友元</h2>
<p>友元实际上是一种单向的关系,在将某个函数/类声明为类A的友元函数/类的时候,类A开放了protected,private修饰的成员变量的权限给它,同时这个友元函数/类只需声明在类A(不是类A的函数啥的,只是声明),可以定义在外头,有利于工具类的使用,也有利于泛型编程,也避免了如Java一样的繁复的get,set函数</p>
<p>参考文章:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenai886/article/details/144667981">友元</a></li>
</ul>
<h2 id="crtp"><a class="markdownIt-Anchor" href="#crtp"></a> CRTP</h2>
<p>CRTP,curiously recurring template pattern,奇异递归模板模式,静态多态实现方式,其实就是基类是个类模板,模板形参传入的是派生类,基类内部的函数通过<code>static_cast&lt;derived*&gt;(this)-&gt;xxx()</code>的形式实现downcast,实现编译期的多态</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/linux/">linux</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/24/%E9%87%8D%E5%BA%86%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%9A%E8%AE%AE%E8%AE%B0%E5%BD%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">重庆高性能会议记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/15/little-knowledge-of-loadable-kernel-module/">
                        <span class="hidden-mobile">little-knowledge-of-loadable-kernel-module</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'c26778f9dcc30274cc0603f5d9511f91'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
