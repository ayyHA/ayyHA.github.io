

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="learn learn learn">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="learn learn learn">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-learning">
<meta property="og:url" content="http://example.com/2024/02/29/leetcode-learning/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="learn learn learn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png">
<meta property="og:image" content="https://s2.loli.net/2024/09/18/yCZi7WxrEN2SsnJ.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/05/TFOilYVa1yLGPrz.png">
<meta property="og:image" content="https://s2.loli.net/2024/10/05/K69fzbjt7yrANoG.png">
<meta property="article:published_time" content="2024-02-29T06:01:02.000Z">
<meta property="article:modified_time" content="2024-10-05T17:29:38.827Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithm learning">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png">
  
  <title>leetcode-learning - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="leetcode-learning">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-02-29 14:01" pubdate>
        2024年2月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      35k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      110 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">leetcode-learning</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：12 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2>
<p>🔴 -&gt; 一般是指hard的题目,且没pass出来的,就是连暴力解法都想不到的</p>
<p>🔵 -&gt; 表示十拿九稳的题目</p>
<h2 id="c的字符数组和c的string转换以及常用函数"><a class="markdownIt-Anchor" href="#c的字符数组和c的string转换以及常用函数"></a> C的字符数组和C++的string转换以及常用函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c_s = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>c++中通过导入iomanip,可以用fixed来使浮点数定位(无论double d 里的值是整数浮点数,统统给它输出浮点数形式)<br />通过setprecision(n)来确定整体数字位数,若没有结合fixed使用,则代表的位数是整数位+小数位n;<mark>结合fixed使用则代表的位数是小数位n</mark></p>
          </div>
<h2 id="c一些流"><a class="markdownIt-Anchor" href="#c一些流"></a> C++一些流</h2>
<p><code>istream&amp; getline(istream&amp; is,string&amp; s,char delim)</code></p>
<ul>
<li><code>is</code>是输入流对象, 可以是<strong>标准输入cin</strong>,可以是<strong>输入文件流对象ifstream</strong>,可以是<strong>输入字符串流对象istringstream</strong>等等</li>
<li><code>s</code>存储读到的一行文本的字串</li>
<li><code>delim</code>分隔符,<strong>表示在哪个字符处停止读取,默认是<code>\n</code></strong></li>
<li>返回值是输入流对象的引用</li>
</ul>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://vcsos.com/article/pageSource/160122/20160122233408.shtml">io流,文件流,字串流</a></li>
</ul>
<h2 id="algorithm一些算法"><a class="markdownIt-Anchor" href="#algorithm一些算法"></a> algorithm一些算法</h2>
<h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3>
<p>排序算法,很经典,c++里用的是快排实现的,我们的容器可以通过如下方式使用它:</p>
<p><code>sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</code></p>
<ul>
<li>第一个参数是迭代器的起始地址</li>
<li>第二个参数是迭代器的结束地址(就是那个<code>end()</code>,结束位置的下一位)</li>
<li>第三个参数是排序规则</li>
</ul>
<p>这里主要讲自定义排序规则,<strong>默认是升序(即默认采用<code>&lt;</code>运算符进行比较,谁小谁排前面)</strong>.可以通过:</p>
<ul>
<li>
<p><strong>lambda表达式(本质上是定义一个返回值为bool的两个待比较参数的比较函数)</strong></p>
</li>
<li>
<p><strong>重载运算符</strong></p>
<p><strong>主要运用在结构体里,以指示如何对结构体里的成员进行比较</strong>,然后调用c++自带的仿函数<code>less&lt;T&gt;()</code>/<code>greater&lt;T&gt;()</code>(头文件是<code>&lt;functional&gt;</code>)来对序列中的<code>T</code>类型排序,示例如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>  <span class="hljs-comment">// 重载&gt;运算符</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> Person&amp; other) <span class="hljs-keyword">const</span>&#123;<br>  	<span class="hljs-keyword">if</span>(score != other.score)<br>  		<span class="hljs-keyword">return</span> score &gt; other.score;<br>  	<span class="hljs-keyword">return</span> id &lt; other.id;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">// 使用greater仿函数来通过&#x27;&gt;&#x27;运算符进行比较,则会调用到Person里重载的&#x27;&gt;&#x27;运算符里的规矩来进行排序</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:people)<br>    	cout &lt;&lt; p.id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; p.score &lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png" srcset="/img/loading.gif" lazyload alt="cpp_functional_greater" style="zoom:80%;" />
</li>
<li>
<p><strong>仿函数</strong></p>
<p><strong>仿函数(functor)是一个类/结构体,里面重载了<code>operator()</code>,从而仿函数的对象可以像函数一样被调用,大致如下:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greater</span>&#123;</span>	<span class="hljs-comment">// 定义一个仿函数</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; y)</span></span>&#123;<br>			<span class="hljs-keyword">return</span> x&gt;y;<br>		&#125;	<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>&#125;;<br>	Greater g;	<span class="hljs-comment">// 仿函数的对象</span><br>	<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),g); <br>	<br>    <span class="hljs-comment">// 下面这种也可以,跟c++提供的仿函数greater&lt;int&gt;()一样,这里的greater是个struct</span><br>    <span class="hljs-comment">//	sort(v.begin(),v.end(),Greater());</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>以上三种方式的任一方式来实现自己的排序功能,乃至多级排序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是对vector降序排序*/</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; j)-&gt;<span class="hljs-keyword">bool</span>&#123;<span class="hljs-keyword">return</span> i&gt;j;&#125;);<br></code></pre></td></tr></table></figure>
<p>可以这么理解i&gt;j就是谁大谁排前面(i是第一个参数,j是第二个参数),当然上面的也可以写成普通的函数;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是多级排序,对自定义结构体Person*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    排序规则:</span><br><span class="hljs-comment">    	1.先按分数由高到低排</span><br><span class="hljs-comment">    	2.分数相同的id小的排前面</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> Person&amp; a,<span class="hljs-keyword">const</span> Person&amp; b)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>    	<span class="hljs-keyword">if</span>(a.score != b.score)<br>            <span class="hljs-keyword">return</span> a.score &gt; b.score;<br>        <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/263333.htm">c++自定义sort()函数的排序方法介绍</a></li>
</ul>
<h3 id="iota"><a class="markdownIt-Anchor" href="#iota"></a> iota</h3>
<p>这是一个区间填充函数,所在头文件为<code>numeric</code>,函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iota</span><span class="hljs-params">(ForwardIt first, ForwardIt last, T value)</span></span>;<br></code></pre></td></tr></table></figure>
<p>前两个参数用迭代器指定区间范围,最后的参数用来指示起始值,可以迅速的填充好一个区间,比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> size = n;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>); <span class="hljs-comment">// [0, ..., n-1]</span><br></code></pre></td></tr></table></figure>
<h2 id="一些stl容器回顾"><a class="markdownIt-Anchor" href="#一些stl容器回顾"></a> 一些STL容器回顾</h2>
<p>这里主要记着主要方法,后续有新的会来补充,以便于一开始训练的时候查方法,当然也会说一下不同容器/相似容器间的差别</p>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvshen/p/17839484.html">STL容器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57190374/article/details/127042161">C++常用容器介绍</a></li>
</ul>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<p>因为字符串涉及的函数非常多,且有些函数很少用,但在一些机试的时候会遇到,而且自己重写非常繁琐,因此这里记录一下一些函数,这里会混杂字符的内容</p>
<p><strong>数字,字母,大小写部分:</strong></p>
<ul>
<li><code>isalpha()</code>用于判断一个字符是否是字母</li>
<li><code>isalnum()</code>用于判断一个字符是否是字母或数字</li>
<li><code>isupper()</code>用于判断一个字符是否是大写的</li>
<li><code>islower()</code>用于判断一个字符是否是小写的</li>
<li><code>toupper()</code>将一个字符转为大写</li>
<li><code>tolower()</code>将一个字符转为小写</li>
</ul>
<p>上面的是针对字符的,源自<code>&lt;ctype.h&gt;</code></p>
<p>对于字串来说的话,导入algorithm库可有以下转换方式:</p>
<ul>
<li><strong><code>transform(s.begin().s.end(),s.begin(),::tolower)</code></strong> 转换整个字串为小写,其中第一二个参数是输入容器的起始和终止迭代器(终止不含),第三个参数是输出容器的开始迭代器,第四个参数是一元函数对象</li>
<li><strong><code>transform(s.begin(),s.end(),s.begin(),::toupper)</code></strong> 转换整个字串为大写</li>
</ul>
<p><strong>字符串和整型的转换:</strong></p>
<ul>
<li><strong><code>stoi(string,nullptr,base)</code></strong> 字串转整数,base是string的进制,比如string是二进制的,则这里就写个2,会自动做进制转换</li>
<li><strong><code>to_string(int/long/float)</code></strong> 将一个数字常量转为字符串</li>
</ul>
<p>还有一种<code>atoi()</code>,<code>itoa</code>的字串和整型的转换,但是需要注意这种针对的是字符数组,而非string</p>
<p><strong>字符串做切片</strong></p>
<ul>
<li><strong><code>substr(start,len)</code></strong> 从<code>start</code>处,切len这么长的子串,不指定len则到结尾</li>
<li><s><code>substring(start,end)</code> 从start处开始,切到end,其中不包括end索引的字符,不指定end则到结尾</s><mark>[这是java/js才有的,搞错了= =]</mark></li>
</ul>
<p><strong>初始化函数</strong></p>
<p>在结构体或者类中,需要对一些为指针的成员实现初始化(别的也尽量初始化),不然会报内存不对齐的错误,传统的C在<code>cstring</code>这个库里有**<code>memset(void* s,int c,size_t n)</code>**可以对一块内存进行初始化,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        isEnd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意:由于<code>memset</code>是按字节对内存块进行初始化,也就是说第二个参数c只会取低八位,然后赋值给一块地址(一块地址是一字节).比如int是4字节,那如果给的c是1,就会变成<code>0x01010101</code>,每个字节分别是<code>0000 0001</code>这么一个情况,所以一般第二位填0或-1就好了,它跟那种<code>vector&lt;int&gt;v(10,5) // 十个数,每个都是5</code>不一样</p>
<div class="note note-info">
            <p>由于LeetCode检测机制更加严格，所以我们在创建节点是，还需将指针域赋值。</p><p>参考文件:<a target="_blank" rel="noopener" href="https://blog.csdn.net/Zhenyu_Coder/article/details/132273442">runtime error: member access within misaligned address(力扣最常见错误之一)</a></p>
          </div>
<h3 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h3>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4>
<ul>
<li><code>push_back()</code></li>
<li><code>emplace_back()</code></li>
</ul>
<div class="note note-info">
            <p>上面两个函数都是向容器尾部添加元素</p><p>push_back():1. 创建元素; 2. 调用移动构造函数/拷贝构造函数,将元素弄到容器中</p><p>emplace_back(): 1. 直接在容器尾部创建元素,减少了拷贝/移动的开销</p><p>其中<strong>移动构造函数</strong>和<strong>拷贝构造函数</strong>是不同的:<strong>后者是将一个已存在的对象复制到一个新的对象中;前者是将一个对象的资源移动到一个新的对象中</strong>.因为一般自己写的拷贝构造是深拷贝(为了避免浅拷贝指向同一块内存的问题)所以涉及到<strong>内存分配</strong>,而拷贝又涉及到<strong>数据复制</strong></p><p>而其中移动构造涉及到右值引用的知识,可以看看参考文件</p><p>参考文件:</p><ul><li><a target="_blank" rel="noopener" href="https://gitcode.csdn.net/65eed6611a836825ed79f6e7.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NTk3OTAyMCwiZXhwIjoxNzE3MTIwNTQyLCJpYXQiOjE3MTY1MTU3NDIsInVzZXJuYW1lIjoid2VpeGluXzQ1Mzg4MzEyIn0.NhR7qBK3BAP_eFFZfFm1NLr7JxVF3TFaKd_tDLsOZ-4">【C++11】之 emplace_back() 与 push_back() 的区别</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44355021/article/details/129369368">移动构造函数与拷贝构造函数对比</a> (未看完)</li></ul>
          </div>
<h4 id="queue容器适配器"><a class="markdownIt-Anchor" href="#queue容器适配器"></a> queue[容器适配器]</h4>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
</ul>
<div class="note note-info">
            <p>push,pop遵循FIFO</p>
          </div>
<ul>
<li><code>size()</code></li>
<li><code>empty()</code></li>
<li><code>front()</code></li>
<li><code>back()</code></li>
</ul>
<p>queue参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59068776/article/details/130549065">queue基本方法</a></p>
<h4 id="deque双端队列"><a class="markdownIt-Anchor" href="#deque双端队列"></a> deque(双端队列)</h4>
<p>相比于vector,可以更好更迅速的处理头部元素</p>
<h4 id="list双向链表"><a class="markdownIt-Anchor" href="#list双向链表"></a> list(双向链表)</h4>
<h4 id="forward_list单链表"><a class="markdownIt-Anchor" href="#forward_list单链表"></a> forward_list(单链表)</h4>
<h4 id="stack栈容器适配器"><a class="markdownIt-Anchor" href="#stack栈容器适配器"></a> stack(栈)[容器适配器]</h4>
<ul>
<li><code>push()</code> #压入</li>
<li><code>pop()</code> # 弹出</li>
<li><code>top()</code> # get栈顶</li>
<li><code>back()</code> # get栈底</li>
<li><code>empty()</code></li>
<li><code>size()</code></li>
</ul>
<p>不能通过索引遍历,用<code>while(!s.empty())</code>遍历</p>
<p>stack参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130857503">stack基本方法</a></p>
<h4 id="priority_queue优先队列容器适配器"><a class="markdownIt-Anchor" href="#priority_queue优先队列容器适配器"></a> priority_queue(优先队列)[容器适配器]</h4>
<p><strong>底层是通过堆实现的优先队列,常数时间的最大/最小元素查找,默认是大顶堆(<code>less&lt;T&gt;</code>),则最大元素位于<code>top()</code>,当调用<code>pop()</code>则会发生类似<code>adjust_down()</code>一类的内部函数的操作</strong></p>
<p>具备<strong>自动排序</strong>的特性,所以对如<strong>前k个…最大/最小</strong>的题目都很适用</p>
<p>优先队列的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq; <span class="hljs-comment">// 其中只有第一个是要具体定义的,三个分别是:元素类型,容器类型,比较函数类型</span><br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>注:这里传入的是比较函数的类型,而不是具体的对象,因此不用像sort里的加多个<code>()</code>; 这个跟自定义map的key的比较方式很相似,传的是类型而不是匿名对象</p>
          </div>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>top()</code></li>
<li><code>size()</code></li>
<li><code>empty()</code></li>
</ul>
<p>有一个比较可能会遇到的问题就是<strong>重写比较函数</strong>,这里给出一个模板:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b)&#123;<br>    <span class="hljs-keyword">return</span> a.xxx &gt; b.xxx;					<span class="hljs-comment">//这样构造的是该规则下的小顶堆,可以按sort理解为这是降序,然后堆排序降序的话是小顶堆弄的</span><br>&#125;<br>priority_queue&lt;T,vector&lt;T&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure>
<p>这么一个模板可以重写比较规则,使得出来的大顶堆/小顶堆(也就是最大值/最小值)符合我们的需求</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_68278653/article/details/131015181">priority_queue</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/498045886">[C++STL] Priority Queue 介绍及源码分析</a></li>
</ul>
<h3 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h3>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4>
<p>内部是通过<strong>红黑树</strong>实现的,<strong>去重且递增</strong>(自动有序),<strong>遍历只可以通过iterator遍历</strong>,插入值是insert的方式</p>
<p><img src="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png" srcset="/img/loading.gif" lazyload alt="set方法大全" /></p>
<p>以下这俩函数是针对的容器中的数值是有序的,而set有序,故可以用:</p>
<ul>
<li><code>lower_bound()</code>:实参用个val,会找到set容器中&gt;=val的iterator,找不到就滑到<code>end()</code>了</li>
<li><code>upper_bound()</code>:实参用个val,会找到set容器中&gt;val的首个iterator,找不到就滑到<code>end()</code></li>
</ul>
<p>set参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130800542">set</a></p>
<h4 id="unordered_map"><a class="markdownIt-Anchor" href="#unordered_map"></a> unordered_map</h4>
<p>底层是通过<strong>哈希表实现的无序map</strong></p>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4>
<ul>
<li><code>insert()</code></li>
<li><code>begin()</code></li>
<li><code>end()</code></li>
<li><code>clear()</code></li>
<li><code>count()</code> # 返回指定元素出现的次数,key唯一就是0/1</li>
<li><code>empty()</code></li>
<li><code>erase()</code> # 删除一个元素,并返回下一个元素的迭代器(使用特别注意,要承接这个return值,而不是自增)</li>
<li><code>find()</code> # 查找一个元素,找得到返回对应位置迭代器,否则滑倒<code>end()</code>去</li>
<li><code>size()</code></li>
<li><code>rbegin()</code></li>
<li><code>rend()</code></li>
<li><code>lower_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>给定元素的第一个位置</li>
<li><code>upper_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">\gt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>给定元素的第一个位置</li>
<li><code>swap()</code> # 交换两个map</li>
</ul>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58086930/article/details/120393227">map和multimap的解释c++</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nntzhc/p/14606368.html">erase神奇用法!</a></li>
</ul>
<h4 id="multimap"><a class="markdownIt-Anchor" href="#multimap"></a> multimap</h4>
<p><strong>允许key重复,没有重载<code>operator[]</code>,底层红黑树</strong></p>
<ul>
<li><code>insert()</code></li>
</ul>
<div class="note note-info">
            <p>注:只可以用这个加值,不像map可以用<code>[]</code>来加值,需要注意</p>
          </div>
<h2 id="一些板子"><a class="markdownIt-Anchor" href="#一些板子"></a> 一些板子</h2>
<p>写题记录总结,并记忆一些板子,以便后期快速完成题目</p>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3>
<p><em><strong>不撞南墙不回头</strong></em></p>
<p>实现手段: 递归</p>
<p>适用于: 树,图</p>
<p>经典题目: 迷宫找通路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-comment">/*状态*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*递归结束条件*/</span>)&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*找寻新状态*/</span>)&#123;<br>        <span class="hljs-comment">// 定义新状态</span><br>    	<span class="hljs-keyword">if</span>(<span class="hljs-comment">/*新状态满足边界条件*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足标志位*/</span>)&#123;<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置标志位</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-comment">/*新状态*/</span>);<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置为旧的flag以回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>状态是指比如迷宫里的坐标xy一类的东西</p>
          </div>
<h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h3>
<p><em><strong>像波一样,由近及外</strong></em></p>
<p>实现手段: 队列</p>
<p>适用于: 最短路径</p>
<p>因为广度优先搜索和层序遍历概念很像,这里举的模板是按着层序遍历的写的,可以在这基础上根据题意进行变通,变通版本在下面:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(node); 				<span class="hljs-comment">// 这里push的是类似于&quot;头节点&quot;或&quot;符合题目要求的!首类节点!&quot;</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;			<span class="hljs-comment">// 遍历队列里的点</span><br>    <span class="hljs-comment">/*跳出条件*/</span> 			<span class="hljs-comment">// 有些题目需要设置跳出条件</span><br>    <span class="hljs-keyword">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;	<span class="hljs-comment">// 一层层的遍历,这个sz代表的是这一次波及到的点,可以从树的层序遍历和矩阵中点逐个向外扩散进行想象</span><br>		<span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>         q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*候选点*/</span>)&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            	获取一个候选点</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*满足边界*/</span> &amp;&amp; <span class="hljs-comment">/*满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*满足标志位*/</span>)&#123;	<span class="hljs-comment">// 筛选符合状态的点</span><br>        		flags[candidateNode] = ... 					<span class="hljs-comment">// 设置标志位</span><br>                 q.<span class="hljs-built_in">push</span>(candidateNode);						<span class="hljs-comment">// 满足条件的点加入队列中(这是下一层)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3>
<p>使用场景:原数组不变动,但需要对子数组进行频繁的累和操作(频繁查询区间和),则可以构建<strong>前缀和数组</strong></p>
<p>前缀和数组即<code>prefix[i]</code>表示的是原数组nums在<code>[0,i-1]</code>这个区间的元素的累和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//	假设题目给的数组是:vector&lt;int&gt;&amp; nums</span><br><span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span>* prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要多一个位置</span><br>prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;	<span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=len; i++)<br>    prefix[i] = prefix[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">... 对前缀和数据的操作,如想获得[i,j]区间的累和,则可以通过prefix[j+1] - prefix[i]获得</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> []prefix;<br></code></pre></td></tr></table></figure>
<p><strong>前缀和+哈希表</strong></p>
<p>这里以560题<u>和为k的子数组</u>为例,前缀和一般喜欢考某一个区间的和是k值的情况(会变形),如果按照暴力的思路,开个前缀和数组,计算每一个<code>[i,j]</code>区间的和,判断是否为k,如此处理,则需要两重循环,时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,其实跟暴力做没太大区别</p>
<p>这时要怎么优化呢?首先我们期望求**<code>[i,j]</code>区间值为k的个数,即等价于<code>prefix[j+1] - prefix[i] = k</code>**,就是上面二重循环的循环判断条件</p>
<p><strong>这其实跟两数之和:<code>i + j = target</code>是一样的,对于两数之和,我们是转换成<code>i = target-j</code>,然后遍历得到j,通过哈希表判断存不存在<code>target-j</code>,存在则返回,不存在则把j加入哈希表中来处理</strong></p>
<p>对于利用前缀和求区间和满足题意的个数的题目(就是上面那个题),也可以这样转换:<strong><code>prefix[i] = prefix[j+1] - k</code>,即求满足这样条件的<code>prefix[i]</code>的数量,也即等价于求满足<code>prefix[j+1]-k</code>的数量</strong>,所以遍历就<strong>可以只遍历一个维度,同时利用<code>prefix[j+1]-k</code>去哈希表里看,有没有match的,match就加上去,最后统计<code>prefix[j+1]</code>:<code>ump[prefix[j+1]]++;</code>,这里统计的是<code>prefix[j+1]</code>的次数,也即前缀和为某一个值的个数</strong></p>
<p>由此则利用哈希表,把时间复杂度降到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>当然,也可以只利用一个变量<code>preSum</code>去统计当前区间的和(比如[0:j-1])然后利用<code>ump.count(preSum-k)</code>来判断是否存在区间[i,j-1]满足区间和(由于累和顺序是从左到右,依次把值加入哈希表中,所以保证了区间i&lt;j),满足则加上满足的区间数量.这样的话,开前缀和的空间复杂度就降到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><strong>典型例题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></li>
<li>724 寻找数组的中心下标</li>
</ul>
<h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3>
<p>当我们需要对一个数组的区间批量的进行数据增改操作时,可以考虑使用差分数组~</p>
<p>数组<code>a  = [1,2,3,4,5]</code>转换为差分数组则为<code>diff=[1,1,1,1,1]</code>,其中diff[0]=a[0];别的则是通过<code>a[i]-a[i-1]</code>项获得的,具体构造见下方:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(n)</span></span>;<br>diff[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    diff[i] = a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure>
<p>那差分数组diff怎么变回a呢只需要第<code>i</code>项加上第<code>i-1</code>项,见下方(这里用数组b代替):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>b[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    b[i] = diff[i] + b[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那差分数组是如何发挥作用的,当面对批量对区间元素进行增改,比如我们需要对数组a的[1,3]这个区间每个元素加3(这里的区间从0开始),[0,2]每个元素减5:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>&#125;&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [i,j,val]:vec)&#123;<br>    diff[i]+=val;<br>    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n)&#123;<br>    	diff[j+<span class="hljs-number">1</span>]-=val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过修改有:<code>diff=&#123;-4,4,1,6,-2&#125;</code>,根据题意我们直接翻译出a被修改为<code>a=&#123;-4,0,1,7,5&#125;</code>,将diff还原出b有:<code>b=&#123;-4,0,1,7,5&#125;</code></p>
<p>以上,便是差分数组的概念,我们可以通过原数组经过处理得到差分数组,同时差分数组可以变换回原数组,并且对区间的操作[i,j,val],是对<code>diff[i]+=val;</code>,<code>diff[j+1]-=val;</code>,因为[i,j]的元素在变回去的时候会加到<code>diff[i]</code>上多出来的<code>val</code>,我们只需要加到<code>j</code>即可,因此在<code>j+1</code>的时候要把累加的这个val给它收回去,则保证了只有<code>[i,j]</code>区间的数增加了<code>val</code></p>
<p>典型例题:</p>
<ul>
<li>1109 航班预定统计</li>
<li>1094 拼车</li>
</ul>
<h3 id="反转链表系列"><a class="markdownIt-Anchor" href="#反转链表系列"></a> 反转链表系列</h3>
<p>&quot;反转链表,反转链表Ⅱ,K个一组链表进行翻转&quot;这三道题目本质上是针对反转链表的层层深入,如果采用朴素的头插法进行实现,其实罗里吧嗦要写比较多的代码.因此有了这个模板系列:</p>
<p>针对反转链表,主要需要建立三个指针,<code>pre</code>,<code>cur</code>,<code>nxt</code>,用以进行反转,最终返回<code>pre</code>指针即可,而判断循环终止的条件是<code>cur!=nullptr</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 反转链表</span><br>ListNode* pre,*cur,*nxt;<br>pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br></code></pre></td></tr></table></figure>
<p>针对反转链表Ⅱ,是针对区间<code>[left,right]</code>进行的反转,因此我们还需要一个前序节点<code>p0</code>来在left对应的节点前面,以在最后反转结束时,将区间反转的结果与链表中未进行反转的节点进行拼接.但是left如果是1,即是头节点,那么就相对麻烦,因此可以<code>new</code>1个dummy节点,这样一来整体代码就统一了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2. 反转链表Ⅱ</span><br>ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>ListNode* p0 = dummy;<br>ListNode* pre = <span class="hljs-literal">nullptr</span>,*cur,*nxt;<br><span class="hljs-keyword">int</span> sz = right - sz + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">1</span>)&#123;<br>    p0 = p0-&gt;next;<br>    left--;<br>&#125;<br>cur = p0-&gt;next;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br>p0-&gt;next-&gt;next = cur;<br>p0-&gt;next = pre;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br></code></pre></td></tr></table></figure>
<p>针对K个一组链表进行反转,实际上就是在上面的反转链表Ⅱ的基础上,①每次需要满足剩余节点大于K才可以进行反转;②并且p0应该指向的是下一个cur的前序节点(原先就是p0-&gt;next指向的那个点),你得后面给p0指回去.把这两点满足了这题就出来了</p>
<p>典型套题:</p>
<ul>
<li></li>
</ul>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<p>滑动窗口常见于字符串匹配一类的题目,通常暴力求解会遇到TLE的问题,因此需要借助滑动窗口这一算法思想来实现</p>
<p><strong>滑动窗口本质上是左右指针,通过右端的指针不断扩张,直至满足一定条件,再经由左端的指针不断收缩,收缩到一定条件,则继续右端指针扩张,循环往复,直至右端指针越了字串的界</strong></p>
<p>右端指针扩张的过程,可以看作是正在寻找可行解,<strong>当满足可行解的条件,则停止扩展</strong>,通过左端指针收缩,来<strong>优化可行解,寻找到当前小区间里的局部最优解</strong>,当不再满足可行解的条件,则不再收缩,而是还给右端指针继续扩张.如此遍历完整个数组,我们便在局部最优解中挑选出了全局最优解(<mark>有些题目是要找全局最优解,有些是要收集所有符合条件的解,因题而异,这里只是说一种思想</mark>)</p>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s,string t)</span></span>&#123;<br>    <span class="hljs-comment">// need表示需要满足的条件,window表示的是滑动窗口内的数据</span><br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; need,window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)<br>        need[c]++;<br>    <span class="hljs-comment">// 左右指针,左闭右开[left,right)</span><br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// valid表示符合要求的字符数目,比如t=&quot;aabc&quot;; need = &#123;&#123;&#x27;a&#x27;,2&#125;,&#123;&#x27;b&#x27;,1&#125;,&#123;&#x27;c&#x27;,1&#125;&#125;;</span><br>    <span class="hljs-comment">// 则当&#x27;a&#x27;的数目window中收集满了2个,才会给valid自增(后续还可能收集到a,且没有达到进入收缩区间的条件,即a的数目&gt;=2),因此当valid数目和need.size()相等时,则表明t中的字符都在我们的滑动区间里,且可能是&quot;aaabaababc&quot;的形式,则需要收缩区间,找到符合题意的!</span><br>    <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 1.对c处理,怎么个扩张法</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-comment">/* 2.满足条件,开始收缩*/</span>)&#123;<br>            <span class="hljs-comment">// 3.怎么更新局部最优解</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 4.对d处理,怎么收缩法</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面是一个模板,在写同类型题目的时候要思考以下四个问题:</p>
<ol>
<li>
<p>右端指针扩张,怎么更新值;</p>
</li>
<li>
<p>满足什么条件开始收缩;</p>
<p>一般来说,如果是字串匹配系列的题目,我们会有两个字串,一个字串s(source)要包含另一个字串t(target),当<code>valid==need.size()</code>的时候,则说明目前滑动窗口[left,right)里面已经包含了该字串t(滑动窗口是在s上滑动的)</p>
<ul>
<li>[<strong>76-最小覆盖字串</strong>] : 目的最小覆盖,则意味着覆盖(包含)之后再收缩,并在里面更新局部最优解,收缩至不再覆盖为止,则跳出收缩.即此时的收缩条件是<code>valid == need.size()</code></li>
<li>[<strong>567-字符串的排列</strong> <strong>438-找到字符串的所有字母异位词</strong>] : 明确要找匹配到字串t的别的排列形式(即<code>t=&quot;abc&quot;</code>,s里有<code>&quot;cab&quot;</code>也满足),即意味滑动窗口里的尺寸如果比字串t大,必不满足字串t的排列,因此收缩条件应该是<code>right-left == t.size()</code>,而判断是不是满足排列(这里就不是局部最优解的问题了,因为没有最…之类的限定词),就是<code>valid==need.size()</code></li>
<li>[<strong>3-无重复字符的的最长子串</strong>] : 这个题目它只有s没有t,则不要need这个容器了,直接在滑动窗口里统计就好,当window[c]&gt;1则表明有重复的了,那就要开始收缩,直至没有重复的,此刻则需要在收缩循环的外面统计最长字串</li>
</ul>
</li>
<li>
<p>怎么更新局部最优解;(结合2看)</p>
</li>
<li>
<p>左端指针收缩,怎么更新值;</p>
</li>
</ol>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-">leetcode评论区大佬对于滑动窗口的高见</a></li>
</ul>
<p>典型例题:</p>
<ul>
<li>3 无重复字符的最长字串</li>
<li>438 找到字符串中的所有字母异位词</li>
<li>76 最小覆盖字串</li>
<li>567 字符串的排列</li>
<li>239 滑动窗口最大值(搭配单调队列食用)</li>
<li>209 长度最小的数组</li>
<li>219 存在重复元素Ⅱ</li>
<li>30 串联所有单词的子串(滑动窗口以一种技巧被应用,优化算法)</li>
<li>1004 最大连续1的个数Ⅲ</li>
</ul>
<h3 id="dp系列"><a class="markdownIt-Anchor" href="#dp系列"></a> DP系列</h3>
<h4 id="递归-记忆化搜索-递推"><a class="markdownIt-Anchor" href="#递归-记忆化搜索-递推"></a> 递归-&gt;记忆化搜索-&gt;递推</h4>
<p>对于这一类题目,比如涉及到子序列,最长递增子序列,最长上升子序列一类的问题,可以采用dp来进行思考,那如何思考出动规的状态/子问题呢?</p>
<p>我们思考的时候先按照**<u>递归</u>**的思路来思考:</p>
<p><strong>考虑最后一个索引或最前一个的索引对应的子问题</strong>,这个子问题dfs(…)的表述与所求的结果相关,比如组合数/最大值/最小值,然后根据题目类型:</p>
<ul>
<li><strong>背包/LCS</strong>,则是<strong>选和不选的问题</strong>,可以<u>定义为[0,i]这个区间的最大/最小</u>,此时这个状态需要对索引i对应的值进行选/不选的处理;</li>
<li><strong>LIS</strong>,则是<strong>枚举选哪个</strong>,可以<u>定义为以第i个索引作为结尾的最大上升子序列长度</u>,然后就是以这个索引定了区间的右端,来枚举看前面的最大上升子序列选哪个,然后计算完毕要+1,即加上以第i个索引作为结尾的长度</li>
</ul>
<p>由上则可以写出对应的<strong>子问题</strong>和<strong>转移方程</strong>(<strong>选和不选 / 枚举选哪个</strong>)</p>
<p>递归边界,递归入口则根据题目而定</p>
<p>之后可以<u><strong>采用与状态同维的<code>memo</code>用作记忆化</strong></u>,选取一个永远不会计算到的值作为初值,当它为初值则update它,下次遇到同样的状态则直接获取并return即可</p>
<p>完成了记忆化搜索后,可以**<u>通过以下方法将递归翻译成递推</u>**(就是DP):</p>
<ul>
<li>dfs -&gt; f(可能需要放缩一下,避免索引为负数)</li>
<li>递归 -&gt; 循环</li>
<li>边界 -&gt; 初值</li>
</ul>
<p><mark>空间优化暂时忽略,一般不会爆内存,不管!</mark></p>
<h4 id="背包系列"><a class="markdownIt-Anchor" href="#背包系列"></a> 背包系列</h4>
<p>在说起背包系列的问题前,先说下动规题的四大步骤:</p>
<ol>
<li><strong>确定子问题/状态</strong>,这一步需要好好分析,一般是<strong>前k个…/直到第k个…的最大/最小…</strong>,要保证<strong>无后效性</strong>,<strong>后来的结果不会影响前面的结果</strong>,可以通过叠定语或增加数组维度来实现,如果读起来自己觉得有问题的一般就是有问题;子问题是具备<strong>最优子结构</strong>的,<strong>可以通过求解子问题,最终获得原问题的解</strong>,如果奔头不是这个,那求来也没用</li>
<li><strong>推导出状态转移方程</strong>,DP具备<strong>子问题重叠</strong>的性质,也就是说状态转移方程会出现至少两个dp的某种转移的等式</li>
<li>确定初值</li>
<li>确定原问题的答案</li>
</ol>
<p>其中当涉及到多维dp的时候,遍历的顺序也是一个考虑的点,如0/1背包滚动数组版本和完全背包滚动数组版本,内嵌循环的正向遍历和倒序遍历就是这两个问题的关键区别,即取的物品可否重复</p>
<h5 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 0/1背包</h5>
<p>有一个承重为W的背包,N件物品,第i件物品对应的重量是weight[i],对应的价值是value[i],<strong>每件物品只能被取一次</strong>,问如何能使得背包的物品总价值最大?</p>
<p>遍历顺序:<mark>需要好好思考</mark>(说是先遍历物品数量,再遍历背包容量;和反过来的情况是否符合题意)</p>
<p>以二维的为例:</p>
<p><strong><code>dp[i][j]</code>表示从以<code>[0,i]</code>为下标的物品中任取,但每个物品只可以取一次,放到容量为j的背包里,所能达到的最大价值</strong>.要获得<code>dp[i][j]</code>的值可以从以下两个状态中转移过来,并取其中最大的进行转移:</p>
<ul>
<li><code>dp[i-1][j]</code>,表示<strong>不取第i个物品</strong>,不取可能是背包容量不够,也可能是此时的最大价值更大;此时的最大价值延用<code>dp[i-1][j]</code></li>
<li><code>dp[i-1][j-weights[i]] + value[i]</code>,表示<strong>取第i个物品</strong>,value[i]是第i个物品的价值,前面的一串则表示放入第i个物品的话,<br />
此时的背包(<code>j-weight[i]</code>)的最大价值是多少,以加上物品i的价值</li>
</ul>
<p><strong>本质上01背包就是选和不选问题,用回溯法来处理复杂度为O(2^n)(物品数目)</strong></p>
<p>经上面分析可以得到转移方程:</p>
<p><strong><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weights[i]] + values[i]);</code></strong></p>
<p>关于<strong>初值设置</strong>,求最大值,若物品价值都是正数,则初值置为0;若物品价值有负数,则初值置为负无穷(根据题意设置)</p>
<p>关于<strong>遍历顺序</strong>,对于二维dp来说其实遍历物品先还是遍历容量先,对于一个二维的表格来说,就是行主序列主序的那个折线图,实质无影响,因为都构建出了下一步需要的数据</p>
<p>但<strong>为了易于理解和记忆,之后关于01背包统一先遍历物品后遍历背包容量</strong></p>
<p><strong>在考虑第i个物品的加入时,是从[0,i-1]个物品任取的情况下出发考虑的,也就是说: 第i行的数据是基于第i-1行而创建的</strong></p>
<p>正因如此,所以可以把第i-1行的数据拷贝到第i行,如此的话,不如舍去i这个维度,则引出了<strong>一维的01背包dp</strong>(<strong>只是dp这个数组是一维的,实质遍历还是两层for</strong>)</p>
<p>以一维的为例:</p>
<p><strong><code>dp[j]</code>,表示容量为j的背包,所能存放的最大价值</strong></p>
<p>显然,它要么维持<code>dp[j]</code>,要么则取<code>dp[j-weights[i]] + values[i]</code>,表示为容量为j-weights[i]的背包所能获得的最大价值加上第i件物品的价值;</p>
<p>由此得出<strong>转移方程:<code>dp[j] = max(dp[j],dp[j-weights[i]] + values[i]);</code></strong></p>
<p><strong>初值选取跟二维的一样</strong></p>
<p>遍历顺序,在二维dp中,我们的背包容量是正序遍历(从小到大),但是如果这里从小到大遍历,则会存在小容量背包先更新,后面大容量背包更新时则会用到更新后的小容量背包的值,即物品被重复取了</p>
<p>因此它得<strong>倒序遍历</strong>,即<strong>从大到小遍历</strong>,这样<strong>大容量的背包用到的是上一个状态的小容量背包</strong></p>
<p>同时<strong>两个for循环也得是先物品再容量,把一个物品正确放入后,再滑到下个物品</strong>,若是先容量再物品,则存在大容量背包会取到价值最高且能放入的一个物品,因为小容量背包的状态没有更新,所以它只会取能放入自己背包的最大价值的单个物品</p>
<p>模板代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;	  <span class="hljs-comment">// 物品对应的权重</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>&#125;;	  <span class="hljs-comment">// 物品对应的价值</span><br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;					<span class="hljs-comment">// 背包容量</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 01bag problem,1-dimension</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= <span class="hljs-number">0</span>; j--)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h5>
<p>在01背包的基础上,<strong>允许重复取</strong>,也就是对于一维的01背包dp而言,<strong>正序遍历</strong>,则此时<strong>小容量的背包先更新,大容量的背包后更新,会用到更新后的小容量背包,恰好是满足无限次取(重复取),求得最大价值</strong></p>
<p>它的<strong>两个for的遍历顺序则无所谓,都可以了</strong></p>
<p>模板代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/09/18/yCZi7WxrEN2SsnJ.png" srcset="/img/loading.gif" lazyload alt="package change" /></p>
<h4 id="最长公共子序列lcs"><a class="markdownIt-Anchor" href="#最长公共子序列lcs"></a> 最长公共子序列(LCS)</h4>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></li>
</ul>
<h4 id="最长递增子序列lis"><a class="markdownIt-Anchor" href="#最长递增子序列lis"></a> 最长递增子序列(LIS)</h4>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></li>
</ul>
<h4 id="树状dp"><a class="markdownIt-Anchor" href="#树状dp"></a> 树状DP</h4>
<p><strong>树具有天然的递归性,树的问题可以拆分到树的左子树和树的右子树,这种天然的子问题的特性,很容易让我们代入DP的思想</strong></p>
<ul>
<li>
<p><strong>树的直径</strong></p>
<p>树的直径是一类DP题目(后序遍历),<strong>可以从二叉树推广到一般树</strong></p>
<p>比如你求一个树的直径(有些以边定义,有些以点定义,<u>此处以543题为例,以边定义</u>),其实就是<strong>求它的左子树的最大链和右子树的最大链,再加上左右子树与当前根节点的两条边,则为此根节点的直径</strong></p>
<p><strong>向上更新的话则更新的是链</strong>,什么意思呢?就是<strong>更新这个节点所在的链的最大值,就是左子链和右子链找到一个最大的+1,向上更新即为此节点的最大链</strong>(链是用来计算直径的!)</p>
</li>
<li></li>
<li></li>
</ul>
<p>典型例题:</p>
<ul>
<li><strong>树的直径</strong>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">2246. 相邻字符不同的最长路径</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></li>
</ul>
</li>
</ul>
<h4 id="状态机dp"><a class="markdownIt-Anchor" href="#状态机dp"></a> 状态机DP</h4>
<p>状态机DP,即通过<strong>状态机</strong>来清晰地描述一些状态转换关系,因为这些关系可能比较多,比较复杂,用状态机可以更好地描述</p>
<p>这里的典型例题是股票系列的题目,可以分为无限次交易和至多k次交易两种情况:</p>
<ul>
<li>
<p>以122题为例子,它代表了<strong>无限次交易</strong>的情形<br />
我们可以从最后一天考虑,dfs(n-1)表示到最后一天的最大利润,它是由dfs(n-2)和到第n-1天的利润决定的,那么第n-1天的利润有买入/卖出/什么也不做,而这个买入卖出又依赖于前面的,因此需要增设1个状态用以表示现在是持有股票还是未持有股票,因此可以用状态机进行表示!见下图:</p>
<img src="https://s2.loli.net/2024/10/05/TFOilYVa1yLGPrz.png" srcset="/img/loading.gif" lazyload alt="statusDP-unlimited sell" style="zoom:67%;" />
<ul>
<li><strong><code>dfs(i,0)</code>表示到第i天不持有股票最大利润;</strong></li>
<li><strong><code>dfs(i,1)</code>表示到第i天持有股票的最大利润;</strong></li>
</ul>
<p>这两个状态可以什么都不做,或发生买入/卖出,得出以下的<strong>状态转移方程</strong>:</p>
<ul>
<li><strong><code>dfs(i,0) = max(dfs(i-1,0),dfs(i-1,1)+prices[i]); // 第i天卖出</code></strong></li>
<li><strong><code>dfs(i,1) = max(dfs(i-1,1),dfs(i-1,0)-prices[i]); // 第i天买入</code></strong></li>
</ul>
<p><strong>递归边界</strong>是i&lt;0:</p>
<ul>
<li>若是未持有股票,则返回0;</li>
<li>若是持有股票,则是非法的状态,返回INT_MIN</li>
</ul>
<p><strong>递归入口</strong>:<br />
显然最后肯定不可能自己还藏一股股票,肯定卖出去利润更大,因此是<code>dfs(n-1,0)</code></p>
</li>
<li>
<p>以123,188题为例子,它代表了另一类,<strong>至多交易k次</strong>:<br />
需要<strong>加多一个状态用以表示至多允许进行j次交易</strong>,因此状态修改为:</p>
<img src="https://s2.loli.net/2024/10/05/K69fzbjt7yrANoG.png" srcset="/img/loading.gif" lazyload alt="statusDP-mostlyKth sell" style="zoom:67%;" />
<ul>
<li><strong><code>dfs(i,j,0)</code>表示至多允许j次交易,到第i天未持有股票的最大利润;</strong></li>
<li><strong><code>dfs(i,j,1)</code>表示至多允许j次交易,到第i天持有股票的最大利润;</strong></li>
</ul>
<p><strong>状态转移方程</strong>也跟上面的差不多,但是需要注意,因为限制了至多允许的交易次数,买入卖出算一次交易,因此我们可以在买入的时候修改交易次数:<br />
<code>dfs(i,j,1) = max(dfs(i-1,j,1),dfs(i-1,j-1,0)-prices[i]);</code><br />
<strong>递归入口</strong>一致,只是增加了个维度<br />
<strong>递归边界</strong>多了个j&lt;0,直接return INT_MIN即可,因为至多允许负数次交易,一听就很非法状态</p>
</li>
</ul>
<p>需要注意,这类问题加上记忆化搜索一般维度比较多,要细细做;若是翻译成递推形式,更要注意塞入头部的状态,以及从而影响到的初始值(对应递归边界)和答案(对应递归入口)的空间开辟的大小</p>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></li>
</ul>
<h4 id="区间dp"><a class="markdownIt-Anchor" href="#区间dp"></a> 区间DP</h4>
<h4 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h4>
<p>模板如下,此模板可以用于求方案数(这里是对着2376题写的),此类型的变形题可以在此模板上进行修改得到,详细内容见代码及注释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment">  子问题被表示成&quot;在第i位及其之后,在集合为mask情况下的方案数&quot;</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  is_limit用于标识当前第i位的上限,比如123,i=1表示第2位，如果is_limit是true则说明前1位选了1，那么你上限up就是2;否则是9.用此标志位规定每一位的选数的上限</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  is_num用于标识前面的数据是否选了,如果没选则为false.以123为例,如果第一位和第二位都是false,则表示第三位是: _ _ ? 在这样的情况下选的话,选的值是从1开始选的.用此标志位是为了规避前导零</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">  mask是集合的体现,主要是通过位运算体现的:mask = &#123;0,0,0,0,0,0,0,0,0,0&#125;</span><br><span class="hljs-comment">  - 当0被选了,则mask=&#123;0,0,0,0,0,0,0,0,0,1&#125;,转换为二进制的形式:0000000001(b),转换成十进制:1==1&lt;&lt;0</span><br><span class="hljs-comment">  - 当9被选了,则mask=&#123;1,0,0,0,0,0,0,0,0,0&#125;,转换为二进制的形式:1000000000(b),转换成十进制:512==1&lt;&lt;9</span><br><span class="hljs-comment">  因此可以通过判断`mask&gt;&gt;d &amp; 1 ==0 (d∈[0,9])`来判断某一数位是否已经在集合中了,为0则表示不在,通过`mask | 1&lt;&lt;d`来使得某一个数位加入集合中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-keyword">auto</span>&amp;&amp; dfs,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> mask,<span class="hljs-keyword">bool</span> is_limit,<span class="hljs-keyword">bool</span> is_num)&#123;<br>	<span class="hljs-keyword">if</span>(i == m)&#123;	<span class="hljs-comment">// m是题目所给数据的总位数    </span><br>		<span class="hljs-keyword">return</span> is_num;<br>    &#125;	<br>    <br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>  res =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!is_num)&#123;<br>        res = <span class="hljs-built_in">dfs</span>(dfs,i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> up = is_limit ? s[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">9</span>;	<span class="hljs-comment">// 当前第i位取数的上限</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d = is_num ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; d&lt;=up ; d++)&#123;<br>        <span class="hljs-keyword">if</span>( (mask &gt;&gt; d &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>            res += <span class="hljs-built_in">dfs</span>(dfs,i+<span class="hljs-number">1</span>,mask | <span class="hljs-number">1</span>&lt;&lt;d, is_limit&amp;&amp;d==up, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这种类型的题目加上记忆化搜索的话,需要注意,并不一定所有状态都要用上,就比如这一题,它的is_limit状态其实只会走一遍,is_num即前面所选数字为空也只会走一遍,因此只需要记忆:memo[i][mask]的状态即可!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></li>
</ul>
<h3 id="多路归并"><a class="markdownIt-Anchor" href="#多路归并"></a> 多路归并</h3>
<p>以丑数Ⅱ来说,所构造的丑数序列中的数,都是从2,3,5的倍数中变幻出来的,即:丑数序列:<code>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...]</code>中的数是:</p>
<ul>
<li>丑数序列中的数是2的倍数<code>1*2,2*2,3*2,4*2,5*2,...</code></li>
<li>丑数序列中的数是3的倍数<code>1*3,2*3,3*3,4*3,5*3,...</code></li>
<li>丑数序列中的数是5的倍数<code>1*5,2*5,3*5,4*5,5*5,...</code></li>
</ul>
<p><strong>是上面这三条路径经过一定规则的归并从而获得了丑数序列</strong>,针对于这道题的规则,即是丑数序列是按照升序的规则进行排列的,因此从三条路径中取数要每次取最小的,取完了这个数,你就滑到丑数序列的下一位,继续滑到该路径的最前面,跟另外两条路经的最前面的数进行对比</p>
<p>这里的意思就是:比如丑数序列初始化为:[1]对于三条路径是:</p>
<ul>
<li><code>1*2</code>; (这里的1是通过指向丑数序列第0位的索引得到的)</li>
<li><code>1*3</code></li>
<li><code>1*5</code></li>
</ul>
<p>找出最小的放入丑数序列并滑动,则变为:<code>[1,2]</code></p>
<ul>
<li><code>2*2</code>(滑动到丑数序列的下一位索引1,对应丑数是2)</li>
<li><code>1*3</code> (上次的数你不是最小的,你没滑动,保持原样)</li>
<li><code>1*5</code></li>
</ul>
<p>而针对于比如373题这种两个数组<code>nums1</code>和<code>nums2</code>,比如<code>nums1</code>是m,<code>nums2</code>是n,从俩数组对应的组合出m*n个数,从这里取第k个最小的,而<code>nums1</code>,<code>nums2</code>又是升序排列的,显然这些个数可以看作是m条路径,每个路径首先取自己的数(就是<code>nums1</code>对应的)和<code>nums2</code>的第0位;然后依据规则:取最小的,而后弹出最小的数,最小的数后面的数顶上来,假设当前最小的数是第i条路径产生的,则下一个数就是第i条路径的[i,1];由此取数即可</p>
<p>当然后面这个题目相对于丑数Ⅱ的题目而言不是固定的路径数,因此不可以通过具体的多少个指针来滑动,可以结合优先队列一起做~</p>
<p>综上,个人总结的多路归并是:<strong>题目所要求的结果可以通过多条路径经过一定规则的归并而获得某一个具体的序列,序列中的某个数,是题目所求的</strong>,则可以采用多路归并+优先队列的思想来做</p>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数Ⅱ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的k对数字</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786.第k个最小的质数分数</a></li>
<li>23 合并K个升序链表</li>
</ul>
<h3 id="dijkstra-单源最短距离"><a class="markdownIt-Anchor" href="#dijkstra-单源最短距离"></a> dijkstra-单源最短距离</h3>
<p>dijkstra算法是用与寻求单个源点到所有顶点的最短路径,或者说是最短耗时(因题而异,但是都是求最短的~)</p>
<p>这里提供一种利用优先队列来使用dj算法的模板,其中,dj算法如果只用求最短路径,就只需要</p>
<ul>
<li><strong><code>adjacency</code></strong> 邻接矩阵</li>
<li><strong><code>dist</code></strong> 用以表示<strong>源点到所有顶点的最短距离</strong>的数组</li>
<li><strong><code>pq</code></strong> 优先队列,一般求最短最少一类的,用的是<code>greater&lt;&gt;</code>这个比较类型,即小顶堆,一般的参数类型选用<code>pair&lt;int,int&gt;</code>,<strong>first是最短距离,second表示的是某一个结点</strong></li>
</ul>
<p>当需要打印出源点到某一点的最短距离所经过的点时,可以借助</p>
<ul>
<li><strong><code>prev</code></strong> 数组,用于统计每个节点的前序节点</li>
</ul>
<p>以下是很粗糙的模板(<mark>后续看需不需要改一下</mark>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// start表示起始点; n表示顶点个数; paths表示边的关系,内含&lt;u,v&gt;=w;</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n,INT_MAX)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;paths.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">auto</span> vec = paths[i];<br>    <span class="hljs-keyword">int</span> u = vec[<span class="hljs-number">0</span>], v = vec[<span class="hljs-number">1</span>], w = vec[<span class="hljs-number">2</span>];<br>    adjacency[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>&#125;<br>dist[start]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,start&#125;); <span class="hljs-comment">// 表示从start到start最短距离是0</span><br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-keyword">auto</span> [cost,u] = pq.<span class="hljs-built_in">top</span>();<br>    pq.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(cost&gt;dist[u])<br>        <span class="hljs-keyword">continue</span>;<br>   	<span class="hljs-keyword">while</span>(<span class="hljs-keyword">auto</span>&amp; [v,w]:adjacency[u])&#123;<br>        <span class="hljs-keyword">int</span> newCost = cost + w;<br>        <span class="hljs-keyword">if</span>(newCost&lt;dist[v])&#123;<br>            dist[v] = newCost;<br>            pq.<span class="hljs-built_in">push</span>(&#123;newCost,v&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至此就得到了一个从start到所有顶点的最短路径dist数组~</span><br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>网络上可能还充斥着另外一种写法,就是把优先队列替换成一个<code>visited</code>数组用以显示尚未处理过的节点,其实visited结合dist就是<strong>寻求尚未处理过且当前最短距离的点</strong></p><p>而优先队列本质上就隐含这一种关系:出队的是最短距离的点,如果是处理过的点,则会看是不是最小的,因为有可能先入队的并不是最短的,后续更新时一个更短的入了队,则同时它也会更早的出队,更新邻接的点的最短距离,则处理过的点存在不一定是最短距离的情况,就是    <code>auto [cost,node] = pq.top();pq.pop(); if(cost&gt;dist[node]) continue;</code>所以由于这一条件语句的设定,实际上pq寻求的也是没处理过的最短距离的点,因此visited和pq这俩二选一就好,但是用pq更方便~</p>
          </div>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/description/">743 网络延迟时间</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/description/">1514 概率最大的路径</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/DFPeFJ/description/">LCP35 电动车游城市</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">2290. 到达角落需要移除障碍物的最小数目</a> <em>可特化为01BFS</em></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a> <em>可特化为01BFS</em></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-a-safe-walk-through-a-grid/">3286. 穿越网格图的安全路径</a> <em>可特化为01BFS</em></li>
</ul>
<h3 id="floyd-多源最短距离"><a class="markdownIt-Anchor" href="#floyd-多源最短距离"></a> floyd-多源最短距离</h3>
<p>构建一个矩阵<code>vector&lt;vector&lt;int&gt;&gt; adjacency(n,vector&lt;int&gt;(n,INF))</code>(大概长这样,一开始假设都不可达,就是INF远嘛),通过已有的距离更新这个阵(就是直接相邻的点,邻接点嘛),然后利用松弛的思想,就是<code>a-&gt;c</code>顶点a到顶点c的距离,可能是这样最近,也可能是<code>a-&gt;b-&gt;c</code>,先途径顶点b再到达顶点c会更快,通过一个min即可比较出来,如何进行n个点的松弛呢</p>
<p>对一个二维阵操作,需要两重for,再进行n个点的松弛,显然需要套多一层循环,即三重循环可以完成</p>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            adjacency[i][j] = <span class="hljs-built_in">min</span>(adjacency[i][j],adjacency[i][k] + adjacency[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型例题</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/description/">399 除法求值</a></li>
</ul>
<h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3>
<p>并查集它的名字指示了它的功能:支持合并(union)以及查找(find)功能的集合</p>
<p>集合用树来表示,许多集合即许多树构成了森林.当然如果真的整个树形结构蛮麻烦的,因此都是转成数组来处理</p>
<p>我们可以对这些集合中的元素进行如下操作:</p>
<ul>
<li>该元素所属的集合(即这个元素所属哪一棵树,树用其根来代表);</li>
<li>查看两个元素是否属于一个集合(这俩元素是否是一棵树上,即根节点是否相同);</li>
<li>合并两个集合(让其中一棵树的根节点指向另一棵树的根节点);</li>
</ul>
<p>主要思想:通过一个数组<code>vector&lt;int&gt; parent</code>来使得数组中的元素指向它们所属树的父节点,一开始的时候各自以自己为父节点,且只有自己这个节点,此时父节点等于元素本身,即体现了它是根节点.通过:<code>iota(parent.begin(),parent.end(),0);</code>初始化,然后通过模板下的<code>_union</code>操作可以使得两棵树合并成一棵树,这时会找到某一元素的根节点,修改该元素所属父节点的指向,则此时<code>parent[rootx]</code>这棵树就指向了以<code>rooty</code>为根的树,如此操作可以使得想合并的元素给它弄到一颗树上.树的总数则可以通过遍历<code>parent</code>数组,利用<code>x==parent[x]</code>则<code>cnt++;</code>来统计树的总数</p>
<p>因为存在层数/节点数目太多导致效率变低,可以借助如<code>vector&lt;int&gt; size</code>或是<code>vector&lt;int&gt; rank</code>来处理:</p>
<ul>
<li><code>vector&lt;int&gt; size(n,1);</code>表示以<code>i</code>为根节点的<code>size[i]</code>的元素个数,更新(unite)的时候让元素少的挂在元素多的根节点上,同时把元素少的根节点的元素吃掉;</li>
<li><code>vector&lt;int&gt; rank(n,1);</code>表示以<code>i</code>为根节点的<code>rank[i]</code>的深度,更新(unite)的时候让深度小的挂在深度大的根节点上,如果深度相等,则深度需要+1;</li>
<li><code>int setCount;</code>初始化为n,表示有n个集合,合并的时候setCount自减,该变量用来表示这个并查集里的连通分量的个数;</li>
</ul>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unionFindSet</span>&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> n;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unionFindSet</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n))&#123;<br>        <span class="hljs-comment">// 初始化,使得每个节点以自己为根节点</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])&#123;<br>			parent[x] = <span class="hljs-built_in">find</span>(parent[x]);	<span class="hljs-comment">// 这里做了路径压缩,在查找的时候会修改元素的父节点,使得元素的父节点直接指向根节点,把树的高度尽量控制在2   </span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">//  不含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">no_compress_find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(x!=parent[x])&#123;<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];				<span class="hljs-comment">// 这里没有做路径压缩,直接返回根节点</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span>(rootx == rooty)<br>           	<span class="hljs-keyword">return</span>;<br>        parent[rootx] = rooty;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>注: 路径压缩的和无路径压缩的别写混了,写混了可能出现TLE,比如路径压缩那个分支条件给弄成了while,就不对了</p>
          </div>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/">547.省份数量</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/description/">684.冗余连接</a></li>
</ul>
<h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3>
<p><strong>单调栈就是具备单调性的栈</strong>即栈内元素:</p>
<ul>
<li>从栈底到栈顶呈现单调递增性的则是单调递增栈;</li>
<li>从栈底到栈顶呈现单调递减性的则是单调递减栈;</li>
</ul>
<p><strong>一般求解题目,可以转换为求解下一个更大元素,则可以利用上单调栈的方法</strong></p>
<p>那栈内存放的是元素的值吗?一般来说根据题目具体目的而定,但通常存放的是值对应的索引,因为索引包含的信息更多,比如可以求出下一个更大元素和本元素之间的索引差,乃至是最大宽度.</p>
<p>需要注意,我们这里的单调性体现在的是值上,而存在栈中的一般是索引~</p>
<p>而且单调栈的写法还分为从左到右以及从右到左,这里的左和右指的是遍历的顺序:</p>
<ul>
<li><strong>从左到右,栈内的元素还没有寻求到下一个更大元素,通过在出栈时寻求到最大元素,出栈也维护了栈内的单调性;</strong></li>
<li><strong>从右到左,栈内的元素是候选项,是当前索引到的元素的最大元素的候选项,通过出栈来维护栈内的单调性,通过栈内非空的判断来确定当前元素的最大元素;</strong></li>
</ul>
<p>经典模板:</p>
<p>从左到右:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* nums是题目输入的数据,是一个vector&lt;int&gt;的datatpye */</span><br>stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;	<span class="hljs-comment">// 初值根据题目而定</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">// 维持栈内单调性,并且进循环帮助栈顶元素找到下一个&quot;更大&quot;元素</span><br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断以维持栈内需要的单调性)&#123;<br>        <span class="hljs-keyword">int</span> idx = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans[idx] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) // 某些情况下需要的条件判断 */</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从右到左:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br> 	<span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断,以维持栈内需要的单调性)&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-comment">/*某些情况下需要一定的题目条件*/</span>)&#123;<br>        ans[i] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) 某些情况下需要的条件判断*/</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一些小技巧:</p>
<ul>
<li>在需要的时候,可以通过前后补0来避免一些corner case的编写,如84题</li>
</ul>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">496 下一个更大元素Ⅰ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">503 下一个更大元素Ⅱ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">739 每日温度</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84 柱状图中最大的矩形</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/description/">85 最大矩形</a></li>
</ul>
<h3 id="最小生成树minimal-spanning-tree"><a class="markdownIt-Anchor" href="#最小生成树minimal-spanning-tree"></a> 最小生成树(Minimal  Spanning  Tree)</h3>
<p><strong>当我们需要连接一个图中所有顶点并使得总路径开销最小时，可以使用最小生成树算法</strong></p>
<p>普通的图可能会存在环，而树不会存在，所谓的生成树，就是将图中的顶点集弄成一个连通分量，像树一样，不会有环；而最小生成树，则是生成树中，代价最小的，所谓代价可以理解为权重和,即找出权重和最小的生成树</p>
<p>有两种算法可以用来解决此类问题,一个是prim算法,一个是kruskal算法;</p>
<h4 id="prim"><a class="markdownIt-Anchor" href="#prim"></a> prim</h4>
<p>从点集的角度出发,要把原来属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的顶点全部移到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就完成了prim算法,初始的时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是所有的点的点集,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是个空集,这个点什么时候从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>呢?初始化的时候随机选一个点移入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的点到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的点的最短距离的向量,从其中选择到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最短权重/代价最少的点进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后更新这个距离向量,重复这个过程,直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空;</p>
<p>具体做法:创建好邻接矩阵<code>adjacency</code>,并且初始化好距离数组<code>vector&lt;int&gt; dist(n,INT_MAX);</code>,以及一个是否访问过的标志位数组<code>visited</code>,还有一个<code>vector&lt;int&gt; vertexNew;</code>用以记录新集合的节点数目,由这四者通过一个二重循环去<strong>更新距离</strong>,找到<strong>最近的点</strong>,<strong>打下标记</strong>,直至新集合的节点数目为<code>n</code>则说明算法完成~</p>
<p><mark>此算法只用过1次,模板不好总结</mark></p>
<h4 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> kruskal</h4>
<p>从边集的角度出发,这种方法无需创建邻接矩阵,直接用<code>vector&lt;vector&lt;int&gt;&gt;</code>或是<code>vector&lt;Edge&gt;</code>来把所有的边信息存起来,边的信息有啥呢,就像下方结构体所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>  <span class="hljs-keyword">int</span> x,y;<br>  <span class="hljs-keyword">int</span> weight;<br>  <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>  <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> _x,<span class="hljs-keyword">int</span> _y):<span class="hljs-built_in">x</span>(_x),<span class="hljs-built_in">y</span>(_y)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如上所示,两个端点,一个权重/长度(曼哈顿距离/欧式距离,具体依题意而定),构成了一条边,然后对边按照<code>weight</code>进行升序排序,挑选两个不同源(即所属根不同,也就是不同的连通分量)的点进行unite,然后把权重累加到<code>ans</code>(存储权重和的变量),如此进行,借助并查集的unite功能,合并不同的连通分量,直至得到一颗最小生成树~</p>
<p>代码模板:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span>&#123;</span><br><span class="hljs-keyword">public</span>:				<br>    <span class="hljs-keyword">int</span> n;		  <span class="hljs-comment">// 节点数目</span><br>    <span class="hljs-keyword">int</span> setCount; <span class="hljs-comment">//  连通分量数目</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <br>    <span class="hljs-built_in">UnionFindSet</span>(n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">setCount</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n)),<span class="hljs-built_in">size</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>       	<span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> x2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> root1 = <span class="hljs-built_in">find</span>(x1);<br>        <span class="hljs-keyword">int</span> root2 = <span class="hljs-built_in">find</span>(x2);<br>        <span class="hljs-keyword">if</span>(root1==root2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;		<span class="hljs-comment">// 同源</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(root1)&lt;<span class="hljs-built_in">size</span>(root2))&#123;<br>            <span class="hljs-built_in">swap</span>(root1,root2);<br>        &#125;<br>        size[root1] += size[root2];<br>        parent[root2] = root1;<br>        setCount--;				<span class="hljs-comment">// 合并了,连通分量-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,weight;<br>    <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> weight):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y),<span class="hljs-built_in">weight</span>(weight)&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br>   	<span class="hljs-comment">// n是节点数目,points是其中的关系,包括(x1,x2)以及它们之间的weight</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mst_kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; points)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = points.<span class="hljs-built_in">size</span>();	<span class="hljs-comment">// 这是边数的意思</span><br>        <span class="hljs-function">vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-comment">// 遍历points,填充边集edges</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:points)&#123;<br>            edges.<span class="hljs-built_in">push_back</span>(&#123;p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 边集排序,依据权重升序排序</span><br>        <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(),edges.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>            <span class="hljs-keyword">return</span> e1.len &lt; e2.len;<br>        &#125;);<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-function">UnionFindSet <span class="hljs-title">ufs</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">int</span> minVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:edges)&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">unite</span>(e.x,e.y))&#123;<br>                minVal+=e.len;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ufs.setCount==<span class="hljs-number">1</span>)&#123;	<span class="hljs-comment">// 只有一个连通分量则跳出</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584 连接所有点的最小费用</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/">1489 找到最小生成树里的关键边和伪关键边</a></li>
</ul>
<h3 id="st表"><a class="markdownIt-Anchor" href="#st表"></a> ※ST表</h3>
<p><strong>ST表(Sparse Table)可以用于解决RMQ(Range Maximum/Minimum Query)问题</strong>(就是区间最大最小值查询),<strong>当你需要对区间快速的进行最大最小值查询的时候,就可以用到这个数据结构</strong></p>
<div class="note note-info">
            <p>注:ST表不修改原数组信息,只负责查询区间的最大最小值</p>
          </div>
<p>这个数据结构的构建总共分为两个步骤:</p>
<ul>
<li><strong>预处理</strong> O(nlogn);</li>
<li><strong>查询</strong> O(1);</li>
</ul>
<p>在具体说之前,先说下这个算法的特色:</p>
<p>算法采用<strong>倍增</strong>思想:<strong><code>f[i][j]</code>表示<code>[i,i+2^j-1]</code>这么一个区间</strong>.啥意思呢,为啥区间长这样😲?**实际上就是以i作为区间起点,区间长度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>**的意思~</p>
<ul>
<li>
<p><strong>预处理</strong></p>
<ul>
<li>
<p><strong>初始化</strong>:<code>f[i][0]=...;</code>此时表示的区间是<code>[i,i]</code>,也即是给第i个元素赋值,显然如果有N个元素,那么这个二维数组的首个维度就要开到N;</p>
</li>
<li>
<p><strong>确定边界范围</strong>: N个元素,f的第二个维度表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>,即当前区间有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>个元素,即显然存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup><mo>&lt;</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">2^j &lt;= N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.863764em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>,取对数就有:<strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">j&lt;=floor(log2(N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></strong></p>
</li>
<li>
<p><strong>状态转移方程</strong>:(这不是DP的东东吗,实际上就是个递推的关系式)</p>
<p><strong><code>f[i][j] = max(f[i][j-1],f[i+2^(j-1)][j-1])</code></strong> (怎么这么复杂?<strong>实际上就是把一个区间[i,i+2^j-1]分成两半</strong>(两个区间)取max).</p>
<p>同时,通过<em>状态转移方程</em>和<em>边界范围</em>不难知道,我们每个起点元素<code>i</code>也对应不同的<code>j</code>,即:<strong><code>i+2^j-1&lt;=N</code></strong>;</p>
<p>那么在实施状态状态方程的时候,这个二维数组应该先遍历i还是j呢?应当<strong>先遍历j,内部遍历i</strong>,因为我们是一个一个小区间取max,这样合并到<code>f[i][j]</code>这样一个大区间,然后区间内部的元素再扩增(指j变化),这个过程就像是归并排序里分而治之最后一个一个小区间往上合并的过程~</p>
</li>
</ul>
</li>
<li>
<p><strong>查询</strong></p>
<p>查询区间是<code>[l,r]</code>;</p>
<p>计算出k:  <code>k=log2(r-l+1); //这里区间是[l,r]</code>,这个k实际上用log2给它缩回去,后面用作f的第二维度来用嘛,表示一个区间的元素的个数;</p>
<p><code>f[l][k]</code> 和<code>f[r-2^k+1][k]</code>,对它俩取max,即: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(f[l][k],f[r-2^k+1][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>,就可以求出区间<code>[l,r]</code>的最大值了</p>
</li>
</ul>
<div class="note note-info">
            <p>注: 为啥max右边那个左端点是这个长长的式子呢?可以这样想<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">x+2^k-1 = r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>,则求出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">x=r+1-2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>,因为<code>f</code>的第一个维度是区间起始端点,计算好了这个端点,第二维度选k(表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>个元素),即可以从左端点到右端点r,中间有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\le r-l+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>zh这么多个元素</p><p>显然这样的max的两个区间,中间是存在重叠的,但因为是求max,所以无所谓~</p>
          </div>
<p><strong>算法模板</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;	<span class="hljs-comment">// 表示元素个数</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">31</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 第一个维度开元素个数这么多个,考虑有些题目的index_base是1而不是0,加多了1位,下面按照index_base=1的开始计算;</span><br>								       <span class="hljs-comment">// 第二个维度可以用范围算出来,比如元素个数上限是10e9,则一个区间的上限就按这个来									 	  // 算,j即为31,2^31是</span><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    cin &gt;&gt; f[i][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// 边界范围</span><br><span class="hljs-keyword">int</span> jRight = <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">log2</span>(n));<br><span class="hljs-comment">// 预处理</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=jRight;j++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=n;i++)&#123;<br>        f[i][j] = <span class="hljs-built_in">max</span>(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询[l,r]区间的最大值</span><br><span class="hljs-keyword">int</span> l,r;<br>cin &gt;&gt; l &gt;&gt; r;<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">log2</span>(r-l+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">int</span> mx = <span class="hljs-built_in">max</span>(f[l][k],f[r+<span class="hljs-number">1</span>-(<span class="hljs-number">1</span>&lt;&lt;k)][k]);<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure>
<p><strong>参考文件</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/sparse-table/">OI-WIKI-ST表</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zwfymqz/p/8581995.html">浅谈ST表</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/61z2lumk">[模板]ST表图解</a></li>
</ul>
<p><strong>典型例题</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3865">P3865</a></li>
</ul>
<h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3>
<p><strong>线段树(Segment Tree)是一种数据结构,它可以以<code>O(logn)</code>的时间复杂度,进行<u>区间修改</u>和<u>区间查询</u></strong>,是一般CSP考试中末尾两题或是leetcode周赛的题目中常见的数据结构</p>
<p>它的本质是树,但是构建一棵树来管理也太复杂了,因此简化成<strong>利用数组来管理一棵完全二叉树</strong>,在根节点的索引为1的时候,左子树的根节点为其2倍,右子树的根节点为其2倍再加1;(有的人喜欢写成<code>p&lt;&lt;1</code>和<code>p&lt;&lt;1|1</code>,其中<code>p</code>是父节点的索引)</p>
<p><strong>这一棵树<code>vector&lt;T&gt; tree</code>中的每一个元素代表的是一个范围内的数据的某一种信息,比如值的累和,最大最小值,众数等;</strong><mark>具体根据题意而定</mark></p>
<p>考虑到区间修改的时候,如果频繁的递归进行修改,很耗费时间的,因此有个<strong>懒惰标记</strong>,来延迟修改,这个过程被精简为一个函数:<strong><code>push_down()</code>意思是下放懒惰标记</strong>,同时<strong>在区间修改的末尾,需要向上更新(父节点)区间信息,因此对称地有:<code>push_up()</code>函数</strong></p>
<p>一棵线段树的构建过程分为:</p>
<ul>
<li>初始化+建树;</li>
<li>区间查询;</li>
<li>区间修改;</li>
<li><code>push_up()</code>和<code>push_down()</code>;</li>
</ul>
<p>模板如下(提供的是区间和的,具体求区间的啥信息,根据题意灵活处理~):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>   	<span class="hljs-keyword">int</span> n,n4;	<span class="hljs-comment">// n是给定的数组的元素大小,开空间要开到4倍,如果不想浪费空间可以动态开点,具体看参考文件的内容</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; tree,lazy;	<span class="hljs-comment">// tree是线段树,里面的值代表的是一个范围的所求信息,这里是区间和;lazy是懒惰标记</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt;* arr;		<span class="hljs-comment">// 用于初始化;</span><br>    <span class="hljs-keyword">int</span> root,end;			<span class="hljs-comment">// root表示起始检索的下标,这里选择1,这样左右子树都2*i,2*i+1,如果选择0,则各自还要加个1</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(vector&lt;<span class="hljs-keyword">int</span>&gt; a)&#123;<br>        n = a.<span class="hljs-built_in">size</span>();<br>        n4 = n&lt;&lt;<span class="hljs-number">2</span>;<br>        tree = vector&lt;<span class="hljs-keyword">int</span>&gt;(n4,<span class="hljs-number">0</span>);<br>        lazy = vector&lt;<span class="hljs-keyword">int</span>&gt;(n4,<span class="hljs-number">0</span>);<br>        arr = &amp;a;<br>        root =<span class="hljs-number">1</span>;<br>        end = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>,end,root);<br>        arr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 建树</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s==t)&#123;	<span class="hljs-comment">// 叶子节点,装的是数组中的确切值</span><br>            tree[p] = (*arr)[s];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;  <span class="hljs-comment">// 为啥不直接相加除呢,遇到越界的数据就会老实这么写了</span><br>        <span class="hljs-built_in">build</span>(s,mid,p*<span class="hljs-number">2</span>);	    <span class="hljs-comment">// [s,mid]区间</span><br>        <span class="hljs-built_in">build</span>(mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);	<span class="hljs-comment">// [mid+1,t]区间</span><br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br>    <span class="hljs-comment">// 向上更新</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        tree[p] = tree[p*<span class="hljs-number">2</span>] + tree[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 下放标记</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(!lazy[p] &amp;&amp; s!=t)&#123;	<span class="hljs-comment">// s!=t是因为叶子节点没得下放,它也被人update过了</span><br>            tree[p*<span class="hljs-number">2</span>] += (mid-s+<span class="hljs-number">1</span>)*lazy[p];<br>            tree[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] += (t-mid)*lazy[p];<br>            lazy[<span class="hljs-number">2</span>*p] += lazy[p];<br>            lazy[<span class="hljs-number">2</span>*p+<span class="hljs-number">1</span>] += lazy[p]; <br>            lazy[p] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 区间查询 所查询的区间是[l,r] 当前p节点所对应的区间是[s,t]</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">range_query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(l&lt;=s &amp;&amp; r&gt;=t)&#123;	<span class="hljs-comment">// [s,t]是[l,r]的一部分,直接返回tree[p]</span><br>           <span class="hljs-keyword">return</span> tree[p];<br>       &#125; <br>       <span class="hljs-comment">// 下放懒惰标记</span><br>       <span class="hljs-built_in">push_down</span>(s,t,p);<br>       <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<br>           sum+=<span class="hljs-built_in">range_query</span>(l,r,s,mid,p*<span class="hljs-number">2</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(r&gt;mid)&#123;<br>       	   sum+=<span class="hljs-built_in">range_query</span>(l,r,mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);    <br>       &#125;<br>	   <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 区间修改,这里是区间和的累加</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">range_add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> val,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;=s &amp;&amp; r&gt;=t)&#123;<br>            tree[p] += (t-s+<span class="hljs-number">1</span>)*val;	<span class="hljs-comment">// 区间更新,求和嘛,那就是这个[s,t]区间的数都加个val</span><br>            lazy[p] += val;		    <span class="hljs-comment">// 懒惰标记,表明它的修改还没有落实到左右子树,乃至更下方的节点</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 下放懒惰标记</span><br>        <span class="hljs-built_in">push_down</span>(s,t,p);<br>        <span class="hljs-keyword">int</span> mid = s + (t-s)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<br>            <span class="hljs-built_in">range_add</span>(l,r,val,s,mid,p*<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&gt;mid)&#123;<br>            <span class="hljs-built_in">range_add</span>(l,r,val,mid+<span class="hljs-number">1</span>,t,p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 向上更新</span><br>        <span class="hljs-built_in">push_up</span>(p);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>注: 此类题目灵活性高,根据题意确定区间查询的值的类型,然后还可能需要附加别的算法知识进行题意处理,例题中首个题目是洛谷的模板题,但第二个题目是leetcode的题目,里面就结合了线段树和摩尔投票的算法思想来解决问题</p><p>同时,上面的模板也相对粗糙,比如你真正丢给外面的接口,应该是只有(l,r)或者(l,r,value)的接口</p>
          </div>
<p><strong>参考文件:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/seg/">OI-WIKI-线段树</a></li>
</ul>
<p><strong>典型例题:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">P3372</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/online-majority-element-in-subarray/">1157. 子数组中占绝大多数的元素</a></li>
</ul>
<h2 id="排序系列"><a class="markdownIt-Anchor" href="#排序系列"></a> 排序系列</h2>
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3>
<p>一种<strong>选择算法</strong>,<strong>不稳定</strong>(相同值的元素的相对位置可能发生改变),<strong><code>O(nlogn)</code></strong></p>
<p><strong>堆排序步骤:</strong></p>
<ol>
<li><strong>构建大顶堆(升序排序)</strong></li>
<li><strong>根节点与末尾元素交换</strong></li>
<li><strong>在除去末尾元素的剩余元素中,重新下沉根节点,以构建大顶堆</strong></li>
</ol>
<p>重复以上步骤,直至整个序列有序</p>
<p>代码(给出的是小顶堆的构建,是降序):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 左孩子节点</span><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (child &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// 在两个孩子节点找最小的</span><br>        <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[child + <span class="hljs-number">1</span>] &lt; nums[child])<br>        &#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-comment">// 孩子节点中最小的那个比父节点还小,则这个更小的值要上浮到父节点</span><br>        <span class="hljs-keyword">if</span> (nums[child] &lt; nums[parent])<br>        &#123;<br>            <span class="hljs-comment">// swap(nums[child], nums[parent]);</span><br>            <span class="hljs-keyword">int</span> tmp = nums[child];<br>            nums[child] = nums[parent];<br>            nums[parent] = tmp;<br>            <span class="hljs-comment">// 检查孩子节点往下是不是满足小顶堆结构,因为值的上浮可能会破坏原有的小顶堆结构</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从最后一个非叶子节点开始,直至根节点;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">adjustDown</span>(nums, i, heapSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMinHeap</span>(nums, n);<br>    <span class="hljs-comment">// 交换首尾元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// swap(nums[0], nums[i]);</span><br>        <span class="hljs-keyword">int</span> tmp = nums[<span class="hljs-number">0</span>];<br>        nums[<span class="hljs-number">0</span>] = nums[i];<br>        nums[i] = tmp;<br>        <span class="hljs-comment">// 上面的交换破坏了根节点的堆结构,重新构建小顶堆</span><br>        <span class="hljs-built_in">adjustDown</span>(nums, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p><strong>大顶堆是一棵完全二叉树,每个节点的值都大于等于其左右孩子节点的值</strong>(反之小于等于的则是小顶堆,用于降序排列)</p><p><strong>完全二叉树第<code>i</code>个节点的</strong>(这里的**<code>i</code>是根据层序遍历得到的编号,从0开始**)<strong>左右孩子节点分别是<code>2*i+1</code><strong>和</strong><code>2*i+2</code></strong>(这是它的性质)</p><p>用数组表示,即有<code>arr[i] &gt;= arr[2*i+1]</code>和<code>arr[i] &gt;= arr[2*i+2]</code></p><p>也正因为完全二叉树的性质,所以整棵树可以通过简单的数组表示而非复杂的树结构</p><p>在构建堆结构的时候,我们要从最后一个非叶子节点开始,从右往左,从下往上(就是最后一个非叶子节点的编号自减1,直至根节点),对它和它的孩子节点实现交换以满足堆有序(大顶堆或小顶堆的父子节点的性质).而这个<strong>最后一个非叶子节点是通过整个数组的size除以2再减1得到(如果编号从0开始,则要-1;如果编号从1开始,则不用-1</strong>)</p>
          </div>
<p>参考资料:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解堆排序</a></p>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3>
<p><strong>核心:分治算法</strong></p>
<p><strong>稳定的<code>O(nlogn)</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 左区间的左端点,右区间的左端点</span><br>    <span class="hljs-keyword">int</span> l = left, r = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = left;<br>    <span class="hljs-comment">// 构建一个临时数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right-left+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>	<span class="hljs-comment">// l不大于左区间的右端点,r不大于右区间的右端点</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid &amp;&amp; r&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[l]&lt;nums[r])&#123;<br>            tmp[k++] = nums[l++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[r++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对区间剩余的数值搬到tmp上去</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid)&#123;<br>        tmp[k++] = nums[l++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r &lt;= right)&#123;<br>        tmp[k++] = nums[r++];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 把结果从临时数组搬运到nums中去</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=left; q&lt;=right; q++)&#123;<br>        nums[q] = tmp[q];<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">: nums - 待排序数组</span><br><span class="hljs-comment">: left - 区间左端点</span><br><span class="hljs-comment">: right - 区间右端点,即整个区间是[left,right]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(left&gt;=right)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 这里是划分区间为更小的区间</span><br>    <span class="hljs-built_in">mergeSort</span>(nums,left,mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-comment">// 这里是区间合并</span><br>    <span class="hljs-built_in">merge</span>(nums,left,mid,right);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<p><strong>核心:左右指针+分治算法</strong></p>
<p><strong>交换排序中的一种,不稳定的<code>O(nlogn)</code></strong></p>
<p>思想:根据选定的基准(一般是最初确定左指针后,左指针指向的值),将数据分为大于基准的放在右侧,小于基准的放在左侧,然后对左侧和右侧的列表分别重复上述步骤(此刻即分治),最后直至整个序列有序.</p>
<p>快速排序步骤:</p>
<ol>
<li>确定当前的左右指针,并选择基准(注意:取得是基准的索引);</li>
<li>循环,先处理右指针,右指针一直自减,除非遇到小于基准的值(得&gt;=),则暂停处理右指针,开始处理左指针;左指针一直自增,除非遇到大于(得&lt;=,之所以=是得跳过基准,不然左指针指向的不符合的就一直是基准了)基准的值,则暂停处理左指针,此刻左右指针指向的是各自均错误的值,交换,继续循环,直至左指针不再小于右指针;</li>
<li>交换基准和左指针;</li>
<li>对未排序好的左右列表进行快排</li>
</ol>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// left是左指针,right是右指针+1,即整个区间是:[left,right)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 选定基准索引</span><br>    <span class="hljs-keyword">int</span> key = left;<br>    <span class="hljs-comment">// 确定左右指针</span><br>    <span class="hljs-keyword">int</span> l = left,r=right<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;= nums[key])<br>            r--;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt;= nums[key])<br>            l++;<br>        <span class="hljs-built_in">swap</span>(nums[l],nums[r]);<br>    &#125;<br>    <span class="hljs-comment">// 把基准交换到属于它的位置,此刻索引&lt;基准的是值&lt;=它的,索引&gt;基准的是值&gt;=它的</span><br>    <span class="hljs-built_in">swap</span>(nums[l],nums[key]);<br>    <span class="hljs-keyword">if</span>(l &gt; left)<br>        <span class="hljs-built_in">quickSort</span>(nums,left,l); <span class="hljs-comment">// [left,l),其中l是基准确定的位置</span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span> &lt; right)<br>        <span class="hljs-built_in">quickSort</span>(nums,l+<span class="hljs-number">1</span>,right); <span class="hljs-comment">// [l+1,right)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="shell排序"><a class="markdownIt-Anchor" href="#shell排序"></a> shell排序</h3>
<h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3>
<p>拓扑排序是用于有向无环图(下称DAG)来生成一个线性序列,这个序列满足:</p>
<ul>
<li>序列中的每个顶点有且仅出现一次</li>
<li>在图中如果存在u到v的一条路径,那么在序列中u一定出现在v之前</li>
</ul>
<p>对于拓扑排序,经典的应用问题是AOV图(Activity Of Vertex),用于给一个活动网络进行排序,以获取其执行的序列</p>
<p>对于拓扑排序,此处采用的是BFS算法进行实现: 通过邻接矩阵装载图信息,并构建一个入度列表,对入度列表中入度为0的点,push进队列,然后依次执行如下步骤:</p>
<ul>
<li>出队,放入toplo数组</li>
<li>根据邻接矩阵找到以它作为弧尾的点,对它们的入度-1</li>
<li>若有节点入度为0,则push进队列</li>
</ul>
<p>重复以上三个步骤,则当队列为空时,说明以拓扑排序完毕</p>
<p>需要注意:拓扑排序仅针对DAG图,同时也可以利用上述方法增加一些条件来检查有向图中是否有环(有环的节点,入度无法通过上述操作减为0,但队列会跳出,即意味着toplo数组中的节点数量肯定少于图中给出的节点数量,否则的话是相等的)</p>
<p>板子代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    B</span><br><span class="hljs-comment">  /  \ </span><br><span class="hljs-comment">A      D</span><br><span class="hljs-comment">  \  /</span><br><span class="hljs-comment">   C</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> vertexNum; <span class="hljs-comment">// 顶点数</span><br>	<span class="hljs-keyword">int</span> edgeNum;   <span class="hljs-comment">// 边数</span><br>	<span class="hljs-comment">// 4 4</span><br>	cin &gt;&gt; vertexNum &gt;&gt; edgeNum;<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(vertexNum); 	<span class="hljs-comment">// 邻接矩阵		</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(vertexNum,<span class="hljs-number">0</span>)</span></span>;		   <span class="hljs-comment">// 入度列表 </span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	   A B</span><br><span class="hljs-comment">	   A C</span><br><span class="hljs-comment">	   B D</span><br><span class="hljs-comment">	   C D</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edgeNum;i++)&#123;<br>		<span class="hljs-keyword">char</span> a,b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		<span class="hljs-keyword">int</span> A;<br>		<span class="hljs-keyword">int</span> B;<br>		A = a - <span class="hljs-string">&#x27;A&#x27;</span>;<br>		B = b - <span class="hljs-string">&#x27;A&#x27;</span>;<br>		adjacency[A].<span class="hljs-built_in">push_back</span>(B);	<span class="hljs-comment">// 记录有向图的边信息&lt;a,b&gt;</span><br>		indegrees[B]++;			   <span class="hljs-comment">// b的入度增加</span><br>	&#125;	<br>	queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;  <span class="hljs-comment">// 将入度为零的点,即源点放入队列中</span><br>		<span class="hljs-keyword">if</span>(!indegrees[i])<br>			q.<span class="hljs-built_in">push</span>(i);<br>	&#125;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; toplo;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;			  <span class="hljs-comment">// BFS</span><br>		<span class="hljs-keyword">int</span> pre = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		toplo.<span class="hljs-built_in">push_back</span>(pre);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:adjacency[pre])&#123;<br>			<span class="hljs-keyword">if</span>(--indegrees[i] == <span class="hljs-number">0</span>)<br>				q.<span class="hljs-built_in">push</span>(i);<br>		&#125; <br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:toplo)&#123;<br>		<span class="hljs-keyword">char</span> c = i + <span class="hljs-number">65</span>;<br>		cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>	&#125;<br>	cout &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h2>
<h2 id="一些数据结构回顾"><a class="markdownIt-Anchor" href="#一些数据结构回顾"></a> 一些数据结构回顾</h2>
<h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3>
<p>二叉搜索树(BST)是二叉树的一个特别概念,可以理解为排了序的二叉树</p>
<p>左孩子 &lt;= 根节点 &lt;= 右孩子</p>
<p>详细可见<a target="_blank" rel="noopener" href="https://ayyha.github.io/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/">BST,AVL,B,B+,RBT</a></p>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/algorithm-learning/">algorithm learning</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/21/%E6%A8%A1%E5%9E%8B%E9%87%8F%E5%8C%96/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">模型量化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">Makefile简易使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'a350b9ea08704ac87b06dc853c4bada3'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
