

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="learn learn learn">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="learn learn learn">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-learning">
<meta property="og:url" content="http://example.com/2024/02/29/leetcode-learning/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="learn learn learn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/15/aAFU2nBLR5VY7Z8.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/20/bw56tSoifDCcrGJ.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/03/19/DApaJQ6qH4lFwG8.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/12/H6h2EdPU5xSvKrB.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/13/ZM7KdHErQTW2csP.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1649833948-arSlXd-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1649833763-BljEbP-image.png">
<meta property="og:image" content="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg">
<meta property="article:published_time" content="2024-02-29T06:01:02.000Z">
<meta property="article:modified_time" content="2024-08-31T08:32:59.430Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithm learning">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png">
  
  <title>leetcode-learning - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="leetcode-learning">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-02-29 14:01" pubdate>
        2024年2月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      76k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      238 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">leetcode-learning</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：几秒前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2>
<p>🔴 -&gt; 一般是指hard的题目,且没pass出来的,就是连暴力解法都想不到的</p>
<p>🔵 -&gt; 表示十拿九稳的题目</p>
<h2 id="c的字符数组和c的string转换以及常用函数"><a class="markdownIt-Anchor" href="#c的字符数组和c的string转换以及常用函数"></a> C的字符数组和C++的string转换以及常用函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c_s = s.<span class="hljs-built_in">c_str</span>();<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>c++中通过导入iomanip,可以用fixed来使浮点数定位(无论double d 里的值是整数浮点数,统统给它输出浮点数形式)<br />通过setprecision(n)来确定整体数字位数,若没有结合fixed使用,则代表的位数是整数位+小数位n;<mark>结合fixed使用则代表的位数是小数位n</mark></p>
          </div>
<h2 id="c一些流"><a class="markdownIt-Anchor" href="#c一些流"></a> C++一些流</h2>
<p><code>istream&amp; getline(istream&amp; is,string&amp; s,char delim)</code></p>
<ul>
<li><code>is</code>是输入流对象, 可以是<strong>标准输入cin</strong>,可以是<strong>输入文件流对象ifstream</strong>,可以是<strong>输入字符串流对象istringstream</strong>等等</li>
<li><code>s</code>存储读到的一行文本的字串</li>
<li><code>delim</code>分隔符,<strong>表示在哪个字符处停止读取,默认是<code>\n</code></strong></li>
<li>返回值是输入流对象的引用</li>
</ul>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://vcsos.com/article/pageSource/160122/20160122233408.shtml">io流,文件流,字串流</a></li>
</ul>
<h2 id="algorithm一些算法"><a class="markdownIt-Anchor" href="#algorithm一些算法"></a> algorithm一些算法</h2>
<h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3>
<p>排序算法,很经典,c++里用的是快排实现的,我们的容器可以通过如下方式使用它:</p>
<p><code>sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</code></p>
<ul>
<li>第一个参数是迭代器的起始地址</li>
<li>第二个参数是迭代器的结束地址(就是那个<code>end()</code>,结束位置的下一位)</li>
<li>第三个参数是排序规则</li>
</ul>
<p>这里主要讲自定义排序规则,<strong>默认是升序(即默认采用<code>&lt;</code>运算符进行比较,谁小谁排前面)</strong>.可以通过:</p>
<ul>
<li>
<p><strong>lambda表达式(本质上是定义一个返回值为bool的两个待比较参数的比较函数)</strong></p>
</li>
<li>
<p><strong>重载运算符</strong></p>
<p><strong>主要运用在结构体里,以指示如何对结构体里的成员进行比较</strong>,然后调用c++自带的仿函数<code>less&lt;T&gt;()</code>/<code>greater&lt;T&gt;()</code>(头文件是<code>&lt;functional&gt;</code>)来对序列中的<code>T</code>类型排序,示例如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>  <span class="hljs-comment">// 重载&gt;运算符</span><br>  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-keyword">const</span> Person&amp; other) <span class="hljs-keyword">const</span>&#123;<br>  	<span class="hljs-keyword">if</span>(score != other.score)<br>  		<span class="hljs-keyword">return</span> score &gt; other.score;<br>  	<span class="hljs-keyword">return</span> id &lt; other.id;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">// 使用greater仿函数来通过&#x27;&gt;&#x27;运算符进行比较,则会调用到Person里重载的&#x27;&gt;&#x27;运算符里的规矩来进行排序</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:people)<br>    	cout &lt;&lt; p.id &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; p.score &lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2024/05/25/wJRVXOntkojD2sx.png" srcset="/img/loading.gif" lazyload alt="cpp_functional_greater" style="zoom:80%;" />
</li>
<li>
<p><strong>仿函数</strong></p>
<p><strong>仿函数(functor)是一个类/结构体,里面重载了<code>operator()</code>,从而仿函数的对象可以像函数一样被调用,大致如下:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greater</span>&#123;</span>	<span class="hljs-comment">// 定义一个仿函数</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; x,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; y)</span></span>&#123;<br>			<span class="hljs-keyword">return</span> x&gt;y;<br>		&#125;	<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>&#125;;<br>	Greater g;	<span class="hljs-comment">// 仿函数的对象</span><br>	<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),g); <br>	<br>    <span class="hljs-comment">// 下面这种也可以,跟c++提供的仿函数greater&lt;int&gt;()一样,这里的greater是个struct</span><br>    <span class="hljs-comment">//	sort(v.begin(),v.end(),Greater());</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>以上三种方式的任一方式来实现自己的排序功能,乃至多级排序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是对vector降序排序*/</span><br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; j)-&gt;<span class="hljs-keyword">bool</span>&#123;<span class="hljs-keyword">return</span> i&gt;j;&#125;);<br></code></pre></td></tr></table></figure>
<p>可以这么理解i&gt;j就是谁大谁排前面(i是第一个参数,j是第二个参数),当然上面的也可以写成普通的函数;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*下面演示的是多级排序,对自定义结构体Person*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>&#123;</span><br>  <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">int</span> score;<br>  <span class="hljs-built_in">Person</span>():<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">score</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> _id,<span class="hljs-keyword">int</span> _score):<span class="hljs-built_in">id</span>(_id),<span class="hljs-built_in">score</span>(_score)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">people</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">int</span> scores[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        people[i].id = i + <span class="hljs-number">1</span>;<br>        people[i].score = scores[i];<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    排序规则:</span><br><span class="hljs-comment">    	1.先按分数由高到低排</span><br><span class="hljs-comment">    	2.分数相同的id小的排前面</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> Person&amp; a,<span class="hljs-keyword">const</span> Person&amp; b)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>    	<span class="hljs-keyword">if</span>(a.score != b.score)<br>            <span class="hljs-keyword">return</span> a.score &gt; b.score;<br>        <span class="hljs-keyword">return</span> a.id &lt; b.id;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/263333.htm">c++自定义sort()函数的排序方法介绍</a></li>
</ul>
<h3 id="iota"><a class="markdownIt-Anchor" href="#iota"></a> iota</h3>
<p>这是一个区间填充函数,所在头文件为<code>numeric</code>,函数原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">iota</span><span class="hljs-params">(ForwardIt first, ForwardIt last, T value)</span></span>;<br></code></pre></td></tr></table></figure>
<p>前两个参数用迭代器指定区间范围,最后的参数用来指示起始值,可以迅速的填充好一个区间,比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> size = n;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(),idx.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>); <span class="hljs-comment">// [0, ..., n-1]</span><br></code></pre></td></tr></table></figure>
<h2 id="一些stl容器回顾"><a class="markdownIt-Anchor" href="#一些stl容器回顾"></a> 一些STL容器回顾</h2>
<p>这里主要记着主要方法,后续有新的会来补充,以便于一开始训练的时候查方法,当然也会说一下不同容器/相似容器间的差别</p>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvshen/p/17839484.html">STL容器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57190374/article/details/127042161">C++常用容器介绍</a></li>
</ul>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<p>因为字符串涉及的函数非常多,且有些函数很少用,但在一些机试的时候会遇到,而且自己重写非常繁琐,因此这里记录一下一些函数,这里会混杂字符的内容</p>
<p><strong>数字,字母,大小写部分:</strong></p>
<ul>
<li><code>isalpha()</code>用于判断一个字符是否是字母</li>
<li><code>isalnum()</code>用于判断一个字符是否是字母或数字</li>
<li><code>isupper()</code>用于判断一个字符是否是大写的</li>
<li><code>islower()</code>用于判断一个字符是否是小写的</li>
<li><code>toupper()</code>将一个字符转为大写</li>
<li><code>tolower()</code>将一个字符转为小写</li>
</ul>
<p>上面的是针对字符的,源自<code>&lt;ctype.h&gt;</code></p>
<p>对于字串来说的话,导入algorithm库可有以下转换方式:</p>
<ul>
<li><strong><code>transform(s.begin().s.end(),s.begin(),::tolower)</code></strong> 转换整个字串为小写,其中第一二个参数是输入容器的起始和终止迭代器(终止不含),第三个参数是输出容器的开始迭代器,第四个参数是一元函数对象</li>
<li><strong><code>transform(s.begin(),s.end(),s.begin(),::toupper)</code></strong> 转换整个字串为大写</li>
</ul>
<p><strong>字符串和整型的转换:</strong></p>
<ul>
<li><strong><code>stoi(string,nullptr,base)</code></strong> 字串转整数,base是string的进制,比如string是二进制的,则这里就写个2,会自动做进制转换</li>
<li><strong><code>to_string(int/long/float)</code></strong> 将一个数字常量转为字符串</li>
</ul>
<p>还有一种<code>atoi()</code>,<code>itoa</code>的字串和整型的转换,但是需要注意这种针对的是字符数组,而非string</p>
<p><strong>字符串做切片</strong></p>
<ul>
<li><strong><code>substr(start,len)</code></strong> 从<code>start</code>处,切len这么长的子串,不指定len则到结尾</li>
<li><s><code>substring(start,end)</code> 从start处开始,切到end,其中不包括end索引的字符,不指定end则到结尾</s><mark>[这是java/js才有的,搞错了= =]</mark></li>
</ul>
<p><strong>初始化函数</strong></p>
<p>在结构体或者类中,需要对一些为指针的成员实现初始化(别的也尽量初始化),不然会报内存不对齐的错误,传统的C在<code>cstring</code>这个库里有**<code>memset(void* s,int c,size_t n)</code>**可以对一块内存进行初始化,如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        isEnd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意:由于<code>memset</code>是按字节对内存块进行初始化,也就是说第二个参数c只会取低八位,然后赋值给一块地址(一块地址是一字节).比如int是4字节,那如果给的c是1,就会变成<code>0x01010101</code>,每个字节分别是<code>0000 0001</code>这么一个情况,所以一般第二位填0或-1就好了,它跟那种<code>vector&lt;int&gt;v(10,5) // 十个数,每个都是5</code>不一样</p>
<div class="note note-info">
            <p>由于LeetCode检测机制更加严格，所以我们在创建节点是，还需将指针域赋值。</p><p>参考文件:<a target="_blank" rel="noopener" href="https://blog.csdn.net/Zhenyu_Coder/article/details/132273442">runtime error: member access within misaligned address(力扣最常见错误之一)</a></p>
          </div>
<h3 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h3>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4>
<ul>
<li><code>push_back()</code></li>
<li><code>emplace_back()</code></li>
</ul>
<div class="note note-info">
            <p>上面两个函数都是向容器尾部添加元素</p><p>push_back():1. 创建元素; 2. 调用移动构造函数/拷贝构造函数,将元素弄到容器中</p><p>emplace_back(): 1. 直接在容器尾部创建元素,减少了拷贝/移动的开销</p><p>其中<strong>移动构造函数</strong>和<strong>拷贝构造函数</strong>是不同的:<strong>后者是将一个已存在的对象复制到一个新的对象中;前者是将一个对象的资源移动到一个新的对象中</strong>.因为一般自己写的拷贝构造是深拷贝(为了避免浅拷贝指向同一块内存的问题)所以涉及到<strong>内存分配</strong>,而拷贝又涉及到<strong>数据复制</strong></p><p>而其中移动构造涉及到右值引用的知识,可以看看参考文件</p><p>参考文件:</p><ul><li><a target="_blank" rel="noopener" href="https://gitcode.csdn.net/65eed6611a836825ed79f6e7.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NTk3OTAyMCwiZXhwIjoxNzE3MTIwNTQyLCJpYXQiOjE3MTY1MTU3NDIsInVzZXJuYW1lIjoid2VpeGluXzQ1Mzg4MzEyIn0.NhR7qBK3BAP_eFFZfFm1NLr7JxVF3TFaKd_tDLsOZ-4">【C++11】之 emplace_back() 与 push_back() 的区别</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44355021/article/details/129369368">移动构造函数与拷贝构造函数对比</a> (未看完)</li></ul>
          </div>
<h4 id="queue容器适配器"><a class="markdownIt-Anchor" href="#queue容器适配器"></a> queue[容器适配器]</h4>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
</ul>
<div class="note note-info">
            <p>push,pop遵循FIFO</p>
          </div>
<ul>
<li><code>size()</code></li>
<li><code>empty()</code></li>
<li><code>front()</code></li>
<li><code>back()</code></li>
</ul>
<p>queue参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59068776/article/details/130549065">queue基本方法</a></p>
<h4 id="deque双端队列"><a class="markdownIt-Anchor" href="#deque双端队列"></a> deque(双端队列)</h4>
<p>相比于vector,可以更好更迅速的处理头部元素</p>
<h4 id="list双向链表"><a class="markdownIt-Anchor" href="#list双向链表"></a> list(双向链表)</h4>
<h4 id="forward_list单链表"><a class="markdownIt-Anchor" href="#forward_list单链表"></a> forward_list(单链表)</h4>
<h4 id="stack栈容器适配器"><a class="markdownIt-Anchor" href="#stack栈容器适配器"></a> stack(栈)[容器适配器]</h4>
<ul>
<li><code>push()</code> #压入</li>
<li><code>pop()</code> # 弹出</li>
<li><code>top()</code> # get栈顶</li>
<li><code>back()</code> # get栈底</li>
<li><code>empty()</code></li>
<li><code>size()</code></li>
</ul>
<p>不能通过索引遍历,用<code>while(!s.empty())</code>遍历</p>
<p>stack参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130857503">stack基本方法</a></p>
<h4 id="priority_queue优先队列容器适配器"><a class="markdownIt-Anchor" href="#priority_queue优先队列容器适配器"></a> priority_queue(优先队列)[容器适配器]</h4>
<p><strong>底层是通过堆实现的优先队列,常数时间的最大/最小元素查找,默认是大顶堆(<code>less&lt;T&gt;</code>),则最大元素位于<code>top()</code>,当调用<code>pop()</code>则会发生类似<code>adjust_down()</code>一类的内部函数的操作</strong></p>
<p>具备<strong>自动排序</strong>的特性,所以对如<strong>前k个…最大/最小</strong>的题目都很适用</p>
<p>优先队列的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,less&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq; <span class="hljs-comment">// 其中只有第一个是要具体定义的,三个分别是:元素类型,容器类型,比较函数类型</span><br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>注:这里传入的是比较函数的类型,而不是具体的对象,因此不用像sort里的加多个<code>()</code>; 这个跟自定义map的key的比较方式很相似,传的是类型而不是匿名对象</p>
          </div>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>top()</code></li>
<li><code>size()</code></li>
<li><code>empty()</code></li>
</ul>
<p>有一个比较可能会遇到的问题就是<strong>重写比较函数</strong>,这里给出一个模板:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; b)&#123;<br>    <span class="hljs-keyword">return</span> a.xxx &gt; b.xxx;					<span class="hljs-comment">//这样构造的是该规则下的小顶堆,可以按sort理解为这是降序,然后堆排序降序的话是小顶堆弄的</span><br>&#125;<br>priority_queue&lt;T,vector&lt;T&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure>
<p>这么一个模板可以重写比较规则,使得出来的大顶堆/小顶堆(也就是最大值/最小值)符合我们的需求</p>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_68278653/article/details/131015181">priority_queue</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/498045886">[C++STL] Priority Queue 介绍及源码分析</a></li>
</ul>
<h3 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h3>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4>
<p>内部是通过<strong>红黑树</strong>实现的,<strong>去重且递增</strong>(自动有序),<strong>遍历只可以通过iterator遍历</strong>,插入值是insert的方式</p>
<p><img src="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png" srcset="/img/loading.gif" lazyload alt="set方法大全" /></p>
<p>以下这俩函数是针对的容器中的数值是有序的,而set有序,故可以用:</p>
<ul>
<li><code>lower_bound()</code>:实参用个val,会找到set容器中&gt;=val的iterator,找不到就滑到<code>end()</code>了</li>
<li><code>upper_bound()</code>:实参用个val,会找到set容器中&gt;val的首个iterator,找不到就滑到<code>end()</code></li>
</ul>
<p>set参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130800542">set</a></p>
<h4 id="unordered_map"><a class="markdownIt-Anchor" href="#unordered_map"></a> unordered_map</h4>
<p>底层是通过<strong>哈希表实现的无序map</strong></p>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h4>
<ul>
<li><code>insert()</code></li>
<li><code>begin()</code></li>
<li><code>end()</code></li>
<li><code>clear()</code></li>
<li><code>count()</code> # 返回指定元素出现的次数,key唯一就是0/1</li>
<li><code>empty()</code></li>
<li><code>erase()</code> # 删除一个元素,并返回下一个元素的迭代器(使用特别注意,要承接这个return值,而不是自增)</li>
<li><code>find()</code> # 查找一个元素,找得到返回对应位置迭代器,否则滑倒<code>end()</code>去</li>
<li><code>size()</code></li>
<li><code>rbegin()</code></li>
<li><code>rend()</code></li>
<li><code>lower_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>给定元素的第一个位置</li>
<li><code>upper_bound()</code> # 返回键值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">\gt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span>给定元素的第一个位置</li>
<li><code>swap()</code> # 交换两个map</li>
</ul>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58086930/article/details/120393227">map和multimap的解释c++</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html">C++中的STL中map用法详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nntzhc/p/14606368.html">erase神奇用法!</a></li>
</ul>
<h4 id="multimap"><a class="markdownIt-Anchor" href="#multimap"></a> multimap</h4>
<p><strong>允许key重复,没有重载<code>operator[]</code>,底层红黑树</strong></p>
<ul>
<li><code>insert()</code></li>
</ul>
<div class="note note-info">
            <p>注:只可以用这个加值,不像map可以用<code>[]</code>来加值,需要注意</p>
          </div>
<h2 id="一些板子"><a class="markdownIt-Anchor" href="#一些板子"></a> 一些板子</h2>
<p>写题记录总结,并记忆一些板子,以便后期快速完成题目</p>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3>
<p><em><strong>不撞南墙不回头</strong></em></p>
<p>实现手段: 递归</p>
<p>适用于: 树,图</p>
<p>经典题目: 迷宫找通路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-comment">/*状态*/</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*递归结束条件*/</span>)&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*找寻新状态*/</span>)&#123;<br>        <span class="hljs-comment">// 定义新状态</span><br>    	<span class="hljs-keyword">if</span>(<span class="hljs-comment">/*新状态满足边界条件*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*新状态满足标志位*/</span>)&#123;<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置标志位</span><br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-comment">/*新状态*/</span>);<br>            flag[<span class="hljs-comment">/*新状态*/</span>]=...<span class="hljs-comment">// 设置为旧的flag以回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>状态是指比如迷宫里的坐标xy一类的东西</p>
          </div>
<h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h3>
<p><em><strong>像波一样,由近及外</strong></em></p>
<p>实现手段: 队列</p>
<p>适用于: 最短路径</p>
<p>因为广度优先搜索和层序遍历概念很像,这里举的模板是按着层序遍历的写的,可以在这基础上根据题意进行变通,变通版本在下面:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(node); 				<span class="hljs-comment">// 这里push的是类似于&quot;头节点&quot;或&quot;符合题目要求的!首类节点!&quot;</span><br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;			<span class="hljs-comment">// 遍历队列里的点</span><br>    <span class="hljs-comment">/*跳出条件*/</span> 			<span class="hljs-comment">// 有些题目需要设置跳出条件</span><br>    <span class="hljs-keyword">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;	<span class="hljs-comment">// 一层层的遍历,这个sz代表的是这一次波及到的点,可以从树的层序遍历和矩阵中点逐个向外扩散进行想象</span><br>		<span class="hljs-keyword">auto</span> node = q.<span class="hljs-built_in">front</span>();<br>         q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-comment">/*候选点*/</span>)&#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            	获取一个候选点</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*满足边界*/</span> &amp;&amp; <span class="hljs-comment">/*满足题意*/</span> &amp;&amp; <span class="hljs-comment">/*满足标志位*/</span>)&#123;	<span class="hljs-comment">// 筛选符合状态的点</span><br>        		flags[candidateNode] = ... 					<span class="hljs-comment">// 设置标志位</span><br>                 q.<span class="hljs-built_in">push</span>(candidateNode);						<span class="hljs-comment">// 满足条件的点加入队列中(这是下一层)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3>
<p>使用场景:原数组不变动,但需要对子数组进行频繁的累和操作,则可以构建<strong>前缀和数组</strong></p>
<p>前缀和数组即<code>prefix[i]</code>表示的是原数组nums在<code>[0,i-1]</code>这个区间的元素的累和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//	假设题目给的数组是:vector&lt;int&gt;&amp; nums</span><br><span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">int</span>* prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要多一个位置</span><br>prefix[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;	<span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;=len; i++)<br>    prefix[i] = prefix[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">... 对前缀和数据的操作,如想获得[i,j]区间的累和,则可以通过prefix[j+1] - prefix[i]获得</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> []prefix;<br></code></pre></td></tr></table></figure>
<p>典型例题:</p>
<ul>
<li>560 和为k的子数组</li>
<li>724 寻找数组的中心下标</li>
</ul>
<h3 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h3>
<p>当我们需要对一个数组的区间批量的进行数据增改操作时,可以考虑使用差分数组~</p>
<p>数组<code>a  = [1,2,3,4,5]</code>转换为差分数组则为<code>diff=[1,1,1,1,1]</code>,其中diff[0]=a[0];别的则是通过<code>a[i]-a[i-1]</code>项获得的,具体构造见下方:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">diff</span><span class="hljs-params">(n)</span></span>;<br>diff[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    diff[i] = a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure>
<p>那差分数组diff怎么变回a呢只需要第<code>i</code>项加上第<code>i-1</code>项,见下方(这里用数组b代替):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>b[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    b[i] = diff[i] + b[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那差分数组是如何发挥作用的,当面对批量对区间元素进行增改,比如我们需要对数组a的[1,3]这个区间每个元素加3(这里的区间从0开始),[0,2]每个元素减5:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;tuple&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>&#125;&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [i,j,val]:vec)&#123;<br>    diff[i]+=val;<br>    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n)&#123;<br>    	diff[j+<span class="hljs-number">1</span>]-=val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过修改有:<code>diff=&#123;-4,4,1,6,-2&#125;</code>,根据题意我们直接翻译出a被修改为<code>a=&#123;-4,0,1,7,5&#125;</code>,将diff还原出b有:<code>b=&#123;-4,0,1,7,5&#125;</code></p>
<p>以上,便是差分数组的概念,我们可以通过原数组经过处理得到差分数组,同时差分数组可以变换回原数组,并且对区间的操作[i,j,val],是对<code>diff[i]+=val;</code>,<code>diff[j+1]-=val;</code>,因为[i,j]的元素在变回去的时候会加到<code>diff[i]</code>上多出来的<code>val</code>,我们只需要加到<code>j</code>即可,因此在<code>j+1</code>的时候要把累加的这个val给它收回去,则保证了只有<code>[i,j]</code>区间的数增加了<code>val</code></p>
<p>典型例题:</p>
<ul>
<li>1109 航班预定统计</li>
<li>1094 拼车</li>
</ul>
<h3 id="反转链表系列"><a class="markdownIt-Anchor" href="#反转链表系列"></a> 反转链表系列</h3>
<p>&quot;反转链表,反转链表Ⅱ,K个一组链表进行翻转&quot;这三道题目本质上是针对反转链表的层层深入,如果采用朴素的头插法进行实现,其实罗里吧嗦要写比较多的代码.因此有了这个模板系列:</p>
<p>针对反转链表,主要需要建立三个指针,<code>pre</code>,<code>cur</code>,<code>nxt</code>,用以进行反转,最终返回<code>pre</code>指针即可,而判断循环终止的条件是<code>cur!=nullptr</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 反转链表</span><br>ListNode* pre,*cur,*nxt;<br>pre = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br></code></pre></td></tr></table></figure>
<p>针对反转链表Ⅱ,是针对区间<code>[left,right]</code>进行的反转,因此我们还需要一个前序节点<code>p0</code>来在left对应的节点前面,以在最后反转结束时,将区间反转的结果与链表中未进行反转的节点进行拼接.但是left如果是1,即是头节点,那么就相对麻烦,因此可以<code>new</code>1个dummy节点,这样一来整体代码就统一了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2. 反转链表Ⅱ</span><br>ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>ListNode* p0 = dummy;<br>ListNode* pre = <span class="hljs-literal">nullptr</span>,*cur,*nxt;<br><span class="hljs-keyword">int</span> sz = right - sz + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left&gt;<span class="hljs-number">1</span>)&#123;<br>    p0 = p0-&gt;next;<br>    left--;<br>&#125;<br>cur = p0-&gt;next;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)&#123;<br>    nxt = cur-&gt;next;<br>    cur-&gt;next = pre;<br>    pre = cur;<br>    cur = nxt;<br>&#125;<br>p0-&gt;next-&gt;next = cur;<br>p0-&gt;next = pre;<br><span class="hljs-keyword">return</span> dummy-&gt;next;<br></code></pre></td></tr></table></figure>
<p>针对K个一组链表进行反转,实际上就是在上面的反转链表Ⅱ的基础上,①每次需要满足剩余节点大于K才可以进行反转;②并且p0应该指向的是下一个cur的前序节点(原先就是p0-&gt;next指向的那个点),你得后面给p0指回去.把这两点满足了这题就出来了</p>
<p>典型套题:</p>
<ul>
<li></li>
</ul>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3>
<p>滑动窗口常见于字符串匹配一类的题目,通常暴力求解会遇到TLE的问题,因此需要借助滑动窗口这一算法思想来实现</p>
<p><strong>滑动窗口本质上是左右指针,通过右端的指针不断扩张,直至满足一定条件,再经由左端的指针不断收缩,收缩到一定条件,则继续右端指针扩张,循环往复,直至右端指针越了字串的界</strong></p>
<p>右端指针扩张的过程,可以看作是正在寻找可行解,<strong>当满足可行解的条件,则停止扩展</strong>,通过左端指针收缩,来<strong>优化可行解,寻找到当前小区间里的局部最优解</strong>,当不再满足可行解的条件,则不再收缩,而是还给右端指针继续扩张.如此遍历完整个数组,我们便在局部最优解中挑选出了全局最优解(<mark>有些题目是要找全局最优解,有些是要收集所有符合条件的解,因题而异,这里只是说一种思想</mark>)</p>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s,string t)</span></span>&#123;<br>    <span class="hljs-comment">// need表示需要满足的条件,window表示的是滑动窗口内的数据</span><br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; need,window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)<br>        need[c]++;<br>    <span class="hljs-comment">// 左右指针,左闭右开[left,right)</span><br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// valid表示符合要求的字符数目,比如t=&quot;aabc&quot;; need = &#123;&#123;&#x27;a&#x27;,2&#125;,&#123;&#x27;b&#x27;,1&#125;,&#123;&#x27;c&#x27;,1&#125;&#125;;</span><br>    <span class="hljs-comment">// 则当&#x27;a&#x27;的数目window中收集满了2个,才会给valid自增(后续还可能收集到a,且没有达到进入收缩区间的条件,即a的数目&gt;=2),因此当valid数目和need.size()相等时,则表明t中的字符都在我们的滑动区间里,且可能是&quot;aaabaababc&quot;的形式,则需要收缩区间,找到符合题意的!</span><br>    <span class="hljs-keyword">int</span> valid=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 1.对c处理,怎么个扩张法</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-comment">/* 2.满足条件,开始收缩*/</span>)&#123;<br>            <span class="hljs-comment">// 3.怎么更新局部最优解</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 4.对d处理,怎么收缩法</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面是一个模板,在写同类型题目的时候要思考以下四个问题:</p>
<ol>
<li>
<p>右端指针扩张,怎么更新值;</p>
</li>
<li>
<p>满足什么条件开始收缩;</p>
<p>一般来说,如果是字串匹配系列的题目,我们会有两个字串,一个字串s(source)要包含另一个字串t(target),当<code>valid==need.size()</code>的时候,则说明目前滑动窗口[left,right)里面已经包含了该字串t(滑动窗口是在s上滑动的)</p>
<ul>
<li>[<strong>76-最小覆盖字串</strong>] : 目的最小覆盖,则意味着覆盖(包含)之后再收缩,并在里面更新局部最优解,收缩至不再覆盖为止,则跳出收缩.即此时的收缩条件是<code>valid == need.size()</code></li>
<li>[<strong>567-字符串的排列</strong> <strong>438-找到字符串的所有字母异位词</strong>] : 明确要找匹配到字串t的别的排列形式(即<code>t=&quot;abc&quot;</code>,s里有<code>&quot;cab&quot;</code>也满足),即意味滑动窗口里的尺寸如果比字串t大,必不满足字串t的排列,因此收缩条件应该是<code>right-left == t.size()</code>,而判断是不是满足排列(这里就不是局部最优解的问题了,因为没有最…之类的限定词),就是<code>valid==need.size()</code></li>
<li>[<strong>3-无重复字符的的最长子串</strong>] : 这个题目它只有s没有t,则不要need这个容器了,直接在滑动窗口里统计就好,当window[c]&gt;1则表明有重复的了,那就要开始收缩,直至没有重复的,此刻则需要在收缩循环的外面统计最长字串</li>
</ul>
</li>
<li>
<p>怎么更新局部最优解;(结合2看)</p>
</li>
<li>
<p>左端指针收缩,怎么更新值;</p>
</li>
</ol>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-">leetcode评论区大佬对于滑动窗口的高见</a></li>
</ul>
<p>典型例题:</p>
<ul>
<li>3 无重复字符的最长字串</li>
<li>438 找到字符串中的所有字母异位词</li>
<li>76 最小覆盖字串</li>
<li>567 字符串的排列</li>
<li>239 滑动窗口最大值(搭配单调队列食用)</li>
<li>209 长度最小的数组</li>
<li>219 存在重复元素Ⅱ</li>
<li>30 串联所有单词的子串(滑动窗口以一种技巧被应用,优化算法)</li>
<li>1004 最大连续1的个数Ⅲ</li>
</ul>
<h3 id="dp背包系列"><a class="markdownIt-Anchor" href="#dp背包系列"></a> DP背包系列</h3>
<p>在说起背包系列的问题前,先说下动规题的四大步骤:</p>
<ol>
<li><strong>确定子问题/状态</strong>,这一步需要好好分析,一般是<strong>前k个…/直到第k个…的最大/最小…</strong>,要保证<strong>无后效性</strong>,<strong>后来的结果不会影响前面的结果</strong>,可以通过叠定语或增加数组维度来实现,如果读起来自己觉得有问题的一般就是有问题;子问题是具备<strong>最优子结构</strong>的,<strong>可以通过求解子问题,最终获得原问题的解</strong>,如果奔头不是这个,那求来也没用</li>
<li><strong>推导出状态转移方程</strong>,DP具备<strong>子问题重叠</strong>的性质,也就是说状态转移方程会出现至少两个dp的某种转移的等式</li>
<li>确定初值</li>
<li>确定原问题的答案</li>
</ol>
<p>其中当涉及到多维dp的时候,遍历的顺序也是一个考虑的点,如0/1背包滚动数组版本和完全背包滚动数组版本,内嵌循环的正向遍历和倒序遍历就是这两个问题的关键区别,即取的物品可否重复</p>
<h4 id="01背包"><a class="markdownIt-Anchor" href="#01背包"></a> 0/1背包</h4>
<p>有一个承重为W的背包,N件物品,第i件物品对应的重量是weight[i],对应的价值是value[i],<strong>每件物品只能被取一次</strong>,问如何能使得背包的物品总价值最大?</p>
<p>遍历顺序:<mark>需要好好思考</mark>(说是先遍历物品数量,再遍历背包容量;和反过来的情况是否符合题意)</p>
<p>以二维的为例:</p>
<p><strong><code>dp[i][j]</code>表示从以<code>[0,i]</code>为下标的物品中任取,但每个物品只可以取一次,放到容量为j的背包里,所能达到的最大价值</strong>.要获得<code>dp[i][j]</code>的值可以从以下两个状态中转移过来,并取其中最大的进行转移:</p>
<ul>
<li><code>dp[i-1][j]</code>,表示<strong>不取第i个物品</strong>,不取可能是背包容量不够,也可能是此时的最大价值更大;此时的最大价值延用<code>dp[i-1][j]</code></li>
<li><code>dp[i-1][j-weights[i]] + value[i]</code>,表示<strong>取第i个物品</strong>,value[i]是第i个物品的价值,前面的一串则表示放入第i个物品的话,<br />
此时的背包(<code>j-weight[i]</code>)的最大价值是多少,以加上物品i的价值</li>
</ul>
<p><strong>本质上01背包就是选和不选问题,用回溯法来处理复杂度为O(2^n)(物品数目)</strong></p>
<p>经上面分析可以得到转移方程:</p>
<p><strong><code>dp[i][j] = max(dp[i-1][j],dp[i-1][j-weights[i]] + values[i]);</code></strong></p>
<p>关于<strong>初值设置</strong>,求最大值,若物品价值都是正数,则初值置为0;若物品价值有负数,则初值置为负无穷(根据题意设置)</p>
<p>关于<strong>遍历顺序</strong>,对于二维dp来说其实遍历物品先还是遍历容量先,对于一个二维的表格来说,就是行主序列主序的那个折线图,实质无影响,因为都构建出了下一步需要的数据</p>
<p>但<strong>为了易于理解和记忆,之后关于01背包统一先遍历物品后遍历背包容量</strong></p>
<p><strong>在考虑第i个物品的加入时,是从[0,i-1]个物品任取的情况下出发考虑的,也就是说: 第i行的数据是基于第i-1行而创建的</strong></p>
<p>正因如此,所以可以把第i-1行的数据拷贝到第i行,如此的话,不如舍去i这个维度,则引出了<strong>一维的01背包dp</strong>(<strong>只是dp这个数组是一维的,实质遍历还是两层for</strong>)</p>
<p>以一维的为例:</p>
<p><strong><code>dp[j]</code>,表示容量为j的背包,所能存放的最大价值</strong></p>
<p>显然,它要么维持<code>dp[j]</code>,要么则取<code>dp[j-weights[i]] + values[i]</code>,表示为容量为j-weights[i]的背包所能获得的最大价值加上第i件物品的价值;</p>
<p>由此得出<strong>转移方程:<code>dp[j] = max(dp[j],dp[j-weights[i]] + values[i]);</code></strong></p>
<p><strong>初值选取跟二维的一样</strong></p>
<p>遍历顺序,在二维dp中,我们的背包容量是正序遍历(从小到大),但是如果这里从小到大遍历,则会存在小容量背包先更新,后面大容量背包更新时则会用到更新后的小容量背包的值,即物品被重复取了</p>
<p>因此它得<strong>倒序遍历</strong>,即<strong>从大到小遍历</strong>,这样<strong>大容量的背包用到的是上一个状态的小容量背包</strong></p>
<p>同时<strong>两个for循环也得是先物品再容量,把一个物品正确放入后,再滑到下个物品</strong>,若是先容量再物品,则存在大容量背包会取到价值最高且能放入的一个物品,因为小容量背包的状态没有更新,所以它只会取能放入自己背包的最大价值的单个物品</p>
<p>模板代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;	  <span class="hljs-comment">// 物品对应的权重</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>&#125;;	  <span class="hljs-comment">// 物品对应的价值</span><br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;					<span class="hljs-comment">// 背包容量</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 01bag problem,1-dimension</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = bagWeight; j &gt;= <span class="hljs-number">0</span>; j--)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="完全背包"><a class="markdownIt-Anchor" href="#完全背包"></a> 完全背包</h4>
<p>在01背包的基础上,<strong>允许重复取</strong>,也就是对于一维的01背包dp而言,<strong>正序遍历</strong>,则此时<strong>小容量的背包先更新,大容量的背包后更新,会用到更新后的小容量背包,恰好是满足无限次取(重复取),求得最大价值</strong></p>
<p>它的<strong>两个for的遍历顺序则无所谓,都可以了</strong></p>
<p>模板代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; weights = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; values = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; weights.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagWeight; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= weights[i])<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weights[i]] + values[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="多路归并"><a class="markdownIt-Anchor" href="#多路归并"></a> 多路归并</h3>
<p>以丑数Ⅱ来说,所构造的丑数序列中的数,都是从2,3,5的倍数中变幻出来的,即:丑数序列:<code>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...]</code>中的数是:</p>
<ul>
<li>丑数序列中的数是2的倍数<code>1*2,2*2,3*2,4*2,5*2,...</code></li>
<li>丑数序列中的数是3的倍数<code>1*3,2*3,3*3,4*3,5*3,...</code></li>
<li>丑数序列中的数是5的倍数<code>1*5,2*5,3*5,4*5,5*5,...</code></li>
</ul>
<p><strong>是上面这三条路径经过一定规则的归并从而获得了丑数序列</strong>,针对于这道题的规则,即是丑数序列是按照升序的规则进行排列的,因此从三条路径中取数要每次取最小的,取完了这个数,你就滑到丑数序列的下一位,继续滑到该路径的最前面,跟另外两条路经的最前面的数进行对比</p>
<p>这里的意思就是:比如丑数序列初始化为:[1]对于三条路径是:</p>
<ul>
<li><code>1*2</code>; (这里的1是通过指向丑数序列第0位的索引得到的)</li>
<li><code>1*3</code></li>
<li><code>1*5</code></li>
</ul>
<p>找出最小的放入丑数序列并滑动,则变为:<code>[1,2]</code></p>
<ul>
<li><code>2*2</code>(滑动到丑数序列的下一位索引1,对应丑数是2)</li>
<li><code>1*3</code> (上次的数你不是最小的,你没滑动,保持原样)</li>
<li><code>1*5</code></li>
</ul>
<p>而针对于比如373题这种两个数组<code>nums1</code>和<code>nums2</code>,比如<code>nums1</code>是m,<code>nums2</code>是n,从俩数组对应的组合出m*n个数,从这里取第k个最小的,而<code>nums1</code>,<code>nums2</code>又是升序排列的,显然这些个数可以看作是m条路径,每个路径首先取自己的数(就是<code>nums1</code>对应的)和<code>nums2</code>的第0位;然后依据规则:取最小的,而后弹出最小的数,最小的数后面的数顶上来,假设当前最小的数是第i条路径产生的,则下一个数就是第i条路径的[i,1];由此取数即可</p>
<p>当然后面这个题目相对于丑数Ⅱ的题目而言不是固定的路径数,因此不可以通过具体的多少个指针来滑动,可以结合优先队列一起做~</p>
<p>综上,个人总结的多路归并是:<strong>题目所要求的结果可以通过多条路径经过一定规则的归并而获得某一个具体的序列,序列中的某个数,是题目所求的</strong>,则可以采用多路归并+优先队列的思想来做</p>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数Ⅱ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums">373. 查找和最小的k对数字</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786.第k个最小的质数分数</a></li>
<li>23 合并K个升序链表</li>
</ul>
<h3 id="dijkstra-单源最短距离"><a class="markdownIt-Anchor" href="#dijkstra-单源最短距离"></a> dijkstra-单源最短距离</h3>
<p>dijkstra算法是用与寻求单个源点到所有顶点的最短路径,或者说是最短耗时(因题而异,但是都是求最短的~)</p>
<p>这里提供一种利用优先队列来使用dj算法的模板,其中,dj算法如果只用求最短路径,就只需要</p>
<ul>
<li><strong><code>adjacency</code></strong> 邻接矩阵</li>
<li><strong><code>dist</code></strong> 用以表示<strong>源点到所有顶点的最短距离</strong>的数组</li>
<li><strong><code>pq</code></strong> 优先队列,一般求最短最少一类的,用的是<code>greater&lt;&gt;</code>这个比较类型,即小顶堆,一般的参数类型选用<code>pair&lt;int,int&gt;</code>,<strong>first是最短距离,second表示的是某一个结点</strong></li>
</ul>
<p>当需要打印出源点到某一点的最短距离所经过的点时,可以借助</p>
<ul>
<li><strong><code>prev</code></strong> 数组,用于统计每个节点的前序节点</li>
</ul>
<p>以下是很粗糙的模板(<mark>后续看需不需要改一下</mark>):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// start表示起始点; n表示顶点个数; paths表示边的关系,内含&lt;u,v&gt;=w;</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n,INT_MAX)</span></span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;paths.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">auto</span> vec = paths[i];<br>    <span class="hljs-keyword">int</span> u = vec[<span class="hljs-number">0</span>], v = vec[<span class="hljs-number">1</span>], w = vec[<span class="hljs-number">2</span>];<br>    adjacency[u].<span class="hljs-built_in">push_back</span>(&#123;v,w&#125;);<br>&#125;<br>dist[start]=<span class="hljs-number">0</span>;<br>priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,start&#125;); <span class="hljs-comment">// 表示从start到start最短距离是0</span><br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>    <span class="hljs-keyword">auto</span> [cost,u] = pq.<span class="hljs-built_in">top</span>();<br>    pq.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(cost&gt;dist[u])<br>        <span class="hljs-keyword">continue</span>;<br>   	<span class="hljs-keyword">while</span>(<span class="hljs-keyword">auto</span>&amp; [v,w]:adjacency[u])&#123;<br>        <span class="hljs-keyword">int</span> newCost = cost + w;<br>        <span class="hljs-keyword">if</span>(newCost&lt;dist[v])&#123;<br>            dist[v] = newCost;<br>            pq.<span class="hljs-built_in">push</span>(&#123;newCost,v&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至此就得到了一个从start到所有顶点的最短路径dist数组~</span><br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>网络上可能还充斥着另外一种写法,就是把优先队列替换成一个<code>visited</code>数组用以显示尚未处理过的节点,其实visited结合dist就是<strong>寻求尚未处理过且当前最短距离的点</strong></p><p>而优先队列本质上就隐含这一种关系:出队的是最短距离的点,如果是处理过的点,则会看是不是最小的,因为有可能先入队的并不是最短的,后续更新时一个更短的入了队,则同时它也会更早的出队,更新邻接的点的最短距离,则处理过的点存在不一定是最短距离的情况,就是    <code>auto [cost,node] = pq.top();pq.pop(); if(cost&gt;dist[node]) continue;</code>所以由于这一条件语句的设定,实际上pq寻求的也是没处理过的最短距离的点,因此visited和pq这俩二选一就好,但是用pq更方便~</p>
          </div>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/network-delay-time/description/">743 网络延迟时间</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-probability/description/">1514 概率最大的路径</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/DFPeFJ/description/">LCP35 电动车游城市</a></li>
</ul>
<h3 id="floyd-多源最短距离"><a class="markdownIt-Anchor" href="#floyd-多源最短距离"></a> floyd-多源最短距离</h3>
<p>构建一个矩阵<code>vector&lt;vector&lt;int&gt;&gt; adjacency(n,vector&lt;int&gt;(n,INF))</code>(大概长这样,一开始假设都不可达,就是INF远嘛),通过已有的距离更新这个阵(就是直接相邻的点,邻接点嘛),然后利用松弛的思想,就是<code>a-&gt;c</code>顶点a到顶点c的距离,可能是这样最近,也可能是<code>a-&gt;b-&gt;c</code>,先途径顶点b再到达顶点c会更快,通过一个min即可比较出来,如何进行n个点的松弛呢</p>
<p>对一个二维阵操作,需要两重for,再进行n个点的松弛,显然需要套多一层循环,即三重循环可以完成</p>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            adjacency[i][j] = <span class="hljs-built_in">min</span>(adjacency[i][j],adjacency[i][k] + adjacency[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型例题</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/description/">399 除法求值</a></li>
</ul>
<h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3>
<p>并查集它的名字指示了它的功能:支持合并(union)以及查找(find)功能的集合</p>
<p>集合用树来表示,许多集合即许多树构成了森林.当然如果真的整个树形结构蛮麻烦的,因此都是转成数组来处理</p>
<p>我们可以对这些集合中的元素进行如下操作:</p>
<ul>
<li>该元素所属的集合(即这个元素所属哪一棵树,树用其根来代表);</li>
<li>查看两个元素是否属于一个集合(这俩元素是否是一棵树上,即根节点是否相同);</li>
<li>合并两个集合(让其中一棵树的根节点指向另一棵树的根节点);</li>
</ul>
<p>主要思想:通过一个数组<code>vector&lt;int&gt; parent</code>来使得数组中的元素指向它们所属树的父节点,一开始的时候各自以自己为父节点,且只有自己这个节点,此时父节点等于元素本身,即体现了它是根节点.通过:<code>iota(parent.begin(),parent.end(),0);</code>初始化,然后通过模板下的<code>_union</code>操作可以使得两棵树合并成一棵树,这时会找到某一元素的根节点,修改该元素所属父节点的指向,则此时<code>parent[rootx]</code>这棵树就指向了以<code>rooty</code>为根的树,如此操作可以使得想合并的元素给它弄到一颗树上.树的总数则可以通过遍历<code>parent</code>数组,利用<code>x==parent[x]</code>则<code>cnt++;</code>来统计树的总数</p>
<p>因为存在层数/节点数目太多导致效率变低,可以借助如<code>vector&lt;int&gt; size</code>或是<code>vector&lt;int&gt; rank</code>来处理:</p>
<ul>
<li><code>vector&lt;int&gt; size(n,1);</code>表示以<code>i</code>为根节点的<code>size[i]</code>的元素个数,更新(unite)的时候让元素少的挂在元素多的根节点上,同时把元素少的根节点的元素吃掉;</li>
<li><code>vector&lt;int&gt; rank(n,1);</code>表示以<code>i</code>为根节点的<code>rank[i]</code>的深度,更新(unite)的时候让深度小的挂在深度大的根节点上,如果深度相等,则深度需要+1;</li>
<li><code>int setCount;</code>初始化为n,表示有n个集合,合并的时候setCount自减,该变量用来表示这个并查集里的连通分量的个数;</li>
</ul>
<p>模板如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unionFindSet</span>&#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> n;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unionFindSet</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n))&#123;<br>        <span class="hljs-comment">// 初始化,使得每个节点以自己为根节点</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])&#123;<br>			parent[x] = <span class="hljs-built_in">find</span>(parent[x]);	<span class="hljs-comment">// 这里做了路径压缩,在查找的时候会修改元素的父节点,使得元素的父节点直接指向根节点,把树的高度尽量控制在2   </span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">//  不含路径压缩的find</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">no_compress_find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(x!=parent[x])&#123;<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];				<span class="hljs-comment">// 这里没有做路径压缩,直接返回根节点</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span>(rootx == rooty)<br>           	<span class="hljs-keyword">return</span>;<br>        parent[rootx] = rooty;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>注: 路径压缩的和无路径压缩的别写混了,写混了可能出现TLE,比如路径压缩那个分支条件给弄成了while,就不对了</p>
          </div>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/">547.省份数量</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/description/">684.冗余连接</a></li>
</ul>
<h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3>
<p><strong>单调栈就是具备单调性的栈</strong>即栈内元素:</p>
<ul>
<li>从栈底到栈顶呈现单调递增性的则是单调递增栈;</li>
<li>从栈底到栈顶呈现单调递减性的则是单调递减栈;</li>
</ul>
<p><strong>一般求解题目,可以转换为求解下一个更大元素,则可以利用上单调栈的方法</strong></p>
<p>那栈内存放的是元素的值吗?一般来说根据题目具体目的而定,但通常存放的是值对应的索引,因为索引包含的信息更多,比如可以求出下一个更大元素和本元素之间的索引差,乃至是最大宽度.</p>
<p>需要注意,我们这里的单调性体现在的是值上,而存在栈中的一般是索引~</p>
<p>而且单调栈的写法还分为从左到右以及从右到左,这里的左和右指的是遍历的顺序:</p>
<ul>
<li><strong>从左到右,栈内的元素还没有寻求到下一个更大元素,通过在出栈时寻求到最大元素,出栈也维护了栈内的单调性;</strong></li>
<li><strong>从右到左,栈内的元素是候选项,是当前索引到的元素的最大元素的候选项,通过出栈来维护栈内的单调性,通过栈内非空的判断来确定当前元素的最大元素;</strong></li>
</ul>
<p>经典模板:</p>
<p>从左到右:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* nums是题目输入的数据,是一个vector&lt;int&gt;的datatpye */</span><br>stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;	<span class="hljs-comment">// 初值根据题目而定</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">// 维持栈内单调性,并且进循环帮助栈顶元素找到下一个&quot;更大&quot;元素</span><br>    <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断以维持栈内需要的单调性)&#123;<br>        <span class="hljs-keyword">int</span> idx = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        ans[idx] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) // 某些情况下需要的条件判断 */</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从右到左:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br><span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br> 	<span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; 题目条件具体判断,以维持栈内需要的单调性)&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-comment">/*某些情况下需要一定的题目条件*/</span>)&#123;<br>        ans[i] = ...;<br>    &#125;<br>    <span class="hljs-comment">/* if(...) 某些情况下需要的条件判断*/</span><br>    st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一些小技巧:</p>
<ul>
<li>在需要的时候,可以通过前后补0来避免一些corner case的编写,如84题</li>
</ul>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/description/">496 下一个更大元素Ⅰ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">503 下一个更大元素Ⅱ</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">739 每日温度</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/">84 柱状图中最大的矩形</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/description/">85 最大矩形</a></li>
</ul>
<h3 id="最小生成树minimal-spanning-tree"><a class="markdownIt-Anchor" href="#最小生成树minimal-spanning-tree"></a> 最小生成树(Minimal  Spanning  Tree)</h3>
<p><strong>当我们需要连接一个图中所有顶点并使得总路径开销最小时，可以使用最小生成树算法</strong></p>
<p>普通的图可能会存在环，而树不会存在，所谓的生成树，就是将图中的顶点集弄成一个连通分量，像树一样，不会有环；而最小生成树，则是生成树中，代价最小的，所谓代价可以理解为权重和,即找出权重和最小的生成树</p>
<p>有两种算法可以用来解决此类问题,一个是prim算法,一个是kruskal算法;</p>
<h4 id="prim"><a class="markdownIt-Anchor" href="#prim"></a> prim</h4>
<p>从点集的角度出发,要把原来属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的顶点全部移到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就完成了prim算法,初始的时候<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是所有的点的点集,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是个空集,这个点什么时候从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>移动到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>呢?初始化的时候随机选一个点移入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中的点到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的点的最短距离的向量,从其中选择到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最短权重/代价最少的点进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后更新这个距离向量,重复这个过程,直到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">V_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为空;</p>
<p>具体做法:创建好邻接矩阵<code>adjacency</code>,并且初始化好距离数组<code>vector&lt;int&gt; dist(n,INT_MAX);</code>,以及一个是否访问过的标志位数组<code>visited</code>,还有一个<code>vector&lt;int&gt; vertexNew;</code>用以记录新集合的节点数目,由这四者通过一个二重循环去<strong>更新距离</strong>,找到<strong>最近的点</strong>,<strong>打下标记</strong>,直至新集合的节点数目为<code>n</code>则说明算法完成~</p>
<p><mark>此算法只用过1次,模板不好总结</mark></p>
<h4 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> kruskal</h4>
<p>从边集的角度出发,这种方法无需创建邻接矩阵,直接用<code>vector&lt;vector&lt;int&gt;&gt;</code>或是<code>vector&lt;Edge&gt;</code>来把所有的边信息存起来,边的信息有啥呢,就像下方结构体所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>  <span class="hljs-keyword">int</span> x,y;<br>  <span class="hljs-keyword">int</span> weight;<br>  <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>  <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> _x,<span class="hljs-keyword">int</span> _y):<span class="hljs-built_in">x</span>(_x),<span class="hljs-built_in">y</span>(_y)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如上所示,两个端点,一个权重/长度(曼哈顿距离/欧式距离,具体依题意而定),构成了一条边,然后对边按照<code>weight</code>进行升序排序,挑选两个不同源(即所属根不同,也就是不同的连通分量)的点进行unite,然后把权重累加到<code>ans</code>(存储权重和的变量),如此进行,借助并查集的unite功能,合并不同的连通分量,直至得到一颗最小生成树~</p>
<p>代码模板:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFindSet</span>&#123;</span><br><span class="hljs-keyword">public</span>:				<br>    <span class="hljs-keyword">int</span> n;		  <span class="hljs-comment">// 节点数目</span><br>    <span class="hljs-keyword">int</span> setCount; <span class="hljs-comment">//  连通分量数目</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <br>    <span class="hljs-built_in">UnionFindSet</span>(n):<span class="hljs-built_in">n</span>(n),<span class="hljs-built_in">setCount</span>(n),<span class="hljs-built_in">parent</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n)),<span class="hljs-built_in">size</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(),parent.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>       	<span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> x2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> root1 = <span class="hljs-built_in">find</span>(x1);<br>        <span class="hljs-keyword">int</span> root2 = <span class="hljs-built_in">find</span>(x2);<br>        <span class="hljs-keyword">if</span>(root1==root2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;		<span class="hljs-comment">// 同源</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span>(root1)&lt;<span class="hljs-built_in">size</span>(root2))&#123;<br>            <span class="hljs-built_in">swap</span>(root1,root2);<br>        &#125;<br>        size[root1] += size[root2];<br>        parent[root2] = root1;<br>        setCount--;				<span class="hljs-comment">// 合并了,连通分量-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,weight;<br>    <span class="hljs-built_in">Edge</span>()&#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> weight):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y),<span class="hljs-built_in">weight</span>(weight)&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br>   	<span class="hljs-comment">// n是节点数目,points是其中的关系,包括(x1,x2)以及它们之间的weight</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mst_kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; points)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = points.<span class="hljs-built_in">size</span>();	<span class="hljs-comment">// 这是边数的意思</span><br>        <span class="hljs-function">vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-comment">// 遍历points,填充边集edges</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p:points)&#123;<br>            edges.<span class="hljs-built_in">push_back</span>(&#123;p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 边集排序,依据权重升序排序</span><br>        <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(),edges.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; e2)-&gt;<span class="hljs-keyword">bool</span>&#123;<br>            <span class="hljs-keyword">return</span> e1.len &lt; e2.len;<br>        &#125;);<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-function">UnionFindSet <span class="hljs-title">ufs</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">int</span> minVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; e:edges)&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">unite</span>(e.x,e.y))&#123;<br>                minVal+=e.len;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ufs.setCount==<span class="hljs-number">1</span>)&#123;	<span class="hljs-comment">// 只有一个连通分量则跳出</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minVal;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>典型例题:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-to-connect-all-points/description/">1584 连接所有点的最小费用</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/">1489 找到最小生成树里的关键边和伪关键边</a></li>
</ul>
<h2 id="排序系列"><a class="markdownIt-Anchor" href="#排序系列"></a> 排序系列</h2>
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3>
<p>一种<strong>选择算法</strong>,<strong>不稳定</strong>(相同值的元素的相对位置可能发生改变),<strong><code>O(nlogn)</code></strong></p>
<p><strong>堆排序步骤:</strong></p>
<ol>
<li><strong>构建大顶堆(升序排序)</strong></li>
<li><strong>根节点与末尾元素交换</strong></li>
<li><strong>在除去末尾元素的剩余元素中,重新下沉根节点,以构建大顶堆</strong></li>
</ol>
<p>重复以上步骤,直至整个序列有序</p>
<p>代码(给出的是小顶堆的构建,是降序):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjustDown</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 左孩子节点</span><br>    <span class="hljs-keyword">int</span> child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (child &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// 在两个孩子节点找最小的</span><br>        <span class="hljs-keyword">if</span> (child + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; nums[child + <span class="hljs-number">1</span>] &lt; nums[child])<br>        &#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-comment">// 孩子节点中最小的那个比父节点还小,则这个更小的值要上浮到父节点</span><br>        <span class="hljs-keyword">if</span> (nums[child] &lt; nums[parent])<br>        &#123;<br>            <span class="hljs-comment">// swap(nums[child], nums[parent]);</span><br>            <span class="hljs-keyword">int</span> tmp = nums[child];<br>            nums[child] = nums[parent];<br>            nums[parent] = tmp;<br>            <span class="hljs-comment">// 检查孩子节点往下是不是满足小顶堆结构,因为值的上浮可能会破坏原有的小顶堆结构</span><br>            parent = child;<br>            child = <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums, <span class="hljs-keyword">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从最后一个非叶子节点开始,直至根节点;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (heapSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">adjustDown</span>(nums, i, heapSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMinHeap</span>(nums, n);<br>    <span class="hljs-comment">// 交换首尾元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-comment">// swap(nums[0], nums[i]);</span><br>        <span class="hljs-keyword">int</span> tmp = nums[<span class="hljs-number">0</span>];<br>        nums[<span class="hljs-number">0</span>] = nums[i];<br>        nums[i] = tmp;<br>        <span class="hljs-comment">// 上面的交换破坏了根节点的堆结构,重新构建小顶堆</span><br>        <span class="hljs-built_in">adjustDown</span>(nums, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p><strong>大顶堆是一棵完全二叉树,每个节点的值都大于等于其左右孩子节点的值</strong>(反之小于等于的则是小顶堆,用于降序排列)</p><p><strong>完全二叉树第<code>i</code>个节点的</strong>(这里的**<code>i</code>是根据层序遍历得到的编号,从0开始**)<strong>左右孩子节点分别是<code>2*i+1</code><strong>和</strong><code>2*i+2</code></strong>(这是它的性质)</p><p>用数组表示,即有<code>arr[i] &gt;= arr[2*i+1]</code>和<code>arr[i] &gt;= arr[2*i+2]</code></p><p>也正因为完全二叉树的性质,所以整棵树可以通过简单的数组表示而非复杂的树结构</p><p>在构建堆结构的时候,我们要从最后一个非叶子节点开始,从右往左,从下往上(就是最后一个非叶子节点的编号自减1,直至根节点),对它和它的孩子节点实现交换以满足堆有序(大顶堆或小顶堆的父子节点的性质).而这个<strong>最后一个非叶子节点是通过整个数组的size除以2再减1得到(如果编号从0开始,则要-1;如果编号从1开始,则不用-1</strong>)</p>
          </div>
<p>参考资料:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解堆排序</a></p>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3>
<p><strong>核心:分治算法</strong></p>
<p><strong>稳定的<code>O(nlogn)</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 左区间的左端点,右区间的左端点</span><br>    <span class="hljs-keyword">int</span> l = left, r = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> k = left;<br>    <span class="hljs-comment">// 构建一个临时数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(right-left+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>	<span class="hljs-comment">// l不大于左区间的右端点,r不大于右区间的右端点</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid &amp;&amp; r&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(nums[l]&lt;nums[r])&#123;<br>            tmp[k++] = nums[l++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            tmp[k++] = nums[r++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对区间剩余的数值搬到tmp上去</span><br>    <span class="hljs-keyword">while</span>(l &lt;= mid)&#123;<br>        tmp[k++] = nums[l++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r &lt;= right)&#123;<br>        tmp[k++] = nums[r++];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 把结果从临时数组搬运到nums中去</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=left; q&lt;=right; q++)&#123;<br>        nums[q] = tmp[q];<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">: nums - 待排序数组</span><br><span class="hljs-comment">: left - 区间左端点</span><br><span class="hljs-comment">: right - 区间右端点,即整个区间是[left,right]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(left&gt;=right)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 这里是划分区间为更小的区间</span><br>    <span class="hljs-built_in">mergeSort</span>(nums,left,mid);<br>    <span class="hljs-built_in">mergeSort</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>    <span class="hljs-comment">// 这里是区间合并</span><br>    <span class="hljs-built_in">merge</span>(nums,left,mid,right);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<p><strong>核心:左右指针+分治算法</strong></p>
<p><strong>交换排序中的一种,不稳定的<code>O(nlogn)</code></strong></p>
<p>思想:根据选定的基准(一般是最初确定左指针后,左指针指向的值),将数据分为大于基准的放在右侧,小于基准的放在左侧,然后对左侧和右侧的列表分别重复上述步骤(此刻即分治),最后直至整个序列有序.</p>
<p>快速排序步骤:</p>
<ol>
<li>确定当前的左右指针,并选择基准(注意:取得是基准的索引);</li>
<li>循环,先处理右指针,右指针一直自减,除非遇到小于基准的值(得&gt;=),则暂停处理右指针,开始处理左指针;左指针一直自增,除非遇到大于(得&lt;=,之所以=是得跳过基准,不然左指针指向的不符合的就一直是基准了)基准的值,则暂停处理左指针,此刻左右指针指向的是各自均错误的值,交换,继续循环,直至左指针不再小于右指针;</li>
<li>交换基准和左指针;</li>
<li>对未排序好的左右列表进行快排</li>
</ol>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// left是左指针,right是右指针+1,即整个区间是:[left,right)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">// 选定基准索引</span><br>    <span class="hljs-keyword">int</span> key = left;<br>    <span class="hljs-comment">// 确定左右指针</span><br>    <span class="hljs-keyword">int</span> l = left,r=right<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;= nums[key])<br>            r--;<br>        <span class="hljs-keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt;= nums[key])<br>            l++;<br>        <span class="hljs-built_in">swap</span>(nums[l],nums[r]);<br>    &#125;<br>    <span class="hljs-comment">// 把基准交换到属于它的位置,此刻索引&lt;基准的是值&lt;=它的,索引&gt;基准的是值&gt;=它的</span><br>    <span class="hljs-built_in">swap</span>(nums[l],nums[key]);<br>    <span class="hljs-keyword">if</span>(l &gt; left)<br>        <span class="hljs-built_in">quickSort</span>(nums,left,l); <span class="hljs-comment">// [left,l),其中l是基准确定的位置</span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span> &lt; right)<br>        <span class="hljs-built_in">quickSort</span>(nums,l+<span class="hljs-number">1</span>,right); <span class="hljs-comment">// [l+1,right)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="shell排序"><a class="markdownIt-Anchor" href="#shell排序"></a> shell排序</h3>
<h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3>
<p>拓扑排序是用于有向无环图(下称DAG)来生成一个线性序列,这个序列满足:</p>
<ul>
<li>序列中的每个顶点有且仅出现一次</li>
<li>在图中如果存在u到v的一条路径,那么在序列中u一定出现在v之前</li>
</ul>
<p>对于拓扑排序,经典的应用问题是AOV图(Activity Of Vertex),用于给一个活动网络进行排序,以获取其执行的序列</p>
<p>对于拓扑排序,此处采用的是BFS算法进行实现: 通过邻接矩阵装载图信息,并构建一个入度列表,对入度列表中入度为0的点,push进队列,然后依次执行如下步骤:</p>
<ul>
<li>出队,放入toplo数组</li>
<li>根据邻接矩阵找到以它作为弧尾的点,对它们的入度-1</li>
<li>若有节点入度为0,则push进队列</li>
</ul>
<p>重复以上三个步骤,则当队列为空时,说明以拓扑排序完毕</p>
<p>需要注意:拓扑排序仅针对DAG图,同时也可以利用上述方法增加一些条件来检查有向图中是否有环(有环的节点,入度无法通过上述操作减为0,但队列会跳出,即意味着toplo数组中的节点数量肯定少于图中给出的节点数量,否则的话是相等的)</p>
<p>板子代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    B</span><br><span class="hljs-comment">  /  \ </span><br><span class="hljs-comment">A      D</span><br><span class="hljs-comment">  \  /</span><br><span class="hljs-comment">   C</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">int</span> vertexNum; <span class="hljs-comment">// 顶点数</span><br>	<span class="hljs-keyword">int</span> edgeNum;   <span class="hljs-comment">// 边数</span><br>	<span class="hljs-comment">// 4 4</span><br>	cin &gt;&gt; vertexNum &gt;&gt; edgeNum;<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">adjacency</span>(vertexNum); 	<span class="hljs-comment">// 邻接矩阵		</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(vertexNum,<span class="hljs-number">0</span>)</span></span>;		   <span class="hljs-comment">// 入度列表 </span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	   A B</span><br><span class="hljs-comment">	   A C</span><br><span class="hljs-comment">	   B D</span><br><span class="hljs-comment">	   C D</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edgeNum;i++)&#123;<br>		<span class="hljs-keyword">char</span> a,b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		<span class="hljs-keyword">int</span> A;<br>		<span class="hljs-keyword">int</span> B;<br>		A = a - <span class="hljs-string">&#x27;A&#x27;</span>;<br>		B = b - <span class="hljs-string">&#x27;A&#x27;</span>;<br>		adjacency[A].<span class="hljs-built_in">push_back</span>(B);	<span class="hljs-comment">// 记录有向图的边信息&lt;a,b&gt;</span><br>		indegrees[B]++;			   <span class="hljs-comment">// b的入度增加</span><br>	&#125;	<br>	queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;  <span class="hljs-comment">// 将入度为零的点,即源点放入队列中</span><br>		<span class="hljs-keyword">if</span>(!indegrees[i])<br>			q.<span class="hljs-built_in">push</span>(i);<br>	&#125;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; toplo;<br>	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;			  <span class="hljs-comment">// BFS</span><br>		<span class="hljs-keyword">int</span> pre = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		toplo.<span class="hljs-built_in">push_back</span>(pre);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:adjacency[pre])&#123;<br>			<span class="hljs-keyword">if</span>(--indegrees[i] == <span class="hljs-number">0</span>)<br>				q.<span class="hljs-built_in">push</span>(i);<br>		&#125; <br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>&amp; i:toplo)&#123;<br>		<span class="hljs-keyword">char</span> c = i + <span class="hljs-number">65</span>;<br>		cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>	&#125;<br>	cout &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="算法总结"><a class="markdownIt-Anchor" href="#算法总结"></a> 算法总结</h2>
<h2 id="一些数据结构回顾"><a class="markdownIt-Anchor" href="#一些数据结构回顾"></a> 一些数据结构回顾</h2>
<h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3>
<p>二叉搜索树(BST)是二叉树的一个特别概念,可以理解为排了序的二叉树</p>
<p>左孩子 &lt;= 根节点 &lt;= 右孩子</p>
<p>详细可见<a target="_blank" rel="noopener" href="https://ayyha.github.io/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/">BST,AVL,B,B+,RBT</a></p>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>
<h2 id="每日一练"><a class="markdownIt-Anchor" href="#每日一练"></a> 每日一练</h2>
<h3 id="2864-最大二进制奇数"><a class="markdownIt-Anchor" href="#2864-最大二进制奇数"></a> 2864 最大二进制奇数</h3>
<h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4>
<h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4>
<h4 id="重写官方思路"><a class="markdownIt-Anchor" href="#重写官方思路"></a> 重写官方思路</h4>
<h3 id="2789-合并后数组中的最大元素"><a class="markdownIt-Anchor" href="#2789-合并后数组中的最大元素"></a> 2789 合并后数组中的最大元素</h3>
<h4 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h4>
<p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p>
<p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p>
<ul>
<li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li>
</ul>
<p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">21</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">21</span>,<span class="hljs-number">3</span>] 。<br>最终数组中的最大元素是 <span class="hljs-number">21</span> 。可以证明我们无法获得更大的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">11</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">11</span>] 。<br>最终数组中只有一个元素，即 <span class="hljs-number">11</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4>
<ol>
<li><strong>合并</strong></li>
<li><strong>找最大值</strong></li>
<li><strong>避免爆int边界</strong></li>
</ol>
<p>根据题目,我们可以知道我们会①合并满足条件的数组;②合并了之后它未必是最大值,可能有个很巨大的在一些比较奇怪的地方,比如最左边(因为中间的都会给合并,再大的都给它拼起来,但<code>nums[0]</code>就无能为力),因此我们可以在合并完,再比较一波</p>
<p>在提交的时候,原本我是利用<code>nums[i] +=nums[i+1]</code>来累加满足条件的值,但是会爆了signed int的可表达的值的边界,其实看题目的函数返回值<code>long long</code>,就知道可能有比较极端的用例会去爆了signed int的边界</p>
<p><strong>合并的方法仔细观察可以得值,从最右边往左遍历可以大数吃小数</strong>(if满足条件)</p>
<p><strong>我这里通过<code>tmp</code>来承接累加的值,当然它如果小于前面的就得给它置零,当然得跟max比一下,大的话就让max拿走了,然后最后再跟nums[0]一决高下比一比,最后返回.这里的tmp和max都是longlong类型的.</strong></p>
<p>注:以下的差距是在于我把后面的一个迭代找最大值换成了<code>max</code>和<code>nums[0]</code>比较得到的提升~</p>
<p><img src="https://s2.loli.net/2024/03/15/aAFU2nBLR5VY7Z8.jpg" srcset="/img/loading.gif" lazyload alt="maxArrayValue-effect" /></p>
<h4 id="重写官方思路-2"><a class="markdownIt-Anchor" href="#重写官方思路-2"></a> 重写官方思路</h4>
<h3 id="2684-矩阵中移动的最大次数"><a class="markdownIt-Anchor" href="#2684-矩阵中移动的最大次数"></a> 2684 矩阵中移动的最大次数</h3>
<h4 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h4>
<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>
<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p>
<ul>
<li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>
</ul>
<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：grid = [[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：可以从单元格 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 开始并且按下面的路径移动：<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span> -&gt;</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<br>可以证明这是能够移动的最大次数。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[3,2,4],[2,1,9],[1,1,7]]</span><br>输出：<span class="hljs-number">0</span><br>解释：从第一列的任一单元格开始都无法移动。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 1000</code></li>
<li><code>4 &lt;= m * n &lt;= 10^5</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 10^6</code></li>
</ul>
<h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4>
<p>当时写这道题目的时候是周六23点多吧,然后比较疲惫,也差不多三天没写题目了,有畏惧感,就没写出来,主要在纠结BFS和DFS的模板问题,大脑一直在思考BFS做层序遍历咋做的,对这道题就很烦躁,然后最后写了一种很暴力DFS的,但不知道怎么剪枝,卡在了(810/814)这个用例那,本想着用标签来表明已走过的路,但思路比较混乱,也不想写了,就直接看了答案.</p>
<p>对于此题,有一种类似BFS的做法,就是将矩阵从<code>[:,0]-&gt;[:,n-1]</code>这么来逐列遍历,然后目的是找可以走多长,最大就是<code>n</code>嘛,把右边可以走的路径点亮,然后看最远可以走到哪即可(比较抽象的描述,等等写完贴下方)</p>
<p>而对于DFS剪枝可以采用标签,还有一种针对此题,非常绝杀的:<code>grid[row][col]=0</code>当该点深搜完毕后,则给它置零!只要在我原来被卡住的代码里面加上这一句,通过并且耗时直接超了77%的人,非常恐怖的思想.细细想下来,这个设置还可以牵扯出类似动规的思想:</p>
<p>随机掉落到<code>(row,col)</code>这个点,它后面能到哪里取决于该点本身,而是否能到该点,则取决于前面的节点的值,意思即是,<code>(row,col)</code>这个点我们前面确定了是可以走的,后面它的路线其实是确定的,能走到的路也是确定的,有记载就好了,不用重复记载,因此它走完了它的路,就打一个走完的标志了,后面想要从这个点出发的点,知道了它是一个已完成的任务点,就不会走了,而设置的标志便是给它置零(因为整个数组都是正整数,置零了就走不过去了,不符合要求了),这种剪枝方法非常变态,因为是一条路径都给剪了,之后想往这走的都知道走过了,就不会走了.效率极高</p>
<p>原思路如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m,n,max;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>,row=<span class="hljs-number">0</span>,col=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(row=<span class="hljs-number">0</span>;row&lt;<span class="hljs-keyword">this</span>-&gt;m;row++)<br>            <span class="hljs-built_in">dfs</span>(grid,step,row,col);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,<span class="hljs-keyword">int</span> step,<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> col)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row<span class="hljs-number">-1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>            <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row][col+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row,col+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;m<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row+<span class="hljs-number">1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max&lt;step)<br>                <span class="hljs-keyword">this</span>-&gt;max = step;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max &lt; step)<br>            <span class="hljs-keyword">this</span>-&gt;max = step;<br>        grid[row][col]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>自写类BFS:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags; <span class="hljs-comment">//(表示是否可通行)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-comment">// 按列主序的方式遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; (flags[i][j] || j == <span class="hljs-number">0</span>))<br>                &#123;<br>                    max = max &lt; j ? j : max;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (i &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (grid[i][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; flags[i][j])<br>                    max = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>自写DFS(普通剪枝):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m, n, max;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col) -&gt; <span class="hljs-keyword">void</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (col &gt; max)<br>                max = col;<br>            <span class="hljs-keyword">if</span> (col &lt; n - <span class="hljs-number">1</span> &amp;&amp; !flags[row][col])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (row &gt; <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row - <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (grid[row][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                    <span class="hljs-built_in">dfs</span>(row, col + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (row &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 走完了所有分支，下次别走这</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 无路可走，其实可以不设这个</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m; row++)<br>            <span class="hljs-built_in">dfs</span>(row, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/20/bw56tSoifDCcrGJ.png" srcset="/img/loading.gif" lazyload alt="2684-maxMoves-flags" /></p>
<p>如果把flags去掉，换成置零，就是一个点的分支走完，然后置零，性能（时间和空间）都超过了90%的人==（有点不解，我true别人也进不来，为啥置零会快那么多）==</p>
<h4 id="重写官方思路-3"><a class="markdownIt-Anchor" href="#重写官方思路-3"></a> 重写官方思路</h4>
<p>重写了一个大佬的思路（就看了思路，代码自己写的，都通过了）</p>
<h2 id="73-矩阵置零"><a class="markdownIt-Anchor" href="#73-矩阵置零"></a> 73 矩阵置零</h2>
<h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3>
<p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br>输出：<span class="hljs-string">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(mn)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<p>当时我写的思路是暴力解法，就是用一个标记数组<code>nflags</code>标记列数，一个标记变量<code>mflags</code>标记行数，之所以这样设置标记是因为行主序的矩阵，一行里有一个是0，那就全部都是0；而列则需要逐行读的时候匹配（就是根据标记数组匹配）再置零。然后当一行全部置为0后，再把行标记变量<code>mflags</code>置否，最后根据标记数组<code>nflags</code>去重新扫一遍，避免有些列数匹配的元素没置零。</p>
<p>官方给出的方法（这里借鉴的是方法二）是采用两个标记数组来对元素为0的行列进行分别记录，然后再通过一个二重循环遍历，判断<code>row[i] || col[j]</code>来给元素置零。方法二则是在这个方法一的基础上，把两个标记数组用原矩阵的第一行和第一列来存储，而第一行和第一列的状态情况则用两个状态变量来存储，先处理除第一行和第一列外的剩余矩阵，然后再扫第一行和第一列，如果有0，则给它置零了。</p>
<h3 id="重写官方代码"><a class="markdownIt-Anchor" href="#重写官方代码"></a> 重写官方代码</h3>
<h2 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合"></a> 77 组合</h2>
<h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<p>当时写这题的时候看题目看了半天没看懂，后来才发现就是排列组合那个组合的意思，就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>的意思。想了很久，用递归写的。其中n定了边界<code>[1,n]</code>,k定了一次要拿多少个数字出来。</p>
<p>当时的想法很质朴，就比如k=2那就需要两层循环，为3就需要3层循环，就用递归写（一开始想用别的，但想了很久，没想到）。然后最初提交的版本，漏判断了一个边界条件，还有一些简单的错误，改了之后就报超时的错，通过剪枝让其pass了。</p>
<p>官方思路则感觉很套路，很模板，但又很有道理，它利用一种回溯的思想来做，就是先从简单的二进制枚举来说起，比如有一个长度为n的序列，要求其所有子序列。那么则可以用一个游标cur来在<code>[1,n]</code>这个范围内由小到大的滑动，而每一个cur指向的字符/数字，则有选和不选两种情况，选了的进递归一次，不选的进递归一次，然后当游标cur滑过了边界则将值塞进结果数组里，并return。</p>
<p>而这个题目官方管它叫组合枚举，我感觉就是多了个临时值的大小判断，就是这个临时的数组它长度到k了，就给它塞进结果数组里，并return。然后再根据可能达不到k进行剪枝就好了。</p>
<h3 id="重写官方代码-2"><a class="markdownIt-Anchor" href="#重写官方代码-2"></a> 重写官方代码</h3>
<h2 id="86-分隔链表"><a class="markdownIt-Anchor" href="#86-分隔链表"></a> 86 分隔链表</h2>
<h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[2,1]</span>, x = 2<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<p>我一开始写这道题，只看到了示例2的情况，就是当<code>head.val == x</code>，因此直接进行了分类讨论，后来写着写着发现代码冗余很多，才发现一开始思路错了。不过最后还是做了出来，虽然比较暴力和耗了很长的时间。思路是要用两个指针，来做标识，分别是<code>cur_left</code>和<code>cur_right</code>，其中需要先确定<code>cur_right</code>的位置，就是第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点的位置，因为此后要往前插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点，而<code>cur_right</code>前面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点则为<code>cur_left</code>，掌管着左边界（因为要保留原来节点们的相对位置），之后遇到的<code>&lt; x</code>的节点就往这里面插入，然后滑动<code>cur_left</code>。当遇到<code>head.val == x</code>的情况，其实已经定好了<code>cur_right</code>，就是往左增加了一个节点，要移动head和<code>cur_left</code>节点为该节点。之后则化为上面的普通情况了。</p>
<p>官方思路，我看了一下觉得很符合题目意思，又看了一下题目描述，感觉就是在暗示你，把它分成两个链表来看待。即是有两个链表，<code>small_list</code>的值都小于<code>big_list</code>的，最后需要将<code>small_list</code>末尾节点的指针指向<code>big_list</code>的头指针，而<code>big_list</code>的末尾节点的指针需要置为<code>nullptr</code>，不然可能出错。</p>
<h3 id="重写官方代码-3"><a class="markdownIt-Anchor" href="#重写官方代码-3"></a> 重写官方代码</h3>
<h2 id="43-字符串相乘"><a class="markdownIt-Anchor" href="#43-字符串相乘"></a> 43 字符串相乘</h2>
<h3 id="题目描述-7"><a class="markdownIt-Anchor" href="#题目描述-7"></a> 题目描述</h3>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p>**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>
<li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li>
<li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li>
</ul>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<p>根据题目给出的<code>m,n</code>边界可以知道,如果是最大的<code>num1</code>和最大的<code>num2</code>相乘,得到的数的指数部分是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>400</mn></msup></mrow><annotation encoding="application/x-tex">10^{400}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,即差不多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1200</mn></msup></mrow><annotation encoding="application/x-tex">2^{1200}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,显然32位的int和64位的long,都无法存下这么大的数,因此是利用字串相乘来做<strong>大数乘法</strong></p>
<p>可能太久没怎么写代码了,写这个的时候那个进位数不知道咋处理(确实很离谱😢 ),因此通过构建一个<code>vector&lt;vector&lt;int&gt;&gt; vec_res</code>这样的二维数组来给它存储,<code>vec_res.size()</code>表示的是有多少个中间值,就比如<code>123*456</code>,可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>100</mn><mo>+</mo><mn>20</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>400</mn><mo>+</mo><mn>50</mn><mo>+</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>6</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(100+20+3)*(400+50+6) = (1*10^2 + 2*10^1 + 3*10^0)* (4*10^2+5*10^1+6*10^0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>其中我们两个数值都逐位数遍历,然后系数相乘,指数相加,其中系数相乘得到的结果是最多为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>∗</mo><mn>9</mn><mo>=</mo><mn>81</mn></mrow><annotation encoding="application/x-tex">9*9=81</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">1</span></span></span></span>,就是只是向前一位进位;指数则通过<code>size()-1-i</code>来表示(<code>i: 0-&gt;size()</code>)</p>
<p>因此可以得到许多个最多两位数的值,装进vector里面,然后它们的索引表示的是指数值,而<code>vec_res</code>则把这些个数组装进去了,形成了一个稀疏的矩阵,其中每一行最多有两个元素值,最后再累加和reverse并拼接为string,需要注意<code>num1</code>或<code>num2</code>为0的情况,以及结果的string首位为0的情况.</p>
<p>反思:</p>
<p>这道题写得久很不应该(思路大概十分钟就出来了),因为本科我记得写过,但是实在是太久没练了,因此很多思维都僵化了,就比如上面并不需要用二维数组来承担结果的装载,直接用个<code>vector&lt;int&gt; vec_res</code>就行了,然后再诸位处理进位的问题,因为是int,比如<code>vec_res[0] = 213</code>,只需要留住3就好,210向前两位进过去就好.</p>
<p>官方思路:</p>
<ol>
<li>思路一就是把比如<code>123*456</code>给弄成<code>123*6</code>,<code>123*50</code>,<code>123*400</code>,然后再利用字符串相加,给它们加起来;</li>
<li>思路二跟我这个思路差不太多,不过巧妙很多,因为我的还需要reverse,它是计算了下两个数相乘后最小的位数情况为<code>m+n-1</code>,最大位数情况为<code>m+n</code>(其中:<code>m = num1.size();n = num2.size();</code>),因此直接给<code>vector&lt;int&gt; vec_res(m+n)</code>,然后第零位就是最高位(它不一定有数填充,可能是前导零),就比如<code>123*456</code>中的<code>3*6</code>,则放置在第五位(第三位*第三位=第六位,但是是[0,5],所以是第五位,如果有进位则是进在第四位),因而最后判断一下最高位是否前导0就可以把其转为字串;</li>
<li><mark>还有一种是可以把它考虑成卷积的情况,然后利用fft加速好像(这个方法还没细看)</mark></li>
</ol>
<h3 id="重写官方代码-4"><a class="markdownIt-Anchor" href="#重写官方代码-4"></a> 重写官方代码</h3>
<h2 id="10-正则表达式匹配"><a class="markdownIt-Anchor" href="#10-正则表达式匹配"></a> 10 正则表达式匹配🔴</h2>
<h3 id="题目描述-8"><a class="markdownIt-Anchor" href="#题目描述-8"></a> 题目描述</h3>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;aa&quot;</span>, p = <span class="hljs-comment">&quot;a*&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 20</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>
</ul>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<h3 id="重写官方代码-5"><a class="markdownIt-Anchor" href="#重写官方代码-5"></a> 重写官方代码</h3>
<h2 id="103-二叉树的锯齿形层序遍历"><a class="markdownIt-Anchor" href="#103-二叉树的锯齿形层序遍历"></a> 103 二叉树的锯齿形层序遍历</h2>
<h3 id="题目描述-9"><a class="markdownIt-Anchor" href="#题目描述-9"></a> 题目描述</h3>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h3 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h3>
<p>首先,当我一开始看到题目的描述,①要层序遍历,②锯齿形就是给它左一下右一下,就是奇数次的时候(就是某个一维数组位于奇数索引),是从右到左的层序遍历.因此最初的思路是:BFS+reverse,完美解题,轻而易举!</p>
<p>但是问题来了,我忘了bfs咋写,于是经过漫长思想纠结,用了一下之前类似回溯(其实不是回溯,bad)的dfs形式实现的(其中大多数花费的时间是在考虑怎么来度量是同一层,因为这样才可以放入<code>vector&lt;vector&lt;int&gt; res</code>中的同一层), 主要的思路是:写了个递归,然后该递归函数的声明:<code>void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; res,int height,TreeNode* node)</code>,通过如下的方式控制height:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; (height))<br>    &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        res[height].<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>    &#125;<br>    height++;<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;left);<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>官方思路则是使用了bfs(才记起来要用队列),不过它的方法没有用reverse,而是给了个flag,来标记从左开始还是从右开始push,其实就是头插和尾插,因为要用头插,所以用了个deque双端队列来存储.</p>
<h3 id="重写官方代码-6"><a class="markdownIt-Anchor" href="#重写官方代码-6"></a> 重写官方代码</h3>
<p>这里采用的是广搜的方法写的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *node;<br>            <span class="hljs-keyword">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (flag)<br>                    deq.<span class="hljs-built_in">push_front</span>(node-&gt;val);<br>                <span class="hljs-keyword">else</span><br>                    deq.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            flag = !flag;<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;deq.<span class="hljs-built_in">begin</span>(), deq.<span class="hljs-built_in">end</span>()&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 之前的方法</span><br><span class="hljs-comment">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="hljs-comment">        if(root == nullptr)</span><br><span class="hljs-comment">            return res;</span><br><span class="hljs-comment">        bfs(res,0,root);</span><br><span class="hljs-comment">        for(int i=0;i&lt;res.size();i++)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if(i%2!=0)</span><br><span class="hljs-comment">                reverse(res[i].begin(),res[i].end());</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return res;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 之前的方法,写是bfs实则dfs</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            v = res[height];<br>        v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            res[height]=v;<br>        <span class="hljs-keyword">else</span><br>            res.<span class="hljs-built_in">push_back</span>(v);<br>        TreeNode* left = node-&gt;left;<br>        <span class="hljs-built_in">bfs</span>(res,++height,left);<br>        height--;<br>        TreeNode* right = node-&gt;right;<br>        <span class="hljs-built_in">bfs</span>(res,++height,right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/19/DApaJQ6qH4lFwG8.png" srcset="/img/loading.gif" lazyload alt="103-zigzagLevelOrder-effect" /></p>
<h2 id="146-lru缓存"><a class="markdownIt-Anchor" href="#146-lru缓存"></a> 146 LRU缓存</h2>
<h3 id="题目描述-10"><a class="markdownIt-Anchor" href="#题目描述-10"></a> 题目描述</h3>
<p>请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<h3 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h3>
<p>因为这个题目要求<code>get</code>和<code>put</code>的时间复杂度是要在<code>O(1)</code>,显然对于数组来说,在随机位置读是<code>O(1)</code>,而增删则为<code>O(n)</code>,对于链表来说任意位置增删则为<code>O(1)</code>,因为不需要搬移元素,但如果指定位置增删则需要移动过去,这个过程会比较慢,比如单链表,那要删除尾巴节点则需要移动到尾巴那里,即使把尾巴节点存了也没意义,因为删了之后又得遍历一次存一次,因此对于这个题,显然我们需要一个链表来管理元素,即表示元素的优先级,优先级越高的越靠前,表明它使用的次数越多,而在尾巴节点的则表明有淘汰的风险,一旦有新的节点要加入,就要删除,因此本题需要使用双向链表<code>list</code>来管理元素的优先级,然后采用<code>vector&lt;int&gt;</code>来存储键值对,<code>list&lt;int&gt;</code>则用来管理索引.</p>
<p>一开始因为时间限制卡住了,后来在lolored的提醒下,<code>find</code>这个函数很耗时间,可以换下位置减少调用次数,就通过了,不过数据不大好看,但代码蛮简洁的~,以下是我的代码部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:     <br>    <span class="hljs-keyword">int</span> capacity;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>    list&lt;<span class="hljs-keyword">int</span>&gt; ls;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10001</span>,<span class="hljs-number">-1</span>);<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-number">-1</span> != <span class="hljs-keyword">this</span>-&gt;vec[key])<br>        &#123;<br>            list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            <span class="hljs-comment">// 调整至头部</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;vec[key];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-comment">// 为新值 且 长度到界 则需要弹出一个</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-keyword">this</span>-&gt;capacity &amp;&amp; <span class="hljs-keyword">this</span>-&gt;vec[key] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">back</span>();<br>                <span class="hljs-comment">// 链表弹出</span><br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">// 数组置-1</span><br>                <span class="hljs-keyword">this</span>-&gt;vec[t] = <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 以下是不同时满足上述两种情况的剩余情况</span><br>            <span class="hljs-comment">// 这个key在链表中没有(新值),头插</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">-1</span> == <span class="hljs-keyword">this</span>-&gt;vec[key])<br>            &#123;<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            &#125;<br>            <span class="hljs-comment">// 这个key链表有(旧值),调整至头部</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);   <br>            &#125;  <br>            <span class="hljs-keyword">this</span>-&gt;vec[key] = value;   <br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>官方思路其实也差不大多,因为这个问题的关键是<strong>快速查找到元素和快速增删元素</strong>,那有一种融合了这两种(数组和链表)优点的数据结构,叫<strong>哈希表</strong>.在C++中存储键值对的数据结构有<code>map,unordered_map,ordered_map</code>等等,其中<code>map</code>内部实现了红黑树(有序)和<code>unordered_map</code>内部则实现了哈希表,即它查找会更快,但是相对来说更占空间一点.</p>
<p>双向链表则自己实现,然后用它来存k,v(虽然<code>unordered_map</code>的key也是k,这里主要便于后期操作,所以加了个k),则有大概如下的结构<mark>这道题其实</mark>,可以实现查找O(1),增删O(1),其实还有个移动节点,分为删+增,也是O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d_node</span>&#123;</span><br>    d_node *prev,*next;<br>    <span class="hljs-keyword">int</span> key,value;<br>&#125;<br>unordered_map&lt;<span class="hljs-keyword">int</span>,d_node*&gt; u_m; <br></code></pre></td></tr></table></figure>
<p>比起我自己的方法来说,这种方法更好,因为我的方法实际上在查找确实是O(1),但是增删的时候多了一个<code>find()</code>操作,这一步是O(n)的.而且确实,我的vector跟list并没有实质意义上过大的链接关系,就是说它们唯一的共通点是vector的索引是key,而list里面的值是key,并没有真正把它们linked到一起.</p>
<h3 id="重写官方代码-7"><a class="markdownIt-Anchor" href="#重写官方代码-7"></a> 重写官方代码</h3>
<h2 id="14-最长公共前缀"><a class="markdownIt-Anchor" href="#14-最长公共前缀"></a> 14 最长公共前缀🔵</h2>
<h3 id="题目描述-11"><a class="markdownIt-Anchor" href="#题目描述-11"></a> 题目描述</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<h3 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h3>
<p>这个实际写了大概20分钟不到,这个题目比较直,即使暴力解也有好的结果,只要适当剪枝就好.抓一个string出来,然后跟别的比就好,只要出现了不匹配的就跳出来就好(用个标志位)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string ans;<br>        string tmp = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">bool</span> break_flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;tmp.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;strs.<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(strs[j].<span class="hljs-built_in">size</span>() &lt;= i)<br>                &#123;<br>                    break_flag=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp[i] != strs[j][i])<br>                    break_flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(break_flag)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans += tmp[i];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153 寻找旋转排序数组中的最小值</h2>
<h3 id="题目描述-12"><a class="markdownIt-Anchor" href="#题目描述-12"></a> 题目描述</h3>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br>解释：原数组为 <span class="hljs-string">[1,2,3,4,5]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：原数组为 <span class="hljs-string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[11,13,15,17]</span><br>输出：<span class="hljs-number">11</span><br>解释：原数组为 <span class="hljs-string">[11,13,15,17]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<h3 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h3>
<p>一开始写这题的时候非常烦躁,感觉写题目是一件非常私人的事情,不要随着别人的时间写,不然很影响自己的状态.</p>
<p>后面我重新看了题目,确定了是二分查找,因为你要做到<code>O(logn)</code>这么一个时间复杂度,但是二分查找呢是排好序了的.于是自己又写了几个案例来观察:</p>
<p><code>[2,3,4,5,6,7,8,9,0,1]</code> | <code>[7,8,9,0,1,2,3,4,5,6]</code></p>
<p>不难发现,根据旋转的次数,我们的最小值可能在中点的左边,也可能在右边:</p>
<ul>
<li>最小值在中点左边,说明旋转次数少,左边的值偏大;</li>
<li>最小值在中点右边,说明旋转次数多,右边的值偏小;</li>
</ul>
<p>因此,我就选择拿最左端与中点的值进行比较,一步步缩小区间(a表示左侧端点,mid表示中点):</p>
<p><code>if(nums[mid]&gt;nums[a]) // 最小值在右边的区间 向右收缩区间</code></p>
<p><code>if(nums[mid]&lt;nums[a] // 最小值在左边的区间) 向左收缩区间</code></p>
<p>其中向右收缩区间则<code>mid</code>和<code>nums.size()</code>相加除2,把mid往右移,a把原来mid的索引给拿走;</p>
<p>其中向左收缩区间则<code>mid</code>和<code>a</code>相加除2,把mid往左移;</p>
<p>因为收缩到的子区间也是满足这种旋转的情况的(就是两个升序的序列,但是拼接处是最大值和最小值),直到<code>a</code>和<code>mid</code>相等,说明它俩挨得近,上一次只差了个1,但是左缩了,说明上一次的mid是小于a的值的,但是相等了,说明上一次的值已经是最小的了.</p>
<h3 id="重写官方代码-8"><a class="markdownIt-Anchor" href="#重写官方代码-8"></a> 重写官方代码</h3>
<h2 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> 56 合并区间</h2>
<h3 id="题目描述-13"><a class="markdownIt-Anchor" href="#题目描述-13"></a> 题目描述</h3>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^4</code></li>
</ul>
<h3 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h3>
<p>我真是无语写这道题,因为官方给的示例,我以为左端点是递增的,后面提交才发现,是需要先排个序的…</p>
<p>不过写分类的时候也是跌跌撞撞试了几次错,再整理思路写出来的,虽然好像看起来结果还挺pass,但方法比较呆瓜(不用一直合并,可以累积一波再合并),之后要重写一遍这题.</p>
<p>官方的思路是先按左端点排序,则能合尽合,不能合则next one go go.</p>
<h3 id="重写官方代码-9"><a class="markdownIt-Anchor" href="#重写官方代码-9"></a> 重写官方代码</h3>
<h2 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和"></a> 53 最大子数组和</h2>
<h3 id="题目描述-14"><a class="markdownIt-Anchor" href="#题目描述-14"></a> 题目描述</h3>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h3 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h3>
<p>原思路如下虽通过了,但是有一个压力测试的用例是绕过去的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max,sum;<br>        <span class="hljs-comment">// 这个来定区间</span><br>        <span class="hljs-keyword">int</span> r;<br>        <span class="hljs-comment">// 把边界先给处理了</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;nums.<span class="hljs-built_in">size</span>();l++)&#123;<br>            <span class="hljs-comment">// 初始值设置</span><br>            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>)<br>                max = nums[l];<br>            sum = nums[l];<br>            <br>            <span class="hljs-comment">// 极端情况,全负</span><br>            <span class="hljs-keyword">if</span>(max &lt; nums[l])<br>                max = nums[l];<br>            <span class="hljs-comment">// 左端点和步距表示区间</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s=l+<span class="hljs-number">1</span>;s&lt;nums.<span class="hljs-built_in">size</span>();s++)&#123;<br>                <span class="hljs-comment">// 左端点值小于0直接跳出去</span><br>                <span class="hljs-keyword">if</span>(nums[l] &lt; <span class="hljs-number">0</span>)&#123;<br>                    sum = <span class="hljs-number">0</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 对着用例加的一个无聊的标志位,如果是有负则为false;</span><br>                <span class="hljs-keyword">if</span>(nums[s]&lt;<span class="hljs-number">0</span>)<br>                    flag = <span class="hljs-literal">false</span>;<br><br>                sum += nums[s];<br>                <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(sum&gt;max)<br>                        max = sum;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间里的和只要是大于零(大于max(因为怕有极端情况))的就有反转的余地,不然就废了</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>上面代码的思路是通过l(left)和s(stride)这两个来定区间,然后逐个区间找最大值的可能,什么时候放弃一个区间呢?</p>
<ul>
<li>当它开头(区间左端点)是负数(因为如果全负的话,直接从负的找最大的就好),如果有大于等于0的话,那就说明这个负的开头的不可能是最大连续子数组,因为它的起点就比别人低;</li>
<li>当它区间的总和小于0时,也要跳出,因为你开头不为0,你这时为0了,后面即使有再大的数,也不如直接就挑那一个大数作为最大值的连续子数组</li>
</ul>
<p>而当我们区间的总和不为0时,则表示有回转的余地,还可以继续区间的和的最大值的计算</p>
<p>昨天lolored跟我说她写了一个绝佳的方法,确实牛牛,代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = nums.<span class="hljs-built_in">size</span>(); i &lt; len; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (max &lt; nums[i]) max = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个方法其实是把我上面的方法高度压缩了一波,利用数组内的每个值作为sum来统计,而当其本身小于0或是累和小于0则放弃,当累和比max大则更新max</p>
<p>这个方法的时间复杂度是<code>O(n)</code>,但我觉得精简程度堪称典范,比官方的dp方法还好.</p>
<p>官方的思路是采用动态规划的算法,这里采用一个看到的大佬的思路(<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">参考自liweiwei1419</a>),作者详细地讲了这个题目<strong>如何找到/定义状态</strong>(就是子问题,<mark>从有后效性到无后效性(后面对子问题的求解不影响前面已求解完的子问题),好像要么就是给它加定语设条件,要么就是增加状态数组维度</mark>),然后找到<strong>子问题之间的联系,就是状态转移方程</strong></p>
<p>以<code> [-2,1,-3,4,-1,2,1,-5,4]</code>为例</p>
<p>比如一开始会想:</p>
<ul>
<li>含有<code>-2</code>的连续子序列的最大和 -&gt; <code>dp[0]</code></li>
<li>含有<code>1</code>的连续子序列的最大和 -&gt; <code>dp[1]</code></li>
<li>…</li>
<li>含有<code>4</code>的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li>
</ul>
<p>但是这并没有很好的阐述清楚这个问题,子问题间的关系扑朔迷离,且对现在的子问题依旧有<strong>不确定</strong>的因素就判定为仍有后效性(我感觉意思上来说就是只要你感觉怪怪的,就是还有后效性,只要当你的子问题定语够多,前提是不要错,对不对很容易感受出来)</p>
<p>现在的不确定性就是比如含有<code>-2</code>的连续子序列有很多很多个,含有<code>1</code>的连续子序列也有很多很多个,这里的作者就借助<strong>位置</strong>这个定语来加强子问题的限定</p>
<ul>
<li>以<code>-2</code>为末尾元素的连续子序列的最大和 -&gt; <code>dp[0]</code></li>
<li>…</li>
<li>以<code>4</code>为 末尾元素的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li>
</ul>
<p>这样就有:</p>
<p>对于以-2为结尾的<code>[-2]</code>即是在所有连续子序列中选一个最大和的,而这个只有一种情况,所以<code>dp[0]=nums[0];</code></p>
<p>对于以1为结尾的<code>[-2,1]</code>,<code>[1]</code>有这么两种情况,即是在选不选<code>dp[0]</code>的情况下做选择,当然我们如果前一个<code>dp[i-1]</code>的是<code>&lt;=0</code>的数加了只会更小或者说没区别,还不如就不加了.</p>
<p>因此状态转移方程也就呼之欲出了</p>
<p>此外,作者也说了动规题的做题路径:</p>
<ol>
<li>定义状态/子问题</li>
<li>定义状态转移方程</li>
<li>考虑初始值</li>
<li>考虑输出</li>
<li><mark>空间优化(这一步先放弃,一般空间不要太离谱也不会爆)</mark></li>
</ol>
<h3 id="重写官方代码-10"><a class="markdownIt-Anchor" href="#重写官方代码-10"></a> 重写官方代码</h3>
<p><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的连续子序列的最大和</p>
<p>当发生状态转移的时候,即是选择<code>dp[i]</code>选择<code>dp[i] = dp[i-1] + nums[i];</code>或是<code>dp[i] = nums[i];</code>的过程,而这个选择的条件就是<code>dp[i-1]</code>是否<code>&gt;0</code></p>
<p>定义好状态了,状态转移方程以及相关条件都定义好了,考虑初值,即<code>dp[0]</code>表示以<code>nums[0]</code>结尾的连续子序列的最大和,有且也只有一个<code>[nums[0]]</code>这么一个子序列,所以<code>dp[0] = nums[0];</code></p>
<p>题目要求我们求出连续子序列的最大和,就是说,并不是一定要以谁结尾,而是要在这些情况中,找个最大的,也就是遍历所有的状态,找个最大的返回出去.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span>)<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + nums[i];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = nums[i];<br>            <span class="hljs-keyword">if</span>(dp[i] &gt; max)<br>                max = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/12/H6h2EdPU5xSvKrB.png" srcset="/img/loading.gif" lazyload alt="53 最大子数组和-前后效果对比" /></p>
<h2 id="162-寻找峰值"><a class="markdownIt-Anchor" href="#162-寻找峰值"></a> 162 寻找峰值</h2>
<h3 id="题目描述-15"><a class="markdownIt-Anchor" href="#题目描述-15"></a> 题目描述</h3>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>
</ul>
<h3 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h3>
<p>这个题目,看到**<code>O(logn)</code><strong>的时候就意识到了要用</strong>二分查找**(因为它就是找类似于极大值点的这么一个情况,就是找某一个满足特殊条件的值),但是它跟普通的二分查找不一样,因为那种是排好序的,那么这个二分查找你在折半区间后,往哪一个新的区间走都还不知道呢</p>
<p>这个时候就要结合题目分析一波,因为题目说是找峰值:</p>
<ul>
<li>当是<code>nums[i]&gt;nums[i-1] &amp;&amp; nums[i]&gt;nums[i+1]</code>的时候则满足条件;</li>
<li>如果是<code>nums[i-1]&lt;nums[i]&lt;nums[i+1]</code>的说明是个目前处于增函数一侧(方便理解,故如此称呼),则要往右走;</li>
<li>如果是<code>nums[i-1]&gt;nums[i]&gt;nums[i+1]</code>则说明是处于减函数一侧,要往左走</li>
</ul>
<p>然后这里通用的做法的话是<strong>缩区间,区间找中点,判断,循环往复</strong></p>
<p>但是我不知道为啥写的时候死犟,用了个二分法+进退法,死都想不起来缩区间,而是:先找到中点<code>mid</code>,用它去判断是处于增/减,再往另一个区间去,<code>pre_mid</code>继承<code>mid</code>的位置,则可能存在增-减/减-增的理想情况,也可能存在增-增/减-减的情况,会导致陷入区间,因此要用一些方法将此类情况移除,采用逐次增加步距,跳出陷入区间的可能.此外,也可能存在比较对称的点,导致<code>pre_mid</code>和<code>mid</code>振荡,因此每次陷入的时候都加多个1,避免振荡.然后得出了下面这么一个结果(好得有点惊讶,因为我写到后面甚至不知道我在干嘛了,指振荡那一部分,是遇到了一个用例死活过不去(振荡了),就把步距那一块都加了个1,后来感觉是打破了对称性):</p>
<p><img src="https://s2.loli.net/2024/03/13/ZM7KdHErQTW2csP.jpg" srcset="/img/loading.gif" lazyload alt="162 寻找峰值元素-奇怪的运行结果" /></p>
<p>代码如下,此题需要重写,用正常的写法写(就是我说的缩区间的,官方的解法也是这个)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre_mid=<span class="hljs-number">-1</span>,mid = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>,tmp,stride;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 处理两个边界情况</span><br>            <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[mid+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(mid==nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; nums[mid] &gt; nums[mid<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 可以出去的情况</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果找错极值了,乱弹一下</span><br>            <span class="hljs-keyword">if</span>(mid == pre_mid)&#123;<br>                mid = <span class="hljs-number">2</span> * mid;<br>                <span class="hljs-keyword">if</span>(mid &gt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                    mid = mid % nums.<span class="hljs-built_in">size</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = (mid + nums.<span class="hljs-built_in">size</span>()) / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往右走</span><br>                    tmp = mid;<br>                    mid = (mid + pre_mid) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                    <br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &lt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span> &amp;&amp; <br>                nums[mid] &gt; nums[pre_mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (mid - pre_mid) + <span class="hljs-number">1</span> ;<br>                    mid = mid + stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//if(nums[mid]&gt;nums[mid+1]&amp;&amp;nums[mid]&lt;nums[mid-1])&#123;</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = mid / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往左走</span><br>                    tmp = mid;<br>                    mid = (pre_mid + mid ) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &gt; <span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[pre_mid] <br>                &amp;&amp; nums[mid] &lt; nums[mid<span class="hljs-number">-1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (pre_mid - mid) + <span class="hljs-number">1</span>;<br>                    mid = mid - stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;mid:&quot;</span>&lt;&lt; mid &lt;&lt; <span class="hljs-string">&quot; pre_mid:&quot;</span> &lt;&lt; pre_mid &lt;&lt;<span class="hljs-string">&quot; len:&quot;</span> &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl ;<br>            <span class="hljs-keyword">if</span>(mid&lt;<span class="hljs-number">0</span>)<br>                mid = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(mid&gt;nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                mid = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">题目是查找满足某种条件的值的索引(找峰值)</span><br><span class="hljs-comment">然后说O(logn)</span><br><span class="hljs-comment">那不就是二分查找嘛</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">把示例的输入都化成点图,感觉就是找尖尖的点</span><br><span class="hljs-comment">遇到左&lt;中&lt;右的就往右移动;</span><br><span class="hljs-comment">遇到左&gt;中&gt;右的就往左移动;</span><br><span class="hljs-comment">记录上一个&quot;中&quot;值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="重写官方代码-11"><a class="markdownIt-Anchor" href="#重写官方代码-11"></a> 重写官方代码</h3>
<h2 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160 相交链表</h2>
<h3 id="题目描述-16"><a class="markdownIt-Anchor" href="#题目描述-16"></a> 题目描述</h3>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">1</span><br>输出：Intersected at &#x27;<span class="hljs-number">2</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h3 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h3>
<p>题目说要<strong>在两个单链表中找到它们相交的节点</strong>,我的思路是很暴力的,直接两个链表遍历,当有节点相等则意味着找到相交点了,因为相交的点们都是同样的内存地址.本来想着用数值来找的,但是数值有重复的.</p>
<p>上述这种方法时间复杂度是<code>O(mn)</code>(虽然AC了但是性能一般),等我想到<code>O(m+n)</code>的再看题解,不然怕没逻辑过程~</p>
<hr />
<p>叮~~~(仔细想了半小时左右,指以下过程,还回看了分隔链表的题目,因为觉得它们很像),不小心按到题解(之前做完跳过去的,页面没关),看到<strong>双指针</strong>,看到<strong>后面的长度一样</strong>,然后想了一下,大概知道怎么做了,写一遍</p>
<hr />
<p>新的思路主要是<strong>先对齐数组,然后逐个比较</strong></p>
<p>对齐数组是指listA和listB长度不一样,而显然交点及之后的大小是一样的长度,而多出来的那部分(就是那些个节点),肯定不是交点会在的地方,因此先对齐,而对齐前要统计两个链表的长度,则这部分的时间复杂度是<code>O(m+n)</code>,之后对齐需要处理长链表的节点,而后的逐个比较则是减去了这部分长链表的节点,所以后面这部分的时间复杂度为<code>O(max(m,n))</code>,假设m&gt;n,则总时间复杂度为<code>O(2m+n)</code>这样子,算是达到了<code>O(m+n)</code>的时间复杂度</p>
<p>以下为更正后的代码部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *tmpA = headA, *tmpB = headB;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (tmpA != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            tmpA = tmpA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (tmpB != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        tmpA = headA;<br>        tmpB = headB;<br>        pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt = m &gt; n ? <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, m - n) : <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, n - m);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">max</span>(m, n) - cnt.second;<br><br>        <span class="hljs-keyword">while</span> (cnt.second)<br>        &#123;<br>            <span class="hljs-comment">// 处理listB</span><br>            <span class="hljs-keyword">if</span> (cnt.first)<br>                tmpB = tmpB-&gt;next;<br>            <span class="hljs-comment">// 处理listA</span><br>            <span class="hljs-keyword">else</span><br>                tmpA = tmpA-&gt;next;<br><br>            cnt.second--;<br>        &#125;<br>        ListNode *ans = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (tmpB == tmpA)<br>            &#123;<br>                ans = tmpB;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpA = tmpA-&gt;next;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 下面是暴力解法</span><br><span class="hljs-comment">        ListNode* tmpA = headA;</span><br><span class="hljs-comment">        ListNode* tmpB = headB;</span><br><span class="hljs-comment">        ListNode* ans = nullptr;</span><br><span class="hljs-comment">        bool flag = false;</span><br><span class="hljs-comment">        while(tmpA != nullptr)&#123;</span><br><span class="hljs-comment">            while(tmpB != nullptr)&#123;</span><br><span class="hljs-comment">                if(tmpA == tmpB)&#123;</span><br><span class="hljs-comment">                    ans = tmpA ;</span><br><span class="hljs-comment">                    flag = true;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                tmpB = tmpB -&gt;next;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            tmpA = tmpA -&gt;next;</span><br><span class="hljs-comment">            tmpB = headB;</span><br><span class="hljs-comment">            if(flag)</span><br><span class="hljs-comment">                break;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return ans;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方代码-12"><a class="markdownIt-Anchor" href="#重写官方代码-12"></a> 重写官方代码</h3>
<h2 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> 98 验证二叉搜索树</h2>
<h3 id="题目描述-17"><a class="markdownIt-Anchor" href="#题目描述-17"></a> 题目描述</h3>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>
<p>节点的左</p>
<p>子树</p>
<p>只包含</p>
<p>小于</p>
<p>当前节点的数。</p>
</li>
<li>
<p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li>
<p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h3 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h3>
<p>验证二叉搜索树，就是要根据给定的输入，验证输入的树结构是否是bst</p>
<p>我们知道，对于bst而言，中序遍历的时候相当于排序，而对于如左子树&lt;根&lt;右子树的情况，则相当于升序</p>
<p>我一开始写的时候想用广度优先搜索写，主要遵循的是左节点&lt;根&lt;右节点这样规则，但后面过用例的时候会出现，有左子树的部分节点会比根节点的值大，这就不符合bst了。后面想了一下，没想出如何解决，因此转用了dfs做中序遍历，然后看是不是升序的，是则说明是bst</p>
<h3 id="重写官方思路-4"><a class="markdownIt-Anchor" href="#重写官方思路-4"></a> 重写官方思路</h3>
<h2 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> 110 平衡二叉树🔴</h2>
<h3 id="题目描述-18"><a class="markdownIt-Anchor" href="#题目描述-18"></a> 题目描述</h3>
<p>给定一个二叉树，判断它是否是平衡二叉树</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = []<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<h3 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h3>
<p>写这道题太挫败了,简单题我写不出来😢</p>
<p>一开始的想法是想用bfs,层序遍历树结构,用<code>vector&lt;vector&lt;int&gt;&gt;</code>把树结构的信息装起来,然后遍历,我们知道树的高度为h,则该行长满节点则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>(h是从0开始算的),我的判断依据是当存在两行不满足长满节点,则不是平衡二叉树,然后在一个用例上错了😈,如<code>[1,2,3,4,5,6,null,8]</code>这样的,满足我的不是平衡二叉树的判断,但它又确实是,因为每一个子树都满足左右子树高度差&lt;=1</p>
<hr />
<p>昨天晚上重写了这个题目,看了题解,用了递归写的,但是性能不大好,应该是属于自顶向下的那种?</p>
<p>主要思路是所有平衡二叉树的子树都是平衡二叉树,因为都要满足左右子树高度差不为1的条件.则对于叶子节点,高度为1,一层层的这样累加上去,则可以知道根的左右子树的高度;并且在检索左右子树的高度时,也对每一个小子树的高度差进行判定,如果超过1,则直接返回-1,且上层对-1直接疯狂返回就行.即使这样时间上也只是超过53%的人</p>
<p>重写的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> height_l = <span class="hljs-built_in">findHeight</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> height_r = <span class="hljs-built_in">findHeight</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(height_l - height_r) &lt;=<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findHeight</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-comment">// 空节点高度为0</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 叶子节点则高度为1</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> height_l,height_r;<br><br>        height_l = <span class="hljs-built_in">findHeight</span>(node-&gt;left);<br>        height_r = <span class="hljs-built_in">findHeight</span>(node-&gt;right);<br>        <br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span> || height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(height_l - height_r) &gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(height_l,height_r) + <span class="hljs-number">1</span> ;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-5"><a class="markdownIt-Anchor" href="#重写官方思路-5"></a> 重写官方思路</h3>
<p>之后看下有没有啥更好的题解</p>
<h2 id="121-股票i"><a class="markdownIt-Anchor" href="#121-股票i"></a> 121 股票Ⅰ</h2>
<h3 id="题目描述-19"><a class="markdownIt-Anchor" href="#题目描述-19"></a> 题目描述</h3>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure>
<h3 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h3>
<p>写这道题的时候我的心路历程如下:</p>
<ol>
<li>左右指针,左扫最低,右扫最高,相减为ans,为负则0 -&gt; failed;</li>
<li>慢慢划过去,找最小值,然后最大值是最小值右边的(历史最低点不一定是赚到最多钱的时候<code>[2,5,1,3]</code>)</li>
</ol>
<p>然后不知道触动了哪个叛逆的神经,我想了下,如果动态规划做的话:</p>
<p><code>dp[i]</code>表示第<code>i</code>天的最大收益,则它这个会模糊不清吗(就是有无后效性),然后就大概的过一过,比如:</p>
<ul>
<li><code>dp[0]</code>第一天的最大收益</li>
<li><code>dp[1]</code>第二天的最大收益</li>
<li>…</li>
<li><code>dp[len-1]</code>最后一天的最大收益</li>
</ul>
<p>那这个最大收益呢,它并不是说我一定非得要在那天卖出(上面的就有点模糊,有后效性,因为我们不知道在第几天卖出,描述很模糊,但买入一定是之前的某个时间节点),就是<strong>直至到第<code>i</code>天的最大收益</strong>,同时转移方程也出来了(很神奇,感觉只要状态找好了找对了,转移方程就很快出来的):</p>
<p><code>dp[i] = max(dp[i-1],prices[i]-min)</code></p>
<p>即直到第<code>i</code>天的最大收益,要么是直到第i-1天的最大收益,要么是今天的卖出价减去之前存储好的相对较低的买入价,两者取max即为所得</p>
<p>同时初始值<code>dp[0]</code>肯定是0,因为撑死就今天买入,卖出如果是同一天的话,也是0.</p>
<p>同时期望的输出就是<code>dp[len-1]</code>,直到最后一天的最大收益(战斗到股市最后一刻),因为存的是最大利润,故输出其即可.</p>
<h3 id="重写官方思路-6"><a class="markdownIt-Anchor" href="#重写官方思路-6"></a> 重写官方思路</h3>
<p>和你的一样哇哈哈</p>
<p>思路一倒是居然没有往这里想,就是跟之前有道题类似(好像是组合?),限定左端,然后右端在左端下一位移动;左端往右走一位,右端在左端下一位继续移动;</p>
<p>限定了区间,但据说会报超时.</p>
<h2 id="122-股票ii"><a class="markdownIt-Anchor" href="#122-股票ii"></a> 122 股票Ⅱ</h2>
<h3 id="题目描述-20"><a class="markdownIt-Anchor" href="#题目描述-20"></a> 题目描述</h3>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
<h3 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h3>
<p>一开始的时候没啥思路,知道这题递归做,虽然说递归做出来了,但是官网跟我类似的方法是贪心算法,bad,分不清了</p>
<p>我的想法是<code>dp[i]</code>继续表示<strong>直到第i天的最大利润</strong>,但是跟前面的有点不一样,因为我们现在可以<strong>每一天可以多次交易(可以买入卖出),但是任何时候最多只有一股</strong>,也即是说我可能第三天买,第四天价格好就卖了,第五天又买入,第七天行情好了,又卖出去,并不是说买入的时候一定比卖出的早(因为多次交易,可能在之前就有卖出行为了),感觉原来的状态依旧可行,于是修改状态转移方程思路如下:</p>
<p>dp[i]是我直到第i天的最大利润,它的计算方式是:它如果今天不卖出东西的话(就是没赚钱嘛,我依旧不管什么时候买入的),那它就是dp[i-1],那如果今天卖东西呢(就是卖了,有得赚嘛),那就是dp[i-1]+prices[i]-minPrice.那卖不卖东西,其实看的是赚不赚钱:</p>
<p><code>dp[i] = dp[i-1] +  max(0,prices[i]-minPrice)</code></p>
<p>那问题转移到了minPrice怎么找,我们知道,因为任何时候最多持有一股,所以卖了的话,minPrice就得更新(有股且卖).那如果没卖(有股和无股,且不卖,更新minPrice),当天的价格低,就给它换,即是更新到一个价格相对更低的minPrice,当然你得先看它(前一天的价格)卖的话赚不赚钱,赚的话先卖了,再更新,故minPrice变成了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否出售</span><br><span class="hljs-keyword">for</span>(...)&#123;<br>    <span class="hljs-keyword">if</span>(prices[i]-minPrice&gt;<span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,prices[i]-minPrice);<br>	<span class="hljs-keyword">if</span>(minPrice &gt; prices[i])&#123;<br>        minPrice = prices[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        minPrice = prices[i]; <span class="hljs-comment">// 大的话在之后的遍历会缩</span><br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还加了flag辅助,虽然好像没啥用(简化代码这个flag可以去掉)</p>
<p>但是官方说这个是贪心算法,我看了下评论区的人的解释:<strong>只要是利润都是赚的,那直接累加利润就是能赚到的最多的钱</strong>,确实如此!</p>
<p>官方的动态规划的做法则是从<strong>最多只能持有一股股票</strong>入手</p>
<p>那如果第i天交易结束,我手里要么有一股股票,要么没有股票,所以我们原先121的<code>dp[i]</code>,直到第i天的最大利润,可以加个定语变为:<strong>直到第i天有一股股票的最大利润</strong>和<strong>直到第i天没有股票时的最大利润</strong>,而只增加定语并不能解决真正的问题,则要加个维度来表示这个定语了,于是有新的状态定义如下:</p>
<p><code>dp[i][0]</code>: 直到第i天交易结束后没有股票时的最大利润</p>
<p><code>dp[i][1]</code>: 直到第i天交易结束后有一股股票时的最大利润</p>
<p>对应状态的变化可以这样想,买入一股,相当于赊账买入,则减,卖出相当于进账,则加.则我们的状态表示<code>dp[i]</code>直到第i天的账户余额数</p>
<p>因此引出状态转移方程如下:</p>
<p><code>dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])</code></p>
<p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])</code></p>
<p>相应的对于如&quot;直到第1天交易结束时的最大利润&quot;这样的初始值的处置也可以分为:<code>dp[0][0] = 0;dp[0][1] = -prices[0]</code></p>
<p>然后最终的输出是要输出能获得的最大利润,显然<code>dp[n-1][1]</code>是比<code>dp[n-1][0]</code>所赚的钱少的,还有一股股票压箱底呢,因此最终的输出就直接是<code>dp[n-1][0]</code></p>
<h3 id="重写官方思路-7"><a class="markdownIt-Anchor" href="#重写官方思路-7"></a> 重写官方思路</h3>
<p>有缘重写一下咯~</p>
<h2 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46 全排列🔴</h2>
<h3 id="题目描述-21"><a class="markdownIt-Anchor" href="#题目描述-21"></a> 题目描述</h3>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h3 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h3>
<p>一开始的想法跑偏了,想到动规那里去了,为什么会想到那去呢,因为想着这种排列,它比如<code>[1,2,3,4]</code>,如果是一位数的情况下,以<code>nums[0]</code>结尾的情况,即<code>dp[0][0]</code>只有一种,显而易见,这个二维矩阵的第一行很好填满,而第一列则如<code>dp[1][0]</code>,是两位数的情况下,以<code>nums[0]</code>结尾的情况,很明显,这个东西它好像不大对劲,就是它可以用来统计个数?也可能在过程可以append vector到ans这个二维数组,但就是很奇怪,故直觉觉得奇怪,大多数情况下无法用dp做出;</p>
<p>后来不知道为何没有想出做法(思路跑到组合那里去了),即使和lolored的想法是相同的(递归处理每个首位数),但处理上出了些问题,导致递归出不去,重写修改并整理思路写于如下:</p>
<p>以<code>nums=[1,2,3]</code>为例,我们知道,当我们在数学中遇到排列问题,会想着第一个位置可以排列3个,第二个位置就排列2个,最后一个位置则排列1个,因此即是首位数可以排列1,2,3三种情况,首位数的下一个首位数,就是第二位数,可以排列第一位数排列剩下的情况,后面的首位数也是如此,在剔除了上一位选择的数字后,在剩下的数字里选择</p>
<p>因此,nums如果是3位数,则应该有3个for,用来为每一位数挑选剩余的数字;<strong>如果有n位数,则应该有n个for来为每一位数挑选剩余的数字</strong>(一般n不会太大,不然容易oom,而且也有爆栈的风险),因此是<strong>递归</strong>,且<strong>每个递归函数中处理一位数</strong></p>
<p>那如何知道这个数字被选了呢,<strong>标志位</strong></p>
<p>因此有伪代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(flags[i])&#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        flags[i] = <span class="hljs-literal">true</span>;<br>        ...处理下一位数字...<br>        flags[i] = <span class="hljs-literal">false</span>;<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终写好的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flags</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>()&gt; findNumber = [&amp;]()-&gt; <span class="hljs-keyword">void</span>&#123;<br>                <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == len)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(tmp);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(!flags[i])&#123;<br>                        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                        flags[i] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-built_in">findNumber</span>();<br>                        flags[i] = <span class="hljs-literal">false</span>;<br>                        tmp.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">findNumber</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-8"><a class="markdownIt-Anchor" href="#重写官方思路-8"></a> 重写官方思路</h3>
<h2 id="47-全排列ii"><a class="markdownIt-Anchor" href="#47-全排列ii"></a> 47  全排列Ⅱ</h2>
<h3 id="题目描述-22"><a class="markdownIt-Anchor" href="#题目描述-22"></a> 题目描述</h3>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h3 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h3>
<p>容易看出,它是在46题的基础上增加了<strong>重复数字</strong>,这样一来相较于原先的情况,应该多了更多剪枝的方法,比如<code>[1,1,2]</code>就相较于原来的<code>[1,2,3]</code>由6种排列变成了3种,但是想了好久都没想出来新的剪枝如何实现,就用个set在46题的基础上给它主动去重,当然性能也很差,后面看下解析改进一下.</p>
<h3 id="重写官方思路-9"><a class="markdownIt-Anchor" href="#重写官方思路-9"></a> 重写官方思路</h3>
<p>细看了一下官方的解题思路,其中关于<strong>剔除重复序列</strong>(也就是这个题的关键)有点看不懂,但是看了下评论区大家的解释,大致了然了,下面以<code>[1,1,1,2]</code>举例:</p>
<p>从这个含有重复数字的序列中,不难看出,一共就:<code>[1,1,1,2]</code>;<code>[1,1,2,1]</code>;<code>[1,2,1,1]</code>;<code>[2,1,1,1]</code>这么几种排列情况,如果按照A44=4!=24种情况,显然有20种情况是重复的,就比如以顺序给重复的以命名,如:<code>[1a,1b,1c,2]</code>,其中<code>1a1b1c</code>这个排列有6种情况,但其实都是重复的,我们取其中一种,如<code>1a1b1c</code>即可,那么如何过滤掉其余的几种呢?</p>
<p>显然如果要取<code>1a1b1c</code>这一种,即我们在递归的顶层遍历(即第一个for),可以得到1a,然后第二个for可以得到1b,第三个for可以得到1c,最后一个for得到2,那么期望的数字排列1a1b1c2就出来了,接下来则顶层遍历的for会把1a的标志位给置否,并把它从数组中弹出,则1b登场,显然我们不想要这组排列,包括之后的1c开头的排列也是,如何剔除?</p>
<p>可以看出,这些有重复数字的得排在一起,如<code>[1,1,1,2]</code>这样,而非<code>[1,2,1,1]</code>,这样能更好且规律地剔除,因此一开始得对nums排个序,使之成为<code>[1,1,1,2]</code>这样,然后,我们不要的是1b,1c开头的,它们前面都有重复的数字<code>nums[i] == nums[i-1]</code>,且此种情况下,前面的排好了,即<code>nums[i-1]</code>它排好了<code>nums[i]</code>的情况,且此时flags[i-1]已经置否,则这个可以作为已排过的标志!</p>
<p>我们先对nums排序,若是<code>nums[i] == nums[i-1]</code>说明此时滑到了重复的数字上,为了避免越界需加上<code>i&gt;0</code>,而当flags[i-1]还为true的时候,表明正在发生如下的排列:<code>1a...</code>,而当<code>nums[i-1]</code>为false的时候说明已排列好,则此时的排列若是<code>nums[i] == nums[i-1] &amp;&amp; !flags[i-1]</code>说明在排重复的序列了,可以直接continue</p>
<p>这样做会使得重复数字的第一个数排好情况,而后面重复的那些,就直接continue,continue走掉,直到一个新的重复序列的开头~</p>
<p>已重写🆗</p>
<h2 id="49-字母异位词分组"><a class="markdownIt-Anchor" href="#49-字母异位词分组"></a> 49 字母异位词分组</h2>
<h3 id="题目描述-23"><a class="markdownIt-Anchor" href="#题目描述-23"></a> 题目描述</h3>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 10^4</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<h3 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h3>
<p>写这道题,我只有暴力的想法!非常暴力,以至于很弱智:</p>
<ol>
<li>标志flags表征这个字串是否加入过结果数组;</li>
<li>两层遍历,第一层从左往右,第二层顺着第一层,在它右起新一个位置搜索,两个字串比对长度,长度一致则排序,若一致则加入vecString,并置标志位;</li>
<li>从第二层遍历出来,判断vecString的size是否不为0,不为0则加入结果数组;</li>
</ol>
<p>以上以极高时间复杂度完成了整道题,但是内存开销则还可以(?很怪)</p>
<p>同时发现了自己在C的字符数组这一块的相关函数忘得差不多了.之后补齐相关的知识</p>
<h3 id="重写官方思路-10"><a class="markdownIt-Anchor" href="#重写官方思路-10"></a> 重写官方思路</h3>
<p>官方的思路是用哈希表来处理这个问题,主要是抓住字母异位词的特点来处理,有两种做法一种是排序,一种是根据比如<code>[pet,etp,cat,rag]</code>构造对应的key值,如:<code>1e1p1t,1e1p1t,1a1c1t,1a1g1r</code>这样.</p>
<p>重写一遍代码如下(29号再写):</p>
<p>已重写🆗</p>
<h2 id="61-旋转链表"><a class="markdownIt-Anchor" href="#61-旋转链表"></a> 61 旋转链表</h2>
<h3 id="题目描述-24"><a class="markdownIt-Anchor" href="#题目描述-24"></a> 题目描述</h3>
<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 2 * 10^9</code></li>
</ul>
<h3 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h3>
<p>因为我们旋转1次就会把尾节点放到前面,当旋转链表的长度<code>len</code>次的话,就相当于没动,因此旋转的次数<code>k</code>要对长度<code>len</code>取余,避免转圈圈,而当<code>k%len</code>的时候表示需要从尾巴移动这么多个节点,也即相当于我们的链表从第1个节点(即头节点)到<code>len-(k%len)</code>这个节点的时候是不用动的,因此从头节点为1开始计数,直到遇到第<code>len-(k%len)</code>个节点,则此刻该节点的next是要移到前面去的,这时我们可以借用一个空节点<code>preHead</code>(前于head节点)来承接要被切开的节点,并置新的尾节点的next为<code>nullptr</code>.此刻我们有两个链表,一个是以head为代表的,一个是以preHead为代表的,(这时跟分隔链表那道题就基本一样了).让preHead扫到next节点是<code>nullptr</code>的,接上head节点,然后head节点变为preHead节点的next节点,则完成了链表旋转.</p>
<p>这道题一开始十几分钟有思路,后来被边界卡了一下,就对着failed的用例在写,导致最后写了1个小时出头,非常糟糕,最后还是把前面乱改的部分删掉,然后重新理清思路再写,就AC了</p>
<div class="note note-info">
            <ol><li>做题要先把边界,特殊情况给考虑了;</li><li>要理清思路写,不要根据用例编码,乱了就重新捋一遍思路.</li></ol>
          </div>
<h3 id="重写官方思路-11"><a class="markdownIt-Anchor" href="#重写官方思路-11"></a> 重写官方思路</h3>
<h2 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> 287 寻找重复数🔴</h2>
<h3 id="题目描述-25"><a class="markdownIt-Anchor" href="#题目描述-25"></a> 题目描述</h3>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且<strong>只用常量级 <code>O(1)</code> 的额外空间</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,3,4,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,3,4,2]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3 :</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,3,3,3,3]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>
<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>
</ul>
<h3 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h3>
<p>一开始的思路完全错误,虽然AC了,但是没有遵循到题目所说的<strong>不修改数组<code>nums</code></strong>,我给它排了个序,但是确实只是开了常量级的额外空间</p>
<p>根据题目,我们知道需要遵守:</p>
<ul>
<li><strong>不修改数组nums</strong></li>
<li><strong>只允许开常量级O(1)的额外空间</strong></li>
</ul>
<p>如果没有第一条,排序就可以解决;如果没有第二条,用哈希表就可以解决.</p>
<p>但是这两条都得遵守,因此不知道怎么做了(想了好久,其实看到官方题解的<strong>二进制,二分法,快慢指针</strong>这三个方法名称,也试着往上面靠着来解决问题,但failed)</p>
<p>以下是看了一个<strong>快慢指针的思路</strong>:</p>
<p>题目说了数组值是在<code>[1,n]</code>这个区间内,且有n+1个数,且只有一个重复的整数,按照一种很乐观的想法,即区间内的每个数各取一个,并且随机重复一个,如n=5:<code>[1,2,3,4,5,3]</code>这种情况,当然,它的顺序是打乱的,如<code>[3,1,2,4,5,3]</code>,当然也有可能是并非n个值都取满,重复的数字重复次数&gt;2的情况,如n=5:<code>[3,2,2,4,5,2]</code></p>
<p>如果按<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的情况来说,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的散点图是符合题意的,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \in 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的情况则是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">R_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>上随机取一个值,至此是符合题意的,而将其打乱,则亦符合题意,因此,我们可以知道除了0这个元素,我们需要指定它到达,别的可以通过:<code>x = nums[x] </code>到达(可以想象成一个x从1到n,y从1到n的棋盘,0则是一个随机的起点),因此<code>x</code>的初值可以是0,为什么会说这个呢?</p>
<p>因为可以把这一个数组想象成是一个带环的链表,起点元素0是<code>ListNode*</code>,而<code>nums[0]</code>是<code>ListNode*</code>,也即是<code>0-&gt;nums[0]</code>这也很符合我们的认知,而<code>nums[0]</code>是在[1,n]这个区间的,即是上面将其想象成一个棋盘的原因,即<code>nums[0]</code>的next是<code>nums[nums[0]]</code></p>
<p>根据题意,确实可以将其以此方式想象成是一个链表,<code>x=0;nums[x] -&gt; nums[nums[x]] -&gt;...</code>.以<code>[2,1,3,4,5,3]</code>为例,有:</p>
<p><code>2-&gt;3-&gt;4-&gt;5-&gt;3-&gt;4-&gt;5</code>,可知,<strong>这种方式起的链表,不会包含原始数据中所有的值,但会在遇到重复的值的时候,陷入对应的循环,这个循环就是我们链表中的环,而这个循环的入口,就是重复的数值!</strong></p>
<p>因此目标转换为了找链表的环的入口,链表有环,就或多或少会牵扯到快慢指针了.以<code>[1,2,3,4,5,3]</code>为例,以上述方式写出其链表形式有:</p>
<pre class="mermaid">graph LR
1-->2;2-->3;3-->4;4-->5;5-->3;</pre>
<p>快指针fast和慢指针slow会在环内相遇(毕竟速度不同),假设慢指针走了n步,快指针是它的两倍,即走了2n步,则有快指针fast在相遇处走多n步即绕一圈遇到的慢指针slow,从起点1到入口3设为m,则慢指针slow在环内走了n-m步,当它再走m步,则相当于转了一圈,就到了<strong>环的入口</strong>,即得到了重复的值,因此在它们相遇时可以起多一个指针从起点走,直到和慢指针slow碰头,则说明当前的值为重复的值</p>
<p>重写代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">[1,2,3,4,5,3]</span><br><span class="hljs-comment">1,2,[3,4,5],[3,4,5],...</span><br><span class="hljs-comment">fast:2,4,3,5</span><br><span class="hljs-comment">slow:1,2,3 | 4,5,3·</span><br><span class="hljs-comment">ans:       | 1,2,3·</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>; <span class="hljs-comment">// 三个指针</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            fast = nums[nums[fast]];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(fast == slow)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            slow = nums[slow];<br>            ans = nums[ans];<br>            <span class="hljs-keyword">if</span>(slow == ans)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-12"><a class="markdownIt-Anchor" href="#重写官方思路-12"></a> 重写官方思路</h3>
<p>没看官方思路,看了别人题解的做法.</p>
<h2 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> 20 有效的括号</h2>
<h3 id="题目描述-26"><a class="markdownIt-Anchor" href="#题目描述-26"></a> 题目描述</h3>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li>
</ul>
<h3 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h3>
<h3 id="重写官方思路-13"><a class="markdownIt-Anchor" href="#重写官方思路-13"></a> 重写官方思路</h3>
<h2 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215 数组中的第k个最大元素🔴</h2>
<h3 id="题目描述-27"><a class="markdownIt-Anchor" href="#题目描述-27"></a> 题目描述</h3>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<h3 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h3>
<p>像这种要找第几个最大元素,第几个最小元素,其实考察的点都是堆排序,这里我实现的是一个降序排序,即通过构建一个小顶堆,然后交换首尾元素,然后下沉根节点以满足小顶堆结构,直至整个序列有序</p>
<p>但其实这种方法不是很好,别人有一种优化的算法,但是没看明白</p>
<h3 id="重写官方思路-14"><a class="markdownIt-Anchor" href="#重写官方思路-14"></a> 重写官方思路</h3>
<h2 id="234-回文链表"><a class="markdownIt-Anchor" href="#234-回文链表"></a> 234 回文链表</h2>
<h3 id="题目描述-28"><a class="markdownIt-Anchor" href="#题目描述-28"></a> 题目描述</h3>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p>**进阶：**你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<h3 id="思路-28"><a class="markdownIt-Anchor" href="#思路-28"></a> 思路</h3>
<h3 id="重写官方思路-15"><a class="markdownIt-Anchor" href="#重写官方思路-15"></a> 重写官方思路</h3>
<h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206 反转链表</h2>
<h3 id="题目描述-29"><a class="markdownIt-Anchor" href="#题目描述-29"></a> 题目描述</h3>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h3 id="思路-29"><a class="markdownIt-Anchor" href="#思路-29"></a> 思路</h3>
<h3 id="重写官方思路-16"><a class="markdownIt-Anchor" href="#重写官方思路-16"></a> 重写官方思路</h3>
<h2 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200 岛屿数量</h2>
<h3 id="题目描述-30"><a class="markdownIt-Anchor" href="#题目描述-30"></a> 题目描述</h3>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
<h3 id="思路-30"><a class="markdownIt-Anchor" href="#思路-30"></a> 思路</h3>
<h3 id="重写官方思路-17"><a class="markdownIt-Anchor" href="#重写官方思路-17"></a> 重写官方思路</h3>
<h2 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站"></a> 134 加油站</h2>
<h3 id="题目描述-31"><a class="markdownIt-Anchor" href="#题目描述-31"></a> 题目描述</h3>
<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: gas = [2,3,4], cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 10^4</code></li>
</ul>
<h3 id="思路-31"><a class="markdownIt-Anchor" href="#思路-31"></a> 思路</h3>
<h3 id="重写官方思路-18"><a class="markdownIt-Anchor" href="#重写官方思路-18"></a> 重写官方思路</h3>
<h2 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> 155 最小栈</h2>
<h3 id="题目描述-32"><a class="markdownIt-Anchor" href="#题目描述-32"></a> 题目描述</h3>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li>
<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>
<li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li>
</ul>
<h3 id="思路-32"><a class="markdownIt-Anchor" href="#思路-32"></a> 思路</h3>
<p>这道题,感觉自己把自己绕进去了,因为看着题目说要构建最小栈,于是想,栈的push和pop执行也很快,那么题目要求常数时间检索到最小元素,就感觉应该三个都是常数时间的级别</p>
<p>关于栈的构建其实很简单,只要用个vector一类的容器便可以解决,<code>push()</code>对应<code>push_back()</code>,<code>pop()</code>对应<code>pop_back()</code>,<code>top()</code>对应<code>back()</code></p>
<div class="note note-info">
            <p>后面看一个外国人的这道题的代码时,用的是链表来构建栈,不过是头插构建(这让我想到反转链表),这样top就是头节点,pop也就是头节点的移动,push也就是头插,而且关于常数时间检索最小值的处理也很直接,直接通过min来处理当前头值对应的最小值和新值,由此得到最小值</p>
          </div>
<p>而关于常数时间检索最小值,又觉得是本题的关键,可以在push和pop的时候维持一个有序的链表(其实一开始是lolored提出来的,因为我做题目纠结在一些点上会宕机),因为链表增删方便且快速,而有序则在push和pop的时候来进行维护,其中头节点是最小的值(升序的链表),其实一开始会担心这样写会不会超时,但最终其实还是AC了的,然后lolored说这个链表是双向链表,但其实单向应该就ok,毕竟也需要遍历链表嘛,而且也没利用到尾节点干嘛,但考虑到前面LRUCache那道题我用的是list而非自己写的双向链表,便也写了双向链表</p>
<h3 id="重写官方思路-19"><a class="markdownIt-Anchor" href="#重写官方思路-19"></a> 重写官方思路</h3>
<p>官方思路十分简洁,通过两个stack来模拟最小栈,一个是数值的栈,一个是最小值的栈,需要注意这两个的push和pop是同步的,不过最小值的栈存储的是当前对应stack的最小值,只需要每次都拿自己的top和新来的value进行一下比较就好,最小的就push进去.</p>
<h2 id="lcp-52-二叉搜索树染色"><a class="markdownIt-Anchor" href="#lcp-52-二叉搜索树染色"></a> LCP 52 二叉搜索树染色</h2>
<h3 id="题目描述-33"><a class="markdownIt-Anchor" href="#题目描述-33"></a> 题目描述</h3>
<p>欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。</p>
<p>每位勇士面前设有一个<strong>二叉搜索树</strong>的模型，模型的根节点为 <code>root</code>，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， <code>ops[i] = [type, x, y]</code> 表示第 <code>i</code> 次操作为：</p>
<ul>
<li><code>type</code> 等于 0 时，将节点值范围在 <code>[x, y]</code> 的节点均染蓝</li>
<li><code>type</code> 等于 1 时，将节点值范围在 <code>[x, y]</code> 的节点均染红</li>
</ul>
<p>请返回完成所有染色后，该二叉树中红色节点的数量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>题目保证对于每个操作的 <code>x</code>、<code>y</code> 值定出现在二叉搜索树节点中</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]</code></p>
<p>输出：<code>2</code></p>
<p>解释： 第 0 次操作，将值为 2、3、4 的节点染红； 第 1 次操作，将值为 1、2、3 的节点染红； 第 2 次操作，将值为 3、4、5 的节点染蓝； 因此，最终值为 1、2 的节点为红色节点，返回数量 2<img src="https://pic.leetcode-cn.com/1649833948-arSlXd-image.png" srcset="/img/loading.gif" lazyload alt="image.png" /></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>root = [4,2,7,1,null,5,null,null,null,null,6]</code> <code>ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]</code></p>
<p>输出：<code>5</code></p>
<p>解释： 第 0 次操作，将值为 2 的节点染蓝； 第 1 次操作，将值为 1、2、4、5 的节点染红； 第 2 次操作，将值为 4、5 的节点染蓝； 第 3 次操作，将值为 5、6、7 的节点染红； 因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5<img src="https://pic.leetcode-cn.com/1649833763-BljEbP-image.png" srcset="/img/loading.gif" lazyload alt="image.png" /></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= 二叉树节点数量 &lt;= 10^5</code></li>
<li><code>1 &lt;= ops.length &lt;= 10^5</code></li>
<li><code>ops[i].length == 3</code></li>
<li><code>ops[i][0]</code> 仅为 <code>0</code> or <code>1</code></li>
<li><code>0 &lt;= ops[i][1] &lt;= ops[i][2] &lt;= 10^9</code></li>
<li><code>0 &lt;= 节点值 &lt;= 10^9</code></li>
</ul>
<h3 id="思路-33"><a class="markdownIt-Anchor" href="#思路-33"></a> 思路</h3>
<p>我的思路是中序遍历获取树的节点值(因为你树是bst,但其实后面用到的容器如果是map或set的话,因为这俩容器底层实现是红黑树,所以其实前序遍历也行,毕竟最终迭代器遍历也是按升序的顺序遍历的),然后用一个map把数据装着,key用节点值表示,而val则是0-蓝色,1-红色.然后迭代器遍历ops,根据(*ops_iter)[1]和(*ops_iter)[2]的值,也就是x,y,因为恒存在,所以可以通过<code>find()</code>获得它们的迭代器,然后由iter_x遍历到iter_y,给它们的属性值second设置op值(注意迭代器没有重载大于小于,只有等于不等于运算符,所以iter_y在外面设置一下second),然后这个二重循环完了之后,对map用迭代器遍历,统计值为1的key,这样就获得了最终染色为红色的节点数目.</p>
<p>思路和写法是对的,但是!会超时;</p>
<p>lolored给我提供了一个建议:倒序思考看看</p>
<p>倒序的好处是:每个点的状态都是最终确定的,是蓝的就是蓝的,是红的就是红的,不会被覆盖.但是要知道一个点可能被多个区间重叠,即会多次被访问,可以通过标志位去处理(当时没往这里想,应该是可行的,不知道会不会超时),也可以通过删除点去处理(我当时想的是删除区间),但是如何知道一个区间被处理完了呢,这就要用到<code>lower_bound()</code>这个神奇的函数了,这个函数可以根据你给的值,找到<code>&gt;=</code>该值的最近的迭代器(这个函数针对的是有序的情况,而set,map这些天生就是有序),那这样很利于节点的删除,而且一个点被删了的话,找到的就是<code>end()</code>,如果一个x<code>&gt;=</code>y那也说明区间被删干净了,因为这时候<code>lower_bound()</code>找到的是越过了y值的迭代器,而且这样还可以统计最终为红色的节点数目,省了另开一个循环统计的时间</p>
<h3 id="重写官方思路-20"><a class="markdownIt-Anchor" href="#重写官方思路-20"></a> 重写官方思路</h3>
<p>这里是依据别人的实现思路重写的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组"><a class="markdownIt-Anchor" href="#560-和为k的子数组"></a> 560 和为k的子数组</h2>
<h3 id="题目描述-34"><a class="markdownIt-Anchor" href="#题目描述-34"></a> 题目描述</h3>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-10^7 &lt;= k &lt;= 10^7</code></li>
</ul>
<h3 id="思路-34"><a class="markdownIt-Anchor" href="#思路-34"></a> 思路</h3>
<p>本题需要统计子数组和,无需变动原数组,且是频繁统计子数组和,因此想到需要<strong>构造前缀和数组</strong>,不然的话,那就得弄个<code>sum(int start,int end)</code>来计算区间和,则这样会加大时间开销,不如遍历一遍原数组,构造前缀和数组</p>
<p>然后找合适条件的子数组,则是双重循环,计算一下所有子数组和,满足和为k的则cnt++,最终return cnt</p>
<p>看了别人的思路,可以采用哈希表对这个统计过程进行优化(没细看,大致思路:可以通过一个无序map来放[前缀和:前缀和出现的次数],然后通过计算前缀和的时候,看看[k-当前前缀和]这个前缀和在无序哈希表中是否存在,存在的话,则cnt加上该键值对的值(因为1个当前的前缀和,可以和该键值对的值分别对应搭配,构建出k来))</p>
<h3 id="重写官方思路-21"><a class="markdownIt-Anchor" href="#重写官方思路-21"></a> 重写官方思路</h3>
<h2 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> 203 移除链表元素</h2>
<h3 id="题目描述-35"><a class="markdownIt-Anchor" href="#题目描述-35"></a> 题目描述</h3>
<h3 id="思路-35"><a class="markdownIt-Anchor" href="#思路-35"></a> 思路</h3>
<h3 id="重写官方思路-22"><a class="markdownIt-Anchor" href="#重写官方思路-22"></a> 重写官方思路</h3>
<h2 id="208-实现trie前缀树"><a class="markdownIt-Anchor" href="#208-实现trie前缀树"></a> 208 实现Trie(前缀树)</h2>
<h3 id="题目描述-36"><a class="markdownIt-Anchor" href="#题目描述-36"></a> 题目描述</h3>
<h3 id="思路-36"><a class="markdownIt-Anchor" href="#思路-36"></a> 思路</h3>
<p>最初思路很质朴,这种题目肯定在操作上卡时间,尽量选个插入搜索都快的,关于<code>startswith</code>这种前缀匹配的函数,要手撸.那插入和搜索快的就是哈希表,因此选了<code>unordered_set&lt;int&gt;</code>来存,关于<code>startswith</code>函数的实现则是比较朴素的,遍历哈希表,然后用prefix的长度去截取字串的长度(就是substr嘛),然后比较有无满足的字串,有则置标志位跳出循环,返回true,没有就返回false</p>
<p>AC了,但是时间也只是刚好过线</p>
<h3 id="重写官方思路-23"><a class="markdownIt-Anchor" href="#重写官方思路-23"></a> 重写官方思路</h3>
<p>参考了别人的思考,了解了Trie这种神奇的结构:<strong>非典型的多叉树</strong></p>
<p>它的节点定义是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    Trie* next[<span class="hljs-number">26</span>];<br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>
<p>跟别的多叉树不同,别的多叉树里面会存值和指向其所负责的孩子节点;而这里存着的是一个<strong>布尔值</strong>,<strong>表示</strong>到没到终点(即是否是<strong>一个单词的结束</strong>),而<strong>next指针指向的是下一个字符</strong>,如&quot;sea&quot;,&quot;shell&quot;这样的单词,第一个Trie的next的<code>'s'-'a'</code>处索引到的是指向下一个Trie,而此时该索引的指针非nullptr则表示,已有单词的字符是以<code>'s'</code>开头</p>
<p>构建的前缀树可以用于自动补全</p>
<p>清楚了它的节点定义后,可以根据题目要求写出三个函数实现了(<code>insert | search | startswith</code>)</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">前缀树:非典型的多节点树</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">bool</span> end;<br>    Trie* next[<span class="hljs-number">26</span>];<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;        <br>        end = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">memset</span>(next,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(next));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:word)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>] != <span class="hljs-literal">nullptr</span>)&#123;<br>                node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Trie *_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>                node-&gt;next[c<span class="hljs-number">-97</span>] = _node;<br>                node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>            &#125;<br>        &#125;<br>        node-&gt;end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c:word)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;end;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; c : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(node-&gt;next[c<span class="hljs-number">-97</span>]==<span class="hljs-literal">nullptr</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            node = node-&gt;next[c<span class="hljs-number">-97</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器"><a class="markdownIt-Anchor" href="#11-盛最多水的容器"></a> 11 盛最多水的容器</h2>
<h3 id="题目描述-37"><a class="markdownIt-Anchor" href="#题目描述-37"></a> 题目描述</h3>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h3 id="思路-37"><a class="markdownIt-Anchor" href="#思路-37"></a> 思路</h3>
<p>题目的意思是:找height中的两个值:以索引差值为宽度,以高度小者为高度,二者相乘得到的面积即为所求area,欲求最大的area:<code>int area = (j-i)*min(height[j],height[i])</code>,于是有:</p>
<ol>
<li>最朴素的想法,先定右边界j,然后移动左边界i,左边界&lt;右边界(不然就是0了),二次循环,暴力解法.结果超时,意料之中;</li>
<li>想着在这个方法能不能dp,dp的状态/子问题被描述为:以i为终点的最大雨量是:<code>dp[i]</code>写了好几个状态的表达,发现前后没啥关联.就是<code>dp[0]</code>和<code>dp[1]</code>没啥共同的部分,每个部分算的都是都很独立,无法减少计算,故舍弃;</li>
<li>如果高度我无法决定,我想要在现有高度下面积最大,则需要宽度最大,基于此,分了两个二重循环写了两个求面积公式,之所以分两个,是因为中点左侧的数据,宽度最大是与最右端点计算;中点及其右侧端点的最大宽度是与最左端点计算,这种实际是方法1的变体:从每个端点的最大面积出发,因为最终的最大面积是立足于某个端点的最大面积,所以求了所有端点的最大面积,最终的最大面积也就在里面了.这种方法较1做了些剪枝</li>
</ol>
<h3 id="重写官方思路-24"><a class="markdownIt-Anchor" href="#重写官方思路-24"></a> 重写官方思路</h3>
<p><strong>双指针</strong>.我没有想过这道题可以这样做…</p>
<p>主要思想是:以0作为左端点,以n-1作为右端点,所成面积是一个值,这时候选对应height值小的进行索引变动,直至left不再满足小于right,就跳出循环</p>
<h2 id="3-无重复字符的最长字串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长字串"></a> 3 无重复字符的最长字串</h2>
<h3 id="题目描述-38"><a class="markdownIt-Anchor" href="#题目描述-38"></a> 题目描述</h3>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h3 id="思路-38"><a class="markdownIt-Anchor" href="#思路-38"></a> 思路</h3>
<p>一开始的思路完全错误,因为我的移动会越过一些不重复的字符,且因为用的方法比较诡异,无法修改,遂放弃;</p>
<p>后来仔细审了下题目,发现我的原方法错的离谱,但依旧过了300+个用例😂</p>
<p>不难发现针对如下用例:</p>
<p><code>abcabcbb</code>,当遇到第二个a的时候我们显然需要移动<u>1</u>个值,使之以b开头;</p>
<p><code>abcbcaee</code>,当遇到第二个b的时候显然需要移动<u>2</u>个值,使之以c开头;</p>
<p>也就是说<strong>当遇到前面已出现的值的时候,需要跳过这个已出现过的值,也即是下一个字串要从这个字符之后开始</strong></p>
<p>也即是需要记录开始的索引<code>start_index</code>,然后找到重复的字符,计算下一个<code>start_index</code>,通过<code>重复字符的索引-start_index+1</code>跳到重复字符的下一位(就是新的<code>start_index</code>),然后重新组织子串,如此统计无重复的最长字串,直至<code>start_index</code>大于len或者说<code>start_index</code>的offset走到len了(即一种是起始索引超过了len,一种是字串走完了)</p>
<p>这样的结果是勉强过线的结果,还在这基础上改了一版,但超时了😭</p>
<h3 id="重写官方思路-25"><a class="markdownIt-Anchor" href="#重写官方思路-25"></a> 重写官方思路</h3>
<p>见到了一种一步一步移动的方法,大致思路如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(len &lt;=<span class="hljs-number">1</span>) <br>   	<span class="hljs-keyword">return</span> len;<br><span class="hljs-comment">// start表示滑动窗口的左边界</span><br><span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>,mx=<span class="hljs-number">0</span>;<br>unordered_set&lt;<span class="hljs-keyword">char</span>&gt; st;<br><span class="hljs-comment">// abcbcaad</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>    <span class="hljs-comment">// 存在重复元素</span><br>    <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">find</span>(s[i])!=st.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-comment">// 擦除左端元素并右移,直至把重复元素擦除</span><br>        st.<span class="hljs-built_in">erase</span>(s[start]);<br>        start++;<br>    &#125;<br>    st.<span class="hljs-built_in">insert</span>(s[i]);<br>    mx = <span class="hljs-built_in">max</span>(mx,i-start+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure>
<p>上面的方法中规定了滑动窗口的左端为start,i则为滑动窗口的右端(一直移动),若遇到已存在的元素(通过find找),那就不断删除左端元素,并将左端向右移动一位,直至去掉这个重复元素,并将新元素加入哈希表中,然后统计此刻的字串大小与mx比较,取大者</p>
<p>上面的方法的弊端在于用了find,它是一个比较耗时的操作,且右端的i可以换个更加通俗的名字:end</p>
<p>可以使用如map之类的数据结构来存放数据,已有的数据则为1,没有(默认为0)则为0,若数据重复,则计数一次,在进一步的循环中,不断移出值,更改start,直到计数重新置为0,则有如下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> len;<br>unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; mp;<br><span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>,mx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(end&lt;len)&#123;<br>    <span class="hljs-keyword">if</span>(mp[s[end]] &gt; <span class="hljs-number">0</span>)<br>        count++;<br>    mp[s[end]]++;<br>    <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(mp[s[start]]&gt;<span class="hljs-number">1</span>)<br>            count--;<br>        mp[s[start]]--;<br>        start++;<br>    &#125;<br>    mx = <span class="hljs-built_in">max</span>(mx,end-start+<span class="hljs-number">1</span>);<br>    end++;<br>&#125;<br><span class="hljs-keyword">return</span> mx;<br></code></pre></td></tr></table></figure>
<h2 id="876-链表的中间节点"><a class="markdownIt-Anchor" href="#876-链表的中间节点"></a> 876 链表的中间节点</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<h3 id="思路-39"><a class="markdownIt-Anchor" href="#思路-39"></a> 思路</h3>
<p>快慢指针,这样找到的中间节点是中间节点或中间偏下的节点</p>
<h2 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> 21 合并两个有序链表</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<h3 id="思路-40"><a class="markdownIt-Anchor" href="#思路-40"></a> 思路</h3>
<p>归并排序的合并思想</p>
<h2 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> 148 排序链表🔴</h2>
<h3 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h3>
<h3 id="思路-41"><a class="markdownIt-Anchor" href="#思路-41"></a> 思路</h3>
<p>归并排序进行链表排序,需要①876找到中间节点;②21合并两个有序链表,同时掌握归并排序的知识</p>
<h2 id="lcr140-训练计划ii"><a class="markdownIt-Anchor" href="#lcr140-训练计划ii"></a> LCR140 训练计划Ⅱ</h2>
<h3 id="题目-4"><a class="markdownIt-Anchor" href="#题目-4"></a> 题目</h3>
<p>找链表中的倒数第N个节点</p>
<h3 id="思路-42"><a class="markdownIt-Anchor" href="#思路-42"></a> 思路</h3>
<p>快慢指针,快指针先走N步,再快慢指针同步距行进,直至快指针nullptr了,就说明慢指针走到了</p>
<h2 id="19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第n个节点"></a> 19 删除链表的倒数第N个节点</h2>
<h3 id="题目-5"><a class="markdownIt-Anchor" href="#题目-5"></a> 题目</h3>
<h3 id="思路-43"><a class="markdownIt-Anchor" href="#思路-43"></a> 思路</h3>
<p>思路同上,也是快慢指针,快的先走N步,然后快慢指针再同步距行进,不过需要注意,可能删的是头节点,则快指针此时直接走到nullptr了,因此需要分支判断一下</p>
<h2 id="92-反转链表ii"><a class="markdownIt-Anchor" href="#92-反转链表ii"></a> 92 反转链表Ⅱ</h2>
<h3 id="题目-6"><a class="markdownIt-Anchor" href="#题目-6"></a> 题目</h3>
<h3 id="思路-44"><a class="markdownIt-Anchor" href="#思路-44"></a> 思路</h3>
<p>需分情况讨论,首先走到区间左右端点,然后记录左右端点的左侧和右侧端点,方便后面拼接,同时把此时的slow节点记录下,后面要跟尾巴拼接,局部区间反转完后,拼接链表即可.</p>
<p>但需要注意,可能存在整个链表反转,以及区间左端点是head的情况,需要分类讨论一下</p>
<p>这道题相对做得比较混乱</p>
<h2 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合"></a> 17 电话号码的字母组合</h2>
<h3 id="题目-7"><a class="markdownIt-Anchor" href="#题目-7"></a> 题目</h3>
<h3 id="思路-45"><a class="markdownIt-Anchor" href="#思路-45"></a> 思路</h3>
<p>每个数字对应一个字串,每次从各自的一个字串取一个字符,按数字的顺序排列.找出所有排列的情况.通过DFS实现,是顺序已定的排列问题(个人思路里说的排列和组合,更多的是往全排列以及组合模板上靠的排列组合思想)</p>
<h2 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1 两数之和</h2>
<h3 id="题目-8"><a class="markdownIt-Anchor" href="#题目-8"></a> 题目</h3>
<h3 id="思路-46"><a class="markdownIt-Anchor" href="#思路-46"></a> 思路</h3>
<p>哈希表(虽然一开始我是排序+双指针+找索引的方式,而且找索引还不能用unordered_map,比如3+3=6,key唯一的情况会找不到两个索引,用的是朴素的找索引方式找的,很慢)的思路则非常好,一重循环直接完成</p>
<h2 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> 2 两数相加</h2>
<h3 id="题目-9"><a class="markdownIt-Anchor" href="#题目-9"></a> 题目</h3>
<h3 id="思路-47"><a class="markdownIt-Anchor" href="#思路-47"></a> 思路</h3>
<p>普通的链表加法,但要细心,因为进位可能是9999+1的情况,且最后的carry_bit也要检查是否要new多一个节点</p>
<h2 id="45-跳跃游戏ii"><a class="markdownIt-Anchor" href="#45-跳跃游戏ii"></a> 45 跳跃游戏Ⅱ</h2>
<h3 id="题目-10"><a class="markdownIt-Anchor" href="#题目-10"></a> 题目</h3>
<h3 id="思路-48"><a class="markdownIt-Anchor" href="#思路-48"></a> 思路</h3>
<ul>
<li>dp</li>
<li>滚动的去找</li>
<li>在每次的跳跃中,已跳跃的步数都是一样的,在遇到此次跳跃的边界end前,要更新下一次跳跃的最远边界,然后在更新边界的时候,也更新已跳跃的步数即可(这个是看别人的方法学来的)</li>
</ul>
<h2 id="781-森林中的兔子"><a class="markdownIt-Anchor" href="#781-森林中的兔子"></a> 781 森林中的兔子</h2>
<h3 id="题目-11"><a class="markdownIt-Anchor" href="#题目-11"></a> 题目</h3>
<h3 id="思路-49"><a class="markdownIt-Anchor" href="#思路-49"></a> 思路</h3>
<p>逻辑题</p>
<h2 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> 15 三数之和</h2>
<h3 id="题目-12"><a class="markdownIt-Anchor" href="#题目-12"></a> 题目</h3>
<h3 id="思路-50"><a class="markdownIt-Anchor" href="#思路-50"></a> 思路</h3>
<p>排序+左右指针,由左及右遍历,根据索引定左右指针,找match的;当下一次索引的值与左边的值是一样的则直接跳过,不必要重复计算,然后可以用set对收集到的三数vector进行去重,最后灌到ans即可</p>
<h2 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> 102 二叉树的层序遍历</h2>
<h3 id="题目-13"><a class="markdownIt-Anchor" href="#题目-13"></a> 题目</h3>
<h3 id="思路-51"><a class="markdownIt-Anchor" href="#思路-51"></a> 思路</h3>
<p>BFS模板</p>
<h2 id="128-最长连续序列"><a class="markdownIt-Anchor" href="#128-最长连续序列"></a> 128 最长连续序列</h2>
<h3 id="题目-14"><a class="markdownIt-Anchor" href="#题目-14"></a> 题目</h3>
<h3 id="思路-52"><a class="markdownIt-Anchor" href="#思路-52"></a> 思路</h3>
<p>哈希表,逻辑理通,即可解决(如何用哈希表去找到最长连续序列,最长则意味着start是它)</p>
<h2 id="54-螺旋矩阵"><a class="markdownIt-Anchor" href="#54-螺旋矩阵"></a> 54 螺旋矩阵</h2>
<h3 id="题目-15"><a class="markdownIt-Anchor" href="#题目-15"></a> 题目</h3>
<h3 id="思路-53"><a class="markdownIt-Anchor" href="#思路-53"></a> 思路</h3>
<p>四个边界u,d,l,r,边界如u&gt;d则跳出,但可==</p>
<h2 id="283-移动零"><a class="markdownIt-Anchor" href="#283-移动零"></a> 283 移动零</h2>
<h3 id="题目-16"><a class="markdownIt-Anchor" href="#题目-16"></a> 题目</h3>
<h3 id="思路-54"><a class="markdownIt-Anchor" href="#思路-54"></a> 思路</h3>
<p>双指针,区间[l,r)圈养了一堆0,有点像冒泡一样,一直交换非0数与0</p>
<h2 id="438-找到字符串的所有字母异位词"><a class="markdownIt-Anchor" href="#438-找到字符串的所有字母异位词"></a> 438 找到字符串的所有字母异位词</h2>
<h3 id="题目-17"><a class="markdownIt-Anchor" href="#题目-17"></a> 题目</h3>
<h3 id="思路-55"><a class="markdownIt-Anchor" href="#思路-55"></a> 思路</h3>
<p>滑动窗口,一般都是左指针out,右指针in,通过一定条件判断是否match,则push_back,然后左指针再out掉一个字符这样(具体参考板子部分&quot;“滑动窗口”&quot;的内容)</p>
<h2 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯"></a> 70 爬楼梯</h2>
<h3 id="题目-18"><a class="markdownIt-Anchor" href="#题目-18"></a> 题目</h3>
<h3 id="思路-56"><a class="markdownIt-Anchor" href="#思路-56"></a> 思路</h3>
<p>经典dp题,走到第n阶楼梯的方式是从第n-1阶往上走,或者n-2阶往上走</p>
<h2 id="76-最小覆盖字串"><a class="markdownIt-Anchor" href="#76-最小覆盖字串"></a> 76 最小覆盖字串</h2>
<h3 id="题目-19"><a class="markdownIt-Anchor" href="#题目-19"></a> 题目</h3>
<h3 id="思路-57"><a class="markdownIt-Anchor" href="#思路-57"></a> 思路</h3>
<p>从字串s中找到覆盖字串t的最小字串,滑动窗口实现</p>
<h2 id="567-字符串的排列"><a class="markdownIt-Anchor" href="#567-字符串的排列"></a> 567 字符串的排列</h2>
<h3 id="题目-20"><a class="markdownIt-Anchor" href="#题目-20"></a> 题目</h3>
<h3 id="思路-58"><a class="markdownIt-Anchor" href="#思路-58"></a> 思路</h3>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<h2 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> 239 滑动窗口最大值</h2>
<h3 id="题目-21"><a class="markdownIt-Anchor" href="#题目-21"></a> 题目</h3>
<h3 id="思路-59"><a class="markdownIt-Anchor" href="#思路-59"></a> 思路</h3>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<h2 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像"></a> 48 旋转图像</h2>
<h3 id="题目-22"><a class="markdownIt-Anchor" href="#题目-22"></a> 题目</h3>
<h3 id="思路-60"><a class="markdownIt-Anchor" href="#思路-60"></a> 思路</h3>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<h2 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> 78 子集</h2>
<h3 id="题目-23"><a class="markdownIt-Anchor" href="#题目-23"></a> 题目</h3>
<h3 id="思路-61"><a class="markdownIt-Anchor" href="#思路-61"></a> 思路</h3>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<h2 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> 94 二叉树的中序遍历</h2>
<h3 id="题目-24"><a class="markdownIt-Anchor" href="#题目-24"></a> 题目</h3>
<h3 id="思路-62"><a class="markdownIt-Anchor" href="#思路-62"></a> 思路</h3>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<h2 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> 39 组合总和</h2>
<h3 id="题目-25"><a class="markdownIt-Anchor" href="#题目-25"></a> 题目</h3>
<h3 id="思路-63"><a class="markdownIt-Anchor" href="#思路-63"></a> 思路</h3>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<h2 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏"></a> 55 跳跃游戏</h2>
<h3 id="题目-26"><a class="markdownIt-Anchor" href="#题目-26"></a> 题目</h3>
<h3 id="思路-64"><a class="markdownIt-Anchor" href="#思路-64"></a> 思路</h3>
<h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3>
<h2 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> 22 括号生成</h2>
<h3 id="题目-27"><a class="markdownIt-Anchor" href="#题目-27"></a> 题目</h3>
<h3 id="思路-65"><a class="markdownIt-Anchor" href="#思路-65"></a> 思路</h3>
<h3 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h3>
<h2 id="994-腐烂的橘子"><a class="markdownIt-Anchor" href="#994-腐烂的橘子"></a> 994 腐烂的橘子</h2>
<h3 id="题目-28"><a class="markdownIt-Anchor" href="#题目-28"></a> 题目</h3>
<h3 id="思路-66"><a class="markdownIt-Anchor" href="#思路-66"></a> 思路</h3>
<h3 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h3>
<h2 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> 207 课程表</h2>
<h3 id="题目-29"><a class="markdownIt-Anchor" href="#题目-29"></a> 题目</h3>
<h3 id="思路-67"><a class="markdownIt-Anchor" href="#思路-67"></a> 思路</h3>
<h3 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h3>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/algorithm-learning/">algorithm learning</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GEMM-intrinsic优化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">Makefile简易使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'a350b9ea08704ac87b06dc853c4bada3'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
