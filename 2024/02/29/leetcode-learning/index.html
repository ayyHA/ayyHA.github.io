

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="learn learn learn">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="learn learn learn">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-learning">
<meta property="og:url" content="http://example.com/2024/02/29/leetcode-learning/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="learn learn learn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/15/aAFU2nBLR5VY7Z8.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/20/bw56tSoifDCcrGJ.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/03/19/DApaJQ6qH4lFwG8.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/12/H6h2EdPU5xSvKrB.png">
<meta property="og:image" content="https://s2.loli.net/2024/03/13/ZM7KdHErQTW2csP.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg">
<meta property="article:published_time" content="2024-02-29T06:01:02.000Z">
<meta property="article:modified_time" content="2024-03-30T17:23:28.322Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithm learning">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png">
  
  <title>leetcode-learning - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="leetcode-learning">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-02-29 14:01" pubdate>
        2024年2月29日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      39k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      121 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">leetcode-learning</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 天前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h2>
<p>🔴 -&gt; 一般是指hard的题目,且没pass出来的,就是连暴力解法都想不到的</p>
<p>🔵 -&gt; 表示十拿九稳的题目</p>
<h2 id="c的字符数组和c的string转换以及常用函数"><a class="markdownIt-Anchor" href="#c的字符数组和c的string转换以及常用函数"></a> C的字符数组和C++的string转换以及常用函数</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* c_s = s.<span class="hljs-built_in">c_str</span>();<br><br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>c++中通过导入iomanip,可以用fixed来使浮点数定位(无论double d 里的值是整数浮点数,统统给它输出浮点数形式)<br />通过setprecision(n)来确定整体数字位数,若没有结合fixed使用,则代表的位数是整数位+小数位<mark>n;结合fixed使用则代表的位数是小数位</mark>n</p>
          </div>
<h2 id="c一些流"><a class="markdownIt-Anchor" href="#c一些流"></a> C++一些流</h2>
<p>参考文件:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://vcsos.com/article/pageSource/160122/20160122233408.shtml">io流,文件流,字串流</a></li>
</ul>
<h2 id="一些stl容器回顾"><a class="markdownIt-Anchor" href="#一些stl容器回顾"></a> 一些STL容器回顾</h2>
<p>这里主要记着主要方法,后续有新的会来补充,以便于一开始训练的时候查方法,当然也会说一下不同容器/相似容器间的差别</p>
<p>参考资料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvshen/p/17839484.html">STL容器</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_57190374/article/details/127042161">C++常用容器介绍</a></li>
</ul>
<h3 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h3>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> vector</h4>
<h4 id="queue容器适配器"><a class="markdownIt-Anchor" href="#queue容器适配器"></a> queue[容器适配器]</h4>
<p>queue参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59068776/article/details/130549065">queue基本方法</a></p>
<h4 id="deque双端队列"><a class="markdownIt-Anchor" href="#deque双端队列"></a> deque(双端队列)</h4>
<p>相比于vector,可以更好更迅速的处理头部元素</p>
<h4 id="list双向链表"><a class="markdownIt-Anchor" href="#list双向链表"></a> list(双向链表)</h4>
<h4 id="forward_list单链表"><a class="markdownIt-Anchor" href="#forward_list单链表"></a> forward_list(单链表)</h4>
<h4 id="stack栈容器适配器"><a class="markdownIt-Anchor" href="#stack栈容器适配器"></a> stack(栈)[容器适配器]</h4>
<ul>
<li>push() #压入</li>
<li>pop() # 弹出</li>
<li>top() # get栈顶</li>
<li>back() # get栈底</li>
<li>empty()</li>
<li>size()</li>
</ul>
<p>不能通过索引遍历,用<code>while(!s.empty())</code>遍历</p>
<p>stack参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130857503">stack基本方法</a></p>
<h3 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h3>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h4>
<p>内部是通过<strong>红黑树</strong>实现的,<strong>去重且递增</strong>(自动有序),遍历只可以通过iterator遍历,插入值是insert的方式</p>
<p><img src="https://s2.loli.net/2024/03/27/kCuPm5slzJyDUB3.png" srcset="/img/loading.gif" lazyload alt="set方法大全" /></p>
<p>set参考资料:<a target="_blank" rel="noopener" href="https://blog.csdn.net/H1727548/article/details/130800542">set</a></p>
<h4 id="unordered_map"><a class="markdownIt-Anchor" href="#unordered_map"></a> unordered_map</h4>
<p>底层是通过<strong>哈希表实现的无序map</strong></p>
<h4 id="ordered_map"><a class="markdownIt-Anchor" href="#ordered_map"></a> ordered_map</h4>
<h2 id="一些板子"><a class="markdownIt-Anchor" href="#一些板子"></a> 一些板子</h2>
<p>写题记录总结,并记忆一些板子,以便后期快速完成题目</p>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3>
<h3 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h3>
<h2 id="一些数据结构回顾"><a class="markdownIt-Anchor" href="#一些数据结构回顾"></a> 一些数据结构回顾</h2>
<h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3>
<p>二叉搜索树(BST)是二叉树的一个特别概念,可以理解为排了序的二叉树</p>
<p>左孩子 &lt;= 根节点 &lt;= 右孩子</p>
<p>详细可见<a target="_blank" rel="noopener" href="https://ayyha.github.io/2022/10/15/BST,AVL%E6%A0%91,B%E6%A0%91,B+%E6%A0%91,%E7%BA%A2%E9%BB%91%E6%A0%91/">BST,AVL,B,B+,RBT</a></p>
<h2 id="每日一练"><a class="markdownIt-Anchor" href="#每日一练"></a> 每日一练</h2>
<h3 id="2864-最大二进制奇数"><a class="markdownIt-Anchor" href="#2864-最大二进制奇数"></a> 2864 最大二进制奇数</h3>
<h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4>
<h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4>
<h4 id="重写官方思路"><a class="markdownIt-Anchor" href="#重写官方思路"></a> 重写官方思路</h4>
<h3 id="2789-合并后数组中的最大元素"><a class="markdownIt-Anchor" href="#2789-合并后数组中的最大元素"></a> 2789 合并后数组中的最大元素</h3>
<h4 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h4>
<p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p>
<p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p>
<ul>
<li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li>
</ul>
<p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">21</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">3</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">21</span>,<span class="hljs-number">3</span>] 。<br>最终数组中的最大元素是 <span class="hljs-number">21</span> 。可以证明我们无法获得更大的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">11</span><br>解释：我们可以在数组上执行下述操作：<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">1</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br>- 选中 <span class="hljs-attr">i</span> = <span class="hljs-number">0</span> ，得到数组 <span class="hljs-attr">nums</span> = [<span class="hljs-number">11</span>] 。<br>最终数组中只有一个元素，即 <span class="hljs-number">11</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<h4 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h4>
<ol>
<li><strong>合并</strong></li>
<li><strong>找最大值</strong></li>
<li><strong>避免爆int边界</strong></li>
</ol>
<p>根据题目,我们可以知道我们会①合并满足条件的数组;②合并了之后它未必是最大值,可能有个很巨大的在一些比较奇怪的地方,比如最左边(因为中间的都会给合并,再大的都给它拼起来,但<code>nums[0]</code>就无能为力),因此我们可以在合并完,再比较一波</p>
<p>在提交的时候,原本我是利用<code>nums[i] +=nums[i+1]</code>来累加满足条件的值,但是会爆了signed int的可表达的值的边界,其实看题目的函数返回值<code>long long</code>,就知道可能有比较极端的用例会去爆了signed int的边界</p>
<p><strong>合并的方法仔细观察可以得值,从最右边往左遍历可以大数吃小数</strong>(if满足条件)</p>
<p><strong>我这里通过<code>tmp</code>来承接累加的值,当然它如果小于前面的就得给它置零,当然得跟max比一下,大的话就让max拿走了,然后最后再跟nums[0]一决高下比一比,最后返回.这里的tmp和max都是longlong类型的.</strong></p>
<p>注:以下的差距是在于我把后面的一个迭代找最大值换成了<code>max</code>和<code>nums[0]</code>比较得到的提升~</p>
<p><img src="https://s2.loli.net/2024/03/15/aAFU2nBLR5VY7Z8.jpg" srcset="/img/loading.gif" lazyload alt="maxArrayValue-effect" /></p>
<h4 id="重写官方思路-2"><a class="markdownIt-Anchor" href="#重写官方思路-2"></a> 重写官方思路</h4>
<h3 id="2684-矩阵中移动的最大次数"><a class="markdownIt-Anchor" href="#2684-矩阵中移动的最大次数"></a> 2684 矩阵中移动的最大次数</h3>
<h4 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h4>
<p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p>
<p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p>
<ul>
<li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code>、<code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li>
</ul>
<p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：grid = [[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：可以从单元格 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 开始并且按下面的路径移动：<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span> -&gt;</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<br>- <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>).<br>可以证明这是能够移动的最大次数。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/12/yetgrid4drawio.png" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[3,2,4],[2,1,9],[1,1,7]]</span><br>输出：<span class="hljs-number">0</span><br>解释：从第一列的任一单元格开始都无法移动。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 1000</code></li>
<li><code>4 &lt;= m * n &lt;= 10^5</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 10^6</code></li>
</ul>
<h4 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h4>
<p>当时写这道题目的时候是周六23点多吧,然后比较疲惫,也差不多三天没写题目了,有畏惧感,就没写出来,主要在纠结BFS和DFS的模板问题,大脑一直在思考BFS做层序遍历咋做的,对这道题就很烦躁,然后最后写了一种很暴力DFS的,但不知道怎么剪枝,卡在了(810/814)这个用例那,本想着用标签来表明已走过的路,但思路比较混乱,也不想写了,就直接看了答案.</p>
<p>对于此题,有一种类似BFS的做法,就是将矩阵从<code>[:,0]-&gt;[:,n-1]</code>这么来逐列遍历,然后目的是找可以走多长,最大就是<code>n</code>嘛,把右边可以走的路径点亮,然后看最远可以走到哪即可(比较抽象的描述,等等写完贴下方)</p>
<p>而对于DFS剪枝可以采用标签,还有一种针对此题,非常绝杀的:<code>grid[row][col]=0</code>当该点深搜完毕后,则给它置零!只要在我原来被卡住的代码里面加上这一句,通过并且耗时直接超了77%的人,非常恐怖的思想.细细想下来,这个设置还可以牵扯出类似动规的思想:</p>
<p>随机掉落到<code>(row,col)</code>这个点,它后面能到哪里取决于该点本身,而是否能到该点,则取决于前面的节点的值,意思即是,<code>(row,col)</code>这个点我们前面确定了是可以走的,后面它的路线其实是确定的,能走到的路也是确定的,有记载就好了,不用重复记载,因此它走完了它的路,就打一个走完的标志了,后面想要从这个点出发的点,知道了它是一个已完成的任务点,就不会走了,而设置的标志便是给它置零(因为整个数组都是正整数,置零了就走不过去了,不符合要求了),这种剪枝方法非常变态,因为是一条路径都给剪了,之后想往这走的都知道走过了,就不会走了.效率极高</p>
<p>原思路如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m,n,max;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>,row=<span class="hljs-number">0</span>,col=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(row=<span class="hljs-number">0</span>;row&lt;<span class="hljs-keyword">this</span>-&gt;m;row++)<br>            <span class="hljs-built_in">dfs</span>(grid,step,row,col);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid,<span class="hljs-keyword">int</span> step,<span class="hljs-keyword">int</span> row,<span class="hljs-keyword">int</span> col)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;n<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row<span class="hljs-number">-1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>            <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row][col+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row,col+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=<span class="hljs-keyword">this</span>-&gt;m<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">if</span>(grid[row][col] &lt; grid[row+<span class="hljs-number">1</span>][col+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,step+<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>,col+<span class="hljs-number">1</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max&lt;step)<br>                <span class="hljs-keyword">this</span>-&gt;max = step;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;max &lt; step)<br>            <span class="hljs-keyword">this</span>-&gt;max = step;<br>        grid[row][col]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>自写类BFS:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags; <span class="hljs-comment">//(表示是否可通行)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-comment">// 按列主序的方式遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; (flags[i][j] || j == <span class="hljs-number">0</span>))<br>                &#123;<br>                    max = max &lt; j ? j : max;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (i &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (grid[i][j + <span class="hljs-number">1</span>] &gt; grid[i][j])<br>                        flags[i][j + <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span> &amp;&amp; flags[i][j])<br>                    max = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>自写DFS(普通剪枝):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m, n, max;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxMoves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        max = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; flags;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            flags.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)&gt; dfs = [&amp;](<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col) -&gt; <span class="hljs-keyword">void</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (col &gt; max)<br>                max = col;<br>            <span class="hljs-keyword">if</span> (col &lt; n - <span class="hljs-number">1</span> &amp;&amp; !flags[row][col])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (row &gt; <span class="hljs-number">0</span> &amp;&amp; grid[row - <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row - <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (grid[row][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                    <span class="hljs-built_in">dfs</span>(row, col + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (row &lt; m - <span class="hljs-number">1</span> &amp;&amp; grid[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] &gt; grid[row][col])<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(row + <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>);<br>                &#125;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 走完了所有分支，下次别走这</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                flags[row][col] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 无路可走，其实可以不设这个</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; m; row++)<br>            <span class="hljs-built_in">dfs</span>(row, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> max;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/20/bw56tSoifDCcrGJ.png" srcset="/img/loading.gif" lazyload alt="2684-maxMoves-flags" /></p>
<p>如果把flags去掉，换成置零，就是一个点的分支走完，然后置零，性能（时间和空间）都超过了90%的人==（有点不解，我true别人也进不来，为啥置零会快那么多）==</p>
<h4 id="重写官方思路-3"><a class="markdownIt-Anchor" href="#重写官方思路-3"></a> 重写官方思路</h4>
<p>重写了一个大佬的思路（就看了思路，代码自己写的，都通过了）</p>
<h2 id="73-矩阵置零"><a class="markdownIt-Anchor" href="#73-矩阵置零"></a> 73 矩阵置零</h2>
<h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3>
<p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br>输出：<span class="hljs-string">[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[0].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(mn)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<p>当时我写的思路是暴力解法，就是用一个标记数组<code>nflags</code>标记列数，一个标记变量<code>mflags</code>标记行数，之所以这样设置标记是因为行主序的矩阵，一行里有一个是0，那就全部都是0；而列则需要逐行读的时候匹配（就是根据标记数组匹配）再置零。然后当一行全部置为0后，再把行标记变量<code>mflags</code>置否，最后根据标记数组<code>nflags</code>去重新扫一遍，避免有些列数匹配的元素没置零。</p>
<p>官方给出的方法（这里借鉴的是方法二）是采用两个标记数组来对元素为0的行列进行分别记录，然后再通过一个二重循环遍历，判断<code>row[i] || col[j]</code>来给元素置零。方法二则是在这个方法一的基础上，把两个标记数组用原矩阵的第一行和第一列来存储，而第一行和第一列的状态情况则用两个状态变量来存储，先处理除第一行和第一列外的剩余矩阵，然后再扫第一行和第一列，如果有0，则给它置零了。</p>
<h3 id="重写官方代码"><a class="markdownIt-Anchor" href="#重写官方代码"></a> 重写官方代码</h3>
<h2 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合"></a> 77 组合</h2>
<h3 id="题目描述-5"><a class="markdownIt-Anchor" href="#题目描述-5"></a> 题目描述</h3>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<p>当时写这题的时候看题目看了半天没看懂，后来才发现就是排列组合那个组合的意思，就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">C_n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.096108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>的意思。想了很久，用递归写的。其中n定了边界<code>[1,n]</code>,k定了一次要拿多少个数字出来。</p>
<p>当时的想法很质朴，就比如k=2那就需要两层循环，为3就需要3层循环，就用递归写（一开始想用别的，但想了很久，没想到）。然后最初提交的版本，漏判断了一个边界条件，还有一些简单的错误，改了之后就报超时的错，通过剪枝让其pass了。</p>
<p>官方思路则感觉很套路，很模板，但又很有道理，它利用一种回溯的思想来做，就是先从简单的二进制枚举来说起，比如有一个长度为n的序列，要求其所有子序列。那么则可以用一个游标cur来在<code>[1,n]</code>这个范围内由小到大的滑动，而每一个cur指向的字符/数字，则有选和不选两种情况，选了的进递归一次，不选的进递归一次，然后当游标cur滑过了边界则将值塞进结果数组里，并return。</p>
<p>而这个题目官方管它叫组合枚举，我感觉就是多了个临时值的大小判断，就是这个临时的数组它长度到k了，就给它塞进结果数组里，并return。然后再根据可能达不到k进行剪枝就好了。</p>
<h3 id="重写官方代码-2"><a class="markdownIt-Anchor" href="#重写官方代码-2"></a> 重写官方代码</h3>
<h2 id="86-分隔链表"><a class="markdownIt-Anchor" href="#86-分隔链表"></a> 86 分隔链表</h2>
<h3 id="题目描述-6"><a class="markdownIt-Anchor" href="#题目描述-6"></a> 题目描述</h3>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[2,1]</span>, x = 2<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>-200 &lt;= x &lt;= 200</code></li>
</ul>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<p>我一开始写这道题，只看到了示例2的情况，就是当<code>head.val == x</code>，因此直接进行了分类讨论，后来写着写着发现代码冗余很多，才发现一开始思路错了。不过最后还是做了出来，虽然比较暴力和耗了很长的时间。思路是要用两个指针，来做标识，分别是<code>cur_left</code>和<code>cur_right</code>，其中需要先确定<code>cur_right</code>的位置，就是第一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点的位置，因为此后要往前插入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点，而<code>cur_right</code>前面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lt x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的节点则为<code>cur_left</code>，掌管着左边界（因为要保留原来节点们的相对位置），之后遇到的<code>&lt; x</code>的节点就往这里面插入，然后滑动<code>cur_left</code>。当遇到<code>head.val == x</code>的情况，其实已经定好了<code>cur_right</code>，就是往左增加了一个节点，要移动head和<code>cur_left</code>节点为该节点。之后则化为上面的普通情况了。</p>
<p>官方思路，我看了一下觉得很符合题目意思，又看了一下题目描述，感觉就是在暗示你，把它分成两个链表来看待。即是有两个链表，<code>small_list</code>的值都小于<code>big_list</code>的，最后需要将<code>small_list</code>末尾节点的指针指向<code>big_list</code>的头指针，而<code>big_list</code>的末尾节点的指针需要置为<code>nullptr</code>，不然可能出错。</p>
<h3 id="重写官方代码-3"><a class="markdownIt-Anchor" href="#重写官方代码-3"></a> 重写官方代码</h3>
<h2 id="43-字符串相乘"><a class="markdownIt-Anchor" href="#43-字符串相乘"></a> 43 字符串相乘</h2>
<h3 id="题目描述-7"><a class="markdownIt-Anchor" href="#题目描述-7"></a> 题目描述</h3>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p>**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span><br>输出: <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span><br>输出: <span class="hljs-string">&quot;56088&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>
<li><code>num1</code> 和 <code>num2</code> 只能由数字组成。</li>
<li><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</li>
</ul>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<p>根据题目给出的<code>m,n</code>边界可以知道,如果是最大的<code>num1</code>和最大的<code>num2</code>相乘,得到的数的指数部分是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>400</mn></msup></mrow><annotation encoding="application/x-tex">10^{400}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,即差不多<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1200</mn></msup></mrow><annotation encoding="application/x-tex">2^{1200}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>,显然32位的int和64位的long,都无法存下这么大的数,因此是利用字串相乘来做<strong>大数乘法</strong></p>
<p>可能太久没怎么写代码了,写这个的时候那个进位数不知道咋处理(确实很离谱😢 ),因此通过构建一个<code>vector&lt;vector&lt;int&gt;&gt; vec_res</code>这样的二维数组来给它存储,<code>vec_res.size()</code>表示的是有多少个中间值,就比如<code>123*456</code>,可以表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>100</mn><mo>+</mo><mn>20</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>400</mn><mo>+</mo><mn>50</mn><mo>+</mo><mn>6</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>3</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>4</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>5</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>1</mn></msup><mo>+</mo><mn>6</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>0</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(100+20+3)*(400+50+6) = (1*10^2 + 2*10^1 + 3*10^0)* (4*10^2+5*10^1+6*10^0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>其中我们两个数值都逐位数遍历,然后系数相乘,指数相加,其中系数相乘得到的结果是最多为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>∗</mo><mn>9</mn><mo>=</mo><mn>81</mn></mrow><annotation encoding="application/x-tex">9*9=81</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">1</span></span></span></span>,就是只是向前一位进位;指数则通过<code>size()-1-i</code>来表示(<code>i: 0-&gt;size()</code>)</p>
<p>因此可以得到许多个最多两位数的值,装进vector里面,然后它们的索引表示的是指数值,而<code>vec_res</code>则把这些个数组装进去了,形成了一个稀疏的矩阵,其中每一行最多有两个元素值,最后再累加和reverse并拼接为string,需要注意<code>num1</code>或<code>num2</code>为0的情况,以及结果的string首位为0的情况.</p>
<p>反思:</p>
<p>这道题写得久很不应该(思路大概十分钟就出来了),因为本科我记得写过,但是实在是太久没练了,因此很多思维都僵化了,就比如上面并不需要用二维数组来承担结果的装载,直接用个<code>vector&lt;int&gt; vec_res</code>就行了,然后再诸位处理进位的问题,因为是int,比如<code>vec_res[0] = 213</code>,只需要留住3就好,210向前两位进过去就好.</p>
<p>官方思路:</p>
<ol>
<li>思路一就是把比如<code>123*456</code>给弄成<code>123*6</code>,<code>123*50</code>,<code>123*400</code>,然后再利用字符串相加,给它们加起来;</li>
<li>思路二跟我这个思路差不太多,不过巧妙很多,因为我的还需要reverse,它是计算了下两个数相乘后最小的位数情况为<code>m+n-1</code>,最大位数情况为<code>m+n</code>(其中:<code>m = num1.size();n = num2.size();</code>),因此直接给<code>vector&lt;int&gt; vec_res(m+n)</code>,然后第零位就是最高位(它不一定有数填充,可能是前导零),就比如<code>123*456</code>中的<code>3*6</code>,则放置在第五位(第三位*第三位=第六位,但是是[0,5],所以是第五位,如果有进位则是进在第四位),因而最后判断一下最高位是否前导0就可以把其转为字串;</li>
<li><mark>还有一种是可以把它考虑成卷积的情况,然后利用fft加速好像(这个方法还没细看)</mark></li>
</ol>
<h3 id="重写官方代码-4"><a class="markdownIt-Anchor" href="#重写官方代码-4"></a> 重写官方代码</h3>
<h2 id="10-正则表达式匹配"><a class="markdownIt-Anchor" href="#10-正则表达式匹配"></a> 10 正则表达式匹配🔴</h2>
<h3 id="题目描述-8"><a class="markdownIt-Anchor" href="#题目描述-8"></a> 题目描述</h3>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code> 匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-string">&quot;a&quot;</span> 无法匹配 <span class="hljs-string">&quot;aa&quot;</span> 整个字符串。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;aa&quot;</span>, p = <span class="hljs-comment">&quot;a*&quot;</span><br>输出：<span class="hljs-keyword">true</span><br>解释：因为 <span class="hljs-string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">&#x27;a&#x27;</span>。因此，字符串 <span class="hljs-comment">&quot;aa&quot;</span> 可被视为 <span class="hljs-string">&#x27;a&#x27;</span> 重复了一次。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-string">&quot;.*&quot;</span> 表示可匹配零个或多个（<span class="hljs-string">&#x27;*&#x27;</span>）任意字符（<span class="hljs-string">&#x27;.&#x27;</span>）。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 20</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
<li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li>
</ul>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<h3 id="重写官方代码-5"><a class="markdownIt-Anchor" href="#重写官方代码-5"></a> 重写官方代码</h3>
<h2 id="103-二叉树的锯齿形层序遍历"><a class="markdownIt-Anchor" href="#103-二叉树的锯齿形层序遍历"></a> 103 二叉树的锯齿形层序遍历</h2>
<h3 id="题目描述-9"><a class="markdownIt-Anchor" href="#题目描述-9"></a> 题目描述</h3>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h3 id="思路-9"><a class="markdownIt-Anchor" href="#思路-9"></a> 思路</h3>
<p>首先,当我一开始看到题目的描述,①要层序遍历,②锯齿形就是给它左一下右一下,就是奇数次的时候(就是某个一维数组位于奇数索引),是从右到左的层序遍历.因此最初的思路是:BFS+reverse,完美解题,轻而易举!</p>
<p>但是问题来了,我忘了bfs咋写,于是经过漫长思想纠结,用了一下之前类似回溯(其实不是回溯,bad)的dfs形式实现的(其中大多数花费的时间是在考虑怎么来度量是同一层,因为这样才可以放入<code>vector&lt;vector&lt;int&gt; res</code>中的同一层), 主要的思路是:写了个递归,然后该递归函数的声明:<code>void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; res,int height,TreeNode* node)</code>,通过如下的方式控制height:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt; (height))<br>    &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br>        tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        res[height].<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>    &#125;<br>    height++;<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;left);<br>    <span class="hljs-built_in">dfs</span>(res,height,node-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>官方思路则是使用了bfs(才记起来要用队列),不过它的方法没有用reverse,而是给了个flag,来标记从左开始还是从右开始push,其实就是头插和尾插,因为要用头插,所以用了个deque双端队列来存储.</p>
<h3 id="重写官方代码-6"><a class="markdownIt-Anchor" href="#重写官方代码-6"></a> 重写官方代码</h3>
<p>这里采用的是广搜的方法写的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *node;<br>            <span class="hljs-keyword">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            deque&lt;<span class="hljs-keyword">int</span>&gt; deq;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            &#123;<br>                node = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (flag)<br>                    deq.<span class="hljs-built_in">push_front</span>(node-&gt;val);<br>                <span class="hljs-keyword">else</span><br>                    deq.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            flag = !flag;<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;deq.<span class="hljs-built_in">begin</span>(), deq.<span class="hljs-built_in">end</span>()&#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 之前的方法</span><br><span class="hljs-comment">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="hljs-comment">        if(root == nullptr)</span><br><span class="hljs-comment">            return res;</span><br><span class="hljs-comment">        bfs(res,0,root);</span><br><span class="hljs-comment">        for(int i=0;i&lt;res.size();i++)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            if(i%2!=0)</span><br><span class="hljs-comment">                reverse(res[i].begin(),res[i].end());</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return res;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 之前的方法,写是bfs实则dfs</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res,<span class="hljs-keyword">int</span> height,TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            v = res[height];<br>        v.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &gt;= (height+<span class="hljs-number">1</span>))<br>            res[height]=v;<br>        <span class="hljs-keyword">else</span><br>            res.<span class="hljs-built_in">push_back</span>(v);<br>        TreeNode* left = node-&gt;left;<br>        <span class="hljs-built_in">bfs</span>(res,++height,left);<br>        height--;<br>        TreeNode* right = node-&gt;right;<br>        <span class="hljs-built_in">bfs</span>(res,++height,right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/19/DApaJQ6qH4lFwG8.png" srcset="/img/loading.gif" lazyload alt="103-zigzagLevelOrder-effect" /></p>
<h2 id="146-lru缓存"><a class="markdownIt-Anchor" href="#146-lru缓存"></a> 146 LRU缓存</h2>
<h3 id="题目描述-10"><a class="markdownIt-Anchor" href="#题目描述-10"></a> 题目描述</h3>
<p>请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<h3 id="思路-10"><a class="markdownIt-Anchor" href="#思路-10"></a> 思路</h3>
<p>因为这个题目要求<code>get</code>和<code>put</code>的时间复杂度是要在<code>O(1)</code>,显然对于数组来说,在随机位置读是<code>O(1)</code>,而增删则为<code>O(n)</code>,对于链表来说任意位置增删则为<code>O(1)</code>,因为不需要搬移元素,但如果指定位置增删则需要移动过去,这个过程会比较慢,比如单链表,那要删除尾巴节点则需要移动到尾巴那里,即使把尾巴节点存了也没意义,因为删了之后又得遍历一次存一次,因此对于这个题,显然我们需要一个链表来管理元素,即表示元素的优先级,优先级越高的越靠前,表明它使用的次数越多,而在尾巴节点的则表明有淘汰的风险,一旦有新的节点要加入,就要删除,因此本题需要使用双向链表<code>list</code>来管理元素的优先级,然后采用<code>vector&lt;int&gt;</code>来存储键值对,<code>list&lt;int&gt;</code>则用来管理索引.</p>
<p>一开始因为时间限制卡住了,后来在lolored的提醒下,<code>find</code>这个函数很耗时间,可以换下位置减少调用次数,就通过了,不过数据不大好看,但代码蛮简洁的~,以下是我的代码部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:     <br>    <span class="hljs-keyword">int</span> capacity;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>    list&lt;<span class="hljs-keyword">int</span>&gt; ls;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10001</span>,<span class="hljs-number">-1</span>);<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-number">-1</span> != <span class="hljs-keyword">this</span>-&gt;vec[key])<br>        &#123;<br>            list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>            <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            <span class="hljs-comment">// 调整至头部</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;vec[key];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-comment">// 为新值 且 长度到界 则需要弹出一个</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-keyword">this</span>-&gt;capacity &amp;&amp; <span class="hljs-keyword">this</span>-&gt;vec[key] == <span class="hljs-number">-1</span>)<br>            &#123;<br>                <span class="hljs-keyword">int</span> t = <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">back</span>();<br>                <span class="hljs-comment">// 链表弹出</span><br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">// 数组置-1</span><br>                <span class="hljs-keyword">this</span>-&gt;vec[t] = <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 以下是不同时满足上述两种情况的剩余情况</span><br>            <span class="hljs-comment">// 这个key在链表中没有(新值),头插</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">-1</span> == <span class="hljs-keyword">this</span>-&gt;vec[key])<br>            &#123;<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);<br>            &#125;<br>            <span class="hljs-comment">// 这个key链表有(旧值),调整至头部</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                list&lt;<span class="hljs-keyword">int</span>&gt;::iterator pos = <span class="hljs-built_in">find</span>(<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">begin</span>(),<span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">end</span>(),key);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">erase</span>(pos);<br>                <span class="hljs-keyword">this</span>-&gt;ls.<span class="hljs-built_in">push_front</span>(key);   <br>            &#125;  <br>            <span class="hljs-keyword">this</span>-&gt;vec[key] = value;   <br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>官方思路其实也差不大多,因为这个问题的关键是<strong>快速查找到元素和快速增删元素</strong>,那有一种融合了这两种(数组和链表)优点的数据结构,叫<strong>哈希表</strong>.在C++中存储键值对的数据结构有<code>map,unordered_map,ordered_map</code>等等,其中<code>map</code>内部实现了红黑树(有序)和<code>unordered_map</code>内部则实现了哈希表,即它查找会更快,但是相对来说更占空间一点.</p>
<p>双向链表则自己实现,然后用它来存k,v(虽然<code>unordered_map</code>的key也是k,这里主要便于后期操作,所以加了个k),则有大概如下的结构<mark>这道题其实</mark>,可以实现查找O(1),增删O(1),其实还有个移动节点,分为删+增,也是O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">d_node</span>&#123;</span><br>    d_node *prev,*next;<br>    <span class="hljs-keyword">int</span> key,value;<br>&#125;<br>unordered_map&lt;<span class="hljs-keyword">int</span>,d_node*&gt; u_m; <br></code></pre></td></tr></table></figure>
<p>比起我自己的方法来说,这种方法更好,因为我的方法实际上在查找确实是O(1),但是增删的时候多了一个<code>find()</code>操作,这一步是O(n)的.而且确实,我的vector跟list并没有实质意义上过大的链接关系,就是说它们唯一的共通点是vector的索引是key,而list里面的值是key,并没有真正把它们linked到一起.</p>
<h3 id="重写官方代码-7"><a class="markdownIt-Anchor" href="#重写官方代码-7"></a> 重写官方代码</h3>
<h2 id="14-最长公共前缀"><a class="markdownIt-Anchor" href="#14-最长公共前缀"></a> 14 最长公共前缀🔵</h2>
<h3 id="题目描述-11"><a class="markdownIt-Anchor" href="#题目描述-11"></a> 题目描述</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]<br>输出：<span class="hljs-string">&quot;fl&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-keyword">strs</span> = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]<br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<h3 id="思路-11"><a class="markdownIt-Anchor" href="#思路-11"></a> 思路</h3>
<p>这个实际写了大概20分钟不到,这个题目比较直,即使暴力解也有好的结果,只要适当剪枝就好.抓一个string出来,然后跟别的比就好,只要出现了不匹配的就跳出来就好(用个标志位)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        string ans;<br>        string tmp = strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">bool</span> break_flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;tmp.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;strs.<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(strs[j].<span class="hljs-built_in">size</span>() &lt;= i)<br>                &#123;<br>                    break_flag=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp[i] != strs[j][i])<br>                    break_flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(break_flag)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans += tmp[i];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153 寻找旋转排序数组中的最小值</h2>
<h3 id="题目描述-12"><a class="markdownIt-Anchor" href="#题目描述-12"></a> 题目描述</h3>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br>解释：原数组为 <span class="hljs-string">[1,2,3,4,5]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span><br>输出：<span class="hljs-number">0</span><br>解释：原数组为 <span class="hljs-string">[0,1,2,4,5,6,7]</span> ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[11,13,15,17]</span><br>输出：<span class="hljs-number">11</span><br>解释：原数组为 <span class="hljs-string">[11,13,15,17]</span> ，旋转 <span class="hljs-number">4</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<h3 id="思路-12"><a class="markdownIt-Anchor" href="#思路-12"></a> 思路</h3>
<p>一开始写这题的时候非常烦躁,感觉写题目是一件非常私人的事情,不要随着别人的时间写,不然很影响自己的状态.</p>
<p>后面我重新看了题目,确定了是二分查找,因为你要做到<code>O(logn)</code>这么一个时间复杂度,但是二分查找呢是排好序了的.于是自己又写了几个案例来观察:</p>
<p><code>[2,3,4,5,6,7,8,9,0,1]</code> | <code>[7,8,9,0,1,2,3,4,5,6]</code></p>
<p>不难发现,根据旋转的次数,我们的最小值可能在中点的左边,也可能在右边:</p>
<ul>
<li>最小值在中点左边,说明旋转次数少,左边的值偏大;</li>
<li>最小值在中点右边,说明旋转次数多,右边的值偏小;</li>
</ul>
<p>因此,我就选择拿最左端与中点的值进行比较,一步步缩小区间(a表示左侧端点,mid表示中点):</p>
<p><code>if(nums[mid]&gt;nums[a]) // 最小值在右边的区间 向右收缩区间</code></p>
<p><code>if(nums[mid]&lt;nums[a] // 最小值在左边的区间) 向左收缩区间</code></p>
<p>其中向右收缩区间则<code>mid</code>和<code>nums.size()</code>相加除2,把mid往右移,a把原来mid的索引给拿走;</p>
<p>其中向左收缩区间则<code>mid</code>和<code>a</code>相加除2,把mid往左移;</p>
<p>因为收缩到的子区间也是满足这种旋转的情况的(就是两个升序的序列,但是拼接处是最大值和最小值),直到<code>a</code>和<code>mid</code>相等,说明它俩挨得近,上一次只差了个1,但是左缩了,说明上一次的mid是小于a的值的,但是相等了,说明上一次的值已经是最小的了.</p>
<h3 id="重写官方代码-8"><a class="markdownIt-Anchor" href="#重写官方代码-8"></a> 重写官方代码</h3>
<h2 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> 56 合并区间</h2>
<h3 id="题目描述-13"><a class="markdownIt-Anchor" href="#题目描述-13"></a> 题目描述</h3>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^4</code></li>
</ul>
<h3 id="思路-13"><a class="markdownIt-Anchor" href="#思路-13"></a> 思路</h3>
<p>我真是无语写这道题,因为官方给的示例,我以为左端点是递增的,后面提交才发现,是需要先排个序的…</p>
<p>不过写分类的时候也是跌跌撞撞试了几次错,再整理思路写出来的,虽然好像看起来结果还挺pass,但方法比较呆瓜(不用一直合并,可以累积一波再合并),之后要重写一遍这题.</p>
<p>官方的思路是先按左端点排序,则能合尽合,不能合则next one go go.</p>
<h3 id="重写官方代码-9"><a class="markdownIt-Anchor" href="#重写官方代码-9"></a> 重写官方代码</h3>
<h2 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和"></a> 53 最大子数组和</h2>
<h3 id="题目描述-14"><a class="markdownIt-Anchor" href="#题目描述-14"></a> 题目描述</h3>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h3 id="思路-14"><a class="markdownIt-Anchor" href="#思路-14"></a> 思路</h3>
<p>原思路如下虽通过了,但是有一个压力测试的用例是绕过去的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max,sum;<br>        <span class="hljs-comment">// 这个来定区间</span><br>        <span class="hljs-keyword">int</span> r;<br>        <span class="hljs-comment">// 把边界先给处理了</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;nums.<span class="hljs-built_in">size</span>();l++)&#123;<br>            <span class="hljs-comment">// 初始值设置</span><br>            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>)<br>                max = nums[l];<br>            sum = nums[l];<br>            <br>            <span class="hljs-comment">// 极端情况,全负</span><br>            <span class="hljs-keyword">if</span>(max &lt; nums[l])<br>                max = nums[l];<br>            <span class="hljs-comment">// 左端点和步距表示区间</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s=l+<span class="hljs-number">1</span>;s&lt;nums.<span class="hljs-built_in">size</span>();s++)&#123;<br>                <span class="hljs-comment">// 左端点值小于0直接跳出去</span><br>                <span class="hljs-keyword">if</span>(nums[l] &lt; <span class="hljs-number">0</span>)&#123;<br>                    sum = <span class="hljs-number">0</span>;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 对着用例加的一个无聊的标志位,如果是有负则为false;</span><br>                <span class="hljs-keyword">if</span>(nums[s]&lt;<span class="hljs-number">0</span>)<br>                    flag = <span class="hljs-literal">false</span>;<br><br>                sum += nums[s];<br>                <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(sum&gt;max)<br>                        max = sum;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">区间里的和只要是大于零(大于max(因为怕有极端情况))的就有反转的余地,不然就废了</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>上面代码的思路是通过l(left)和s(stride)这两个来定区间,然后逐个区间找最大值的可能,什么时候放弃一个区间呢?</p>
<ul>
<li>当它开头(区间左端点)是负数(因为如果全负的话,直接从负的找最大的就好),如果有大于等于0的话,那就说明这个负的开头的不可能是最大连续子数组,因为它的起点就比别人低;</li>
<li>当它区间的总和小于0时,也要跳出,因为你开头不为0,你这时为0了,后面即使有再大的数,也不如直接就挑那一个大数作为最大值的连续子数组</li>
</ul>
<p>而当我们区间的总和不为0时,则表示有回转的余地,还可以继续区间的和的最大值的计算</p>
<p>昨天lolored跟我说她写了一个绝佳的方法,确实牛牛,代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = nums.<span class="hljs-built_in">size</span>(); i &lt; len; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) nums[i] += nums[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (max &lt; nums[i]) max = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个方法其实是把我上面的方法高度压缩了一波,利用数组内的每个值作为sum来统计,而当其本身小于0或是累和小于0则放弃,当累和比max大则更新max</p>
<p>这个方法的时间复杂度是<code>O(n)</code>,但我觉得精简程度堪称典范,比官方的dp方法还好.</p>
<p>官方的思路是采用动态规划的算法,这里采用一个看到的大佬的思路(<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">参考自liweiwei1419</a>),作者详细地讲了这个题目<strong>如何找到/定义状态</strong>(就是子问题,<mark>从有后效性到无后效性(后面对子问题的求解不影响前面已求解完的子问题),好像要么就是给它加定语设条件,要么就是增加状态数组维度</mark>),然后找到<strong>子问题之间的联系,就是状态转移方程</strong></p>
<p>以<code> [-2,1,-3,4,-1,2,1,-5,4]</code>为例</p>
<p>比如一开始会想:</p>
<ul>
<li>含有<code>-2</code>的连续子序列的最大和 -&gt; <code>dp[0]</code></li>
<li>含有<code>1</code>的连续子序列的最大和 -&gt; <code>dp[1]</code></li>
<li>…</li>
<li>含有<code>4</code>的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li>
</ul>
<p>但是这并没有很好的阐述清楚这个问题,子问题间的关系扑朔迷离,且对现在的子问题依旧有<strong>不确定</strong>的因素就判定为仍有后效性(我感觉意思上来说就是只要你感觉怪怪的,就是还有后效性,只要当你的子问题定语够多,前提是不要错,对不对很容易感受出来)</p>
<p>现在的不确定性就是比如含有<code>-2</code>的连续子序列有很多很多个,含有<code>1</code>的连续子序列也有很多很多个,这里的作者就借助<strong>位置</strong>这个定语来加强子问题的限定</p>
<ul>
<li>以<code>-2</code>为末尾元素的连续子序列的最大和 -&gt; <code>dp[0]</code></li>
<li>…</li>
<li>以<code>4</code>为 末尾元素的连续子序列的最大和 -&gt; <code>dp[n-1]</code></li>
</ul>
<p>这样就有:</p>
<p>对于以-2为结尾的<code>[-2]</code>即是在所有连续子序列中选一个最大和的,而这个只有一种情况,所以<code>dp[0]=nums[0];</code></p>
<p>对于以1为结尾的<code>[-2,1]</code>,<code>[1]</code>有这么两种情况,即是在选不选<code>dp[0]</code>的情况下做选择,当然我们如果前一个<code>dp[i-1]</code>的是<code>&lt;=0</code>的数加了只会更小或者说没区别,还不如就不加了.</p>
<p>因此状态转移方程也就呼之欲出了</p>
<p>此外,作者也说了动规题的做题路径:</p>
<ol>
<li>定义状态/子问题</li>
<li>定义状态转移方程</li>
<li>考虑初始值</li>
<li>考虑输出</li>
<li><mark>空间优化(这一步先放弃,一般空间不要太离谱也不会爆)</mark></li>
</ol>
<h3 id="重写官方代码-10"><a class="markdownIt-Anchor" href="#重写官方代码-10"></a> 重写官方代码</h3>
<p><code>dp[i]</code>表示以<code>nums[i]</code>为结尾的连续子序列的最大和</p>
<p>当发生状态转移的时候,即是选择<code>dp[i]</code>选择<code>dp[i] = dp[i-1] + nums[i];</code>或是<code>dp[i] = nums[i];</code>的过程,而这个选择的条件就是<code>dp[i-1]</code>是否<code>&gt;0</code></p>
<p>定义好状态了,状态转移方程以及相关条件都定义好了,考虑初值,即<code>dp[0]</code>表示以<code>nums[0]</code>结尾的连续子序列的最大和,有且也只有一个<code>[nums[0]]</code>这么一个子序列,所以<code>dp[0] = nums[0];</code></p>
<p>题目要求我们求出连续子序列的最大和,就是说,并不是一定要以谁结尾,而是要在这些情况中,找个最大的,也就是遍历所有的状态,找个最大的返回出去.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span>)<br>                dp[i] = dp[i<span class="hljs-number">-1</span>] + nums[i];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = nums[i];<br>            <span class="hljs-keyword">if</span>(dp[i] &gt; max)<br>                max = dp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2024/03/12/H6h2EdPU5xSvKrB.png" srcset="/img/loading.gif" lazyload alt="53 最大子数组和-前后效果对比" /></p>
<h2 id="162-寻找峰值"><a class="markdownIt-Anchor" href="#162-寻找峰值"></a> 162 寻找峰值</h2>
<h3 id="题目描述-15"><a class="markdownIt-Anchor" href="#题目描述-15"></a> 题目描述</h3>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>
<p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p>
<p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>
</ul>
<h3 id="思路-15"><a class="markdownIt-Anchor" href="#思路-15"></a> 思路</h3>
<p>这个题目,看到**<code>O(logn)</code><strong>的时候就意识到了要用</strong>二分查找**(因为它就是找类似于极大值点的这么一个情况,就是找某一个满足特殊条件的值),但是它跟普通的二分查找不一样,因为那种是排好序的,那么这个二分查找你在折半区间后,往哪一个新的区间走都还不知道呢</p>
<p>这个时候就要结合题目分析一波,因为题目说是找峰值:</p>
<ul>
<li>当是<code>nums[i]&gt;nums[i-1] &amp;&amp; nums[i]&gt;nums[i+1]</code>的时候则满足条件;</li>
<li>如果是<code>nums[i-1]&lt;nums[i]&lt;nums[i+1]</code>的说明是个目前处于增函数一侧(方便理解,故如此称呼),则要往右走;</li>
<li>如果是<code>nums[i-1]&gt;nums[i]&gt;nums[i+1]</code>则说明是处于减函数一侧,要往左走</li>
</ul>
<p>然后这里通用的做法的话是<strong>缩区间,区间找中点,判断,循环往复</strong></p>
<p>但是我不知道为啥写的时候死犟,用了个二分法+进退法,死都想不起来缩区间,而是:先找到中点<code>mid</code>,用它去判断是处于增/减,再往另一个区间去,<code>pre_mid</code>继承<code>mid</code>的位置,则可能存在增-减/减-增的理想情况,也可能存在增-增/减-减的情况,会导致陷入区间,因此要用一些方法将此类情况移除,采用逐次增加步距,跳出陷入区间的可能.此外,也可能存在比较对称的点,导致<code>pre_mid</code>和<code>mid</code>振荡,因此每次陷入的时候都加多个1,避免振荡.然后得出了下面这么一个结果(好得有点惊讶,因为我写到后面甚至不知道我在干嘛了,指振荡那一部分,是遇到了一个用例死活过不去(振荡了),就把步距那一块都加了个1,后来感觉是打破了对称性):</p>
<p><img src="https://s2.loli.net/2024/03/13/ZM7KdHErQTW2csP.jpg" srcset="/img/loading.gif" lazyload alt="162 寻找峰值元素-奇怪的运行结果" /></p>
<p>代码如下,此题需要重写,用正常的写法写(就是我说的缩区间的,官方的解法也是这个)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre_mid=<span class="hljs-number">-1</span>,mid = nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>,tmp,stride;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// 处理两个边界情况</span><br>            <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[mid+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(mid==nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> &amp;&amp; nums[mid] &gt; nums[mid<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 可以出去的情况</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果找错极值了,乱弹一下</span><br>            <span class="hljs-keyword">if</span>(mid == pre_mid)&#123;<br>                mid = <span class="hljs-number">2</span> * mid;<br>                <span class="hljs-keyword">if</span>(mid &gt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                    mid = mid % nums.<span class="hljs-built_in">size</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid<span class="hljs-number">-1</span>] &amp;&amp; nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = (mid + nums.<span class="hljs-built_in">size</span>()) / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往右走</span><br>                    tmp = mid;<br>                    mid = (mid + pre_mid) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                    <br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &lt; nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span> &amp;&amp; <br>                nums[mid] &gt; nums[pre_mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="hljs-number">1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (mid - pre_mid) + <span class="hljs-number">1</span> ;<br>                    mid = mid + stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//if(nums[mid]&gt;nums[mid+1]&amp;&amp;nums[mid]&lt;nums[mid-1])&#123;</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(pre_mid == <span class="hljs-number">-1</span>)&#123;<br>                    pre_mid = mid;<br>                    mid = mid / <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// mid往左走</span><br>                    tmp = mid;<br>                    mid = (pre_mid + mid ) /<span class="hljs-number">2</span>;<br>                    pre_mid = tmp;<br>                &#125;<br>                <span class="hljs-comment">// 避免陷入绝境</span><br>                <span class="hljs-keyword">while</span>(mid &gt; <span class="hljs-number">0</span> &amp;&amp; nums[mid] &gt; nums[pre_mid] <br>                &amp;&amp; nums[mid] &lt; nums[mid<span class="hljs-number">-1</span>])&#123;<br>                    tmp = mid;<br>                    stride = <span class="hljs-number">2</span> * (pre_mid - mid) + <span class="hljs-number">1</span>;<br>                    mid = mid - stride;<br>                    pre_mid = tmp;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;mid:&quot;</span>&lt;&lt; mid &lt;&lt; <span class="hljs-string">&quot; pre_mid:&quot;</span> &lt;&lt; pre_mid &lt;&lt;<span class="hljs-string">&quot; len:&quot;</span> &lt;&lt; nums.<span class="hljs-built_in">size</span>() &lt;&lt; endl ;<br>            <span class="hljs-keyword">if</span>(mid&lt;<span class="hljs-number">0</span>)<br>                mid = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(mid&gt;nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>)<br>                mid = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">题目是查找满足某种条件的值的索引(找峰值)</span><br><span class="hljs-comment">然后说O(logn)</span><br><span class="hljs-comment">那不就是二分查找嘛</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">把示例的输入都化成点图,感觉就是找尖尖的点</span><br><span class="hljs-comment">遇到左&lt;中&lt;右的就往右移动;</span><br><span class="hljs-comment">遇到左&gt;中&gt;右的就往左移动;</span><br><span class="hljs-comment">记录上一个&quot;中&quot;值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="重写官方代码-11"><a class="markdownIt-Anchor" href="#重写官方代码-11"></a> 重写官方代码</h3>
<h2 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160 相交链表</h2>
<h3 id="题目描述-16"><a class="markdownIt-Anchor" href="#题目描述-16"></a> 题目描述</h3>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br>— 请注意相交节点的值不为 <span class="hljs-number">1</span>，因为在链表 <span class="hljs-keyword">A</span> 和链表 B 之中值为 <span class="hljs-number">1</span> 的节点 (<span class="hljs-keyword">A</span> 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <span class="hljs-keyword">A</span> 和链表 B 中值为 <span class="hljs-number">8</span> 的节点 (<span class="hljs-keyword">A</span> 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">1</span><br>输出：Intersected at &#x27;<span class="hljs-number">2</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 A 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" srcset="/img/loading.gif" lazyload alt="img" /></a></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p>**进阶：**你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h3 id="思路-16"><a class="markdownIt-Anchor" href="#思路-16"></a> 思路</h3>
<p>题目说要<strong>在两个单链表中找到它们相交的节点</strong>,我的思路是很暴力的,直接两个链表遍历,当有节点相等则意味着找到相交点了,因为相交的点们都是同样的内存地址.本来想着用数值来找的,但是数值有重复的.</p>
<p>上述这种方法时间复杂度是<code>O(mn)</code>(虽然AC了但是性能一般),等我想到<code>O(m+n)</code>的再看题解,不然怕没逻辑过程~</p>
<hr />
<p>叮~~~(仔细想了半小时左右,指以下过程,还回看了分隔链表的题目,因为觉得它们很像),不小心按到题解(之前做完跳过去的,页面没关),看到<strong>双指针</strong>,看到<strong>后面的长度一样</strong>,然后想了一下,大概知道怎么做了,写一遍</p>
<hr />
<p>新的思路主要是<strong>先对齐数组,然后逐个比较</strong></p>
<p>对齐数组是指listA和listB长度不一样,而显然交点及之后的大小是一样的长度,而多出来的那部分(就是那些个节点),肯定不是交点会在的地方,因此先对齐,而对齐前要统计两个链表的长度,则这部分的时间复杂度是<code>O(m+n)</code>,之后对齐需要处理长链表的节点,而后的逐个比较则是减去了这部分长链表的节点,所以后面这部分的时间复杂度为<code>O(max(m,n))</code>,假设m&gt;n,则总时间复杂度为<code>O(2m+n)</code>这样子,算是达到了<code>O(m+n)</code>的时间复杂度</p>
<p>以下为更正后的代码部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *tmpA = headA, *tmpB = headB;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (tmpA != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            tmpA = tmpA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (tmpB != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        tmpA = headA;<br>        tmpB = headB;<br>        pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt = m &gt; n ? <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, m - n) : <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, n - m);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">max</span>(m, n) - cnt.second;<br><br>        <span class="hljs-keyword">while</span> (cnt.second)<br>        &#123;<br>            <span class="hljs-comment">// 处理listB</span><br>            <span class="hljs-keyword">if</span> (cnt.first)<br>                tmpB = tmpB-&gt;next;<br>            <span class="hljs-comment">// 处理listA</span><br>            <span class="hljs-keyword">else</span><br>                tmpA = tmpA-&gt;next;<br><br>            cnt.second--;<br>        &#125;<br>        ListNode *ans = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (tmpB == tmpA)<br>            &#123;<br>                ans = tmpB;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmpA = tmpA-&gt;next;<br>            tmpB = tmpB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">/* 下面是暴力解法</span><br><span class="hljs-comment">        ListNode* tmpA = headA;</span><br><span class="hljs-comment">        ListNode* tmpB = headB;</span><br><span class="hljs-comment">        ListNode* ans = nullptr;</span><br><span class="hljs-comment">        bool flag = false;</span><br><span class="hljs-comment">        while(tmpA != nullptr)&#123;</span><br><span class="hljs-comment">            while(tmpB != nullptr)&#123;</span><br><span class="hljs-comment">                if(tmpA == tmpB)&#123;</span><br><span class="hljs-comment">                    ans = tmpA ;</span><br><span class="hljs-comment">                    flag = true;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                tmpB = tmpB -&gt;next;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            tmpA = tmpA -&gt;next;</span><br><span class="hljs-comment">            tmpB = headB;</span><br><span class="hljs-comment">            if(flag)</span><br><span class="hljs-comment">                break;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        return ans;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方代码-12"><a class="markdownIt-Anchor" href="#重写官方代码-12"></a> 重写官方代码</h3>
<h2 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> 98 验证二叉搜索树</h2>
<h3 id="题目描述-17"><a class="markdownIt-Anchor" href="#题目描述-17"></a> 题目描述</h3>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>
<p>节点的左</p>
<p>子树</p>
<p>只包含</p>
<p>小于</p>
<p>当前节点的数。</p>
</li>
<li>
<p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li>
<p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h3 id="思路-17"><a class="markdownIt-Anchor" href="#思路-17"></a> 思路</h3>
<p>验证二叉搜索树，就是要根据给定的输入，验证输入的树结构是否是bst</p>
<p>我们知道，对于bst而言，中序遍历的时候相当于排序，而对于如左子树&lt;根&lt;右子树的情况，则相当于升序</p>
<p>我一开始写的时候想用广度优先搜索写，主要遵循的是左节点&lt;根&lt;右节点这样规则，但后面过用例的时候会出现，有左子树的部分节点会比根节点的值大，这就不符合bst了。后面想了一下，没想出如何解决，因此转用了dfs做中序遍历，然后看是不是升序的，是则说明是bst</p>
<h3 id="重写官方思路-4"><a class="markdownIt-Anchor" href="#重写官方思路-4"></a> 重写官方思路</h3>
<h2 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> 110 平衡二叉树🔴</h2>
<h3 id="题目描述-18"><a class="markdownIt-Anchor" href="#题目描述-18"></a> 题目描述</h3>
<p>给定一个二叉树，判断它是否是平衡二叉树</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = []<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code></li>
</ul>
<h3 id="思路-18"><a class="markdownIt-Anchor" href="#思路-18"></a> 思路</h3>
<p>写这道题太挫败了,简单题我写不出来😢</p>
<p>一开始的想法是想用bfs,层序遍历树结构,用<code>vector&lt;vector&lt;int&gt;&gt;</code>把树结构的信息装起来,然后遍历,我们知道树的高度为h,则该行长满节点则为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">2^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>(h是从0开始算的),我的判断依据是当存在两行不满足长满节点,则不是平衡二叉树,然后在一个用例上错了😈,如<code>[1,2,3,4,5,6,null,8]</code>这样的,满足我的不是平衡二叉树的判断,但它又确实是,因为每一个子树都满足左右子树高度差&lt;=1</p>
<hr />
<p>昨天晚上重写了这个题目,看了题解,用了递归写的,但是性能不大好,应该是属于自顶向下的那种?</p>
<p>主要思路是所有平衡二叉树的子树都是平衡二叉树,因为都要满足左右子树高度差不为1的条件.则对于叶子节点,高度为1,一层层的这样累加上去,则可以知道根的左右子树的高度;并且在检索左右子树的高度时,也对每一个小子树的高度差进行判定,如果超过1,则直接返回-1,且上层对-1直接疯狂返回就行.即使这样时间上也只是超过53%的人</p>
<p>重写的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> height_l = <span class="hljs-built_in">findHeight</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> height_r = <span class="hljs-built_in">findHeight</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(height_l - height_r) &lt;=<span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findHeight</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-comment">// 空节点高度为0</span><br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 叶子节点则高度为1</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> height_l,height_r;<br><br>        height_l = <span class="hljs-built_in">findHeight</span>(node-&gt;left);<br>        height_r = <span class="hljs-built_in">findHeight</span>(node-&gt;right);<br>        <br>        <span class="hljs-keyword">if</span>(height_l == <span class="hljs-number">-1</span> || height_r == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(height_l - height_r) &gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(height_l,height_r) + <span class="hljs-number">1</span> ;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-5"><a class="markdownIt-Anchor" href="#重写官方思路-5"></a> 重写官方思路</h3>
<p>之后看下有没有啥更好的题解</p>
<h2 id="121-股票i"><a class="markdownIt-Anchor" href="#121-股票i"></a> 121 股票Ⅰ</h2>
<h3 id="题目描述-19"><a class="markdownIt-Anchor" href="#题目描述-19"></a> 题目描述</h3>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure>
<h3 id="思路-19"><a class="markdownIt-Anchor" href="#思路-19"></a> 思路</h3>
<p>写这道题的时候我的心路历程如下:</p>
<ol>
<li>左右指针,左扫最低,右扫最高,相减为ans,为负则0 -&gt; failed;</li>
<li>慢慢划过去,找最小值,然后最大值是最小值右边的(历史最低点不一定是赚到最多钱的时候<code>[2,5,1,3]</code>)</li>
</ol>
<p>然后不知道触动了哪个叛逆的神经,我想了下,如果动态规划做的话:</p>
<p><code>dp[i]</code>表示第<code>i</code>天的最大收益,则它这个会模糊不清吗(就是有无后效性),然后就大概的过一过,比如:</p>
<ul>
<li><code>dp[0]</code>第一天的最大收益</li>
<li><code>dp[1]</code>第二天的最大收益</li>
<li>…</li>
<li><code>dp[len-1]</code>最后一天的最大收益</li>
</ul>
<p>那这个最大收益呢,它并不是说我一定非得要在那天卖出(上面的就有点模糊,有后效性,因为我们不知道在第几天卖出,描述很模糊,但买入一定是之前的某个时间节点),就是<strong>直至到第<code>i</code>天的最大收益</strong>,同时转移方程也出来了(很神奇,感觉只要状态找好了找对了,转移方程就很快出来的):</p>
<p><code>dp[i] = max(dp[i-1],prices[i]-min)</code></p>
<p>即直到第<code>i</code>天的最大收益,要么是直到第i-1天的最大收益,要么是今天的卖出价减去之前存储好的相对较低的买入价,两者取max即为所得</p>
<p>同时初始值<code>dp[0]</code>肯定是0,因为撑死就今天买入,卖出如果是同一天的话,也是0.</p>
<p>同时期望的输出就是<code>dp[len-1]</code>,直到最后一天的最大收益(战斗到股市最后一刻),因为存的是最大利润,故输出其即可.</p>
<h3 id="重写官方思路-6"><a class="markdownIt-Anchor" href="#重写官方思路-6"></a> 重写官方思路</h3>
<p>和你的一样哇哈哈</p>
<p>思路一倒是居然没有往这里想,就是跟之前有道题类似(好像是组合?),限定左端,然后右端在左端下一位移动;左端往右走一位,右端在左端下一位继续移动;</p>
<p>限定了区间,但据说会报超时.</p>
<h2 id="122-股票ii"><a class="markdownIt-Anchor" href="#122-股票ii"></a> 122 股票Ⅱ</h2>
<h3 id="题目描述-20"><a class="markdownIt-Anchor" href="#题目描述-20"></a> 题目描述</h3>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10^4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
<h3 id="思路-20"><a class="markdownIt-Anchor" href="#思路-20"></a> 思路</h3>
<p>一开始的时候没啥思路,知道这题递归做,虽然说递归做出来了,但是官网跟我类似的方法是贪心算法,bad,分不清了</p>
<p>我的想法是<code>dp[i]</code>继续表示<strong>直到第i天的最大利润</strong>,但是跟前面的有点不一样,因为我们现在可以<strong>每一天可以多次交易(可以买入卖出),但是任何时候最多只有一股</strong>,也即是说我可能第三天买,第四天价格好就卖了,第五天又买入,第七天行情好了,又卖出去,并不是说买入的时候一定比卖出的早(因为多次交易,可能在之前就有卖出行为了),感觉原来的状态依旧可行,于是修改状态转移方程思路如下:</p>
<p>dp[i]是我直到第i天的最大利润,它的计算方式是:它如果今天不卖出东西的话(就是没赚钱嘛,我依旧不管什么时候买入的),那它就是dp[i-1],那如果今天卖东西呢(就是卖了,有得赚嘛),那就是dp[i-1]+prices[i]-minPrice.那卖不卖东西,其实看的是赚不赚钱:</p>
<p><code>dp[i] = dp[i-1] +  max(0,prices[i]-minPrice)</code></p>
<p>那问题转移到了minPrice怎么找,我们知道,因为任何时候最多持有一股,所以卖了的话,minPrice就得更新(有股且卖).那如果没卖(有股和无股,且不卖,更新minPrice),当天的价格低,就给它换,即是更新到一个价格相对更低的minPrice,当然你得先看它(前一天的价格)卖的话赚不赚钱,赚的话先卖了,再更新,故minPrice变成了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> minPrice = prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初值</span><br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否出售</span><br><span class="hljs-keyword">for</span>(...)&#123;<br>    <span class="hljs-keyword">if</span>(prices[i]-minPrice&gt;<span class="hljs-number">0</span>)&#123;<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,prices[i]-minPrice);<br>	<span class="hljs-keyword">if</span>(minPrice &gt; prices[i])&#123;<br>        minPrice = prices[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        minPrice = prices[i]; <span class="hljs-comment">// 大的话在之后的遍历会缩</span><br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还加了flag辅助,虽然好像没啥用(简化代码这个flag可以去掉)</p>
<p>但是官方说这个是贪心算法,我看了下评论区的人的解释:<strong>只要是利润都是赚的,那直接累加利润就是能赚到的最多的钱</strong>,确实如此!</p>
<p>官方的动态规划的做法则是从<strong>最多只能持有一股股票</strong>入手</p>
<p>那如果第i天交易结束,我手里要么有一股股票,要么没有股票,所以我们原先121的<code>dp[i]</code>,直到第i天的最大利润,可以加个定语变为:<strong>直到第i天有一股股票的最大利润</strong>和<strong>直到第i天没有股票时的最大利润</strong>,而只增加定语并不能解决真正的问题,则要加个维度来表示这个定语了,于是有新的状态定义如下:</p>
<p><code>dp[i][0]</code>: 直到第i天交易结束后没有股票时的最大利润</p>
<p><code>dp[i][1]</code>: 直到第i天交易结束后有一股股票时的最大利润</p>
<p>对应状态的变化可以这样想,买入一股,相当于赊账买入,则减,卖出相当于进账,则加.则我们的状态表示<code>dp[i]</code>直到第i天的账户余额数</p>
<p>因此引出状态转移方程如下:</p>
<p><code>dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])</code></p>
<p><code>dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])</code></p>
<p>相应的对于如&quot;直到第1天交易结束时的最大利润&quot;这样的初始值的处置也可以分为:<code>dp[0][0] = 0;dp[0][1] = -prices[0]</code></p>
<p>然后最终的输出是要输出能获得的最大利润,显然<code>dp[n-1][1]</code>是比<code>dp[n-1][0]</code>所赚的钱少的,还有一股股票压箱底呢,因此最终的输出就直接是<code>dp[n-1][0]</code></p>
<h3 id="重写官方思路-7"><a class="markdownIt-Anchor" href="#重写官方思路-7"></a> 重写官方思路</h3>
<p>有缘重写一下咯~</p>
<h2 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46 全排列🔴</h2>
<h3 id="题目描述-21"><a class="markdownIt-Anchor" href="#题目描述-21"></a> 题目描述</h3>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h3 id="思路-21"><a class="markdownIt-Anchor" href="#思路-21"></a> 思路</h3>
<p>一开始的想法跑偏了,想到动规那里去了,为什么会想到那去呢,因为想着这种排列,它比如<code>[1,2,3,4]</code>,如果是一位数的情况下,以<code>nums[0]</code>结尾的情况,即<code>dp[0][0]</code>只有一种,显而易见,这个二维矩阵的第一行很好填满,而第一列则如<code>dp[1][0]</code>,是两位数的情况下,以<code>nums[0]</code>结尾的情况,很明显,这个东西它好像不大对劲,就是它可以用来统计个数?也可能在过程可以append vector到ans这个二维数组,但就是很奇怪,故直觉觉得奇怪,大多数情况下无法用dp做出;</p>
<p>后来不知道为何没有想出做法(思路跑到组合那里去了),即使和lolored的想法是相同的(递归处理每个首位数),但处理上出了些问题,导致递归出不去,重写修改并整理思路写于如下:</p>
<p>以<code>nums=[1,2,3]</code>为例,我们知道,当我们在数学中遇到排列问题,会想着第一个位置可以排列3个,第二个位置就排列2个,最后一个位置则排列1个,因此即是首位数可以排列1,2,3三种情况,首位数的下一个首位数,就是第二位数,可以排列第一位数排列剩下的情况,后面的首位数也是如此,在剔除了上一位选择的数字后,在剩下的数字里选择</p>
<p>因此,nums如果是3位数,则应该有3个for,用来为每一位数挑选剩余的数字;<strong>如果有n位数,则应该有n个for来为每一位数挑选剩余的数字</strong>(一般n不会太大,不然容易oom,而且也有爆栈的风险),因此是<strong>递归</strong>,且<strong>每个递归函数中处理一位数</strong></p>
<p>那如何知道这个数字被选了呢,<strong>标志位</strong></p>
<p>因此有伪代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(flags[i])&#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        flags[i] = <span class="hljs-literal">true</span>;<br>        ...处理下一位数字...<br>        flags[i] = <span class="hljs-literal">false</span>;<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终写好的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flags</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; tmp;<br><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>()&gt; findNumber = [&amp;]()-&gt; <span class="hljs-keyword">void</span>&#123;<br>                <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == len)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(tmp);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(!flags[i])&#123;<br>                        tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                        flags[i] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-built_in">findNumber</span>();<br>                        flags[i] = <span class="hljs-literal">false</span>;<br>                        tmp.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">findNumber</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-8"><a class="markdownIt-Anchor" href="#重写官方思路-8"></a> 重写官方思路</h3>
<h2 id="47-全排列ii"><a class="markdownIt-Anchor" href="#47-全排列ii"></a> 47  全排列Ⅱ</h2>
<h3 id="题目描述-22"><a class="markdownIt-Anchor" href="#题目描述-22"></a> 题目描述</h3>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 8</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h3 id="思路-22"><a class="markdownIt-Anchor" href="#思路-22"></a> 思路</h3>
<p>容易看出,它是在46题的基础上增加了<strong>重复数字</strong>,这样一来相较于原先的情况,应该多了更多剪枝的方法,比如<code>[1,1,2]</code>就相较于原来的<code>[1,2,3]</code>由6种排列变成了3种,但是想了好久都没想出来新的剪枝如何实现,就用个set在46题的基础上给它主动去重,当然性能也很差,后面看下解析改进一下.</p>
<h3 id="重写官方思路-9"><a class="markdownIt-Anchor" href="#重写官方思路-9"></a> 重写官方思路</h3>
<p>细看了一下官方的解题思路,其中关于<strong>剔除重复序列</strong>(也就是这个题的关键)有点看不懂,但是看了下评论区大家的解释,大致了然了,下面以<code>[1,1,1,2]</code>举例:</p>
<p>从这个含有重复数字的序列中,不难看出,一共就:<code>[1,1,1,2]</code>;<code>[1,1,2,1]</code>;<code>[1,2,1,1]</code>;<code>[2,1,1,1]</code>这么几种排列情况,如果按照A44=4!=24种情况,显然有20种情况是重复的,就比如以顺序给重复的以命名,如:<code>[1a,1b,1c,2]</code>,其中<code>1a1b1c</code>这个排列有6种情况,但其实都是重复的,我们取其中一种,如<code>1a1b1c</code>即可,那么如何过滤掉其余的几种呢?</p>
<p>显然如果要取<code>1a1b1c</code>这一种,即我们在递归的顶层遍历(即第一个for),可以得到1a,然后第二个for可以得到1b,第三个for可以得到1c,最后一个for得到2,那么期望的数字排列1a1b1c2就出来了,接下来则顶层遍历的for会把1a的标志位给置否,并把它从数组中弹出,则1b登场,显然我们不想要这组排列,包括之后的1c开头的排列也是,如何剔除?</p>
<p>可以看出,这些有重复数字的得排在一起,如<code>[1,1,1,2]</code>这样,而非<code>[1,2,1,1]</code>,这样能更好且规律地剔除,因此一开始得对nums排个序,使之成为<code>[1,1,1,2]</code>这样,然后,我们不要的是1b,1c开头的,它们前面都有重复的数字<code>nums[i] == nums[i-1]</code>,且此种情况下,前面的排好了,即<code>nums[i-1]</code>它排好了<code>nums[i]</code>的情况,且此时flags[i-1]已经置否,则这个可以作为已排过的标志!</p>
<p>我们先对nums排序,若是<code>nums[i] == nums[i-1]</code>说明此时滑到了重复的数字上,为了避免越界需加上<code>i&gt;0</code>,而当flags[i-1]还为true的时候,表明正在发生如下的排列:<code>1a...</code>,而当<code>nums[i-1]</code>为false的时候说明已排列好,则此时的排列若是<code>nums[i] == nums[i-1] &amp;&amp; !flags[i-1]</code>说明在排重复的序列了,可以直接continue</p>
<p>这样做会使得重复数字的第一个数排好情况,而后面重复的那些,就直接continue,continue走掉,直到一个新的重复序列的开头~</p>
<p>已重写🆗</p>
<h2 id="49-字母异位词分组"><a class="markdownIt-Anchor" href="#49-字母异位词分组"></a> 49 字母异位词分组</h2>
<h3 id="题目描述-23"><a class="markdownIt-Anchor" href="#题目描述-23"></a> 题目描述</h3>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<h3 id="思路-23"><a class="markdownIt-Anchor" href="#思路-23"></a> 思路</h3>
<p>写这道题,我只有暴力的想法!非常暴力,以至于很弱智:</p>
<ol>
<li>标志flags表征这个字串是否加入过结果数组;</li>
<li>两层遍历,第一层从左往右,第二层顺着第一层,在它右起新一个位置搜索,两个字串比对长度,长度一致则排序,若一致则加入vecString,并置标志位;</li>
<li>从第二层遍历出来,判断vecString的size是否不为0,不为0则加入结果数组;</li>
</ol>
<p>以上以极高时间复杂度完成了整道题,但是内存开销则还可以(?很怪)</p>
<p>同时发现了自己在C的字符数组这一块的相关函数忘得差不多了.之后补齐相关的知识</p>
<h3 id="重写官方思路-10"><a class="markdownIt-Anchor" href="#重写官方思路-10"></a> 重写官方思路</h3>
<p>官方的思路是用哈希表来处理这个问题,主要是抓住字母异位词的特点来处理,有两种做法一种是排序,一种是根据比如<code>[pet,etp,cat,rag]</code>构造对应的key值,如:<code>1e1p1t,1e1p1t,1a1c1t,1a1g1r</code>这样.</p>
<p>重写一遍代码如下(29号再写):</p>
<p>已重写🆗</p>
<h2 id="61-旋转链表"><a class="markdownIt-Anchor" href="#61-旋转链表"></a> 61 旋转链表</h2>
<h3 id="题目描述-24"><a class="markdownIt-Anchor" href="#题目描述-24"></a> 题目描述</h3>
<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" srcset="/img/loading.gif" lazyload alt="img" /></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 2 * 10^9</code></li>
</ul>
<h3 id="思路-24"><a class="markdownIt-Anchor" href="#思路-24"></a> 思路</h3>
<p>因为我们旋转1次就会把尾节点放到前面,当旋转链表的长度<code>len</code>次的话,就相当于没动,因此旋转的次数<code>k</code>要对长度<code>len</code>取余,避免转圈圈,而当<code>k%len</code>的时候表示需要从尾巴移动这么多个节点,也即相当于我们的链表从第1个节点(即头节点)到<code>len-(k%len)</code>这个节点的时候是不用动的,因此从头节点为1开始计数,直到遇到第<code>len-(k%len)</code>个节点,则此刻该节点的next是要移到前面去的,这时我们可以借用一个空节点<code>preHead</code>(前于head节点)来承接要被切开的节点,并置新的尾节点的next为<code>nullptr</code>.此刻我们有两个链表,一个是以head为代表的,一个是以preHead为代表的,(这时跟分隔链表那道题就基本一样了).让preHead扫到next节点是<code>nullptr</code>的,接上head节点,然后head节点变为preHead节点的next节点,则完成了链表旋转.</p>
<p>这道题一开始十几分钟有思路,后来被边界卡了一下,就对着failed的用例在写,导致最后写了1个小时出头,非常糟糕,最后还是把前面乱改的部分删掉,然后重新理清思路再写,就AC了</p>
<div class="note note-info">
            <ol><li>做题要先把边界,特殊情况给考虑了;</li><li>要理清思路写,不要根据用例编码,乱了就重新捋一遍思路.</li></ol>
          </div>
<h3 id="重写官方思路-11"><a class="markdownIt-Anchor" href="#重写官方思路-11"></a> 重写官方思路</h3>
<h2 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> 287 寻找重复数🔴</h2>
<h3 id="题目描述-25"><a class="markdownIt-Anchor" href="#题目描述-25"></a> 题目描述</h3>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且<strong>只用常量级 <code>O(1)</code> 的额外空间</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,3,4,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,3,4,2]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>示例 3 :</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,3,3,3,3]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>nums.length == n + 1</code></li>
<li><code>1 &lt;= nums[i] &lt;= n</code></li>
<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>
<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>
</ul>
<h3 id="思路-25"><a class="markdownIt-Anchor" href="#思路-25"></a> 思路</h3>
<p>一开始的思路完全错误,虽然AC了,但是没有遵循到题目所说的<strong>不修改数组<code>nums</code></strong>,我给它排了个序,但是确实只是开了常量级的额外空间</p>
<p>根据题目,我们知道需要遵守:</p>
<ul>
<li><strong>不修改数组nums</strong></li>
<li><strong>只允许开常量级O(1)的额外空间</strong></li>
</ul>
<p>如果没有第一条,排序就可以解决;如果没有第二条,用哈希表就可以解决.</p>
<p>但是这两条都得遵守,因此不知道怎么做了(想了好久,其实看到官方题解的<strong>二进制,二分法,快慢指针</strong>这三个方法名称,也试着往上面靠着来解决问题,但failed)</p>
<p>以下是看了一个<strong>快慢指针的思路</strong>:</p>
<p>题目说了数组值是在<code>[1,n]</code>这个区间内,且有n+1个数,且只有一个重复的整数,按照一种很乐观的想法,即区间内的每个数各取一个,并且随机重复一个,如n=5:<code>[1,2,3,4,5,3]</code>这种情况,当然,它的顺序是打乱的,如<code>[3,1,2,4,5,3]</code>,当然也有可能是并非n个值都取满,重复的数字重复次数&gt;2的情况,如n=5:<code>[3,2,2,4,5,2]</code></p>
<p>如果按<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>的情况来说,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">y \in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>的散点图是符合题意的,而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \in 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的情况则是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">R_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>上随机取一个值,至此是符合题意的,而将其打乱,则亦符合题意,因此,我们可以知道除了0这个元素,我们需要指定它到达,别的可以通过:<code>x = nums[x] </code>到达(可以想象成一个x从1到n,y从1到n的棋盘,0则是一个随机的起点),因此<code>x</code>的初值可以是0,为什么会说这个呢?</p>
<p>因为可以把这一个数组想象成是一个带环的链表,起点元素0是<code>ListNode*</code>,而<code>nums[0]</code>是<code>ListNode*</code>,也即是<code>0-&gt;nums[0]</code>这也很符合我们的认知,而<code>nums[0]</code>是在[1,n]这个区间的,即是上面将其想象成一个棋盘的原因,即<code>nums[0]</code>的next是<code>nums[nums[0]]</code></p>
<p>根据题意,确实可以将其以此方式想象成是一个链表,<code>x=0;nums[x] -&gt; nums[nums[x]] -&gt;...</code>.以<code>[2,1,3,4,5,3]</code>为例,有:</p>
<p><code>2-&gt;3-&gt;4-&gt;5-&gt;3-&gt;4-&gt;5</code>,可知,<strong>这种方式起的链表,不会包含原始数据中所有的值,但会在遇到重复的值的时候,陷入对应的循环,这个循环就是我们链表中的环,而这个循环的入口,就是重复的数值!</strong></p>
<p>因此目标转换为了找链表的环的入口,链表有环,就或多或少会牵扯到快慢指针了.以<code>[1,2,3,4,5,3]</code>为例,以上述方式写出其链表形式有:</p>
<pre class="mermaid">graph LR
1-->2;2-->3;3-->4;4-->5;5-->3;</pre>
<p>快指针fast和慢指针slow会在环内相遇(毕竟速度不同),假设慢指针走了n步,快指针是它的两倍,即走了2n步,则有快指针fast在相遇处走多n步即绕一圈遇到的慢指针slow,从起点1到入口3设为m,则慢指针slow在环内走了n-m步,当它再走m步,则相当于转了一圈,就到了<strong>环的入口</strong>,即得到了重复的值,因此在它们相遇时可以起多一个指针从起点走,直到和慢指针slow碰头,则说明当前的值为重复的值</p>
<p>重写代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">[1,2,3,4,5,3]</span><br><span class="hljs-comment">1,2,[3,4,5],[3,4,5],...</span><br><span class="hljs-comment">fast:2,4,3,5</span><br><span class="hljs-comment">slow:1,2,3 | 4,5,3·</span><br><span class="hljs-comment">ans:       | 1,2,3·</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>; <span class="hljs-comment">// 三个指针</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            fast = nums[nums[fast]];<br>            slow = nums[slow];<br>            <span class="hljs-keyword">if</span>(fast == slow)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            slow = nums[slow];<br>            ans = nums[ans];<br>            <span class="hljs-keyword">if</span>(slow == ans)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="重写官方思路-12"><a class="markdownIt-Anchor" href="#重写官方思路-12"></a> 重写官方思路</h3>
<p>没看官方思路,看了别人题解的做法.</p>
<h2 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> 20 有效的括号</h2>
<h3 id="题目描述-26"><a class="markdownIt-Anchor" href="#题目描述-26"></a> 题目描述</h3>
<h3 id="思路-26"><a class="markdownIt-Anchor" href="#思路-26"></a> 思路</h3>
<h3 id="重写官方思路-13"><a class="markdownIt-Anchor" href="#重写官方思路-13"></a> 重写官方思路</h3>
<h2 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215 数组中的第k个最大元素</h2>
<h3 id="题目描述-27"><a class="markdownIt-Anchor" href="#题目描述-27"></a> 题目描述</h3>
<h3 id="思路-27"><a class="markdownIt-Anchor" href="#思路-27"></a> 思路</h3>
<h3 id="重写官方思路-14"><a class="markdownIt-Anchor" href="#重写官方思路-14"></a> 重写官方思路</h3>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/algorithm-learning/">algorithm learning</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/28/GEMM-intrinsic%E4%BC%98%E5%8C%96/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GEMM-intrinsic优化</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/24/Makefile%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">Makefile简易使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'a350b9ea08704ac87b06dc853c4bada3'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
