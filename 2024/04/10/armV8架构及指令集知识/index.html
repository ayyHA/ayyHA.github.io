

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="编写算子的主要架构,包含架构知识和指令集知识">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="编写算子的主要架构,包含架构知识和指令集知识">
<meta property="og:type" content="article">
<meta property="og:title" content="armV8架构及指令集知识">
<meta property="og:url" content="http://example.com/2024/04/10/armV8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="ayyHA&#39;s blog">
<meta property="og:description" content="编写算子的主要架构,包含架构知识和指令集知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/04/18/9BJZxrGLgn1Sepm.png">
<meta property="og:image" content="https://s2.loli.net/2024/04/18/l6nvdY2sVQALmaJ.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/04/19/ZwBocAkCQxyn2jI.png">
<meta property="og:image" content="https://s2.loli.net/2024/04/19/DTApiKL1HOl8aUf.png">
<meta property="og:image" content="https://s2.loli.net/2024/04/18/uckhg4E7wfvAYVF.jpg">
<meta property="og:image" content="https://s2.loli.net/2024/04/18/r2SY7ToR5fzQjan.png">
<meta property="article:published_time" content="2024-04-10T01:41:20.000Z">
<meta property="article:modified_time" content="2024-05-08T07:43:13.961Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="assembly">
<meta property="article:tag" content="armv8">
<meta property="article:tag" content="ARM architecture">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/04/18/9BJZxrGLgn1Sepm.png">
  
  <title>armV8架构及指令集知识 - ayyHA&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"9c7ed39aa5906acb06d9f9cb7df236ae","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ayyHA</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="armV8架构及指令集知识">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-04-10 09:41" pubdate>
        2024年4月10日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      26 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">armV8架构及指令集知识</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：6 个月前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="neon-intrinsic入门"><a class="markdownIt-Anchor" href="#neon-intrinsic入门"></a> Neon intrinsic入门</h2>
<h3 id="两个例子学习自arm的neon-intrinsic教程"><a class="markdownIt-Anchor" href="#两个例子学习自arm的neon-intrinsic教程"></a> 两个例子(学习自ARM的neon intrinsic教程)</h3>
<p>其实还有个collision detection的例子,但感觉那个例子不如前两个例子好,因此没编程实现</p>
<ol>
<li><strong>RGB deinterleaving</strong></li>
</ol>
<img src="https://s2.loli.net/2024/04/18/9BJZxrGLgn1Sepm.png" srcset="/img/loading.gif" lazyload alt="RGB image pixel array" style="zoom:50%;" />
<p>我们知道一个像素有三个颜色通道,R,G,B.每个像素点的颜色通道顺序排列,但如果我们想逐通道进行处理,则需要进行像素通道的分离,即从<code>rgb</code>这个数组中,分离三色通道,获得<code>r</code>,<code>g</code>,<code>b</code>三个单独的数组</p>
<p>用C实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_c</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *r,<span class="hljs-keyword">uint8_t</span> *g,<span class="hljs-keyword">uint8_t</span> *b,<span class="hljs-keyword">uint8_t</span> *rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;color_length;i++)&#123;<br>        r[i] = rgb[i*<span class="hljs-number">3</span>];<br>        g[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>];<br>        b[i] = rgb[i*<span class="hljs-number">3</span>+<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样逐个元素取出然后放入数组是很容易联想到的一种方法,但是我们arm的通用寄存器是64位,每次处理都是64位的寄存器从内存load一个8位的数,又store回去.寄存器是宝贵的计算机资源,如此使用很浪费.</p>
<p>因此选择用neon实现,可以用向量寄存器来处理,128位则可以一次性处理16个8位的无符号整数(颜色范围[0,255]),但这样显然有问题,因为一次处理三个通道的数据,需要是3的倍数,因此可以选择用一个<code>uint8x16x3_t</code>的矩阵型数据类型来处理,这样一次采用三个向量寄存器处理即可.</p>
<p>用neon实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arm_neon.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rgb_deinterleave_neon</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* r,<span class="hljs-keyword">uint8_t</span>* g,<span class="hljs-keyword">uint8_t</span>* b,<span class="hljs-keyword">uint8_t</span>* rgb,<span class="hljs-keyword">int</span> color_length)</span></span>&#123;<br>	<span class="hljs-keyword">int</span> num8x16 = color_length/<span class="hljs-number">16</span>;<br>	<span class="hljs-keyword">uint8x16x3_t</span> intlv_rgb;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num8x16;i++)&#123;<br>		intlv_rgb = vld3q_u8(rgb+<span class="hljs-number">3</span>*<span class="hljs-number">16</span>*i);<br>		vst1q_u8(r+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">0</span>]);<br>		vst1q_u8(g+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">1</span>]);<br>		vst1q_u8(b+<span class="hljs-number">16</span>*i,intlv_rgb.val[<span class="hljs-number">2</span>]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中因为一次是处理了16个像素点(48个通道信息),所以像素长度要除以16(也可以让控制像素长度的步长每次走16步)</p>
<p><code>vld3q_u8</code>是第一个接触到的neon intrinsic函数,v表示vector操作,ld表示这个函数的基本功能load,3q表示用到3个qword的寄存器,即是3个128位的向量寄存器,u8表示寄存器里的一个通道的数据是u8类型的,即unsigned int 8类型的.</p>
<p>它的返回值是一个<code>uint8x16x3_t</code> 的数据类型,将该类型的数据逐个取出,通过<code>vst1q_u8</code>的操作写到对应的数组中去</p>
<ol start="2">
<li><strong>matrix multiplication</strong></li>
</ol>
<p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=A*B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>来考虑,其中是列主序的存储方式,C的维度是<code>n*m</code>,则普通的C矩阵乘如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_c</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span>* A,<span class="hljs-keyword">float32_t</span>* B,<span class="hljs-keyword">float32_t</span>* C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,p;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            C[i+j*n] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// Inner Product</span><br>            <span class="hljs-keyword">for</span>(p=<span class="hljs-number">0</span>;p&lt;k;p++)&#123;<br>                C[i+j*n] += A[i + p*n] * B[p + j*k]; <br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>显然,这样的矩阵乘是最朴素的,那怎么优化呢?</p>
<p>不妨先从一个固定大小,然后维度比较小的矩阵来思考,我们的向量寄存器的宽度是128,那就是对于float32_t可以放4个,因此考虑一个<strong>4x4的小矩阵的乘法</strong>先,那么优化的过程如下图示:</p>
<img src="https://s2.loli.net/2024/04/18/l6nvdY2sVQALmaJ.jpg" srcset="/img/loading.gif" lazyload alt="ARM-matrix multiply neon 4x4" style="zoom:60%;" />
<p>如图,我们想算C阵的一列数据,则按照A逐行与B的某一列做内积,则经过多次内积,可以得出C阵的一列数据;</p>
<p>但是这样对于A阵会频繁发生cache miss的问题,频繁访存导致latency,因此A阵最好也以列的方式取数据,通过分析我们知道,若要求C0(C阵的第一列),则A0通通要乘于<code>B0[0]</code>(B阵第一列的第一个数据),A1要乘于<code>B0[1]</code>,如此遍历完A阵(逐列)与B0列(逐元素)的数据,则可以计算出C0,大大减少了cache miss,且可以用neon intrinsic实现(减少指令数量,并有利于编译器做循环展开),代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_4x4_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// 先把A,B,C的列都给用float32x4_t表示</span><br>    <span class="hljs-keyword">float32x4_t</span> A0 = vld1q_f32(A);<br>    <span class="hljs-keyword">float32x4_t</span> A1 = vld1q_f32(A+<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A2 = vld1q_f32(A+<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">float32x4_t</span> A3 = vld1q_f32(A+<span class="hljs-number">12</span>);<br><br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br><br>    <span class="hljs-comment">// 给结果的中间值逐列设置初值0(因为要累加嘛)</span><br>    <span class="hljs-keyword">float32x4_t</span> C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">float32x4_t</span> C3 = vmovq_n_f32(<span class="hljs-number">0</span>); <br><br>    B0 = vld1q_f32(B);<br>    C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>    C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>    C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>    C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br>    vst1q_f32(C,C0);<br><br>    B1 = vld1q_f32(B+<span class="hljs-number">4</span>);<br>    C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>    C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>    C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>    C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">4</span>,C1);<br><br>    B2 = vld1q_f32(B+<span class="hljs-number">8</span>);<br>    C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>    C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>    C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>    C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">8</span>,C2);<br><br>    B3 = vld1q_f32(B+<span class="hljs-number">12</span>);<br>    C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>    C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>    C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>    C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>    vst1q_f32(C+<span class="hljs-number">12</span>,C3);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码思路与上面画图的思路是一样的,由此便完成了一个4x4的neon intrinsic实现的矩阵乘</p>
<p>那么对于大的矩阵呢?如何处理?</p>
<p>其实可以划分为4x4的块,用我们上面优化后的矩阵乘进行计算,当然这样的情况针对的是行列两个维度均是4的倍数的,如果不是4的倍数,比如A的维度是514x515这样的,就可以做padding处理,这样也不用改动4x4的矩阵乘的代码</p>
<p>以下是一般阵的情况(这里没做padding):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">matrix_multiply_neon</span><span class="hljs-params">(<span class="hljs-keyword">float32_t</span> *A,<span class="hljs-keyword">float32_t</span> *B,<span class="hljs-keyword">float32_t</span> *C,<span class="hljs-keyword">uint32_t</span> n,<span class="hljs-keyword">uint32_t</span> m,<span class="hljs-keyword">uint32_t</span> k)</span></span>&#123;<br>    <span class="hljs-comment">// A,B,C三个阵的逐列数据</span><br>    <span class="hljs-keyword">float32x4_t</span> A0,A1,A2,A3;<br>    <span class="hljs-keyword">float32x4_t</span> B0,B1,B2,B3;<br>    <span class="hljs-keyword">float32x4_t</span> C0,C1,C2,C3;<br><br>    <span class="hljs-comment">// A,B,C三个阵的地址偏移值</span><br>    <span class="hljs-keyword">int</span> a_offset,b_offset,c_offset;<br>    <br>    <span class="hljs-comment">// 迭代变量</span><br>    <span class="hljs-keyword">int</span> i_idx,j_idx,k_idx;<br>    <br>    <span class="hljs-keyword">for</span>(i_idx=<span class="hljs-number">0</span>;i_idx&lt;n;i_idx+=<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">for</span>(j_idx=<span class="hljs-number">0</span>;j_idx&lt;m;j_idx+=<span class="hljs-number">4</span>)&#123;<br>            C0 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C1 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C2 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            C3 = vmovq_n_f32(<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 得等这一个循环完成了才算做完4x4次内积,因此里面的C的值得累加,出循环再store</span><br>            <span class="hljs-keyword">for</span>(k_idx=<span class="hljs-number">0</span>;k_idx&lt;k;k_idx+=<span class="hljs-number">4</span>)&#123;<br>                <span class="hljs-comment">// 计算偏移值</span><br>                a_offset = i_idx + n*k_idx;<br>                b_offset = k_idx + k*j_idx;<br>                <span class="hljs-comment">// 获取当前基址+偏移值的位置处的列值</span><br>                A0 = vld1q_f32(A+a_offset);<br>                A1 = vld1q_f32(A+a_offset+n);<br>                A2 = vld1q_f32(A+a_offset+<span class="hljs-number">2</span>*n);<br>                A3 = vld1q_f32(A+a_offset+<span class="hljs-number">3</span>*n);<br><br>                B0 = vld1q_f32(B+b_offset);<br>                C0 = vfmaq_laneq_f32(C0,A0,B0,<span class="hljs-number">0</span>);<br>                C0 = vfmaq_laneq_f32(C0,A1,B0,<span class="hljs-number">1</span>);<br>                C0 = vfmaq_laneq_f32(C0,A2,B0,<span class="hljs-number">2</span>);<br>                C0 = vfmaq_laneq_f32(C0,A3,B0,<span class="hljs-number">3</span>);<br><br>                B1 = vld1q_f32(B+b_offset+k);<br>                C1 = vfmaq_laneq_f32(C1,A0,B1,<span class="hljs-number">0</span>);<br>                C1 = vfmaq_laneq_f32(C1,A1,B1,<span class="hljs-number">1</span>);<br>                C1 = vfmaq_laneq_f32(C1,A2,B1,<span class="hljs-number">2</span>);<br>                C1 = vfmaq_laneq_f32(C1,A3,B1,<span class="hljs-number">3</span>);                                <br><br>                B2 = vld1q_f32(B+b_offset+<span class="hljs-number">2</span>*k);<br>                C2 = vfmaq_laneq_f32(C2,A0,B2,<span class="hljs-number">0</span>);<br>                C2 = vfmaq_laneq_f32(C2,A1,B2,<span class="hljs-number">1</span>);<br>                C2 = vfmaq_laneq_f32(C2,A2,B2,<span class="hljs-number">2</span>);<br>                C2 = vfmaq_laneq_f32(C2,A3,B2,<span class="hljs-number">3</span>);<br><br>                B3 = vld1q_f32(B+b_offset+<span class="hljs-number">3</span>*k);<br>                C3 = vfmaq_laneq_f32(C3,A0,B3,<span class="hljs-number">0</span>);<br>                C3 = vfmaq_laneq_f32(C3,A1,B3,<span class="hljs-number">1</span>);<br>                C3 = vfmaq_laneq_f32(C3,A2,B3,<span class="hljs-number">2</span>);<br>                C3 = vfmaq_laneq_f32(C3,A3,B3,<span class="hljs-number">3</span>);<br>            &#125;<br>            <span class="hljs-comment">// 计算偏移值</span><br>            c_offset = i_idx + n*j_idx;<br>            vst1q_f32(C+c_offset,C0);<br>            vst1q_f32(C+c_offset+n,C1);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">2</span>,C2);<br>            vst1q_f32(C+c_offset+n*<span class="hljs-number">3</span>,C3);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出,n,m,k三个维度的步距都改作了4,注意C阵的值是需要累加完整个k维的循环,才可以得到C的一个小块(4x4)的结果,因此C的摆放位置有了变化,别的基本差不多.</p>
<h3 id="函数规范"><a class="markdownIt-Anchor" href="#函数规范"></a> 函数规范</h3>
<p>在说起函数规范前,先学一下<strong>用于neon的数据类型</strong>:</p>
<ul>
<li><code>baseW_t</code>: <strong>base表示基本的数据类型</strong>,然后<strong>W表示该类型的位宽</strong>,比如int8,uint8,float32这些,后面跟着的t是表示typedef的意思;</li>
<li><code>baseWxL_t</code>:这在上面的基础上加上了个L,实际上就是用了向量寄存器,<strong>L表示数据的个数</strong>,比如128位的寄存器,对于float32_t来说,就可以存4个,即float32x4_t(类似一维数组);</li>
<li><code>baseWxLxN_t</code>: 这个较上面的方法则类似二维数组,<strong>N表示baseWxL的个数</strong>,就比如分离RGB的例子,uint8x16x3_t表示的是有3个uint8x16的一维数组.</li>
</ul>
<div class="note note-info">
            <p>其实x86中比如avx2的数据类型也差不多,虽然看起来是__m256d,__m256i这样高深莫测的样子,但是内部的结构体也差不多</p>
          </div>
<p>在ARM neon intrinsic入门的教程里,函数规范定义如下:</p>
<p><strong><code>return_type v[p][q][r]opname[u][n][q][x][_high][_lane | _laneq][_n][_result]_type(args) </code></strong></p>
<p>非常复杂,从左往右开始说</p>
<ul>
<li>
<p><code>reture_type:</code> 返回类型,就是我们上面说到的neon的数据类型;</p>
</li>
<li>
<p>v: <strong>在所有intrinsic中必有</strong>,表示是一个vector操作</p>
</li>
<li>
<p>p: pair,成对操作</p>
</li>
<li>
<p>q: 饱和操作,就是数值溢出,不是对它做如取余(上溢),加上边界值(下溢)的操作,而是暂停在边界值</p>
</li>
<li>
<p>r: rounding向下取整</p>
</li>
<li>
<p>opname: <strong>具体操作的名字</strong>,比如add,mul,sub之类的</p>
</li>
<li>
<p>u:</p>
</li>
<li>
<p>n: narrow,窄指令,输入操作数的向量是128位的,结果向量是64位的,类型相同,但是宽度减半,例子:</p>
<ul>
<li>``</li>
</ul>
<div class="note note-info">
            <p>我在网上看到还有w(wide,宽指令),l(long,长指令)</p><ul><li>l: long,长指令,输入操作数的向量是64位的,结果向量是128位的,类型相同,但是宽度加倍,例子:</li></ul><p>``</p><ul><li>w: wide,宽指令,输入操作数1个是64位的,1个是128位的,结果向量是128位的,类型相同,宽度上64位的是128位的一半,例子:</li></ul><p><code>uint64x2_t vaddw_u32 (uint64x2_t a, uint32x2_t b) </code></p>
          </div>
</li>
<li>
<p>q: <strong>表示用到是128的向量寄存器</strong>,<strong><u>q</u>uad word</strong>,<strong>默认是64位的double word</strong></p>
</li>
<li>
<p>x:</p>
</li>
<li>
<p>_high:</p>
</li>
<li>
<p>_lane | _laneq: 表示<strong>从一个向量的通道中取一个标量操作数</strong>.<strong>有q和无q的区别就是向量寄存器是用128位还是64位</strong>(感觉就默认的向量寄存器(不加q)就是用64位).下面是官网的两个例子:</p>
<ul>
<li>
<img src="https://s2.loli.net/2024/04/19/ZwBocAkCQxyn2jI.png" srcset="/img/loading.gif" lazyload alt="vfmaq_laneq_f32" style="zoom:50%;" />
</li>
<li>
<img src="https://s2.loli.net/2024/04/19/DTApiKL1HOl8aUf.png" srcset="/img/loading.gif" lazyload alt="vfmaq_lane_f32" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>_n: 表示<strong>有一个标量操作数</strong>,是<strong>要从参数中获取</strong></p>
</li>
<li>
<p>_result:</p>
</li>
<li>
<p>_type: 表示<strong>每个通道的具体的数据类型</strong></p>
</li>
<li>
<p>args: 输入参数</p>
</li>
</ul>
<h2 id="neon相关的体系结构"><a class="markdownIt-Anchor" href="#neon相关的体系结构"></a> Neon相关的体系结构</h2>
<p>下面的内容主要摘自ARM的Neon introducing:</p>
<hr />
<p><strong>Neon技术为指令集体系结构提供了一个专门的扩展</strong>,提供的额外指令能<strong>在多个数据流上并行的执行数学运算(SIMD)</strong></p>
<p>为什么需要用到这个Neon呢?</p>
<p>处理大量数据集,主要的性能限制因素是<strong>执行数据处理指令</strong>所花费的大量<strong>CPU时间</strong> -&gt; 这个<strong>CPU时间</strong>取决于<strong>处理整个数据集的指令数量</strong> -&gt; 这个<strong>指令数量</strong>又取决于<strong>每条指令所能处理的数据项</strong></p>
<blockquote>
<p>When processing large sets of data, a major performance limiting factor is the amount of CPU time taken to perform data processing instructions. This CPU time depends on the number of instructions it takes to deal with the entire data set. And the number of instructions depends on how many items of data each instruction can process.</p>
</blockquote>
<p><strong>如果你现在处理的数值是小于最大位的大小,用SISD的话,额外的潜在的带宽是被浪费掉的</strong></p>
<blockquote>
<p>If the values you are dealing with are smaller than the maximum bit size, that extra potential bandwidth is wasted with SISD instructions.</p>
</blockquote>
<p>即是我要对8位的数值去做一个ADD操作,那么每个8位的数值会被加载到一个单独的64位的寄存器.这样去处理数据,对硬件资源并没有很好的利用到.</p>
<p><strong>SIMD指令是对多个数据项同时执行相同的操作.在一个较大的寄存器里,这些数据项会作为单独的通道被打包.</strong>(通道lane是完全隔离的,互相影响不到的)</p>
<blockquote>
<p>Single Instruction Multiple Data (SIMD) instructions perform the same operation simultaneously for multiple data items. These data items are packed as separate lanes in a larger register.</p>
</blockquote>
<p><strong>Neon寄存器有128位的,也有64位的(就是把128位的高64位给置零,只用低64位</strong>,跟AVX兼容SSE差不多)</p>
<hr />
<p><strong>AArch64:Armv8-A架构的64位的执行状态</strong>.有时候一些GNU/Linux文档会把AArch64叫做ARM64.在AArch64状态下,处理器执行<strong>A64指令集</strong>(包含Neon指令)</p>
<p><strong>AArch32:就是Armv8-A架构的32位执行状态,和Armv7几乎是一样的</strong>.在AArch32状态下处理器可以执行<strong>A32</strong>(在早期架构版本中是叫ARM)/<strong>T32</strong>(Thumb)<strong>指令集</strong>.这俩指令集向下兼容Armv7也有Neon指令</p>
<hr />
<p>Armv8是64位的架构和用的是64位的寄存器,而我们的Neon用的是128位的寄存器,是因为Neon单元是在一个<strong>单独的128位寄存器的寄存器文件</strong>(硬件,可以参照RISC-V内有一个参考文件提及了处理器设计)上进行的操作</p>
<p><strong>Neon寄存器包含了相同数据类型的元素的向量,这些相同数据类型的元素在输入输出寄存器中的位置是被称为通道lane</strong>(其实就跟数组一个样,不过更加具象化)</p>
<p><strong>通道数n</strong>:就是指Neon指令会使得n个操作并行执行,这个n就是通道数,比如我们对一个float32x4_t,做加法操作,那这个4就是通道数,因为做了4个float32的加法操作(不过是一条指令).也就是说操作是针对通道lane的</p>
<p>显然,Neon向量的通道数就取决于向量大小(64位还是128位)和每个通道的数据类型(<strong>8位-B(byte) | 16位-H(halfword) | 32位-S(word,感觉single precision也可以) | 64位-D(doubleword)</strong>)</p>
<p>以128位的向量来说有:</p>
<ul>
<li><strong>16个8位的元素(汇编中寄存器后缀会呈现为<code>.16B</code>)</strong></li>
<li><strong>8个16位元素(汇编中寄存器后缀会呈现为<code>.8H</code>)</strong></li>
<li><strong>4个32位元素(汇编中寄存器后缀会呈现为<code>.4S</code>)</strong></li>
<li><strong>2个64位元素(汇编中寄存器后缀会呈现为<code>.2D</code>)</strong></li>
</ul>
<p>以64位向量来说有:</p>
<ul>
<li><strong>8个8位的(<code>.8B</code>)</strong></li>
<li><strong>4个16位的(<code>.4H</code>)</strong></li>
<li><strong>2个32位的(<code>.2S</code>)</strong></li>
</ul>
<p>下图右侧的<code>V0.4S</code>是在汇编中向量寄存器作为操作码的写法(<strong>0表示V0,有32个向量寄存器</strong>)</p>
<p><img src="https://s2.loli.net/2024/04/18/uckhg4E7wfvAYVF.jpg" srcset="/img/loading.gif" lazyload alt="ARM-neon vector (64and128)" /></p>
<p><strong>在向量中元素是从LSB(最低有效位)开始放置的,就是element0(lane0的数据)会用到寄存器的LSB</strong></p>
<p>有些指令是向量跟一个向量里面的某一个位置的元素进行操作的,比如<code>mul v0.4s v2.4s v3.s[2]</code>就是V2寄存器里的4个float32_t和V3寄存器的lane2处的元素做乘法.如下图示:</p>
<img src="https://s2.loli.net/2024/04/18/r2SY7ToR5fzQjan.png" srcset="/img/loading.gif" lazyload alt="ARM-neon instruction using scalars" style="zoom:80%;" />
<h2 id="一些arm的基础知识"><a class="markdownIt-Anchor" href="#一些arm的基础知识"></a> 一些ARM的基础知识</h2>
<p>ARMv8有31个64位的通用寄存器,有32个128位的向量寄存器</p>
<h2 id="neon-assembly入门"><a class="markdownIt-Anchor" href="#neon-assembly入门"></a> Neon Assembly入门</h2>
<h3 id="神奇的指令"><a class="markdownIt-Anchor" href="#神奇的指令"></a> 神奇的指令</h3>
<ul>
<li>
<p>预取指令</p>
<p><code>prfm pldl1keep,[Rn,#imm]</code>,一般见到的是这样的格式</p>
</li>
<li></li>
</ul>
<p><strong>具体代码参考可见<a target="_blank" rel="noopener" href="https://github.com/ayyHA/OperatorDev">opDev</a>中的数组加权和和<code>box_filter</code>盒子滤波的例子</strong></p>
<h2 id="参考文件"><a class="markdownIt-Anchor" href="#参考文件"></a> 参考文件</h2>
<p><strong>Neon intrinsic系列</strong>:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">intrinsic-set reference</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/102467/0201">Learn the architecture - Optimizing C code with Neon intrinsics</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/102474/0100/">Learn the architecture - Introducing Neon</a></li>
</ul>
<p><strong>Neon Assembly系列:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143328317">neon assembly教程-移动端arm cpu优化学习笔记第4弹–内联汇编入门</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/451014220">ARM Cortex-A 系列ARMv8-A程序员指南： 第6章 A64指令集</a> <mark>未看完</mark></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/assembly/">assembly</a>
                    
                      <a class="hover-with-bg" href="/tags/armv8/">armv8</a>
                    
                      <a class="hover-with-bg" href="/tags/ARM-architecture/">ARM architecture</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/03/CMake%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMake简易使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/10/RISC-V%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/">
                        <span class="hidden-mobile">RISC-V汇编知识</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1db059241d978c80eecd","clientSecret":"fa4f54290b2645c1dd4af84d9241dcb8c3e8e637","repo":"ayyBlog","owner":"ayyha","admin":["ayyha"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'c0c6ed486994e44af09b83a06823e4ba'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?9c7ed39aa5906acb06d9f9cb7df236ae";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

  <script type="text/javascript" src="/js/funnyTitle.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-50,"superSample":2},"mobile":{"show":false},"react":{"opacityDefault":0.7,"opacityOnHover":0.2}});</script></body>
</html>
